此页内容

一

、斐波那契数

列

暴力递归

带备忘录的

递归解法

dp

数

组的迭代（递

推）解法

拓展

延伸

二、凑零

钱问题

暴力

递归

带备忘

录的递归

dp 数

组的迭代解

法

三、最后总

结

动态规划

解题套路框

架

labuladong

原创

约

6863 字

解决 2 题

本文

讲解的例题

LeetCode	力扣	难度

322. Coin Change	322.

零

钱兑换	🟠

509. Fibonacci

Number	509. 斐波

那契数	🟢

前置

知识



阅读本

文前，你需要

先学习：

二叉

树的遍历框

架

多叉树结

构及遍历框

架

这篇文章

是我多年前

一篇 200

多赞赏

的 动态规划

详解 的进阶

版，我添加了

更多干货内

容，希望本文

成为解决动

态规划的一

部「指导方针

」。

动态规划问

题（Dynamic Programming）应该是很

多读者头疼

的，不过这类

问题也是最

具有技巧性

，最有意思的

。本书使用了

整整一个章

节专门来写

这个算法，动

态规划的重

要性也可见

一斑。



本文解

决几个问题

：

动态规划是

什么？解决动

态规划问题

有什么技巧

？如何学习动

态规划？



刷题

刷多了就会

发现，算法技

巧就那几个

套路，我们后

续的动态规

划系列章节

，都在使用本

文的解题框

架思维，如果

你心里有数

，就会轻松很

多。所以本文

放在第一章

，希望能够成

为解决动态

规划问题的

一部指导方

针，下面上干

货。

首先，动态

规划问题的

一般形式就

是求最值。动

态规划其实

是运筹学的

一种最优化

方法，只不过

在计算机问

题上应用比

较多，比如说

让你求最长

递增子序列

呀，最小编辑

距离呀等等

。



既然是要求

最值，核心问

题是什么呢

？求解动态规

划的核心问

题是穷举。因

为要求最值

，肯定要把所

有可行的答

案穷举出来

，然后在其中

找最值呗。

动

态规划这么

简单，就是穷

举就完事了

？我看到的动

态规划问题

都很难啊！



首

先，虽然动态

规划的核心

思想就是穷

举求最值，但

是问题可以

千变万化，穷

举所有可行

解其实并不

是一件容易

的事，需要你

熟练掌握递

归思维，只有

列出正确的

「状态转移方

程」，才能正确

地穷举。而且

，你需要判断

算法问题是

否具备「最优

子结构」，是否

能够通过子

问题的最值

得到原问题

的最值。另外

，动态规划问

题存在「重叠

子问题」，如果

暴力穷举的

话效率会很

低，所以需要

你使用「备忘

录」或者「DP table」来优

化穷举过程

，避免不必要

的计算。

以上

提到的重叠

子问题、最优

子结构、状态

转移方程就

是动态规划

三要素。具体

什么意思等

会会举例详

解，但是在实

际的算法问

题中，写出状

态转移方程

是最困难的

，这也就是为

什么很多朋

友觉得动态

规划问题困

难的原因，我

来提供我总

结的一个思

维框架，辅助

你思考状态

转移方程：



明

确「状态」-> 明确

「选择」

-> 定义 dp 数

组/函数的含

义。

按上面的

套路走，最后

的解法代码

就会是如下

的框架：





#

自顶

向下递归的

动态规划

def dp(状

态1, 状态2,

...):

for 选择

in 所有可能的

选择:



# 此时的

状态已经因

为做了选择

而改变



result = 求最

值(result,

dp(状态1, 状态

2, ...))

return result

# 自底向上迭

代的动态规

划

# 初始化

base case

dp[0][0][...] =

base case

# 进

行状态转移

for

状态1 in 状态1的

所有取值：

for 状

态2

in 状态2的所

有取值：



for ...





dp[状态

1][状态2][...] = 求最值

(选择1，选择2...)

下

面通过斐波

那契数列问

题和凑零钱

问题来详解

动态规划的

基本原理。前

者主要是让

你明白什么

是重叠子问

题（斐波那契

数列没有求

最值，所以严

格来说不是

动态规划问

题），后者主要

举集中于如

何列出状态

转移方程。

一

、斐波那契数

列

力扣第 509 题

「斐波那契数

」就是这个问

题，请读者不

要嫌弃这个

例子简单，只

有简单的例

子才能让你

把精力充分

集中在算法

背后的通用

思想和技巧

上，而不会被

那些隐晦的

细节问题搞

的莫名其妙

。想要困难的

例子，接下来

的动态规划

系列里有的

是。

暴力递归

斐波那契数

列的数学形

式就是递归

的，写成代码

就是这样：



java 🟢cpp

🤖python 🤖go 🤖javascript 🤖

int fib(int N) {

if

(N == 1 ||

N == 2) return

1;

return fib(N - 1)

+ fib(N - 2);

}

 

算

法可视化面

板

这个不用

多说了，学校

老师讲递归

的时候似乎

都是拿这个

举例。我们也

知道这样写

代码虽然简

洁易懂，但是

十分低效，低

效在哪里？假

设 n = 20，请画出递

归树：

Tip



但凡遇

到需要递归

的问题，最好

都画出递归

树，这对你分

析算法的复

杂度，寻找算

法低效的原

因都有巨大

帮助。

这个递

归树怎么理

解？就是说想

要计算原问

题 f(20)，我就得先

计算出子问

题 f(19) 和

f(18)，然后要

计算 f(19)，我就要

先算出子问

题 f(18) 和

f(17)，以此类

推。最后遇到

f(1) 或者 f(2) 的时候

，结果已知，就

能直接返回

结果，递归树

不再向下生

长了。

递归算

法的时间复

杂度怎么计

算？就是用子

问题个数乘

以解决一个

子问题需要

的时间。



首先

计算子问题

个数，即递归

树中节点的

总数。显然二

叉树节点总

数为指数级

别，所以子问

题个数为 O(2^n)。

然

后计算解决

一个子问题

的时间，在本

算法中，没有

循环，只有 f(n - 1)

+ f(n - 2)

一

个加法操作

，时间为 O(1)。



所以

，这个算法的

时间复杂度

为二者相乘

，即

O(2^n)，指数级别

，爆炸。



观察递

归树，很明显

发现了算法

低效的原因

：存在大量重

复计算，比如

f(18) 被计算了两

次，而且你可

以看到，以

f(18) 为

根的这个递

归树体量巨

大，多算一遍

，会耗费巨大

的时间。更何

况，还不止 f(18) 这

一个节点被

重复计算，所

以这个算法

及其低效。

这

就是动态规

划问题的第

一个性质：重

叠子问题。下

面，我们想办

法解决这个

问题。



带备忘

录的递归解

法

明确了问

题，其实就已

经把问题解

决了一半。即

然耗时的原

因是重复计

算，那么我们

可以造一个

「备忘录」，每次

算出某个子

问题的答案

后别急着返

回，先记到「备

忘录」里再返

回；每次遇到

一个子问题

先去「备忘录

」里查一查，如

果发现之前

已经解决过

这个问题了

，直接把答案

拿出来用，不

要再耗时去

计算了。

一般

使用一个数

组充当这个

「备忘录」，当然

你也可以使

用哈希表（字

典），思想都是

一样的。



java 🟢cpp

🤖python 🤖go 🤖javascript 🤖

int fib(int N) {

//

备忘

录全初始化

为 0

vector<int> memo(N +

1, 0);

// 进行带备

忘录的递归



return dp(memo, N);

}



// 带着备忘录

进行递归

int dp(vector<int>& memo, int

n) {

// base case

if

(n == 0 ||

n == 1) return

n;

// 已

经计算过，不

用再计算了



if (memo[n] != 0)

return memo[n];

memo[n] = dp(memo,

n - 1) +

dp(memo, n - 2);

return

memo[n];

}

算法可视化

面板

现在，画

出递归树，你

就知道「备忘

录」到底做了

什么。

实际上

，带「备忘录」的

递归算法，把

一棵存在巨

量冗余的递

归树通过「剪

枝」，改造成了

一幅不存在

冗余的递归

图，极大减少

了子问题（即

递归图中节

点）的个数。





递

归算法的时

间复杂度怎

么计算？就是

用子问题个

数乘以解决

一个子问题

需要的时间

。

子问题个数

，即图中节点

的总数，由于

本算法不存

在冗余计算

，子问题就是

f(1), f(2), f(3) ...

f(20)，数量和输入

规模 n = 20

成正比

，所以子问题

个数为 O(n)。



解决

一个子问题

的时间，同上

，没有什么循

环，时间为

O(1)。



所

以，本算法的

时间复杂度

是 O(n)，比起暴力

算法，是降维

打击。

至此，带

备忘录的递

归解法的效

率已经和迭

代的动态规

划解法一样

了。实际上，这

种解法和常

见的动态规

划解法已经

差不多了，只

不过这种解

法是「自顶向

下」进行「递归

」求解，我们更

常见的动态

规划代码是

「自底向上」进

行「递推」求解

。



啥叫「自顶向

下」？注意我们

刚才画的递

归树（或者说

图），是从上向

下延伸，都是

从一个规模

较大的原问

题比如说 f(20)，向

下逐渐分解

规模，直到

f(1) 和

f(2) 这两个 base

case，然后

逐层返回答

案，这就叫「自

顶向下」。



啥叫

「自底向上」？反

过来，我们直

接从最底下

、最简单、问题

规模最小、已

知结果的 f(1)

和

f(2)（base case）开始往上推

，直到推到我

们想要的答

案 f(20)。这就是「递

推」的思路，这

也是动态规

划一般都脱

离了递归，而

是由循环迭

代完成计算

的原因。

dp 数组

的迭代（递推

）解法

有了上

一步「备忘录

」的启发，我们

可以把这个

「备忘录」独立

出来成为一

张表，通常叫

做 DP

table，在这张表

上完成「自底

向上」的推算

岂不美哉！



java 🟢cpp

🤖python 🤖go 🤖javascript 🤖

int fib(int N) {

if

(N == 0) return

0;

vector<int> dp(N + 1);

//

base case

dp[0] = 0;

dp[1] = 1;

// 状

态转移

for

(int i = 2;

i <= N; i++)

{



dp[i] = dp[i -

1] + dp[i -

2];

}

return dp[N];

}

算法

可视化面板

画个图就很

好理解了，而

且你发现这

个 DP table

特别像之

前那个「剪枝

」后的结果，只

是反过来算

而已：





实际上

，带备忘录的

递归解法中

的那个「备忘

录」memo

数组，最终

完成后就是

这个解法中

的 dp 数组，你对

比一下可视

化面板中两

个算法执行

的过程可以

更直观地看

出它俩的联

系。

所以说自

顶向下、自底

向上两种解

法本质其实

是差不多的

，大部分情况

下，效率也基

本相同。



拓展

延伸

这里，引

出「状态转移

方程」这个名

词，实际上就

是描述问题

结构的数学

形式：

为啥叫

「状态转移方

程」？其实就是

为了听起来

高端。



f(n)

的函数

参数会不断

变化，所以你

把参数 n 想做

一个状态，这

个状态 n

是由

状态 n - 1

和状态

n - 2 转移（相加）而

来，这就叫状

态转移，仅此

而已。

你会发

现，上面的几

种解法中的

所有操作，例

如 return f(n -

1) + f(n -

2)，dp[i] = dp[i -

1] + dp[i -

2]，以及对备

忘录或 DP table 的初

始化操作，都

是围绕这个

方程式的不

同表现形式

。

可见列出「状

态转移方程

」的重要性，它

是解决问题

的核心，而且

很容易发现

，其实状态转

移方程直接

代表着暴力

解法。



千万不

要看不起暴

力解，动态规

划问题最困

难的就是写

出这个暴力

解，即状态转

移方程。

只要

写出暴力解

，优化方法无

非是用备忘

录或者 DP table，再无

奥妙可言。

这

个例子的最

后，讲一个细

节优化。



细心

的读者会发

现，根据斐波

那契数列的

状态转移方

程，当前状态

n 只和之前的

n-1,

n-2 两个状态有

关，其实并不

需要那么长

的一个 DP table

来存

储所有的状

态，只要想办

法存储之前

的两个状态

就行了。



所以

，可以进一步

优化，把空间

复杂度降为

O(1)。这也就是我

们最常见的

计算斐波那

契数的算法

：

java 🟢cpp 🤖python 🤖go

🤖javascript 🤖



int

fib(int n) {

if (n

== 0 || n

== 1) {



// base case



return n;

}

//

分别代表 dp[i - 1]

和

dp[i - 2]

int dp_i_1

= 1, dp_i_2 =

0;

for (int i =

2; i <= n;

i++) {



// dp[i] = dp[i

- 1] + dp[i

- 2];



int dp_i = dp_i_1

+ dp_i_2;



// 滚动更新



dp_i_2 = dp_i_1;



dp_i_1 = dp_i;

}

return

dp_i_1;

}

算

法可视化面

板

这一般是

动态规划问

题的最后一

步优化，如果

我们发现每

次状态转移

只需要 DP table

中的

一部分，那么

可以尝试缩

小 DP table 的大小，只

记录必要的

数据，从而降

低空间复杂

度。

上述例子

就相当于把

DP table 的大小从 n

缩

小到 2，即把空

间复杂度下

降了一个量

级。我会在后

文 对动态规

划发动降维

打击 进一步

讲解这个压

缩空间复杂

度的技巧，一

般来说用来

把一个二维

的

DP table 压缩成一

维，即把空间

复杂度从 O(n^2)

压

缩到 O(n)。



有人会

问，动态规划

的另一个重

要特性「最优

子结构」，怎么

没有涉及？下

面会涉及。斐

波那契数列

的例子严格

来说不算动

态规划，因为

没有涉及求

最值，以上旨

在说明重叠

子问题的消

除方法，演示

得到最优解

法逐步求精

的过程。下面

，看第二个例

子，凑零钱问

题。

二、凑零钱

问题

这是力

扣第 322 题「零钱

兑换」：

给你 k 种

面值的硬币

，面值分别为

c1, c2

... ck，每种硬币的

数量无限，再

给一个总金

额 amount，问你最少

需要几枚硬

币凑出这个

金额，如果不

可能凑出，算

法返回 -1

。算法

的函数签名

如下：



java 🟢cpp

🤖python 🤖go 🤖javascript 🤖

// coins 中是可

选硬币面值

，amount 是目标金额

int

coinChange(vector<int>& coins, int amount);

比如说 k = 3，面值

分别为

1，2，5，总金

额 amount = 11。那么最少

需要

3 枚硬币

凑出，即 11 =

5 + 5 +

1。



你认

为计算机应

该如何解决

这个问题？显

然，就是把所

有可能的凑

硬币方法都

穷举出来，然

后找找看最

少需要多少

枚硬币。

暴力

递归

首先，这

个问题是动

态规划问题

，因为它具有

「最优子结构

」的。要符合「最

优子结构」，子

问题间必须

互相独立。啥

叫相互独立

？你肯定不想

看数学证明

，我用一个直

观的例子来

讲解。



比如说

，假设你考试

，每门科目的

成绩都是互

相独立的。你

的原问题是

考出最高的

总成绩，那么

你的子问题

就是要把语

文考到最高

，数学考到最

高……

为了每门

课考到最高

，你要把每门

课相应的选

择题分数拿

到最高，填空

题分数拿到

最高…… 当然，最

终就是你每

门课都是满

分，这就是最

高的总成绩

。



得到了正确

的结果：最高

的总成绩就

是总分。因为

这个过程符

合最优子结

构，「每门科目

考到最高」这

些子问题是

互相独立，互

不干扰的。

但

是，如果加一

个条件：你的

语文成绩和

数学成绩会

互相制约，不

能同时达到

满分，数学分

数高，语文分

数就会降低

，反之亦然。



这

样的话，显然

你能考到的

最高总成绩

就达不到总

分了，按刚才

那个思路就

会得到错误

的结果。因为

「每门科目考

到最高」的子

问题并不独

立，语文数学

成绩户互相

影响，无法同

时最优，所以

最优子结构

被破坏。

回到

凑零钱问题

，为什么说它

符合最优子

结构呢？假设

你有面值为

1, 2, 5 的硬币，你想

求

amount = 11 时的最少

硬币数（原问

题），如果你知

道凑出

amount = 10, 9,

6 的最

少硬币数（子

问题），你只需

要把子问题

的答案加一

（再选一枚面

值为 1, 2,

5 的硬币

），求个最小值

，就是原问题

的答案。因为

硬币的数量

是没有限制

的，所以子问

题之间没有

相互制，是互

相独立的。



Tip

关

于最优子结

构的问题，后

文 动态规划

答疑篇 还会

再举例探讨

。

那么，既然知

道了这是个

动态规划问

题，就要思考

如何列出正

确的状态转

移方程？



1、确定

「状态」，也就是

原问题和子

问题中会变

化的变量。由

于硬币数量

无限，硬币的

面额也是题

目给定的，只

有目标金额

会不断地向

base case

靠近，所以唯

一的「状态」就

是目标金额

amount。



2、确定「选择」，也

就是导致「状

态」产生变化

的行为。目标

金额为什么

变化呢，因为

你在选择硬

币，你每选择

一枚硬币，就

相当于减少

了目标金额

。所以说所有

硬币的面值

，就是你的「选

择」。

3、明确 dp 函数

/数组的定义

。我们这里讲

的是自顶向

下的解法，所

以会有一个

递归的 dp

函数

，一般来说函

数的参数就

是状态转移

中会变化的

量，也就是上

面说到的「状

态」；函数的返

回值就是题

目要求我们

计算的量。就

本题来说，状

态只有一个

，即「目标金额

」，题目要求我

们计算凑出

目标金额所

需的最少硬

币数量。



所以

我们可以这

样定义 dp

函数

：dp(n) 表示，输入一

个目标金额

n，返回凑出目

标金额 n 所需

的最少硬币

数量。

那么根

据这个定义

，我们的最终

答案就是 dp(amount) 的

返回值。

搞清

楚上面这几

个关键点，解

法的伪码就

可以写出来

了：



java 🟢cpp

🤖python 🤖go 🤖javascript 🤖

// 伪码框架

int coinChange(vector<int>& coins,

int amount) {

// 题目要求的

最终结果是

dp(amount)

return

dp(coins, amount);

}

// 定义：要凑出

金额 n，至少要

dp(coins, n)

个硬币

int dp(vector<int>& coins,

int n) {

// 做选

择，选择需要

硬币最少的

那个结果

int

res = INT_MAX;

for (const

int coin : coins)

{



res = min(res, subProb

+ 1);

}

return res;

}

根

据伪码，我们

加上 base case 即可得

到最终的答

案。显然目标

金额为

0 时，所

需硬币数量

为 0；当目标金

额小于 0

时，无

解，返回 -1：



java

🟢cpp 🤖python 🤖go 🤖javascript

🤖



class Solution

{

public:

int coinChange(vector<int>& coins,

int amount) {



// 题目

要求的最终

结果是 dp(amount)



return dp(coins,

amount);

}



private:

// 定义

：要凑出金额

n，至少要

dp(coins, n) 个硬

币

int dp(vector<int>&

coins, int amount) {



// base

case



if (amount == 0)

return 0;



if (amount < 0)

return -1;



int res =

INT_MAX;



for (int coin :

coins) {





// 计算子问

题的结果





int subProblem = dp(coins,

amount - coin);





// 子

问题无解则

跳过





if (subProblem == -1)

continue;



//

在子问

题中选择最

优解，然后加

一



res

= min(res, subProblem +

1);



}



return res == INT_MAX

? -1 : res;

}

};

Info



这里

coinChange 和 dp 函

数的签名完

全一样，所以

理论上不需

要额外写一

个

dp 函数。但为

了后文讲解

方便，这里还

是另写一个

dp 函数来实现

主要逻辑。

另

外，我经常看

到有读者留

言问，子问题

的结果为什

么要加 1（subProblem + 1），而不

是加硬币金

额之类的。我

这里统一提

示一下，动态

规划问题的

关键是

dp 函数

/数组的定义

，你这个函数

的返回值代

表什么？你回

过头去搞清

楚这一点，然

后就知道为

什么要给子

问题的返回

值加 1 了。

算法

可视化面板

至此，状态转

移方程其实

已经完成了

，以上算法已

经是暴力解

法了，以上代

码的数学形

式就是状态

转移方程：

至

此，这个问题

其实就解决

了，只不过需

要消除一下

重叠子问题

，比如 amount = 11,

coins = {1,2,5} 时画出

递归树看看

：

递归算法的

时间复杂度

分析：子问题

总数 x 解决每

个子问题所

需的时间。

子

问题总数为

递归树的节

点个数，但算

法会进行剪

枝，剪枝的时

机和题目给

定的具体硬

币面额有关

，所以可以想

象，这棵树生

长的并不规

则，确切算出

树上有多少

节点是比较

困难的。对于

这种情况，我

们一般的做

法是按照最

坏的情况估

算一个时间

复杂度的上

界。



假设目标

金额为 n，给定

的硬币个数

为

k，那么递归

树最坏情况

下高度为 n（全

用面额为 1 的

硬币），然后再

假设这是一

棵满

k 叉树，则

节点的总数

在 k^n 这个数量

级。

接下来看

每个子问题

的复杂度，由

于每次递归

包含一个 for 循

环，复杂度为

�

(

�

)

O(k)，相乘得到总

时间复杂度

为

�

(

�

�

)

O(k 

n

)，指数级别

。



带备忘录的

递归

类似之

前斐波那契

数列的例子

，只需要稍加

修改，就可以

通过备忘录

消除子问题

：

java 🟢cpp 🤖python 🤖go

🤖javascript 🤖



class

Solution {

public:

vector<int> memo;



int

coinChange(vector<int>& coins, int amount)

{



memo = vector<int> (amount

+ 1, -666);



// 备忘录初始

化为一个不

会被取到的

特殊值，代表

还未被计算





return dp(coins, amount);

}

int

dp(vector<int>& coins, int amount)

{



if (amount == 0)

return 0;



if (amount < 0)

return -1;



// 查备忘录，防

止重复计算





if (memo[amount] != -666)





return memo[amount];



int res

= INT_MAX;



for (int coin :

coins) {





// 计算子问题

的结果





int subProblem = dp(coins,

amount - coin);





// 子问

题无解则跳

过





if (subProblem == -1)

continue;



//

在子问题

中选择最优

解，然后加一





res =

min(res, subProblem + 1);



}



// 把计算结果

存入备忘录





memo[amount] = (res ==

INT_MAX) ? -1 :

res;



return memo[amount];

}

};

算法可视化

面板

不画图

了，很显然「备

忘录」大大减

小了子问题

数目，完全消

除了子问题

的冗余，所以

子问题总数

不会超过金

额数 n，即子问

题数目为

�

(

�

)

O(n)。处

理一个子问

题的时间不

变，仍是 

�

(

�

)

O(k)，所以

总的时间复

杂度是

�

(

�

�

)

O(kn)。



dp

数组

的迭代解法

当然，我们也

可以自底向

上使用 dp table 来消

除重叠子问

题，关于「状态

」「选择」和

base case 与之

前没有区别

，dp 数组的定义

和刚才

dp 函数

类似，也是把

「状态」，也就是

目标金额作

为变量。不过

dp 函数体现在

函数参数，而

dp 数组体现在

数组索引：

dp 数

组的定义：当

目标金额为

i 时，至少需要

dp[i] 枚硬币凑出

。

根据我们文

章开头给出

的动态规划

代码框架可

以写出如下

解法：



java 🟢cpp

🤖python 🤖go 🤖javascript 🤖

class Solution {

public:

int

coinChange(vector<int>& coins, int amount)

{



// 数组大

小为 amount +

1，初始值

也为 amount + 1



vector<int> dp(amount

+ 1, amount +

1);



dp[0] = 0;



// base case



// 外层

for 循

环在遍历所

有状态的所

有取值



for (int i =

0; i < dp.size();

i++) {





// 内层

for 循环在求所

有选择的最

小值





for (int coin :

coins) {





//

子问题

无解，跳过





if (i

- coin < 0)

{







continue;





}







dp[i] = min(dp[i], 1

+ dp[i - coin]);





}



}



return (dp[amount] == amount

+ 1) ? -1

: dp[amount];

}

};

Info

为

啥 dp 数组中的

值都初始化

为 amount

+ 1 呢，因为凑

成 amount

金额的硬

币数最多只

可能等于 amount（全

用 1 元面值的

硬币），所以初

始化为

amount + 1 就相

当于初始化

为正无穷，便

于后续取最

小值。为啥不

直接初始化

为

int 型的最大

值 Integer.MAX_VALUE 呢？因为后

面有

dp[i - coin] +

1，这就会

导致整型溢

出。





三、最后总

结

第一个斐

波那契数列

的问题，解释

了如何通过

「备忘录」或者

「dp table」的方法来优

化递归树，并

且明确了这

两种方法本

质上是一样

的，只是自顶

向下和自底

向上的不同

而已。



第二个

凑零钱的问

题，展示了如

何流程化确

定「状态转移

方程」，只要通

过状态转移

方程写出暴

力递归解，剩

下的也就是

优化递归树

，消除重叠子

问题而已。

如

果你不太了

解动态规划

，还能看到这

里，真得给你

鼓掌，相信你

已经掌握了

这个算法的

设计技巧。



计

算机解决问

题其实没有

任何特殊的

技巧，它唯一

的解决办法

就是穷举，穷

举所有可能

性。算法设计

无非就是先

思考“如何穷

举”，然后再追

求“如何聪明

地穷举”。

列出

状态转移方

程，就是在解

决“如何穷举

”的问题。之所

以说它难，一

是因为很多

穷举需要递

归实现，二是

因为有的问

题本身的解

空间复杂，不

那么容易穷

举完整。



备忘

录、DP table

就是在追

求“如何聪明

地穷举”。用空

间换时间的

思路，是降低

时间复杂度

的不二法门

，除此之外，试

问，还能玩出

啥花活？



之后

我们会有一

章专门讲解

动态规划问

题，如果有任

何问题都可

以随时回来

重读本文，希

望读者在阅

读每个题目

和解法时，多

往「状态」和「选

择」上靠，才能

对这套框架

产生自己的

理解，运用自

如。

引用本文

的题目

安装

我的 Chrome 刷题插

件

点开下列

题目可直接

查看解题思

路：



LeetCode	力扣

难度

111. Minimum Depth of

Binary Tree	111. 二叉树的最

小深度

🟢

112. Path Sum

112. 路径

总和	🟢

115.

Distinct Subsequences	115. 不同的

子序列

🔴

139. Word Break

139. 单词

拆分	🟠

1696.

Jump Game VI	1696.

跳跃游

戏 VI	🟠

221.

Maximal Square	221. 最大正方

形

🟠

240. Search a

2D Matrix II	240.

搜索二维

矩阵 II	🟠

256.

Paint House🔒	256. 粉刷房

子🔒

🟠

279. Perfect Squares

279. 完全平方

数	🟠

343.

Integer Break	343. 整数拆分

🟠

365. Water and Jug

Problem	365. 水壶问题	🟠

542. 01 Matrix	542.

01 矩

阵	🟠

576.

Out of Boundary Paths

576. 出界的路

径数	🟠

62.

Unique Paths	62. 不同路

径

🟠

63. Unique Paths

II	63. 不同路径

II	🟠

70. Climbing Stairs	70.

爬楼梯	🟢

91. Decode

Ways	91. 解码

方法	🟠

-	剑指 Offer 04.

二

维数组中的

查找	🟠

-	剑指

Offer 10- I. 斐

波那契数列

🟢

-	剑指 Offer 10-

II. 青蛙跳

台阶问题	🟢

-

剑

指 Offer 14- I.

剪绳子	🟠

-	剑

指

Offer 46. 把数字翻

译成字符串

🟠

-

剑指 Offer II 091.

粉刷房

子	🟠

-	剑指

Offer II 097. 子序

列的数目

🔴

-	剑

指 Offer

II 098. 路径的数

目	🟠

-	剑指 Offer II

103. 最少

的硬币数目

🟠
