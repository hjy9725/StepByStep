图灵社区会

员 heruihong 专享 尊重

版权

图灵社

区会员 heruihong 专享

尊重版权

图

灵社区会员

heruihong

专享 尊重版

权

图灵社区

会员 heruihong

专享 尊

重版权

内 容

提

要

本书是

NumPy 的入门教程

，主要介绍 NumPy

以

及相关的 Python 科

学计算库，如

SciPy 和

Matplotlib。

本书内容

涵盖 NumPy 安装、数

组对象、常用

函数、矩阵运

算、线性代数

、金融函数、窗

函数、质量控

制、

Matplotlib 绘图、SciPy 简介

以及 Pygame

等内容

，涉及面较广

。另外，Ivan Idris 针对每

个知识点给

出了简

短而

明晰的示例

，并为大部分

示例给出了

实用场景（如

股票数据分

析），在帮助初

学者入门的

同时，提高了

本书可读性

。

本书适合正

在找寻高质

量开源计算

库的科学家

、工程师、程序

员和定量管

理分析师阅

读参考。

定价

：49.00元

读者服务

热线：(010)51095186转600　印装

质量热线：(010)81055316

反

盗版热线：(010)81055315

广

告经营许可

证：京崇工商

广字第 0021 号

著

[印尼]

Ivan Idris

译

张驭

宇

责任编辑

毛倩倩

执行

编辑

程　芃

责

任印制　焦志

炜

人民邮电

出版社出版

发行　　北京市

丰台区成寿

寺路11号

邮编

100164

电子邮件　315@ptpress.com.cn

网

址　http://www.ptpress.com.cn

北京

印刷

开本：800×1000 1/16

印张：15.25

字

数：371千字 2014年 1

月

第 1 版

印数：1

— 4 000册

2014年 1

月北京第

1 次印刷

著作

权合同登记

号 图字：01-2013-5239号

◆

◆

◆

图

灵社区会员

heruihong

专享 尊重版

权

错误！文档

中没有指定

样式的文字

。 1

1 

2

3 

4

5

8 

10

13 

9

6

7 

12

11 

版 权

声 明

Copyright ©

2013 Packt Publishing. First

published in the English

language under the title

NumPy 

Beginner’s Guide,

Second Edition. 

Simplified

Chinese-language edition copyright ©

2014 by Posts &

Telecom Press. All rights

reserved. 

本

书中文简体

字版由Packt Publishing授权

人民邮电出

版社独家出

版。未经出版

者书面许可

，

不得以任何

方式复制或

抄袭本书内

容。

版权所有

，侵权必究。

图

灵社区会员

heruihong 专享

尊重版

权

前 言 1

1 

2

3 

4

5

8 

10

13 

9

6

7 

12

11 

译 者

序

NumPy，即Numeric Python的缩写

，是一个优秀

的开源科学

计算库，并已

经成为Python科学

计算生态系

统的重要组

成部分。NumPy为我

们提供了丰

富的数学函

数、强大的多

维数组对象

以及

优异的

运算性能。尽

管Python作为流行

的编程语言

非常灵活易

用，但它本身

并非为科学

计算量身

定

做，在开发效

率和执行效

率上均不适

合直接用于

数据分析，尤

其是大数据

的分析和处

理。幸运

的是

，NumPy为Python插上了翅

膀，在保留Python语

言优势的同

时大大增强

了科学计算

和数据处

理

的能力。更重

要的是，NumPy与SciPy、Matplotlib、SciKits等

其他众多Python科

学计算库很

好

地结合在

一起，共同构

建了一个完

整的科学计

算生态系统

。毫不夸张地

讲，NumPy是使用Python

进

行数据分析

的一个必备

工具。

说起NumPy，我

是在数据的

“赛场”上与之

结缘的。出于

对数据挖掘

和机器学习

的爱好，我

与

中国科学院

和北京大学

的同学一起

组建了一支

名为BrickMover的“比赛

小分队”，队友

包括庞

亮、石

磊、刘旭东、黎

强、孙晗晓、刘

璐等。我们先

后参加了一

些国内外的

数据挖掘比

赛，包括

百度

电影推荐系

统算法创新

大赛、首届中

国计算广告

学大赛暨RTB算

法大赛、RecSys

Challenge 

2013、ICDM Contest

2013等，并

且取得了还

算不错的成

绩。无一例外

的是，这些比

赛均需要对

数

据进行快

速、全面的分

析。感谢NumPy，它正

是我们使用

的数据分析

利器之一。

本

书作为NumPy的入

门教程，从安

装NumPy讲起，涵盖

NumPy数组对象、常

用函数、矩阵

运

算、线性代

数、金融函数

、窗函数、质量

控制、Matplotlib绘图、SciPy简

介以及Pygame等内

容，

涉及面较

为广泛。书中

对每个知识

点均给出了

简短而明晰

的示例，很适

合初学者上

手。大部分示

例都有真实

的应用场景

（如股票数据

分析），可读性

远远好于枯

燥的官方文

档，帮助读者

在掌握

NumPy使用

技能的同时

拓宽视野、拓

展思维。本书

的阅读门槛

不高，读者只

需具备基本

的Python

编程知识

。

在翻译本书

的过程中，我

发现原作有

不少地方不

够严谨，甚至

还有一些错

误。经过反复

核对

确认，我

已经修改了

发现的错误

，并在我认为

不够严谨的

地方以译者

注的形式给

出了自己的

理解，

供读者

参考。此外，原

书中的配图

为屏幕截图

，清晰度较低

。为了读者获

得最佳的阅

读体验，我

将

书中的代码

全部运行了

一遍，并输出

矢量图以替

换原有的配

图。需要说明

的是，书中部

分代码

将会

在线下载最

近一年的股

价数据，即数

据的时间区

段取决于代

码运行时的

日期。因此，这

部分

代码对

应的新配图

会与原书中

的配图稍有

差异，但对读

者不会有任

何影响。

图灵

社区会员 heruihong 专

享

尊重版权

2 译者序

感谢

我的研究生

导师王斌老

师的力荐，他

让我有幸成

为本书的译

者。王老师已

有《信息检索

导论》《大数据

：大规模互联

网数据挖掘

与分布式处

理》《机器学习

实战》等诸多

译著。他并不

满

足于自己

畅读国外的

优质书籍，而

是字斟句酌

、不辞辛劳地

完成同样优

质的译作与

广大中文读

者

共飨，这份

精神让我深

受鼓舞。也正

因为此，我才

鼓起勇气接

受了这次自

我挑战，不遗

余力地完

成

了人生第一

次翻译工作

。在这个过程

中，要感谢图

灵公司的李

松峰老师对

译稿提出细

致严谨的

修

改意见，感谢

傅志红、朱巍

、毛倩倩、程芃

等出版界同

仁在审校、编

辑阶段给予

的帮助。最后

，

感谢我的家

人，以及BrickMover

Team的小

伙伴们对翻

译本书的支

持。

由于自己

的专业水平

和翻译能力

十分有限，加

上时间仓促

，译稿中的疏

漏之处在所

难免，恳

请读

者谅解。希望

读者通过新

浪微博@张驭

宇UCAS和个人邮

箱i@zhangyuyu.com，不吝提出

宝贵

的修改

意见和建议

，共同努力不

断完善译稿

。

对于每一个

期望快速了

解NumPy，却又担心

自己迷失在

浩如烟海的

官方文档中

的人，这本书

值得一读。

张

驭宇

2013年11月于

中关村

图灵

社区会员

heruihong 专

享 尊重版权

2 前

言

献给我

的家人和朋

友们。 

图灵社

区会员

heruihong 专享

尊重版权

前

言 1

1 

2

3 

4

5

8 

10

13 

9

6

7 

12

11 

关于审稿

人

Jaidev

Deshpande是Enthought公司的

一位实习生

，他在那里主

要做数据分

析和数据可

视化

方面的

工作。他是个

狂热的科学

计算程序员

，在信号处理

、数据分析和

机器学习的

很多开源项

目

中都有贡

献。

Alexandre

Devert博士在中

国科学技术

大学从事数

据挖掘和软

件工程的教

学工作。他同

时也

是一位

研究员，从事

最优化问题

的研究，并在

生物技术创

业公司中研

究数据挖掘

问题。在所有

这

些工作中

，Alexandre非常乐于使

用Python、NumPy和SciPy。

Mark

Livingstone曾为三

家跨国计算

机公司（如今

已不复存在

）工作，在工程

、产品支持、

编

程和培训等

部门任职。他

厌倦了被裁

员的遭遇。2011年

，他从澳大利

亚黄金海岸

的Griffith大学

毕业

，获得信息技

术学士学位

。目前是他攻

读信息技术

荣誉学士学

位的最后一

个学期，研究

的是

蛋白质

相关的算法

。研究工作中

用到的软件

均是在Mac电脑

上用Python写成的

。他的导师以

及整

个研究

小组都感受

到了Python编程的

乐趣。

Mark喜欢指

导需要帮助

的大一新生

，他是Griffith大学IEEE学

生分会主席

，也是Courthouse

地区的

太平绅士，曾

经担任过信

用合作社的

主管，并将在

2013年年底完成

100次献血的计

划。

他在业余

时间也很多

产，曾与人合

作开发了S2

Salstat Statistics Package（项

目主页①：http://code.

google.com/p/salstat-statistics-package-2/）。这是

一个跨平台

的统计工具

包，其中用到

了wxPython、

NumPy、SciPy、SciKit、Matplotlib等许多Python模

块。

Miklós Prisznyák是一位有

自然科学背

景的资深软

件工程师。他

毕业于匈牙

利历史最悠

久、

规模最大

的大学Eötvös Lóránd大学

，从事物理专

业工作。他于

1992年完成了硕

士论文，研究

了非

阿贝尔

的晶格量子

场论的蒙特

卡罗仿真。在

匈牙利物理

研究中心工

作三年后，他

加入了布达

佩斯

的MultiRáció

Kft。这家

公司是由一

群物理学家

创办的，专注

于用数学方

法分析数据

和预测经济

数

据。在那里

，他的主要项

目是小区域

内的失业统

计分析系统

，从那时候起

，这一系统就

一直被匈

牙

利政府用于

公共就业服

务。2000年他开始

学习Python编程。2002年

，他创办了自

己的咨询公

司，

将Python用于所

有能用的项

目，服务于各

种各样的保

险、医药和电

子商务公司

。他还曾在意

大利

—————————— 

① 该项目

主页已过期

并迁移至SourceForge：http://sourceforge.net/projects/s2statistical/。——译

者注

图灵社

区会员 heruihong 专享

尊重版权

2

关

于审稿人

的

一家欧盟研

究所工作，负

责测试和优

化基于Python的Zope/Plone分

布式网络应

用程序。2007年

他

移居英国，先

是在一家苏

格兰的创业

公司工作，使

用Twisted Python；随后在英

国航天工业

部

门工作，使

用PyQt窗口工具

包、Enthought应用程序

框架，以及NumPy和

SciPy。2012年，他回到

匈

牙利并重新

加入MultiRáció，目前的

工作主要涉

及OpenOffice/EuroOffice上的Python扩展

模块，

并再次

使用NumPy和SciPy来让

用户求解非

线性问题和

随机优化问

题。Miklós喜欢旅行

和阅读，

他兴

趣广泛，对自

然科学、语言

学、历史、政治

、跳棋等均有

涉猎。香浓的

咖啡是他的

最爱。不

过，最

美好的莫过

于和他聪明

的10岁大的儿

子Zsombor一起享受

时光。

Nikolay Karelin拥有光

学博士学位

，有近20年利用

各种方法进

行数值仿真

和分析的经

验，先

后在学

术界和工业

界（从事光纤

通信链路的

仿真）工作。在

初识Python和NumPy后，他

在过去的

五

年内逐渐将

这些优秀的

工具用于几

乎所有数值

分析和脚本

编写工作。

感

谢我的家人

，感谢他们在

我审阅本书

的一个个漫

漫长夜所给

予的理解与

支持。

图灵社

区会员 heruihong

专享

尊重版权

前

言 1

1 

2

3 

4

5

8 

10

13 

9

6

7 

12

11 

前 言

如今

，科学家、工程

师以及定量

管理分析师

面临着众多

的挑战。数据

科学家们希

望能够用最

小的编程代

价在大数据

集上进行数

值分析，他们

希望自己编

写的代码可

读性好、执行

效率高、运

行

速度快，并尽

可能地贴近

他们熟悉的

一系列数学

概念。在科学

计算领域，有

很多符合这

些要求

的解

决方案。

在这

方面，C、C++和Fortran等编

程语言各有

优势，但它们

不是交互式

语言，并且被

很多人

认为

过于复杂。常

见的商业产

品还有Matlab、Maple和Mathematica。这

些产品提供

了强大的脚

本

语言，但和

通用编程语

言比起来，功

能依然很有

限。另外还有

一些类似于

Matlab的开源工具

，如

R、GNU Octave和Scilab。显然，作

为编程语言

，它们都不如

Python强大。

Python是一种

流行的通用

编程语言，在

科学领域被

广泛使用。你

很容易在Python代

码中调用

以

前的C、Fortran或者R代

码。Python是面向对

象语言，比C和

Fortran更加高级。使

用Python可以

写出

易读、整洁并

且缺陷最少

的代码。然而

，Python本身并不具

有与Matlab等效的

功能块，而这

恰恰就是NumPy存

在的意义。本

书就是要介

绍NumPy以及相关

的Python科学计算

库，如SciPy和

Matplotlib。

NumPy是什

么

NumPy（Numerical Python的缩写）是

一个开源的

Python科学计算库

。使用NumPy，就可以

很自然地使

用数组和矩

阵。NumPy包含很多

实用的数学

函数，涵盖线

性代数运算

、傅里叶变换

和

随机数生

成等功能。如

果你的系统

中已经装有

LAPACK，NumPy的线性代数

模块会调用

它，否则

NumPy将使

用自己实现

的库函数。LAPACK是

一个著名的

数值计算库

，最初是用Fortran写

成的，

Matlab同样也

需要调用它

。从某种意义

上讲，NumPy可以取

代Matlab和Mathematica的部分

功能，

并且允

许用户进行

快速的交互

式原型设计

。

在本书中，我

们不会从程

序开发者的

角度来讨论

NumPy，而是更多地

立足于用户

，从他们的

角

度来分析它

。不过值得一

提的是，NumPy是一

个非常活跃

的开源项目

，拥有很多的

贡献者，也

许

有一天你也

能成为其中

的一员！

图灵

社区会员 heruihong

专

享 尊重版权

2 前 言

NumPy的由来

NumPy的前身是Numeric。Numeric最

早发布于1995年

，如今已经废

弃了。由于种

种原因，不

管

是Numeric还是NumPy，都没

能进入Python标准

库，不过单独

安装NumPy也很方

便。关于NumPy

的安

装，我们将在

第1章中详细

介绍。

早在2001年

，一些开发者

受Numeric的启发共

同开创了一

个叫做SciPy的项

目。SciPy是一个开

源的Python科学计

算库，提供了

类似于Matlab、Maple和Mathematica的

许多功能。那

段时间，人

们

对于Numeric越来越

不满。于是，Numarray作

为Numeric的替代品

问世了。Numarray在某

些方面

比Numeric更

强大，但是它

们的工作方

式却截然不

同。鉴于此，SciPy继

续遵循Numeric的工

作方

式，并延

续了对Numeric数组

对象的支持

。虽然人们总

是倾向于使

用“最新最好

”的软件，但是

Numarray依然催生出

了一整套的

系统，包括很

多周边的实

用工具软件

。

2005年，SciPy的早期发

起人之一Travis

Oliphant决

定改变这一

状况，他开始

将Numarray的一

些特

性整合到Numeric中

。一整套的代

码重构工作

就此开始，并

于2006年NumPy 1.0发布的

时候全

部完

成。于是NumPy拥有

了Numeric和Numarray的所有

特性，并且还

新增了一些

功能。SciPy提供

了

一个升级工

具，可以让用

户方便地从

Numeric和Numarray升级到NumPy。由

于Numeric和

Numarray均不再

活跃更新，升

级是必然的

。

如上所述，最

初的NumPy其实是

SciPy的一部分，后

来才从SciPy中分

离出来。如今

，SciPy

在处理数组

和矩阵时会

调用NumPy。

为什么

使用NumPy 

对于同

样的数值计

算任务，使用

NumPy要比直接编

写Python代码便捷

得多。这是因

为NumPy

能够直接

对数组和矩

阵进行操作

，可以省略很

多循环语句

，其众多的数

学函数也会

让编写代码

的

工作轻松

许多。NumPy的底层

算法在设计

时就有着优

异的性能，并

且经受住了

时间的考验

。

NumPy中数组的存

储效率和输

入输出性能

均远远优于

Python中等价的基

本数据结构

（如嵌套

的list容

器）。其能够提

升的性能是

与数组中元

素的数目成

比例的。对于

大型数组的

运算，使用

NumPy的

确很有优势

。对于TB级的大

文件，NumPy使用内

存映射文件

来处理，以达

到最优的数

据读写性能

。不过，NumPy数组的

通用性不及

Python提供的list容器

，这是其不足

之处。因此在

科

学计算之

外的领域，NumPy的

优势也就不

那么明显了

。关于NumPy数组的

技术细节，我

们将在后

面

详细讨论。

NumPy的

大部分代码

都是用C语言

写成的，这使

得NumPy比纯Python代码

高效得多。NumPy

同

样支持C语言

的API，并且允许

在C源代码上

做更多的功

能拓展。C

API的内

容不在本书

讨论之

图灵

社区会员 heruihong 专

享

尊重版权

前 言 3

1 

2

3 

4

5

8 

10

13 

9

6

7 

12

11 

列。最后

要记往一点

，NumPy是开源的，这

意味着使用

NumPy可以享受到

开源带来的

所有益处。

价

格低到了极

限——免费。你再

也不用担心

每次有新成

员加入团队

时，就要面对

软件授权及

更新

的问题

了。开源代码

是向所有人

开放的，对于

代码质量而

言这是非常

有利的。

NumPy的局

限性

如果你

是Java程序员，可

能会对Jython感兴

趣。Jython是Python语言在

Java中的完整实

现。遗

憾的是

，Jython运行在Java虚拟

机上，无法调

用NumPy，因为大部

分NumPy模块是用

C语言实现

的

。Python和Jython可以说是

完全不同的

两个世界，尽

管它们实现

的是同一套

语言规范。当

然，

仍然有一

些变通方案

，具体内容在

本书作者的

另一本著作

《NumPy攻略》中有所

讨论。

本书内

容

第1章指导

你在系统中

安装NumPy，并创建

一个基本的

NumPy应用程序。

第

2章介绍NumPy数组

对象以及一

些基础知识

。

第3章教你使

用NumPy中最常用

的基本数学

和统计分析

函数。

第4章讲

述如何便捷

地使用NumPy，包括

如何选取数

组的某一部

分（例如根据

一组布尔值

来

选取）、多项

式拟合，以及

操纵NumPy对象的

形态。

第5章涵

盖了矩阵和

通用函数的

内容。矩阵在

数学中使用

广泛，在NumPy中也

有专门的对

象

来表示。通

用函数（ufuncs）是一

个能用于NumPy对

象的标量函

数，该函数的

输入为一组

标量，

并将生

成一组标量

作为输出。

第

6章探讨通用

函数的一些

基本模块。通

用函数通常

可映射到对

应的数学运

算，如加、减、

乘

、除等。

第7章介

绍NumPy中的一些

专用函数。作

为NumPy用户，我们

时常发现自

己有一些特

殊的需

求。幸

运的是，NumPy能满

足我们的大

部分需求。

第

8章介绍怎样

编写NumPy的单元

测试代码。

第

9章深入介绍

非常有用的

Python绘图库Matplotlib。虽然

NumPy本身不能用

来绘图，但是

Matplotlib和NumPy两者完美

地结合在一

起，其绘图能

力可与Matlab相媲

美。

第10章更详

细地介绍SciPy。如

前所述，SciPy和NumPy是

有历史渊源

的，SciPy是一套高

端

Python科学计算

框架，可以与

NumPy共同使用。

图

灵社区会员

heruihong

专享 尊重版

权

4 前

言

第11章

是本书的“餐

后甜点”，这一

章介绍如何

用NumPy和Pygame写出有

趣的游戏。同

时，

我们也将

从中“品尝”到

人工智能的

“滋味”。

阅读条

件

要试验本

书中的代码

，你需要安装

最新版NumPy，因此

要先安装能

够运行NumPy的任

一版

Python。本书部

分示例代码

采用Matplotlib进行绘

图，这些代码

不一定需要

读者全部运

行，但依然

推

荐安装Matplotlib。本书

最后一章讲

的是SciPy，会讨论

一个使用SciKits的

例子。

以下是

开发及测试

示例代码所

需的软件：

 Python 2.7

 NumPy 2.0.0.dev20100915

 SciPy 0.9.0.dev20100915

 Matplotlib 1.1.1

 Pygame 1.9.1

 IPython 0.14.dev

当

然，我并不是

要你在计算

机上装全这

些软件或者

必须装指定

版本，但Python和NumPy是

必

须安装的

。

读者对象

本

书适合正在

找寻高质量

开源数学库

的科学家、工

程师、程序员

和分析师阅

读参考。读者

应

具备一些

基本的Python编程

知识。此外，读

者应该是经

常与数学和

统计学打交

道，或起码对

它们

感兴趣

。

排版约定

本

书会通过不

同样式区别

不同类型的

内容。下面给

出部分样式

的示例及解

释。

正文中的

代码格式如

此处所示：“注

意numpysum()函数中没

有使用for循环

。”

代码段如下

所示：

def numpysum(n):

a = numpy.arange(n)

** 2

b = numpy.arange(n) **

3 

 c

= a + b

return c

图灵社

区会员 heruihong 专享

尊重版权

前

言

5 

1

2 

3

4

5 

8

10 

13

9 

6

7

12 

11

当我们希

望你注意代

码中的某一

部分时，会将

相关的行或

项用粗体表

示：

reals = np.isreal(xpoints)

print "Real number?", reals

Real number? [ True

True True True False

False False False ]

命令行输

入输出如下

所示：

>>>fromnumpy.testing import rundocs

>>>rundocs('docstringtest.py') 

新术语

和重要的名

词将用楷体

表示。你在屏

幕、菜单或对

话框中看到

的文本会采

用加粗样式

：

“单击Next按钮进

入下一界面

。”

警告或重要

说明将写在

这里。

小贴士

和技巧将写

在这里。

读者

反馈

一直以

来，我们都非

常欢迎读者

朋友的意见

反馈。请告诉

我们你对本

书的看法，以

及你

喜欢还

是不喜欢书

中的内容。你

的意见对我

们非常重要

，我们将努力

使你从阅读

中得到最大

的收获。

如果

希望提出一

些反馈意见

，敬请发送邮

件至feedback@packtpub.com，并请在

邮件标题中

写

上书名。

如

果你想看某

方面的书并

希望我们出

版，请通过www.packtpub.com上

的SUGGEST

A TITLE

表单提交

选题建议，或

发送邮件至

suggest@packtpub.com。

如果你是某

个领域的专

家，或有兴趣

写书，欢迎访

问www.packtpub.com/authors，里面有我

们的作者指

南。

售后支持

感谢你购买

Packt出版的图书

。我们有诸多

售后支持服

务，希望给你

提供最大的

附加价值。

图

灵社区会员

heruihong 专享 尊重版

权

6 前 言

示例

代码下载

如

果你是www.packtpub.com的注

册用户并从

那里购买了

图书，可以从

网站上下载

配套的示例

代码①。如果你

是在别处购

买了本书，可

以访问www.packtpub.com/support并注

册，我们会直

接将

示例代

码以邮件形

式发送给你

。

勘误

尽管我

们处处小心

以保证图书

内容的准确

性，但错误仍

在所难免。如

果你在阅读

过程中发现

错误并告知

我们，不管是

文字还是代

码中的错误

，我们都将不

胜感激。这样

做可使其他

读者免于

困

惑，也能帮助

我们不断改

进后续版本

。如果你发现

任何错误，敬

请访问www.packtpub. 

com/support报告

给我们，即在

网页上选择

你购买的图

书，单击errata submission

form（提交

勘误②）

链接，并

输入详细描

述。一旦你提

出的错误被

证实，你的勘

误将被接受

并上传至我

们的网站，或

加入到已有

的勘误列表

中。若要查看

已有勘误，请

访问www.packtpub.com/support并通过

书名查找。

关

于盗版

在网

上，所有媒体

都会遭遇盗

版问题。Packt非常

重视版权保

护工作。如果

你在网上发

现Packt

出版物的

任何非法副

本，请立即向

我们提供侵

权网站的地

址或名称，以

便我们采取

补救措施。

敬

请通过copyright@packtpub.com联系

我们，告知涉

嫌侵权内容

的链接。

我们

非常感激你

的帮助。这将

保护我们作

者的利益，同

时也使我们

有能力继续

提供高品质

的

内容。

疑难

解答

如果对

本书的任何

方面有疑问

，欢迎发送邮

件至questions@packtpub.com，我们将

尽最大努

力

为你答疑解

惑。

——————————

① 也可在图

灵社区（iTuring.cn）本书

网页免费注

册下载。——编者

注

② 关于本书

中文版的勘

误，请访问图

灵社区（iTuring.cn）本书

网页提交。——编

者注

图灵社

区会员 heruihong 专享

尊重版权

目

录

1

2 

3

4 

5

6 

7

8 

9

10 

11

12 

13

14 

15

16 

18

17 

目 录

第 1 章

NumPy 快速入门...............................1

1.1 Python ........................................................1

1.2

动

手实践：在不

同的操作系

统上

安装 Python................................................1

1.3

Windows ....................................................2

1.4 动

手实践：在

Windows 上

安装 NumPy、

Matplotlib、SciPy

和 IPython ....................2

1.5

Linux..........................................................4

1.6 动手

实践：在 Linux

上安

装 NumPy、

Matplotlib、SciPy 和

IPython....................5

1.7 Mac OS

X ..................................................5

1.8 动手实

践：在

Mac OS X 上安装

NumPy、

Matplotlib 和 SciPy ....................................5

1.9 动手实践

：使用 MacPorts 或

Fink 安装

NumPy、SciPy、Matplotlib 和 IPython

....7

1.10 编译源代

码..............................................8

1.11

数组对象

..................................................8

1.12 动手实践：向

量加法...............................8

1.13

IPython：一个

交互式 shell 工具

...........11

1.14

在线资源和

帮助 ....................................14

1.15 本章小

结................................................15

第 2 章 NumPy

基础

.....................................16

2.1 NumPy 数组对象

.....................................16

2.2 动

手实践：创建

多维数组.......................17

2.2.1

选

取数组元素

..............................18

2.2.2 NumPy 数据类型..........................19

2.2.3 数

据类型对象

..............................20

2.2.4 字符编码

......................................20

2.2.5 自

定义数据类

型...........................21

2.2.6

dtype 类的属性

..........................22 

2.3

动手实践：创

建自定义数

据类型 ...........22

2.4 一维

数组的索引

和切片...........................23

2.5 动手

实践：多维数

组的切片和

索引........23

2.6 动手实

践：改变数组

的维度...................26

2.7 数组

的组合..............................................27

2.8 动手

实践：组合数

组

..............................27

2.9 数组的分

割..............................................30

2.10

动手实践

：分割数组.............................30

2.11 数

组的属性............................................32

2.12

动

手实践：数组

的转换.........................34

2.13 本章

小结................................................35

第

3 章 常

用函数............................................36

3.1

文件

读写..................................................36

3.2 动手实

践：读写文件

..............................36

3.3

CSV 文件.................................................37

3.4 动手实

践：读入

CSV 文件

.....................37

3.5 成交量加权

平均价格（VWAP）............38

3.6 动

手实践：计算

成交量加权

平均价

格 .............................................................38

3.6.1 算

术平均值函

数 ..........................38

3.6.2

时间加权

平均价格.......................39

3.7 取

值范围..................................................39

3.8

动手

实践：找到最

大值和最小

值 ...........40

3.9 统计分析

..................................................41

3.10 动手实践：简

单统计分析

.....................41

3.11 股票收益率

............................................43

3.12 动手实践：分

析股票收益

率 .................43

3.13

日期分析

................................................45

3.14 动手实践：分

析日期数据

.....................45

3.15

周汇总 ...................................................48

图灵

社区会员 heruihong

专

享 尊重版权

2 目 录

3.16 动手实

践：汇总数据

............................48

3.17 真实波动幅

度均值（ATR）.................52

3.18 动手

实践：计算真

实波动幅度

均值 ......52

3.19

简单移

动平均线 ....................................54

3.20 动

手实践：计算

简单移动平

均线

.........54

3.21 指数移

动平均线 ....................................56

3.22 动

手实践：计算

指数移动平

均线 .........56

3.23

布林带

...................................................58

3.24 动手实践：绘

制布林带.........................58

3.25

线

性模型................................................61

3.26 动手

实践：用线性

模型预测价

格 .........61

3.27 趋势线 ...................................................63

3.28

动

手实践：绘制

趋势线.........................63

3.29 ndarray 对象

的方法............................66

3.30 动手

实践：数组的

修剪和压缩

.............67

3.31 阶乘

.......................................................67

3.32 动手实

践：计算阶乘

............................67

3.33

本章小结................................................68

第

4 章 便捷函数

............................................70

4.1 相关性 .....................................................70

4.2

动手

实践：股票相

关性分析...................71

4.3 多

项式 .....................................................74

4.4 动手实

践：多项式拟

合...........................74

4.5 净额成交

量..............................................77

4.6 动手实践

：计算 OBV.............................78

4.7

交易过

程模拟..........................................79

4.8 动手

实践：避免使

用循环.......................80

4.9

数据

平滑 .................................................82

4.10 动手实

践：使用

hanning 函数

平滑

数据........................................................82

4.11

本

章小结................................................85

第 5 章

矩阵和通用

函数...............................86

5.1 矩阵 .........................................................86

5.2

动

手实践：创建

矩阵 ..............................86

5.3 从已有

矩阵创建新

矩阵...........................88

5.4 动手实

践：从已有矩

阵创建新矩

阵 .......88

5.5

通用函数

.................................................89

5.6 动手实践：创

建通用函数

.......................89

5.7

通用函数的

方法...................................... 90

5.8 动手实

践：在

add 上调用

通用函数的

方法 ......................................................... 91

5.9 算术运

算 ................................................. 93

5.10 动手实践

：数组的除法

运算................. 93

5.11

模运算

................................................... 95

5.12 动手实践：模

运算................................

95

5.13 斐波那

契数列........................................ 96

5.14 动手

实践：计算斐

波那契数列

............. 96

5.15

利萨茹曲线

............................................ 97

5.16 动手实践：绘

制利萨茹曲

线.................

97

5.17 方波....................................................... 99

5.18 动手

实践：绘制方

波 ............................ 99

5.19 锯齿波和

三角波.................................. 100

5.20

动手

实践：绘制锯

齿波和三角

波 ....... 101

5.21

位操作函

数和比较函

数 ...................... 102

5.22

动手实践

：玩转二进制

位................... 102

5.23 本章小结

.............................................

104

第 6 章

深入学

习 NumPy 模块................. 105

6.1 线性

代数 ............................................... 105

6.2 动手实

践：计算逆矩

阵 ........................ 105

6.3 求解线性

方程组.................................... 107

6.4

动手

实践：求解线

性方程组................. 107

6.5 特

征值和特征

向量................................

108

6.6 动手实

践：求解特征

值和特征向

量 .....

108

6.7 奇异值分

解 ...........................................

110

6.8 动手实践

：分解矩阵 ............................

110

6.9 广

义逆矩阵 ...........................................

112

6.10 动

手实践：计算

广义逆矩阵

............... 112

6.11 行列式 ................................................. 113

6.12 动手

实践：计算矩

阵的行列式

........... 113

6.13

快速傅里叶

变换.................................. 114

6.14 动手实

践：计算傅里

叶变换...............

114

6.15 移频

..................................................... 115

6.16 动手实践：移

频.................................. 116

6.17

随机数 ................................................. 117

6.18

动

手实践：硬币

赌博游戏................... 117

6.19 超

几何分布..........................................

119

6.20 动

手实践：模拟

游戏秀节目

............... 119

图灵社区会

员 heruihong 专享 尊重

版权

目 录 3

2

3 

4

5 

6

7 

8

9 

10

11 

12

13 

14

15 

16

18 

17

6.21 连

续分布..............................................121

6.22 动手

实践：绘制正

态分布

...................121

6.23 对数

正态分布 ......................................122

6.24 动

手实践：绘制

对数正态分

布 ...........122

6.25

本章小结

..............................................123

第 7 章

专用函

数..........................................124

7.1 排序 .......................................................124

7.2 动手

实践：按字典

序排序.....................124

7.3 复数

.......................................................126

7.4 动手实践：对

复数进行排

序 .................126

7.5

搜索 .......................................................127

7.6 动手

实践：使用

searchsorted 

函

数........................................................127

7.7

数组元素

抽取 ........................................128

7.8 动手实

践：从数组中

抽取元素

.............128

7.9 金

融函数................................................129

7.10

动手

实践：计算终

值...........................130

7.11 现值 .....................................................131

7.12 动手

实践：计算现

值...........................131

7.13 净现值..................................................131

7.14 动

手实践：计算

净现值.......................132

7.15 内部

收益率..........................................132

7.16 动手

实践：计算内

部收益率 ...............132

7.17

分

期付款..............................................133

7.18 动手

实践：计算分

期付款 ...................133

7.19 付款

期数..............................................133

7.20 动手实

践：计算付款

期数

...................134

7.21 利率 .....................................................134

7.22 动

手实践：计算

利率...........................134

7.23 窗函数

..................................................134

7.24 动手实践：绘

制巴特利特

窗 ...............135

7.25

布莱克曼

窗..........................................135

7.26 动手实践

：使用布莱克

曼窗平滑股

价

数据......................................................136

7.27 汉明

窗..................................................137

7.28 动手实践

：绘制汉明窗

.......................137

7.29 凯泽窗..................................................138

7.30 动手

实践：绘制凯

泽窗.......................138

7.31 专用数

学函数......................................139

7.32 动手

实践：绘制修

正的贝塞尔

函数......................................................139

7.33 sinc 函数............................................140

7.34

动

手实践：绘制

sinc 函数 ................140

7.35

本章小

结..............................................142

第 8 章

质量

控制..........................................143

8.1 断言函

数................................................143

8.2

动手实践

：使用 assert_almost_ 

equal

断言近

似相等 ............................144

8.3 近似

相等................................................145

8.4 动手实

践：使用 assert_approx_

equal 断言

近似相等 ............................145

8.5

数

组近似相等

........................................146

8.6 动手实践：断

言数组近似

相等 .............146

8.7 数组相

等................................................147

8.8 动手实践

：比较数组

............................147

8.9 数

组排序................................................148

8.10

动手

实践：核对数

组排序...................148

8.11 对象

比较..............................................149

8.12

动手实

践：比较对象

...........................149

8.13 字符串比较

..........................................149

8.14

动手实践：比

较字符串.......................150

8.15 浮

点数比较..........................................150

8.16

动

手实践：使用

assert_array_ 

almost_equal_nulp 比较浮点数

.....151

8.17 多 ULP 的浮点数

比较

.........................151

8.18 动手实

践：设置 maxulp

并比

较

浮点数..................................................151

8.19 单

元测试..............................................152

8.20 动手

实践：编写单

元测试...................152

8.21 nose

和测

试装饰器 ............................154

8.22 动

手实践：使用

测试装饰器

...............155

8.23 文档字符串

..........................................157

8.24 动手实践：执

行文档字符

串测试

.......157

8.25 本章

小结..............................................158

图灵社

区会员

heruihong 专享

尊重版权

4 目

录

第 9 章 使用

Matplotlib

绘图 .....................159 

9.1

简单绘

图 ...............................................159

9.2 动手实践

：绘制多项式

函数.................159

9.3 格式字

符串............................................161

9.4 动手实

践：绘制多项

式函数及其

导

函数 .......................................................161

9.5 子图

.......................................................163

9.6 动手实践：绘

制多项式函

数及其导

函

数 .......................................................163

9.7 财经 .......................................................165

9.8

动手

实践：绘制全

年股票价格

.............165

9.9 直方图 ...................................................167

9.10 动手

实践：绘制股

价分布直方

图 .......167

9.11

对数坐标

图..........................................169

9.12 动手实践

：绘制股票成

交量...............169

9.13

散点图

.................................................171

9.14 动手实践：绘

制股票收益

率和成交量

变化的散点

图......................................171

9.15

着色 .....................................................173

9.16 动手

实践：根据条

件进行着色

...........173

9.17 图例和注释

..........................................175

9.18 动手实践：使

用图例和注

释...............175

9.19 三维绘图

..............................................177

9.20 动手实践：在

三维空间中

绘图

...........178

9.21 等高线

图..............................................179

9.22

动手实践

：绘制色彩填

充的等高

线

图 .....................................................179

9.23

动画 .....................................................180

9.24 动手

实践：制作动

画

..........................180

9.25 本章小结

..............................................182

第

10 章 NumPy 的扩展

：SciPy

.............183 

10.1 MATLAB

和 Octave ............................183

10.2

动手实践

：保存和加载

.mat 文件......183

10.3 统计

.....................................................184

10.4 动

手实践：分析

随机数.......................185

10.5

样本

比对和 SciKits .............................187

10.6

动手

实践：比较股

票对数收益

率 .......187

10.7 信号处理

.............................................

190

10.8 动手实践：检

测 QQQ

股价的线

性

趋势 ..................................................... 190

10.9 傅里

叶分析.......................................... 192

10.10

动手

实践：对去除

趋势后的信

号进

行滤波

处理........................................ 192

10.11

数学优

化 ........................................... 194

10.12

动手实践

：拟合正弦波

.................... 195

10.13 数值积分

........................................... 197

10.14 动

手实践：计算

高斯积分.................

198

10.15 插

值................................................... 198

10.16 动手实践

：一维插值 ........................ 198

10.17 图

像处理 ........................................... 200

10.18 动手

实践：处理 Lena 图

像...............

200

10.19 音频处理

........................................... 202

10.20 动手实践：重

复音频片段

................. 202

10.21

本章小结 ........................................... 204

第

11

章 玩转 Pygame ...............................

205 

11.1 Pygame

................................................ 205

11.2 动手

实践：安装

Pygame .................... 205

11.3

Hello World ......................................... 206

11.4 动

手实践：制作

简单游戏................... 206

11.5

动

画..................................................... 208

11.6 动手实践

：使用

NumPy 和 Pygame

制作

动画对象...................................... 208

11.7 Matplotlib

............................................ 211

11.8 动

手实践：在

Pygame 中

使用

Matplotlib ............................................

211

11.9 屏幕像

素 .............................................

214

11.10 动手实践

：访问屏幕像

素................. 214

11.11 人工智能

........................................... 216

11.12

动手实践：数

据点聚类 .................... 216

11.13

OpenGL 和

Pygame ........................... 218

11.14 动手实践：绘

制谢尔宾斯

基地毯 ..... 218

11.15 模拟

游戏 ........................................... 221

11.16 动手实

践：模拟生命

........................ 221

11.17

本章小结 ........................................... 224

突

击测验答案

..................................................

225

图灵社区会

员 heruihong 专享

尊重

版权

1.2 动手实

践：在不同的

操作系统上

安装 Python

1 

1

2 

3

4

5 

11

6

7 

8

9 

10

NumPy快速入

门

让我们开

始吧。首先，我

们将介绍如

何在不同的

操作系统中

安装NumPy和

相关

软件，并给出

使用NumPy的简单

示例代码。然

后，我们将简

单介绍IPython

（一种

交互式shell工具

）。如前言所述

，SciPy和NumPy有着密切

的联系，因此

你

将多次看

到SciPy的身影。在

本章的末尾

，我们将告诉

你如何利用

在线资源，以

便你在受困

于某个问题

或不确定最

佳的解题方

法时，可以在

线获取帮助

。

本章涵盖以

下内容：

 在Windows、Linux和

Macintosh操作系统上

安装Python、SciPy、Matplotlib、IPython和

NumPy；

 编写

简单的NumPy代码

；



了解IPython；

 浏览在

线文档和相

关资源。

1.1

Python 

NumPy是基

于Python的，因此在

安装NumPy之前，我

们需要先安

装Python。某些操作

系统已

经默

认安装有Python环

境，但你仍需

检查Python的版本

是否与你将

要安装的NumPy版

本兼容。

Python有很

多种实现，包

括一些商业

化的实现和

发行版。在本

书中，我们将

使用CPython①实现，

从

而保证与NumPy兼

容。

1.2 动手实践

：在不同的操

作系统上安

装

Python 

NumPy在Windows、各种Linux发

行版以及Mac OS

X上

均有二进制

安装包。如果

你愿意，也

—————————— 

①

CPython是

用C语言实现

的Python解释器。——译

者注

第1章

图

灵社区会员

heruihong 专享

尊重版

权

2 第 1

章 NumPy 快速

入门

可以安

装包含源代

码的版本。你

需要在系统

中安装Python

2.4.x或更

高的版本。我

们将给出在

以下

操作系

统中安装Python的

各个步骤。

(1) Debian和

Ubuntu

Debian和Ubuntu可能已经

默认安装了

Python，但开发者包

（development 

headers）①一般不会默

认安装。在Debian和

Ubuntu中安装python和python-dev的

命令如下：

sudo

apt-get install python

sudo apt-get install python-dev

(2) Windows Python的

Windows安装程序可

以在www.python.org/download下载。在

这个站点

中

，我们也可以

找到Mac

OS X的安装

程序，以及Linux、Unix和

Mac OS X下的源代码

包。

(3) Mac Mac OS

X中预装了

Python，而我们也可

以通过MacPorts、Fink或者

类似的包管

理工

具来获

取Python。举例来说

，可以使用如

下命令安装

Python 2.7：

sudo port install python27

LAPACK并不是必需

的，但如果需

要，NumPy在安装过

程中将检测

并使用之。我

们推荐大家

安装LAPACK以便应

对海量数据

的计算，因为

它拥有高效

的线性代数

计算模块。

刚

才做了些什

么

我们在Debian、Ubuntu、Windows和

Mac操作系统中

安装了Python。

1.3

Windows 

在Windows上

安装NumPy是很简

单的。你只需

要下载安装

程序，运行后

在安装向导

的指导下

完

成安装。

1.4 动手

实践：在 Windows 上安

装

NumPy、Matplotlib、

SciPy 和 IPython

在Windows上安

装NumPy是必需的

，但幸运的是

，安装过程并

不复杂，我们

将在下面详

细阐

述。建议

你安装Matplotlib、SciPy和IPython，虽

然这一操作

对于使用本

书不是必需

的。我们将按

照如下步骤

安装这些软

件。

(1) 从SourceForge网站下

载NumPy的Windows安装程

序：

http://sourceforge.net/projects/numpy/files/ 

——————————

① 该软件包

提供编译Python模

块所需的静

态库、头文件

以及distutils工具等

。——译者注

图灵

社区会员 heruihong

专

享 尊重版权

1.4 动手实践：在

Windows 上安装

NumPy、Matplotlib、SciPy 和 IPython 3

1 

2

3 

4

5

11 

6

7

8 

9

10 

请

选择合适的

版本。在上图

中，我们选择

了numpy-1.7.0-win32-superpack-python2.7.exe。

(2)

下载完成

后，双击运行

安装程序。

(3) 现

在，我们可以

看到一段对

NumPy的描述以及

其特性，如上

图所示。单击

Next（下一步）

按钮

以继续安装

。

(4) 如果你已经

安装了Python，NumPy的安

装程序应该

能自动检测

到。如果没有

检测到Python，

可能

是你的路径

设置有误。在

本章的末尾

，我们列出了

一些在线资

源，供安装NumPy时

遇到问题

的

读者参考。

图

灵社区会员

heruihong 专享 尊重版

权

4

第 1 章 NumPy

快速

入门

(5) 在上图

中，安装程序

成功检测到

系统中已安

装Python 2.7，此时应单

击Next按钮继续

安装；

否则，请

单击Cancel（取消）按

钮并安装Python（NumPy不

能脱离Python单独

安装）。继续单

击

Next按钮，从这

一步起就不

能回退到上

一步了，因此

请你确认是

否选择了合

适的安装路

径和其他

安

装选项。现在

，真正的安装

过程开始了

，你需要等待

一段时间。

(6)

SciPy和

Matplotlib可以通过Enthough安

装，地址为www.enthought.com/products/epd.php。

在

安装过程中

，你可能需要

将一个文件

msvcp71.dll放到目录C:\Windows\system32下

。你可以从这

里下载这个

文件：www.dll-files.com/dllindex/dll-files.shtml?msvcp71。Windows下的IPython安

装程

序可以

通过访问IPython的

官网下载：http://ipython.scipy.org/Wiki/IpythonOnWindows。

刚

才做了些什

么

我们在Windows上

安装了NumPy、SciPy、Matplotlib以及

IPython。

1.5 Linux

在Linux上安装NumPy和

相关软件的

方法取决于

具体使用的

Linux发行版。我们

将用命令行

的

方式安装

NumPy，不过你也可

以使用图形

界面安装程

序，这取决于

具体的Linux发行

版。除了软

件

包的名字不

一样，安装Matplotlib、SciPy和

IPython的命令与安

装NumPy时是完全

一致的。这几

个软件包不

是必需安装

的，但这里建

议你也一并

安装。

图灵社

区会员

heruihong 专享

尊重版权

1.8 动

手实践：在

Mac OS X 上

安装

NumPy、Matplotlib 和 SciPy 5

1 

2

3 

4

5

11 

6

7

8 

9

10 

1.6 动手

实践：在

Linux 上安

装 NumPy、Matplotlib、SciPy

和

IPython 

大部分

Linux发行版都有

NumPy的软件包。我

们将针对一

些流行的Linux发

行版给出安

装步骤。

(1)

要在

Red Hat上安装NumPy，请在

命令行中执

行如下命令

：

yum install

python-numpy 

(2) 要在Mandriva上安装

NumPy，请在命令行

中执行如下

命令：

urpmi python-numpy 

(3)

要在Gentoo上

安装NumPy，请在命

令行中执行

如下命令：

sudo emerge numpy

(4) 要

在Debian或Ubuntu上安装

NumPy，请在命令行

中执行如下

命令：

sudo apt-get

install python-numpy 

下表给

出了各Linux发行

版中相关软

件包的名称

以供参考。

Linux发

行版 NumPy SciPy Matplotlib

IPython 

Arch Linux

python-numpy python-scipy python-matplotlib ipython

Debian python-numpy python-scipy python-matplotlib

ipython 

Fedora numpy

python-scipy python-matplotlib ipython

Gentoo dev-python/numpy scipy matplotlib

ipython 

OpenSUSE python-numpy,python-numpy-devel

python-scipy python-matplotlib ipython

Slackware numpy scipy matplotlib

ipython 

刚才做

了些什么

我

们在各种Linux发

行版上安装

了NumPy、SciPy、Matplotlib以及IPython。

1.7 Mac OS X

在Mac上

，你可以通过

图形用户界

面或者命令

行来安装NumPy、Matplotlib和

SciPy，根据自

己的

喜好选择包

管理工具，如

MacPorts或Fink等。

1.8 动手实

践：在

Mac OS X 上安装

NumPy、Matplotlib

和 SciPy 

我们将使

用图形用户

界面安装程

序，安装步骤

如下所示。

图

灵社区会员

heruihong 专享 尊重版

权

6

第 1 章 NumPy

快速

入门

(1) 我们先

从SourceForge页面下载

NumPy的安装程序

，地址为http://sourceforge.net/projects/

numpy/files/。Matplotlib和SciPy也

可以用类似

的方式下载

，只需将前面

URL中的numpy修改为

scipy

或matplotlib。在我写作

本书的时候

，IPython还没有提供

图形界面的

安装程序。如

下面的截图

所

示，请单击

下载合适的

DMG文件，且通常

要选择最新

版本的文件

。

(2)

打开下载的

DMG文件（示例中

为numpy-1.7.0-py2.7-python.org-macosx10.6.dmg），如下图

所

示。

 在打开的

窗口中，双击

那个下方文

字以.mpkg结尾的

图标，我们将

看到安装程

序的欢迎界

面。

图灵社区

会员 heruihong 专享 尊

重版权

1.9 动手

实践：使用 MacPorts 或

Fink

安装 NumPy、SciPy、Matplotlib 和 IPython

7 

1

2 

3

4

5 

11

6

7 

8

9 

10

 单击

Continue（继续）按钮进

入Read Me（自述页）界

面，我们将看

到一小段NumPy的

描

述文字，如

下图所示

。

 单

击Continue按钮，可以

看到关于软

件许可协议

的说明。

(3)

阅读

软件许可协

议，单击Continue按钮

，在被提示是

否接受协议

时单击Accept（同意

）

按钮。继续安

装，最后单击

Finish（完成）按钮结

束安装。 

刚才

做了些什么

我们在Mac

OS X上用

图形用户界

面安装程序

安装了NumPy。SciPy和Matplotlib的

安装步骤与

之很类似，使

用上面第(1)步

中提到的URL进

行下去即可

。

1.9 动手实践：使

用

MacPorts 或 Fink 安装

NumPy、SciPy、

Matplotlib 和

IPython

我们也可以

选择另外一

种安装方式

，即使用MacPorts或Fink来

安装NumPy、SciPy、Matplotlib

以及IPython。下

面给出的安

装步骤将安

装所有这些

软件包。在本

书中只有NumPy是

必需的，如

果

你对其他软

件包不感兴

趣，也可以暂

不安装。

图灵

社区会员

heruihong 专

享 尊重版权

8 第

1 章 NumPy 快速入

门

(1) 输入以下

命令，从MacPorts安装

这些软件包

：

sudo port

install py-numpy py-scipy py-matplotlib

py-ipython 

(2) Fink也包含了相

关软件包：NumPy的

有scipy-core-py24、scipy-core-py25和

scipy-core-py26；SciPy的有scipy-py24、scipy-py25和

scipy-py26。执行如下命

令，我

们来安

装基于Python 2.6的NumPy以

及其他推荐

安装的软件

包：

fink

install scipy-core-py26 scipy-py26 matplotlib-py26

刚才做了

些什么

我们

在Mac OS X上使用MacPorts和

Fink安装了NumPy以及

其他推荐安

装的软件包

。

1.10 编译源代码

NumPy的源代码可

以使用git获取

，如下所示：

git clone

git://github.com/numpy/numpy.git numpy 

使

用如下命令

将NumPy安装至/usr/local：

python setup.py build

sudo python setup.py install

--prefix=/usr/local 

我

们需要有C编

译器（如GCC）和Python开

发者包（python-dev或python-devel），然

后

才可对源

代码进行编

译。

1.11 数组对象

在介绍完NumPy的

安装步骤后

，我们来看看

NumPy中的数组对

象。NumPy数组在数

值运算

方面

的效率优于

Python提供的list容器

。使用NumPy可以在

代码中省去

很多循环语

句，因此其代

码

比等价的

Python代码更为简

洁。

1.12 动手实践

：向量加法

假

设我们需要

对两个向量

a和b做加法。这

里的向量即

数学意义上

的一维数组

，随后我们将

在第5章中学

习如何用NumPy数

组表示矩阵

。向量a的取值

为0~n的整数的

平方，例如n取

3时，向

量a为0、1或

4。向量b的取值

为0~n的整数的

立方，例如n取

3时，向量b为0、1或

8。用纯Python

代码应

该怎么写呢

？我们先想一

想这个问题

，随后再与等

价的NumPy代码进

行比较。

图灵

社区会员 heruihong 专

享

尊重版权

1.12 动手实践：向

量加法 9

1 

2

3 

4

5

11 

6

7

8 

9

10 

(1) 以下

的纯Python代码可

以解决上述

问题：

def pythonsum(n):

a = range(n)

b = range(n)

c = []

for i in range(len(a)):

a[i] = i

** 2

b[i] = i **

3 

 c.append(a[i]

+ b[i])

return c 

(2)

以下是

使用NumPy的代码

，它同样能够

解决问题：

def numpysum(n):

a = numpy.arange(n) **

2 

 b

= numpy.arange(n) ** 3

c = a

+ b

return c 

注

意，numpysum()函数中没

有使用for循环

。同时，我们使

用NumPy中的arange函数

来创

建包含

0~n 的整数的NumPy数

组。代码中的

arange函数前面有

一个前缀numpy，表

明该函数是

从

NumPy模块导入

的。

下面我们

做一个有趣

的实验。在前

言部分我们

曾提到，NumPy在数

组操作上的

效率优于纯

Python代码。那么究

竟快多少呢

？接下来的程

序将告诉我

们答案，它以

微秒（106

s）的精度

分别

记录下

numpysum()和pythonsum()函数的耗

时。这个程序

还将输出加

和后的向量

最末的两个

元

素。让我们

来看看纯Python代

码和NumPy代码是

否得到相同

的结果：

#!/usr/bin/env/python

import sys 

from

datetime import datetime

import numpy as np

""" 

本书

第1章

该段代

码演示Python中的

向量加法

使

用如下命令

运行程序：

 python vectorsum.py

n 

 n为

指定向量大

小的整数

加

法中的第一

个向量包含

0到n的整数的

平方

第二个

向量包含0到

n的整数的立

方

程序将打

印出向量加

和后的最后

两个元素以

及运行消耗

的时间

"""

图灵

社区会员 heruihong 专

享 尊重版权

10

第 1 章 NumPy

快速入

门

def numpysum(n):

a = np.arange(n) **

2 

 b

= np.arange(n) ** 3

c = a

+ b

return c 

def

pythonsum(n): 

 a

= range(n)

b = range(n)

c = []

for i in range(len(a)):

a[i] = i

** 2

b[i] = i **

3 

 c.append(a[i]

+ b[i])

return c 

size

= int(sys.argv[1]) 

start

= datetime.now() 

c

= pythonsum(size) 

delta

= datetime.now() - start

print "The last 2

elements of the sum",

c[-2:] 

print "PythonSum

elapsed time in microseconds",

delta.microseconds 

start =

datetime.now() 

c =

numpysum(size) 

delta =

datetime.now() - start

print "The last 2

elements of the sum",

c[-2:] 

print "NumPySum

elapsed time in microseconds",

delta.microseconds 

程序在向

量元素个数

为1000、2000和3000时的输

出分别为：



$ python vectorsum.py 1000 

The last 2 elements of the sum [995007996, 998001000] 

PythonSum elapsed time in microseconds 707 

The last 2 elements of the sum [995007996 998001000] 

NumPySum elapsed time in microseconds 171 

$



python vectorsum.py 2000

The last 2 elements

of the sum [7980015996,

7992002000] 

PythonSum elapsed

time in microseconds 1420

The last 2 elements

of the sum [7980015996

7992002000] 

NumPySum elapsed

time in microseconds 168



$ python vectorsum.py 4000 

The last 2 elements of the sum [63920031996, 63968004000] 

PythonSum elapsed time in microseconds 2829 

The last 2 elements of the sum [63920031996 63968004000] 

NumPySum elapsed time in microseconds 274 

图灵社区会员 heruihong 专享 尊重版权

1.13 IPython：一个交互式 shell 工具 11 

1 

2 

3 

4

5 

11 

6

7 

8 

9 

10 

如果你是www.packtpub.com的用户并从那里购买了图书，可以从网站上下

载配套的示例代码。如果你是在别处购买了本书，可以访问www.packtpub.com/ 

support进行登记，我们会直接将示例代码文件以邮件形式发送给你。

刚才做了些什么

显然，NumPy代码比等价的纯Python代码运行速度快得多。有一点可以肯定，即不论我们使

用NumPy还是Python，得到的结果是一致的。不过，两者的输出结果在形式上有些差异。注意，

numpysum()函数的输出不包含逗号。这是为什么呢？显然，我们使用的是NumPy数组，而非

Python自身的list容器。正如前言中所述，NumPy数组对象以专用数据结构来存储数值。我们将在

下一章中详细介绍NumPy数组对象。

突击测验：arange函数的功能

问题1 arrange(5)的作用是什么？

(1) 创建一个包含5个元素的Python列表（list），取值分别为1~5的整数

(2) 创建一个包含5个元素的Python列表，取值分别为0~4的整数

(3) 创建一个包含5个元素的NumPy数组，取值分别为1~5的整数

(4) 创建一个包含5个元素的NumPy数组，取值分别为0~4的整数

(5) 以上都不对

勇敢出发：进一步分析

我们用来比较NumPy和常规Python代码运行速度的程序不是特别严谨，如果将相同的实验

重复多次并计算相应的统计量（如平均运行时间等）会更科学。你可以把实验结果绘制成图表，

并展示给你的好友和同事。

我们在本章的最后给出了一些在线文档和相关资源，你可以在线获取帮助。

顺便提一下，NumPy中的统计函数可以帮你计算平均数。建议你使用Matplotlib

绘图。（第9章概述了Matplotlib。）

1.13 IPython：一个交互式 shell 工具

科学家和工程师都喜欢做实验，而IPython正是诞生于爱做实验的科学家之手。IPython提供

图灵社区会员 heruihong 专享 尊重版权

12 第 1 章 NumPy 快速入门

的交互式实验环境被很多人认为是Matlab、Mathematica和Maple的开源替代品。你可以在线获取

包括安装指南在内的更多信息，地址为http://ipython.org/。

IPython是开源免费的软件，可以在Linux、Unix、Mac OS X以及Windows上使用。IPython的

作者们希望那些用到IPython的科研工作成果在发表时能够提到IPython，这是他们对IPython使用

者唯一的要求。下面是IPython的基本功能：

 Tab键自动补全；

 历史记录存档；

 行内编辑；

 使用%run可以调用外部Python脚本；

 支持系统命令；

 支持pylab模式；

 Python代码调试和性能分析。

在pylab模式下，IPython将自动导入SciPy、NumPy和Matplotlib模块。如果没有这个功能，

我们只能手动导入每一个所需模块。

而现在，我们只需在命令行中输入如下命令：

$



ipython --pylab 

Python

2.7.2 (default, Jun 20

2012, 16:23:33) 

Type

"copyright", "credits" or "license"

for more information.

IPython 0.14.dev -- An

enhanced Interactive Python.

? -> Introduction and

overview of IPython's features.

%quickref -> Quick reference.

help -> Python's own

help system. 

object?

-> Details about 'object',

use 'object??' for extra

details. 

Welcome to

pylab, a matplotlib-based Python

environment [backend: MacOSX].

For more information, type

'help(pylab)'. 

In [1]:

quit() 

使用quit()函数或

快捷键Ctrl+D均可

以退出IPython shell。有时

我们想要回

到之前做过

的实

验，IPython可以

便捷地保存

会话以便稍

后使用。

In [1]: %logstart

Activating auto-logging. Current session

state plus future input

saved. 

Filename :

ipython_log.py 

Mode :

rotate 

Output logging

: False 

Raw

input log : False

Timestamping : False

State : active

举例

来说，我们将

之前的向量

加法程序放

在当前目录

下，可以按照

如下方式运

行脚本：

图灵

社区会员 heruihong 专

享

尊重版权

1.13 IPython：一个交互式

shell 工具 13

1 

2

3 

4

5

11 

6

7

8 

9

10 

In [1]:

ls 

README vectorsum.py

In [2]: %run -i

vectorsum.py 1000 

你可能

还记得，这里

的1000是指向量

中元素的数

量。%run的–d参数将

开启ipdb调试器

，键

入c后，脚本

就开始逐行

执行了（如果

脚本有n行，就

一共执行n步

直到代码结

束）。在ipdb提示

符

后面键入quit可

以关闭调试

器。

In [2]:

%run -d vectorsum.py 1000

*** Blank or comment

*** Blank or comment

Breakpoint 1 at: /Users/.../vectorsum.py:3

在ipdb>提示符

后面键入c，从

而开始运行

代码。

><string>(1)<module>() 

ipdb>

c 

> /Users/.../vectorsum.py(3)<module>()

2 

1--->

3 import sys

4 from datetime import

datetime 

ipdb> n

> 

/Users/.../vectorsum.py(4)<module>()

1 3 import sys

----> 4 from datetime

import datetime

5 import numpy

ipdb> n 

>

/Users/.../vectorsum.py(5)<module>() 

 4

from datetime import datetime

----> 5 import numpy

6 

ipdb>

quit 

我们还

可以使用%run的

–p参数对脚本

进行性能分

析。

In

[4]: %run -p vectorsum.py

1000 

 1058

function calls (1054 primitive

calls) in 0.002 CPU

seconds 

 Ordered

by: internal time

ncallstottimepercallcumtimepercallfilename:lineno(function) 

1 0.001

0.001 0.001 0.001 vectorsum.py:28(pythonsum)

1 0.001 0.001 0.002

0.002 {execfile} 

1000

0.000 0.0000.0000.000 {method "append"

of 'list' objects}

1 0.000 0.000 0.002

0.002 vectorsum.py:3(<module>) 

1

0.000 0.0000.0000.000 vectorsum.py:21(numpysum)

3 0.000 0.0000.0000.000 {range}

1 0.000 0.0000.0000.000 arrayprint.py:175(_array2string)

3/1 0.000 0.0000.0000.000 arrayprint.py:246(array2string)

2 0.000 0.0000.0000.000 {method

'reduce' of 'numpy.ufunc' objects}

4 0.000 0.0000.0000.000 {built-in

method now} 

2

0.000 0.0000.0000.000 arrayprint.py:486(_formatlnteger)

2 0.000 0.0000.0000.000 {numpy.core.multiarray.arange}

1 0.000 0.0000.0000.000 arrayprint.py:320(_formatArray)

图灵社区

会员 heruihong 专享 尊

重版权

14 第 1 章

NumPy

快速入门

3/1 0.000 0.0000.0000.000

numeric.py:1390(array_str) 

1 0.000

0.0000.0000.000 numeric.py:216(asarray) 

2

0.000 0.0000.0000.000 arrayprint.py:312(_extendLine)

1 0.000 0.0000.0000.000 fromnumeric.py:1043(ravel)

2 0.000 0.0000.0000.000 arrayprint.py:208(<lambda>)

1 0.000 0.000 0.002

0.002<string>:1(<module>) 

11 0.000

0.0000.0000.000 {len} 

2

0.000 0.0000.0000.000 {isinstance}

1 0.000 0.0000.0000.000 {reduce}

1 0.000 0.0000.0000.000 {method

'ravel' of 'numpy.ndarray' objects}

4 0.000 0.0000.0000.000 {method

'rstrip' of 'str' objects}

3 0.000 0.0000.0000.000 {issubclass}

2 0.000 0.0000.0000.000 {method

'item' of 'numpy.ndarray' objects}

1 0.000 0.0000.0000.000 {max}

1 0.000 0.0000.0000.000 {method

'disable' of ' lsprof.Profiler'

objects} 

根

据性能分析

的结果，可以

更多地了解

程序的工作

机制，并能够

据此找到程

序的性能瓶

颈。

使用%hist命令

可以查看命

令行历史记

录。

In [2]: a=2+2

In [3]: a

Out[3]: 4 

In

[4]: %hist 

1:

_ip.magic("hist ") 

2:

a=2+2 

3: a

通过前面

的介绍，希望

你也认为IPython是

非常有用的

工具了！

1.14 在线

资源和帮助

在IPython的pylab模式下

，我们可以使

用help命令打开

NumPy函数的手册

页面。你并不

需要

知道所

有函数的名

字，因为可以

在键入少量

字符后按下

Tab键进行自动

补全。例如，我

们来查看

一

下arange函数的相

关信息。

In [2]: help

ar<Tab> 

In [2]:

help arange 

图灵

社区会员

heruihong 专

享 尊重版权

1.15 本章小结

15 

1

2 

3

4

5 

11

6

7 

8

9 

10

另

一种方法是

在函数名后

面加一个问

号：

In [3]: arange?

可以访问

http://docs.scipy.org/doc/查看NumPy和SciPy的在

线文档。在这

个网页上，你

可以访

问http://docs.scipy.org/doc/numpy/reference/浏

览NumPy的参考资

料、用户指南

以及一些使

用教程。

NumPy的wiki站

点上也有许

多相关文档

可供参考：http://docs.scipy.org/numpy/Front%20Page/。

NumPy和

SciPy的论坛地址

为http://ask.scipy.org/en。

广受欢迎

的开发技术

问答网站Stack Overflow上

有成百上千

的提问被标

记为numpy相关问

题。你可以到

这里查看这

些问题：http://stackoverflow.com/questions/tagged/numpy。

如果

你确实被某

个问题困住

了，或者想了

解NumPy开发的最

新进展，可以

订阅NumPy的讨

论

组邮件列表

，电子邮件地

址为numpy-discussion@scipy.org。每天的

邮件数量不

会太多，并且

基

本不会讨

论无意义的

事情。最重要

的是，NumPy的活跃

开发者们也

愿意回答讨

论组里提出

的问题。

完整

的邮件列表

可以在这里

找到：www.scipy.org/Mailing_Lists。

对于IRC①的

用户，可以查

看irc.freenode.net上的IRC频道

。尽管该频道

的名称是#scipy，但

你也可以提

出NumPy的问题，因

为SciPy是基于NumPy的

，SciPy的用户也了

解NumPy的知识。SciPy

频

道上至少会

有50人同时在

线。

1.15 本章小结

在本章中，我

们安装了NumPy以

及其他推荐

软件。我们成

功运行了向

量加法程序

，并以此证

明

了NumPy优异的性

能。随后，我们

介绍了交互

式shell工具IPython。此外

，我们还列出

了供你参

考

的NumPy文档和在

线资源。

在下

一章中，我们

将深入了解

NumPy中的一些基

本概念，包括

数组和数据

类型。

—————————— 

①

Internet Relay Chat，一种公

开的协议，用

于网络即时

聊天。——译者注

图灵社区会

员 heruihong

专享 尊重

版权

16 第

2 章 NumPy 基

础

NumPy基础

在上

一章中我们

学习了NumPy的安

装，并试着运

行了一些代

码。现在，

让我

们正式学习

NumPy的基础知识

吧。

本章涵盖

以下内容：

 数

据类型；

 数组

类型；

 类型转

换；

 创建数组

；

 数组索引；

 数

组切片；

 改变

维度。

不过，在

正式学习之

前，我想就本

章中的示例

代码做一些

说明。本章代

码段中的输

入和输出

均

来自IPython会话。我

们曾在第1章

介绍过用于

科学计算的

交互式shell工具

IPython。IPython的

pylab模式可以

自动导入包

括NumPy在内的很

多Python科学计算

库，并且在IPython中

没有必要显

式调用print语句

输出变量的

值。不过，本书

配套的源代

码文件中均

为使用了import和

print

语句的标准

Python代码。 

2.1

NumPy 数组对

象

NumPy中的ndarray是一

个多维数组

对象，该对象

由两部分组

成：



实际的数

据；

 描述这些

数据的元数

据。

大部分的

数组操作仅

仅修改元数

据部分，而不

改变底层的

实际数据。

第

2章

图灵社区

会员 heruihong 专享

尊

重版权

2.2 动手

实践：创建多

维数组 17

1 

2

3 

4

5

11 

6

7

8 

9

10 

在第

1章中，我们已

经知道如何

使用arange函数创

建数组。实际

上，当时创建

的数组只是

包

含一组数

字的一维数

组，而ndarray支持更

高的维度。

NumPy数

组一般是同

质的（但有一

种特殊的数

组类型例外

，它是异质的

），即数组中的

所有

元素类

型必须是一

致的。这样有

一个好处：如

果我们知道

数组中的元

素均为同一

类型，该数组

所

需的存储

空间就很容

易确定下来

。

与Python中一样，NumPy数

组的下标也

是从0开始的

。数组元素的

数据类型用

专门的对象

表

示，而这些

对象我们将

在本章详细

探讨。

我们再

次用arange函数创

建数组，并获

取其数据类

型：

In: a

= arange(5) 

In:

a.dtype 

Out: dtype('int64')

数组a的数

据类型为int64（在

我的机器上

是这样），当然

如果你使用

32位的Python，得到的

结果可能是

int32。不论是哪种

情形，该数组

的数据类型

都是整数（64位

或32位）。除了数

据类

型，数组

的维度也是

重要的属性

。

第1章中的例

子演示了怎

样创建一个

向量（即一维

的NumPy数组）。向量

在数学中很

常用，但

大部

分情况下，我

们需要更高

维的对象。先

来确定一下

刚刚所创建

向量的维度

：

In [4]: a

Out[4]: array([0, 1, 2,

3, 4]) 

In:

a.shape 

Out: (5,)

正如你所看

到的，这是一

个包含5个元

素的向量，取

值分别为0~4的

整数。数组的

shape属性

返回一

个元组（tuple），元组

中的元素即

为NumPy数组每一

个维度上的

大小。上面例

子中的数组

是一维的，因

此元组中只

有一个元素

。

2.2 动手实践：创

建多维数组

既然我们已

经知道如何

创建向量，现

在可以试着

创建多维的

NumPy数组，并查看

其维度了。

(1) 创

建一个多维

数组。

(2) 显示该

数组的维度

。

In: m = array([arange(2),

arange(2)]) 

In: m

Out: 

array([[0, 1],

[0, 1]])

图灵社区会

员 heruihong 专享 尊重

版权

18 第 2 章

NumPy 基

础

In: m.shape

Out: (2, 2)

刚才做了

些什么

我们

将arange函数创建

的数组作为

列表元素，把

这个列表作

为参数传给

array函数，从而

创

建了一个2×2的

数组，而且没

有出现任何

报错信息。

array函

数可以依据

给定的对象

生成数组。给

定的对象应

是类数组，如

Python中的列表。在

上面的例子

中，我们传给

array函数的对象

是一个NumPy数组

的列表。像这

样的类数组

对象是

array函数

的唯一必要

参数，其余的

诸多参数均

为有默认值

的可选参数

。 

突击测验：ndarray对

象维度属性

的存储方式

问题1 ndarray对象的

维度属性是

以下列哪种

方式存储的

？

(1) 逗号隔开的

字符串 

(2)

Python列表

（list）

(3) Python元组（tuple）

勇敢出

发：创建3×3的多

维数组

现在

，创建一个3×3的

多维数组应

该不是一件

难事。试试看

，并在创建多

维数组后检

查其

维度是

否与你设想

的一致。

2.2.1

选取

数组元素

有

时候，我们需

要选取数组

中的某个特

定元素。首先

还是创建一

个2×2的多维数

组：

In: a

= array([[1,2],[3,4]]) 

In:

a 

Out:

array([[1, 2],

[3, 4]]) 

在创建这

个多维数组

时，我们给array函

数传递的对

象是一个嵌

套的列表。现

在来依次选

取

该数组中

的元素。记住

，数组的下标

是从0开始的

。

In: a[0,0]

Out: 1 

In:

a[0,1] 

Out: 2

图灵社区会

员 heruihong 专享 尊重

版权

2.2 动手实

践：创建多维

数组 19

1 

2

3 

4

5

11 

6

7

8 

9

10 

In: a[1,0]

Out: 3 

In:

a[1,1] 

Out: 4

是的，从

数组中选取

元素就是这

么简单。对于

数组a，只需要

用a[m,n]选取各数

组元素，其

中

m和n为元素下

标，对应的位

置如下表所

示。

2.2.2 NumPy

数据类型

Python支持的数据

类型有整型

、浮点型以及

复数型，但这

些类型不足

以满足科学

计算的需

求

，因此NumPy添加了

很多其他的

数据类型。在

实际应用中

，我们需要不

同精度的数

据类型，

它们

占用的内存

空间也是不

同的。在NumPy中，大

部分数据类

型名是以数

字结尾的，这

个数字

表示

其在内存中

占用的位数

。下面的表格

（整理自NumPy用户

手册）列出了

NumPy中支持的数

据类型。

类 型

描 述

bool

用一位

存储的布尔

类型（值为TRUE或

FALSE）

inti 由所在平台

决定其精度

的整数（一般

为int32或int64）

int8

整数，范

围为128至127 

int16 整数

，范围为32

768至32 767 

int32

整

数，范围为231至

231 1 

int64

整数，范围为

263至263 1 

uint8

无符号整

数，范围为0至

255 

uint16 无符号整数

，范围为0至65

535 

uint32 无

符号整数，范

围为0至2321

uint64 无符

号整数，范围

为0至2641 

float16

半精度

浮点数（16位）：其

中用1位表示

正负号，5位表

示指数，10位表

示尾数

float32 单精

度浮点数（32位

）：其中用1位表

示正负号，8位

表示指数，23位

表示尾数

float64或

float

双精度浮点

数（64位）：其中用

1位表示正负

号，11位表示指

数，52位表示尾

数

complex64 复数，分别

用两个32位浮

点数表示实

部和虚部

complex128或

complex

复数，分别用

两个64位浮点

数表示实部

和虚部

每一

种数据类型

均有对应的

类型转换函

数：

图灵社区

会员 heruihong

专享 尊

重版权

20 第

2 章

NumPy 基础

In:

float64(42) 

Out: 42.0

In: int8(42.0) 

Out:

42 

In: bool(42)

Out: True 

In:

bool(0) 

Out: False

In: bool(42.0) 

Out:

True 

In: float(True)

Out: 1.0 

In:

float(False) 

Out: 0.0

在NumPy中，许

多函数的参

数中可以指

定数据类型

，通常这个参

数是可选的

：

In: arange(7, dtype=uint16)

Out: array([0, 1, 2,

3, 4, 5, 6],

dtype=uint16) 

需要注意的

是，复数是不

能转换为整

数的，这将触

发TypeError错误：

同样

，复数也不能

转换为浮点

数。不过，浮点

数却可以转

换为复数，例

如complex(1.0)。注意，

有j的

部分为复数

的虚部。 

2.2.3 数据

类型对象

数

据类型对象

是numpy.dtype类的实例

。如前所述，NumPy数

组是有数据

类型的，更确

切

地说，NumPy数组

中的每一个

元素均为相

同的数据类

型。数据类型

对象可以给

出单个数组

元素在

内存

中占用的字

节数，即dtype类的

itemsize属性：

In:

a.dtype.itemsize 

Out: 8

2.2.4 字符编

码

NumPy可以使用

字符编码来

表示数据类

型，这是为了

兼容NumPy的前身

Numeric。我不推荐

使

用字符编码

，但有时会用

到，因此下面

还是列出了

字符编码的

对应表。读者

应该优先使

用dtype

对象来表

示数据类型

，而不是这些

字符编码。

图

灵社区会员

heruihong 专享 尊重版

权

2.2 动手实践

：创建多维数

组 21

1 

2

3 

4

5

11 

6

7

8 

9

10 

数据类型

字符编码

整

数

i 

无符号整

数 u

单精度浮

点数 f 

双精度

浮点数

d 

布尔

值 b

复数 D 

字符

串

S 

unicode字符串 U

void （空

） V

下面的代码

创建了一个

单精度浮点

数数组：

In: arange(7, dtype='f')

Out: array([ 0., 1.,

2., 3., 4., 5.,

6.], dtype=float32) 

与此

类似，还可以

创建一个复

数数组：

In: arange(7, dtype='D')

Out: array([ 0.+0.j, 1.+0.j,

2.+0.j, 3.+0.j, 4.+0.j, 5.+0.j,

6.+0.j]) 

2.2.5 自定

义数据类型

我们有很多

种自定义数

据类型的方

法，以浮点型

为例。

 可以使

用Python中的浮点

数类型： 

In:

dtype(float) 

Out: dtype('float64')

 可以

使用字符编

码来指定单

精度浮点数

类型： 

In:

dtype('f') 

Out: dtype('float32')

 可以使

用字符编码

来指定双精

度浮点数类

型： 

In:

dtype('d') 

Out: dtype('float64')

 还可以将

两个字符作

为参数传给

数据类型的

构造函数。此

时，第一个字

符表示数据

类型，

第二个

字符表示该

类型在内存

中占用的字

节数（2、4、8分别代

表精度为16、32、64位

的

浮点数）：

图

灵社区会员

heruihong 专享 尊重版

权

22

第 2 章 NumPy

基础

In: dtype('f8') 

Out:

dtype('float64') 

完整的NumPy数据

类型列表可

以在sctypeDict.keys()中找到

：

In:

sctypeDict.keys() 

Out: [0,

... 

 'i2',

'int0'] 

2.2.6

dtype 类的属性

dtype类

有很多有用

的属性。例如

，我们可以获

取数据类型

的字符编码

：

In:

t = dtype('Float64')

In: t.char 

Out:

'd' 

type属性对应于

数组元素的

数据类型：

In:

t.type 

Out: <type

'numpy.float64'> 

str属

性可以给出

数据类型的

字符串表示

，该字符串的

首个字符表

示字节序（endianness），

后

面如果还有

字符的话，将

是一个字符

编码，接着一

个数字表示

每个数组元

素存储所需

的字节数。

这

里，字节序是

指位长为32或

64的字（word）存储的

顺序，包括大

端序（big-endian）和小端

序

（little-endian）。大端序是

将最高位字

节存储在最

低的内存地

址处，用>表示

；与之相反，小

端序

是将最

低位字节存

储在最低的

内存地址处

，用<表示：

In:

t.str 

Out: '<f8'

2.3 动手

实践：创建自

定义数据类

型

自定义数

据类型是一

种异构数据

类型，可以当

做用来记录

电子表格或

数据库中一

行数据的结

构。作为示例

，我们将创建

一个存储商

店库存信息

的数据类型

。其中，我们用

一个长度为

40个字

符的字

符串来记录

商品名称，用

一个32位的整

数来记录商

品的库存数

量，最后用一

个32位的单精

度浮点数来

记录商品价

格。下面是具

体的步骤。

(1) 创

建数据类型

： 

In:

t = dtype([(,name', str_,

40), ('numitems', int32), ('price',float32)])

In: t 

Out:

dtype([('name', '|S40'), ('numitems', '<i4'),

('price', '<f4')]) 

图灵社区会

员

heruihong 专享 尊重

版权

2.5

动手实

践：多维数组

的切片和索

引 23 

1

2 

3

4

5 

11

6

7 

8

9 

10

(2) 查看数据

类型（也可以

查看某一字

段的数据类

型） :

In: t['name'] 

Out:

dtype('|S40') 

在用array函数

创建数组时

，如果没有在

参数中指定

数据类型，将

默认为浮点

数类型。而现

在，我们想要

创建自定义

数据类型的

数组，就必须

在参数中指

定数据类型

，否则将触发

TypeError

错误：

In: itemz = array([('Meaning

of life DVD', 42,

3.14), ('Butter', 13, 2.72)],

dtype=t) 

In: itemz[1]

Out: ('Butter', 13, 2.7200000286102295)

刚才做

了些什么

我

们创建了一

种自定义的

异构数据类

型，该数据类

型包括一个

用字符串记

录的名字、一

个用

整数记

录的数字以

及一个用浮

点数记录的

价格。

2.4

一维数

组的索引和

切片

一维数

组的切片操

作与Python列表的

切片操作很

相似。例如，我

们可以用下

标3~7来选取元

素3~6：

In: a

= arange(9) 

In:

a[3:7] 

Out: array([3,

4, 5, 6])

也可以用

下标0~7，以2为步

长选取元素

：

In: a[:7:2]

Out: array([0, 2, 4,

6]) 

和Python中一样，我

们也可以利

用负数下标

翻转数组：

In:

a[::-1] 

Out: array([8,

7, 6, 5, 4,

3, 2, 1, 0])

2.5 动

手实践：多维

数组的切片

和索引

ndarray支持

在多维数组

上的切片操

作。为了方便

起见，我们可

以用一个省

略号（...）来

表示

遍历剩下的

维度。

(1) 举例来

说，我们先用

arange函数创建一

个数组并改

变其维度，使

之变成一个

三维数组： 

In:

b = arange(24).reshape(2,3,4)

图

灵社区会员

heruihong 专享 尊重版

权

24

第 2 章 NumPy

基础

In: b.shape 

Out:

(2, 3, 4)

In: b 

Out:

array([[[ 0, 1, 2,

3], 

 [

4, 5, 6, 7],

[ 8, 9,10,11]],

[[12, 13, 14,

15], 

 [16,

17, 18, 19],

[20, 21, 22, 23]]])

多维数组b中

有0~23的整数，共

24个元素，是一

个2×3×4的三维数

组。我们可以

形象地把它

看做一个两

层楼建筑，每

层楼有12个房

间，并排列成

3行4列。或者，我

们也可以将

其看成是电

子

表格中工

作表（sheet）、行和列

的关系。你可

能已经猜到

，reshape函数的作用

是改变数组

的“形

状”，也就

是改变数组

的维度，其参

数为一个正

整数元组，分

别指定数组

在每个维度

上的大小。

如

果指定的维

度和数组的

元素数目不

相吻合，函数

将抛出异常

。

(2) 我们可以用

三维坐标来

选定任意一

个房间，即楼

层、行号和列

号。例如，选定

第1层楼、

第1行

、第1列的房间

（也可以说是

第0层楼、第0行

、第0列，这只是

习惯问题），可

以这样表示

：

In:

b[0,0,0] 

Out: 0

(3) 如果我们不

关心楼层，也

就是说要选

取所有楼层

的第1行、第1列

的房间，那么

可以将第1

个

下标用英文

标点的冒号

:来代替：

In: b[:,0,0] 

Out:

array([ 0, 12])

This selects the first

floor 

In: b[0]

Out: 

array([[ 0,

1, 2, 3],

[ 4, 5, 6,

7], 

 [

8, 9,10,11]]) 

我们

还可以这样

写，选取第1层

楼的所有房

间：

In: b[0, :, :]

Out: 

array([[ 0,

1, 2, 3],

[ 4, 5, 6,

7], 

 [

8, 9,10,11]]) 

多个冒号

可以用一个

省略号（...）来代

替，因此上面

的代码等价

于：

In: b[0, ...]

Out: 

array([[ 0,

1, 2, 3],

[ 4, 5, 6,

7], 

 [

8, 9, 10, 11]])

图灵社区

会员 heruihong 专享 尊

重版权

2.5 动手

实践：多维数

组的切片和

索引 25

1 

2

3 

4

5

11 

6

7

8 

9

10 

进而可

以选取第1层

楼、第2排的所

有房间：

In: b[0,1] 

Out:

array([4, 5, 6, 7])

(4) 再进

一步，我们可

以在上面的

数组切片中

间隔地选定

元素： 

In:

b[0,1,::2] 

Out: array([4,

6]) 

(5) 如果要

选取所有楼

层的位于第

2列的房间，即

不指定楼层

和行号，用如

下代码即可

：

In: b[...,1] 

Out:

array([[ 1, 5, 9],

[13,17,21]]) 

类似地，我们

可以选取所

有位于第2行

的房间，而不

指定楼层和

列号：

In: b[:,1] 

Out:

array([[ 4, 5, 6,

7], 

 [16,17,18,19]])

如果要

选取第1层楼

的所有位于

第2列的房间

，在对应的两

个维度上指

定即可：

In: b[0,:,1]

Out: array([1, 5, 9])

(6) 如果

要选取第1层

楼的最后一

列的所有房

间，使用如下

代码： 

In:

b[0,:,-1] 

Out: array([

3, 7, 11])

如果要

反向选取第

1层楼的最后

一列的所有

房间，使用如

下代码： 

In: b[0,::-1,

-1] 

Out: array([11,

7, 3]) 

在该

数组切片中

间隔地选定

元素：

In: b[0,::2,-1] 

Out:

array([ 3, 11])

如果在

多维数组中

执行翻转一

维数组的命

令，将在最前

面的维度上

翻转元素的

顺序，在我们

的例子中将

把第1层楼和

第2层楼的房

间交换： 

In: b[::-1]

Out: 

array([[[12,13,14,15],

[16,17,18,19], 

 [20,21,22,23],

[[ 0, 1,

2, 3], 

图灵

社区会员

heruihong 专

享 尊重版权

26 第

2 章 NumPy 基础

[ 4, 5, 6,

7], 

 [

8, 9,10,11]]]) 

刚

才做了些什

么

我们用各

种方法对一

个NumPy多维数组

进行了切片

操作。

2.6 动手实

践：改变数组

的维度

我们

已经学习了

怎样使用reshape函

数，现在来学

习一下怎样

将数组展平

。

(1) ravel 我们可以用

ravel函数完成展

平的操作：

In:

b 

Out:

array([[[ 0, 1, 2,

3], 

 [

4, 5, 6, 7],

[ 8, 9,10,11]],

[[12,13,14,15],

[16,17,18,19], 

 [20,21,22,23]]])

In: b.ravel() 

Out:

array([ 0, 1, 2,

3, 4, 5, 6,

7, 8, 9, 10,

11, 12, 13, 14,

15, 16,

17, 18, 19, 20,

21, 22, 23])

(2) flatten 这

个函数恰如

其名，flatten就是展

平的意思，与

ravel函数的功能

相同。

不过，flatten函

数会请求分

配内存来保

存结果，而ravel函

数只是返回

数组的一个

视图（view）：

In: b.flatten() 

Out:

array([ 0, 1, 2,

3, 4, 5, 6,

7, 8, 9, 10,

11, 12, 13, 14,

15, 16,

17, 18, 19, 20,

21, 22, 23])

(3) 用元组

设置维度 除

了可以使用

reshape函数，我们也

可以直接用

一个正整数

元组来设

置

数组的维度

，如下所示：

In: b.shape = (6,4)

In: b 

Out:

array([ 0, 1, 2,

3], 

 [

4, 5, 6, 7],

[ 8, 9,10,11],

[12,13,14,15],

[16,17,18,19], 

 [20,21,22,23]],

正

如你所看到

的，这样的做

法将直接改

变所操作的

数组，现在数

组b成了一个

6×4的多维数组

。

图灵社区会

员 heruihong 专享

尊重

版权

2.8 动手实

践：组合数组

27

1 

2

3 

4

5

11 

6

7

8 

9

10 

(4) transpose

在线性代数

中，转置矩阵

是很常见的

操作。对于多

维数组，我们

也可以这样

做： 

In: b.transpose()

Out: 

array([[ 0,

4, 8, 12, 16,

20], 

 [

1, 5, 9, 13,

17, 21],

[ 2, 6,10, 14,

18, 22],

[ 3, 7,11, 15,

19, 23]]) 

(5)

resize resize和reshape函数的

功能一样，但

resize会直接修改

所操作的数

组：

In: b.resize((2,12))

In: b 

Out:

array([[ 0, 1, 2,

3, 4, 5, 6,

7, 8, 9, 10,

11], 

 [12,13,14,15,16,17,18,19,20,21,

22, 23]]) 

刚才做了

些什么

我们

用ravel、flatten、reshape和resize函数对

NumPy数组的维度

进行了修改

。 

2.7 数组的组合

NumPy数组有水平

组合、垂直组

合和深度组

合等多种组

合方式，我们

将使用vstack、

dstack、hstack、column_stack、row_stack以及

concatenate函数来完成

数组的组合

。 

2.8 动手实践：组

合数组

首先

，我们来创建

一些数组： 

In: a

= arange(9).reshape(3,3) 

In:

a 

Out:

array([[0, 1, 2],

[3, 4, 5],

[6, 7, 8]])

In: b = 2

* a 

In:

b 

Out:

array([[ 0, 2, 4],

[ 6, 8,

10], 

 [12,

14,16]]) 

(1) 水

平组合

我们

先从水平组

合开始练习

。将ndarray对象构成

的元组作为

参数，传给

hstack函

数。如下所示

：

图灵社区会

员 heruihong

专享 尊重

版权

28 第

2 章 NumPy 基

础

In: hstack((a, b))

Out: 

array([[ 0,

1, 2, 0, 2,

4], 

 [

3, 4, 5, 6,

8,10], 

 [

6, 7, 8,12,14,16]])

我们也可

以用concatenate函数来

实现同样的

效果，如下所

示：

In: concatenate((a, b),

axis=1) 

Out:

array([[ 0, 1, 2,

0, 2, 4],

[ 3, 4, 5,

6, 8,10],

[ 6, 7, 8,12,14,16]])

(2) 垂直组合

垂直组合同

样需要构造

一个元组作

为参数，只不

过这次的函

数变成了

vstack。如

下所示：

In: vstack((a, b))

Out: 

array([[ 0,

1, 2],

[ 3, 4, 5],

[ 6, 7,

8], 

 [

0, 2, 4],

[ 6, 8,10],

[12,14,16]]) 

同样

，我们将concatenate函数

的axis参数设置

为0即可实现

同样的效果

。这也是axis参

数

的默认值：

In: concatenatel((a, b), axis

= 0) 

Out:

array([[ 0, 1, 2],

[ 3, 4,

5], 

 [

6, 7, 8],

[ 0, 2, 4],

[ 6, 8,10],

[12,14,16]]) 

(3)

深

度组合 将相

同的元组作

为参数传给

dstack函数，即可完

成数组的深

度组合。所谓

图灵社区会

员 heruihong 专享

尊重

版权

2.8 动手实

践：组合数组

29

1 

2

3 

4

5

11 

6

7

8 

9

10 

深度组合，就

是将一系列

数组沿着纵

轴（深度）方向

进行层叠组

合。举个例子

，有若干张二

维平

面内的

图像点阵数

据，我们可以

将这些图像

数据沿纵轴

方向层叠在

一起，这就形

象地解释了

什么

是深度

组合。 

In: dstack((a,

b)) 

Out:

array([[[0, 0],

[1, 2],

[2, 4]],

[[3, 6],

[4, 8],

[5,10]], 

 [[6,12],

[7,14],

[8,16]]]) 

(4) 列组合

column_stack函数对于一

维数组将按

列方向进行

组合，如下所

示：

In: oned = arange(2)

In: oned 

Out:

array([0, 1]) 

In:

twice_oned = 2 *

oned 

In: twice_oned

Out: array([0, 2])

In: column_stack((oned, twice_oned))

Out: 

array([[0, 0],

[1, 2]])

而对于二

维数组，column_stack与hstack的

效果是相同

的： 

In: column_stack((a,

b)) 

Out:

array([[ 0, 1, 2,

0, 2, 4],

[ 3, 4, 5,

6, 8,10],

[ 6, 7, 8,12,14,16]])

In: column_stack((a, b)) ==

hstack((a, b)) 

Out:

array([[ True, True, True,

True, True, True],

[ True, True, True,

True, True, True],

[ True, True, True,

True, True, True]], dtype=bool)

是的，你猜

对了！我们可

以用==运算符

来比较两个

NumPy数组，是不是

很简洁？

(5) 行组

合 当然，NumPy中也

有按行方向

进行组合的

函数，它就是

row_stack。对于两

个一

维数组，将直

接层叠起来

组合成一个

二维数组。

In: row_stack((oned, twice_oned))

Out: 

array([[0, 1],

[0, 2]])

对

于二维数组

，row_stack与vstack的效果是

相同的： 

图灵

社区会员 heruihong

专

享 尊重版权

30 第 2

章 NumPy 基础

In:

row_stack((a, b)) 

Out:

array([[ 0, 1, 2],

[ 3, 4,

5], 

 [

6, 7, 8],

[ 0, 2, 4],

[ 6, 8,10],

[12,14,16]]) 

In:

row_stack((a,b)) == vstack((a, b))

Out: 

array([[ True,

True, True],

[ True, True, True],

[ True, True,

True], 

 [

True, True, True],

[ True, True, True],

[ True, True,

True]], dtype=bool) 

刚

才做了些什

么

我们按照

水平、垂直和

深度等方式

进行了组合

数组的操作

。我们使用了

vstack、dstack、

hstack、column_stack、row_stack以及concatenate函数。 

2.9

数

组的分割

NumPy数

组可以进行

水平、垂直或

深度分割，相

关的函数有

hsplit、vsplit、dsplit和

split。我们可以

将数组分割

成相同大小

的子数组，也

可以指定原

数组中需要

分割的位置

。

2.10 动手实践：分

割数组

(1) 水平

分割

下面的

代码将把数

组沿着水平

方向分割为

3个相同大小

的子数组： 

In: a

Out: 

array([[0, 1,

2], 

 [3,

4, 5],

[6, 7, 8]])

In: hsplit(a, 3)

Out: 

[array([[0],

[3], 

 [6]]),

array ([[1],

[4], 

 [7]]),

array ([[2],

[5], 

 [8]])]

图

灵社区会员

heruihong 专享 尊重版

权

2.10

动手实践

：分割数组 31 

1

2 

3

4

5 

11

6

7 

8

9 

10

对

同样的数组

，调用split函数并

在参数中指

定参数axis=1，对比

一下结果： 

In: split(a,

3, axis=1) 

Out:

[array([[0], 

 [3],

[6]]), 

array

([[1], 

 [4],

[7]]), 

array

([[2], 

 [5],

[8]])] 

(2)

垂

直分割 vsplit函数

将把数组沿

着垂直方向

分割：

In: vsplit(a,

3) 

Out: [array([[0,

1, 2]]), array([[3, 4,

5]]), array([[6, 7, 8]])]

同样，调

用split函数并在

参数中指定

参数axis=0，也可以

得到同样的

结果： 

In: split(a,

3, axis=0) 

Out:

[array([[0, 1, 2]]), array([[3,

4, 5]]), array([[6, 7,

8]])] 

(3) 深度分

割

不出所料

，dsplit函数将按深

度方向分割

数组。我们先

创建一个三

维数组：

In: c =

arange(27).reshape(3, 3, 3)

In: c 

Out:

array([[[ 0, 1, 2],

[ 3, 4,

5], 

 [

6, 7, 8]],

[[ 9,10,11],

[12,13,14], 

 [15,16,17]],

[[18,19,20],

[21,22,23], 

 [24,25,26]]])

In: dsplit(c, 3)

Out: 

[array([[[ 0],

[ 3],

[ 6]],

[[ 9],

[12], 

 [15]],

[[18],

[21], 

 [24]]]),

array([[[ 1],

[ 4],

[ 7]],

[[10], 

图灵

社区会员 heruihong

专

享 尊重版权

32 第 2

章 NumPy 基础

[13], 

 [16]],

[[19],

[22], 

 [25]]]),

array([[[ 2],

[ 5],

[ 8]],

[[11], 

 [14],

[17]],

[[20], 

 [23],

[26]]])] 

刚

才做了些什

么

我们用hsplit、vsplit、dsplit和

split函数进行了

分割数组的

操作。 

2.11 数组的

属性

除了shape和

dtype属性以外，ndarray对

象还有很多

其他的属性

，在下面一一

列出。

 ndim属性，给

出数组的维

数，或数组轴

的个数：

In:

b 

Out:

array([[0, 1, 2, 3,

4, 5, 6, 7,

8, 9, 10,11],

[12,13,14,15,16,17,18,19,20,21,22,23]]) 

In: b.ndim

Out: 2 



size属性

，给出数组元

素的总个数

，如下所示： 

In: b.size

Out: 24 



itemsize属

性，给出数组

中的元素在

内存中所占

的字节数：

In: b.itemsize

Out: 8 



如

果你想知道

整个数组所

占的存储空

间，可以用nbytes属

性来查看。这

个属性的值

其实

就是itemsize和

size属性值的乘

积： 

In:

b.nbytes 

Out: 192

In: b.size * b.itemsize

Out: 192 

图灵社区

会员

heruihong 专享 尊

重版权

2.11

数组

的属性 33 

1

2 

3

4

5 

11

6

7 

8

9 

10

 T属性

的效果和transpose函

数一样，如下

所示：

In: b.resize(6,4)

In: b 

Out:

array([[ 0, 1, 2,

3], 

 [

4, 5, 6, 7],

[ 8, 9,10,11],

[12,13,14,15],

[16,17,18,19], 

 [20,21,22,23]])

In: b.T 

Out:

array([[ 0, 4, 8,

12,16, 20],

[ 1, 5, 9,

13,17, 21],

[ 2, 6,10, 14,18,

22], 

 [

3, 7,11, 15,19, 23]])

 对于一

维数组，其T属

性就是原数

组： 

In:

b.ndim 

Out: 1

In: b.T 

Out:

array([0, 1, 2, 3,

4]) 

 在NumPy中，复数

的虚部是用

j表示的。例如

，我们可以创

建一个由复

数构成的数

组：

In: b = array([1.j

+ 1, 2.j +

3]) 

In: b

Out: array([ 1.+1.j, 3.+2.j])

 real属性，给出

复数数组的

实部。如果数

组中只包含

实数元素，则

其real属性将输

出原

数组：

In:

b.real 

Out: array([

1., 3.]) 



imag属

性，给出复数

数组的虚部

：

In: b.imag

Out: array([ 1., 2.])

 如果数组中

包含复数元

素，则其数据

类型自动变

为复数型：

In: b.dtype

Out: dtype('complex128') 

In:

b.dtype.str 

Out: '<c16'

 flat属

性将返回一

个numpy.flatiter对象，这是

获得flatiter对象的

唯一方式——我

们无法访问

flatiter的构造函数

。这个所谓的

“扁平迭代器

”可以让我们

像遍历一维

数

组一样去

遍历任意的

多维数组，如

下所示：

图灵

社区会员 heruihong 专

享 尊重版权

34

第 2 章 NumPy

基础

In: b =

arange(4).reshape(2,2) 

In: b

Out: 

array([[0, 1],

[2, 3]])

In: f = b.flat

In: f 

Out:

<numpy.flatiter object at 0x103013e00>

In: for item in

f: print item

.....: 

0

1 

2

3 

我

们还可以用

flatiter对象直接获

取一个数组

元素：

In: b.flat[2] 

Out:

2 

或者获

取多个元素

：

In:

b.flat[[1,3]] 

Out: array([1,

3]) 

flat属性是一个

可赋值的属

性。对flat属性赋

值将导致整

个数组的元

素都被覆盖

：

In: b.flat = 7

In: b 

Out:

array([[7, 7],

[7, 7]]) 

or

selected elements 

In:

b.flat[[1,3]] = 1

In: b 

Out:

array([[7, 1],

[7, 1]]) 

2.12

动手实践：数

组的转换

我

们可以使用

tolist函数将NumPy数组

转换成Python列表

。

图灵社区会

员 heruihong

专享 尊重

版权

2.13 本章小

结

35 

1

2 

3

4

5 

11

6

7 

8

9 

10

(1) 转换成列

表： 

In:

b 

Out: array([

1.+1.j, 3.+2.j]) 

In:

b.tolist() 

Out: [(1+1j),

(3+2j)] 

(2) astype函数可以

在转换数组

时指定数据

类型：

In: b 

Out:

array([ 1.+1.j, 3.+2.j])

In: b.astype(int) 

/usr/local/bin/ipython:1:

ComplexWarning: Casting complex values

to real discards the

imaginary part

#!/usr/bin/python 

Out: array([1,

3]) 

在上面

将复数转换

为整数的过

程中，我们丢

失了复数的

虚部。astype函数

也

可以接受数

据类型为字

符串的参数

。

In: b.astype('complex') 

Out:

array([ 1.+1.j, 3.+2.j])

这一次我们

使用了正确

的数据类型

，因此不会再

显示任何警

告信息。

刚才

做了些什么

我们将NumPy数组

转换成了不

同数据类型

的Python列表。

2.13 本章

小结

在本章

中，我们学习

了很多NumPy的基

础知识：数据

类型和NumPy数组

。对于数组而

言，

有很多属

性可以用来

描述数组，数

据类型就是

其中之一。在

NumPy中，数组的数

据类型是用

对象

来完善

表示的。

类似

于Python列表，NumPy数组

也可以方便

地进行切片

和索引操作

。在多维数组

上，NumPy

有明显的

优势。

涉及改

变数组维度

的操作有很

多种——组合、调

整、设置维度

和分割等。在

这一章中，对

很

多改变数

组维度的实

用函数进行

了说明。这样

的处理。

在学

习完基础知

识后，我们将

进入到第3章

来学习NumPy中的

常用函数，包

括基本数学

函数

和统计

函数等。

图灵

社区会员 heruihong 专

享

尊重版权

36 第 3 章

常用函

数

常用函数

在本章中，我

们将学习NumPy的

常用函数。具

体来说，我们

将以分析历

史股价为例

，介绍怎样从

文件中载入

数据，以及怎

样使用NumPy的基

本数学

和统

计分析函数

。这里还将学

习读写文件

的方法，并尝

试函数式编

程和NumPy

线性代

数运算。

本章

涵盖以下内

容：

 数组相关

的函数；



从文

件中载入数

据；

 将数组写

入文件；



简单

的数学和统

计分析函数

。

3.1 文件读写

首

先，我们来学

习使用NumPy读写

文件。通常情

况下，数据是

以文件形式

存储的。学会

读写

文件是

深入学习NumPy的

基础。

3.2 动手实

践：读写文件

作为文件读

写示例，我们

创建一个单

位矩阵并将

其存储到文

件中，并按照

如下步骤完

成。

(1)

单位矩阵

，即主对角线

上的元素均

为1，其余元素

均为0的正方

形矩阵。在NumPy中

可以

用eye函数

创建一个这

样的二维数

组，我们只需

要给定一个

参数，用于指

定矩阵中1的

元素个数。

例

如，创建2×2的数

组：

i2 = np.eye(2)

print i2 

第3章

图灵

社区会员 heruihong 专

享 尊重版权

3.4

动手实践：读

入 CSV 文件 37

1 

2

3 

4

5

11 

6

7

8 

9

10 

The output

is: 

[[ 1.

0.] 

[ 0.

1.]] 

(2) 使用

savetxt函数将数据

存储到文件

中，当然我们

需要指定文

件名以及要

保存的数组

。

np.savetxt("eye.txt", i2) 

上面的代码

会创建一个

eye.txt文件，你可以

检查文件内

容和设想的

是否一致。这

个示例的代

码（save.py）可以从本

书的售后支

持站点下载

：http://www.packtpub.com/support。

import numpy as np

i2 = np.eye(2)

print i2 

np.savetxt("eye.txt",

i2) 

刚才做了些

什么

读写文

件是数据分

析的一项基

本技能。我们

用savetxt函数进行

了写文件的

操作。在此之

前，

我们还用

eye函数创建了

一个单位矩

阵。

3.3 CSV 文件

CSV（Comma-Separated Value，逗号

分隔值）格式

是一种常见

的文件格式

。通常，数据库

的

转存文件

就是CSV格式的

，文件中的各

个字段对应

于数据库表

中的列。众所

周知，电子表

格软件

（如Microsoft

Excel）可

以处理CSV文件

。

3.4 动手实践：读

入 CSV

文件

我们

应该如何处

理CSV文件呢？幸

运的是，NumPy中的

loadtxt函数可以方

便地读取CSV

文

件，自动切分

字段，并将数

据载入NumPy数组

。下面，我们以

载入苹果公

司的历史股

价数据为

例

展开叙述。股

价数据存储

在CSV文件中，第

一列为股票

代码以标识

股票（苹果公

司股票代码

为

AAPL），第二列为

dd-mm-yyyy格式的日期

，第三列为空

，随后各列依

次是开盘价

、最高价、最低

价和收盘价

，最后一列为

当日的成交

量。下面为一

行数据：

AAPL,28-01-2011, ,344.17,344.4,333.53,336.1,21144800

从现

在开始，我们

只关注股票

的收盘价和

成交量。在上

面的示例数

据中，收盘价

为336.1，

成交量为

21144800。我们将收盘

价和成交量

分别载入到

两个数组中

，如下所示：

c,v=np.loadtxt('data.csv', delimiter=',',

usecols=(6,7), unpack=True) 

可

以看到，数据

存储在data.csv文件

中，我们设置

分隔符为,（英

文标点逗号

），因为我们要

图灵社区会

员

heruihong 专享 尊重

版权

38

第 3 章 常

用函数

处理

一个CSV文件。usecols的

参数为一个

元组，以获取

第7字段至第

8字段的数据

，也就是股票

的收盘价和

成交量数据

。unpack参数设置为

True，意思是分拆

存储不同列

的数据，即分

别将收

盘价

和成交量的

数组赋值给

变量c和v。

刚才

做了些什么

CSV文件是一种

经常用于数

据处理的文

件格式。我们

用loadtxt函数读取

了一个包含

股价数据

的

CSV文件，用delimiter参数

指定了文件

中的分隔符

为英文逗号

，用usecols中的参数

指定了我

们

感兴趣的数

据列，并将unpack参

数设置为True使

得不同列的

数据分开存

储，以便随后

使用。

3.5 成交量

加权平均价

格（VWAP）

VWAP（Volume-Weighted

Average Price，成交量加

权平均价格

）是一个非常

重要的经济

学量，

它代表

着金融资产

的“平均”价格

。某个价格的

成交量越高

，该价格所占

的权重就越

大。VWAP

就是以成

交量为权重

计算出来的

加权平均值

，常用于算法

交易。

3.6 动手实

践：计算成交

量加权平均

价格

我们将

按如下步骤

计算。

(1)

将数据

读入数组。

(2) 计

算VWAP。

import

numpy as np

c,v=np.loadtxt('data.csv', delimiter=',', usecols=(6,7), unpack=True)

vwap = np.average(c, weights=v)

print "VWAP =", vwap

The output is

VWAP = 350.589549353

刚才做了

些什么

这很

容易，不是吗

？我们仅仅调

用了average函数，并

将v作为权重

参数使用，就

完成了

VWAP的计

算。此外，NumPy中也

有计算算术

平均值的函

数。

3.6.1 算术平均

值函数

NumPy中的

mean函数很友好

，一点儿也不

mean（该词有“尖酸

刻薄”的意思

）。这个函数可

以计算数组

元素的算术

平均值。具体

用法如下：

图

灵社区会员

heruihong

专享 尊重版

权

3.7 取值范围

39

1 

2

3 

4

5

11 

6

7

8 

9

10 

print "mean

=", np.mean(c) 

mean

= 351.037666667 

3.6.2

时间加权平

均价格

在经

济学中，TWAP（Time-Weighted Average Price，时间

加权平均价

格）是另一种

“平均”

价格的

指标。既然我

们已经计算

了VWAP，那也来计

算一下TWAP吧。其

实TWAP只是一个

变种

而已，基

本的思想就

是最近的价

格重要性大

一些，所以我

们应该对近

期的价格给

以较高的权

重。

最简单的

方法就是用

arange函数创建一

个从0开始依

次增长的自

然数序列，自

然数的个数

即为收

盘价

的个数。当然

，这并不一定

是正确的计

算TWAP的方式。事

实上，本书中

关于股价分

析的大

部分

示例都仅仅

是为了说明

问题。计算TWAP的

代码如下。

t = np.arange(len(c))

print "twap =", np.average(c,

weights=t) 

程

序将输出如

下结果：

twap

= 352.428321839 

在这

个例子中，TWAP的

值甚至比算

术平均值还

要高。

突击测

验：计算加权

平均值

问题

1 以下哪个函

数可以返回

数组元素的

加权平均值

？

(1)

weighted average

(2) waverage

(3) average

(4) avg

勇敢出发：计

算其他数据

的平均值

请

尝试对开盘

价做相同的

计算，并计算

成交量和其

他各种价格

的算术平均

值。

3.7 取值范围

通常，我们不

仅仅想知道

一组数据的

平均值，还希

望知道数据

的极值以及

完整的取值

范

围——最大值

和最小值。我

们的股价示

例数据中已

经包含了每

天的股价范

围——最高价和

最低

价。但是

，我们还需要

知道最高价

的最大值以

及最低价的

最小值。不然

，我们怎样才

能知道自己

的股票是赚

了还是赔了

呢？

图灵社区

会员 heruihong

专享 尊

重版权

40 第

3 章

常用函数

3.8 动

手实践：找到

最大值和最

小值

min函数和

max函数能够满

足需求。我们

按如下步骤

来找最大值

和最小值。

(1) 首

先，需要再次

读入数据，将

每日最高价

和最低价的

数据载入数

组：

h,l=np.loadtxt('data.csv',delimiter=',', usecols=(4,5), unpack=True)

唯一需要

修改的就是

usecols中的参数，因

为最高价和

最低价与之

前的数据在

不同的列中

。

(2) 下方的代码

即可获取价

格区间：

print

"highest =", np.max(h)

print "lowest =", np.min(l)

程序

将返回如下

结果：

highest = 364.9

lowest = 333.53

现在，计

算区间中点

就很容易了

，留给读者自

己尝试练习

。

(3) NumPy中有一个ptp函

数可以计算

数组的取值

范围。该函数

返回的是数

组元素的最

大值

和最小

值之间的差

值。也就是说

，返回值等于

max(array)

- min(array)。调用ptp函数： 

print

"Spread high price", np.ptp(h)

print "Spread low price",

np.ptp(l) 

我

们将看到如

下结果：

Spread high price 24.86

Spread low price 26.97

刚才

做了些什么

我们定义了

股价的最大

值和最小值

的取值范围

。最大值是在

每日最高价

数据上使用

max函数

得到的

，而最低价是

在每日最低

价数据上使

用min函数得到

的。我们还用

ptp函数计算了

极差，

即最大

值和最小值

之间的差值

。

import

numpy as np

h,l=np.loadtxt('data.csv', delimiter=',', usecols=(4,5), unpack=True)

print "highest =", np.max(h)

print "lowest =", np.min(l)

print (np.max(h) + np.min(l))

/2 

print "Spread

high price", np.ptp(h)

print "Spread low price",

np.ptp(l) 

图灵社区会

员 heruihong

专享 尊重

版权

3.10 动手实

践：简单统计

分析

41 

1

2 

3

4

5 

11

6

7 

8

9 

10

3.9 统计分

析

股票交易

者对于收盘

价的预测很

感兴趣。常识

告诉我们，这

个价格应该

接近于某种

均值。算

数平

均值和加权

平均值都是

在数值分布

中寻找中心

点的方法。然

而，它们对于

异常值（outlier）

既不

鲁棒也不敏

感。举例来说

，如果我们有

一个高达100万

美元的收盘

价，这将影响

到我们的计

算结果。

3.10 动手

实践：简单统

计分析

我们

可以用一些

阈值来除去

异常值，但其

实有更好的

方法，那就是

中位数。将各

个变量值按

大小顺序排

列起来，形成

一个数列，居

于数列中间

位置的那个

数即为中位

数。例如，我们

有1、2、

3、4、5这5个数值

，那么中位数

就是中间的

数字3。下面是

计算中位数

的步骤。

(1) 计算

收盘价的中

位数。创建一

个新的Python脚本

文件，命名为

simplestats.py。你已经知道

如何从CSV文件

中读取数据

到数组中了

，因此只需要

复制一行代

码并确保只

获取收盘价

数据即

可，如

下所示：

c=np.loadtxt('data.csv', delimiter=',', usecols=(6,), unpack=True)

(2) 一个

叫做median的函数

将帮助我们

找到中位数

。我们调用它

并立即打印

出结果。添加

下

面这行代

码：

print "median =", np.median(c)

这段代码

的输出内容

如下：

median = 352.055

(3) 既然这

是我们首次

使用median函数，我

们来检查一

下结果是否

正确。这可不

是因为我

们

多疑！当然，我

们可以将整

个数据文件

浏览一遍并

人工找到正

确的答案，但

那样太无趣

了。

我们将对

价格数组进

行排序，并输

出排序后居

于中间位置

的值，这也就

是模拟了寻

找中位数的

算法。msort函数可

以帮我们完

成第一步。我

们将调用这

个函数，获得

排序后的数

组，并输出

结

果。

sorted_close = np.msort(c)

print "sorted =", sorted_close

这段代码

的输出内容

如下： 

图灵社

区会员 heruihong

专享

尊重版权

42 第

3 章

常用函数

太好了，代码

生效了！现在

，我们来获取

位于中间的

那个数字： 

N =

len(c) 

print "middle

=", sorted[(N - 1)/2]

输

出如下： 

middle =

351.99 

(4) 咦，这

个值和median函数

给出的值不

一样，这是怎

么回事？经过

仔细观察我

们发现，

median函数

返回的结果

甚至根本没

有在我们的

数据文件里

出现过。这就

更奇怪了！在

给NumPy

团队提交

bug报告之前，我

们先来看下

文档。原来这

个谜团很容

易解开。原因

就在于我们

的简单

算法

模拟只对长

度为奇数的

数组奏效。对

于长度为偶

数的数组，中

位数的值应

该等于中间

那两个

数的

平均值。因此

，输入如下代

码：

print "average middle =",

(sorted[N /2] + sorted[(N

- 1) / 2])

/ 2 

输出结果

如下：

average middle = 352.055

成功了

！

(5) 另外一个我

们关心的统

计量就是方

差。方差能够

体现变量变

化的程度。在

我们的例子

中，

方差还可

以告诉我们

投资风险的

大小。那些股

价变动过于

剧烈的股票

一定会给持

有者制造麻

烦。

在NumPy中，计算

方差只需要

一行代码，看

下面： 

print "variance

=", np.var(c) 

将给出

如下结果：

variance = 50.1265178889

(6) 既

然我们不相

信NumPy的函数，那

就再次根据

文档中方差

的定义来复

核一下结果

。注意，

这里方

差的定义可

能与你在统

计学的书中

看到的不一

致，但这个定

义在统计学

上更为通用

。

方差是指各

个数据与所

有数据算术

平均数的离

差平方和除

以数据个数

所得

到的值

。

一些书里面

告诉我们，应

该用数据个

数减1去除离

差平方和①。

print

"variance from definition =",

np.mean((c - c.mean())**2)

—————————— 

① 注

意样本方差

和总体方差

在计算上的

区别。总体方

差是用数据

个数去除离

差平方和，而

样本方差则

是用样本数

据

个数减1去

除离差平方

和，其中样本

数据个数减

1（即n1）称为自由

度。之所以有

这样的差别

，是为了保证

样本

方差是

一个无偏估

计量。——译者注

图灵社区会

员 heruihong 专享

尊重

版权

3.12 动手实

践：分析股票

收益率 43

1 

2

3 

4

5

11 

6

7

8 

9

10 

输出

结果如下：

variance

from definition = 50.1265178889

这

正是我们希

望得到的结

果！

刚才做了

些什么

你可

能已经注意

到了一些新

东西。我们直

接在数组c上

调用了mean方法

c.mean()，是的，

没有写

错。ndarray对象有mean方

法，这将给你

带来便利。从

现在开始，记

住这种用法

是正确

无误

的。示例代码

可以在simplestats.py中找

到。

import numpy as

np 

c=np.loadtxt('data.csv', delimiter=',',

usecols=(6,), unpack=True) 

print

"median =", np.median(c)

sorted = np.msort(c)

print "sorted =", sorted

N = len(c)

print "middle =", sorted[(N

- 1)/2] 

print

"average middle =", (sorted[N

/2] + sorted[(N -

1) / 2]) /

2 

print "variance

=", np.var(c) 

print

"variance from definition =",

np.mean((c - c.mean())**2)

3.11 股票收益

率

在学术文

献中，收盘价

的分析常常

是基于股票

收益率和对

数收益率的

。简单收益率

是指相邻

两

个价格之间

的变化率，而

对数收益率

是指所有价

格取对数后

两两之间的

差值。我们在

高中学习

过

对数的知识

，“a”的对数减去

“b”的对数就等

于“a除以b”的对

数。因此，对数

收益率也可

以用来衡量

价格的变化

率。注意，由于

收益率是一

个比值，例如

我们用美元

除以美元（也

可以是

其他

货币单位），因

此它是无量

纲的。总之，投

资者最感兴

趣的是收益

率的方差或

标准差，因为

这代表着投

资风险的大

小。

3.12 动手实践

：分析股票收

益率

按照如

下步骤分析

股票收益率

。

(1) 首先，我们来

计算简单收

益率。NumPy中的diff函

数可以返回

一个由相邻

数组元素的

差

值构成的

数组。这有点

类似于微积

分中的微分

。为了计算收

益率，我们还

需要用差值

除以前一天

的价格。不过

这里要注意

，diff返回的数组

比收盘价数

组少一个元

素。经过仔细

考虑，我们使

用如下代码

：

图灵社区会

员 heruihong 专享 尊重

版权

44 第 3 章

常

用函数

returns = np.diff(

arr ) / arr[

: -1] 

注意

，我们没有用

收盘价数组

中的最后一

个值做除数

。接下来，用std函

数计算标准

差：

print "Standard deviation =",

np.std(returns) 

输出结果

如下：

Standard deviation = 0.0129221344368

(2) 对数收

益率计算起

来甚至更简

单一些。我们

先用log函数得

到每一个收

盘价的对数

，再

对结果使

用diff函数即可

。

logreturns = np.diff( np.log(c)

) 

一般情况下

，我们应检查

输入数组以

确保其不含

有零和负数

。否则，将得到

一个错误提

示。

不过在我

们的例子中

，股价总为正

值，所以可以

将检查省略

掉。

(3) 我们很可

能对哪些交

易日的收益

率为正值非

常感兴趣。在

完成了前面

的步骤之后

，我们

只需要

用where函数就可

以做到这一

点。where函数可以

根据指定的

条件返回所

有满足条件

的数

组元素

的索引值。输

入如下代码

：

posretindices = np.where(returns >

0) 

print "Indices

with positive returns", posretindices

即可输出该

数组中所有

正值元素的

索引。 

Indices with

positive returns (array([ 0,

1, 4, 5, 6,

7, 9, 10, 11,

12, 16, 17, 18,

19, 21, 22, 23,

25, 28]),) 

(4)

在投资

学中，波动率

（volatility）是对价格变

动的一种度

量。历史波动

率可以根据

历史价

格数

据计算得出

。计算历史波

动率（如年波

动率或月波

动率）时，需要

用到对数收

益率。年波动

率等于对数

收益率的标

准差除以其

均值，再除以

交易日倒数

的平方根，通

常交易日取

252天。我

们用std和

mean函数来计算

，代码如下所

示：

annual_volatility = np.std(logreturns)/np.mean(logreturns)

annual_volatility = annual_volatility /

np.sqrt(1./252.) 

print annual_volatility

(5) 请注意sqrt函

数中的除法

运算。在Python中，整

数的除法和

浮点数的除

法运算机制

不同，

我们必

须使用浮点

数才能得到

正确的结果

。与计算年波

动率的方法

类似，计算月

波动率如下

：

print "Monthly volatility", annual_volatility

* np.sqrt(1./12.) 

刚才做了些

什么

我们用

计算数组相

邻元素差值

的diff函数计算

了简单收益

率，用计算数

组元素自然

对数的

log函数

计算了对数

收益率。最后

，我们计算了

年波动率和

月波动率。示

例代码见return.py文

件。

图灵社区

会员 heruihong

专享 尊

重版权

3.14 动手

实践：分析日

期数据

45 

1

2 

3

4

5 

11

6

7 

8

9 

10

import numpy as np

c=np.loadtxt('data.csv', delimiter=',', usecols=(6,), unpack=True)

returns = np.diff( c

) / c[ :

-1] 

print "Standard

deviation =", np.std(returns)

logreturns = np.diff( np.log(c)

) 

posretindices =

np.where(returns > 0)

print "Indices with positive

returns", posretindices 

annual_volatility

= np.std(logreturns)/np.mean(logreturns) 

annual_volatility

= annual_volatility / np.sqrt(1./252.)

print "Annual volatility", annual_volatility

print "Monthly volatility", annual_volatility

* np.sqrt(1./12.) 

3.13

日期

分析

你是否

有时候会有

星期一焦虑

症和星期五

狂躁症？想知

道股票市场

是否受上述

现象的影

响

？我认为这值

得深入研究

。

3.14

动手实践：分

析日期数据

首先，我们要

读入收盘价

数据。随后，根

据星期几来

切分收盘价

数据，并分别

计算平均价

格。

最后，我们

将找出一周

中哪一天的

平均收盘价

最高，哪一天

的最低。在我

们动手之前

，有一个善

意

的提醒：你可

能希望利用

分析结果在

某一天买股

票或卖股票

，然而我们这

里的数据量

不足以做

出

可靠的决策

，请先咨询专

业的统计分

析师再做决

定！

程序员不

喜欢日期，因

为处理日期

总是很烦琐

。NumPy是面向浮点

数运算的，因

此需要对日

期做一些专

门的处理。请

自行尝试如

下代码，单独

编写脚本文

件或使用本

书附带的代

码文件：

dates, close=np.loadtxt('data.csv', delimiter=',',

usecols=(1,6), unpack=True) 

执行

以上代码后

会得到一个

错误提示：

ValueError: invalid literal for

float(): 28-01-2011 

按

如下步骤处

理日期。

(1) 显然

，NumPy尝试把日期

转换成浮点

数。我们需要

做的是显式

地告诉NumPy怎样

来转换

日期

，而这需要用

到loadtxt函数中的

一个特定的

参数。这个参

数就是converters，它是

一本

数据列

和转换函数

之间进行映

射的字典。

为

此，我们必须

写出转换函

数： 

图灵社区

会员 heruihong

专享 尊

重版权

46 第

3 章

常用函数

# 星

期一

0 

# 星期二

1

# 星期三 2

# 星期

四 3

# 星期五 4

# 星

期六 5

# 星期日

6 

def

datestr2num(s): 

 return

datetime.datetime.strptime 

 (s,

"%d-%m-%Y").date().weekday() 

我们将日期

作为字符串

传给datestr2num函数，如

“28-01-2011”。这个字符串

首先会按照

指定的形式

"%d-%m-%Y"转换成一个

datetime对象。补充一

点，这是由Python标

准库提供的

功能，

与NumPy无关

。随后，datetime对象被

转换为date对象

。最后，调用weekday方

法返回一个

数

字。如同你

在注释中看

到的，这个数

字可以是0到

6的整数，0代表

星期一，6代表

星期天。当然

，

具体的数字

并不重要，只

是用作标识

。

(2) 接下来，我们

将日期转换

函数挂接上

去，这样就可

以读入数据

了。

dates, close=np.loadtxt('data.csv', delimiter=',', usecols=(1,6),

converters={1: 

datestr2num}, unpack=True)

print "Dates =", dates

输出结果

如下： 

Dates =

[ 4. 0. 1.

2. 3. 4. 0.

1. 2. 3. 4.

0. 1. 2. 3.

4. 1. 2. 4.

0. 1. 2. 3.

4. 0. 

1.

2. 3. 4.]

如你所

见，没有出现

星期六和星

期天。股票交

易在周末是

休市的。

(3) 我们

来创建一个

包含5个元素

的数组，分别

代表一周的

5个工作日。数

组元素将初

始化为0。

averages = np.zeros(5)

这个

数组将用于

保存各工作

日的平均收

盘价。

(4) 我们已

经知道，where函数

会根据指定

的条件返回

所有满足条

件的数组元

素的索引值

。

take函数可以按

照这些索引

值从数组中

取出相应的

元素。我们将

用take函数来获

取各个工作

日

的收盘价

。在下面的循

环体中，我们

将遍历0到4的

日期标识，或

者说是遍历

星期一到星

期五，然

后用

where函数得到各

工作日的索

引值并存储

在indices数组中。在

用take函数获取

这些索引值

相应的元素

值。最后，我们

对每个工作

日计算出平

均值存放在

averages数组中。代码

如下： 

for

i in range(5):

indices = np.where(dates ==

i) 

 prices

= np.take(close, indices)

avg = np.mean(prices)

print "Day", i, "prices",

prices, "Average", avg

averages[i] = avg

图灵社

区会员 heruihong 专享

尊重版权

3.14

动

手实践：分析

日期数据 47 

1

2 

3

4

5 

11

6

7 

8

9 

10

输

出结果如下

： 

Day 0

prices [[ 339.32 351.88

359.18 353.21 355.36]] Average

351.79 

Day 1

prices [[ 345.03 355.2

359.9 338.61 349.31 355.76]]

Average 350.635 

Day

2 prices [[ 344.32

358.16 363.13 342.62 352.12

352.47]] Average 352.136666667

Day 3 prices [[

343.44 354.54 358.3 342.88

359.56 346.67]] Average 350.898333333

Day 4 prices [[

336.1 346.5 356.85 350.56

348.16 360. 351.99]] Average

350.022857143 

(5) 如果你愿意

，还可以找出

哪个工作日

的平均收盘

价是最高的

，哪个是最低

的。这很容易

做到，用max和min函

数即可，代码

如下：

top = np.max(averages)

print "Highest average", top

print "Top day of

the week", np.argmax(averages)

bottom = np.min(averages)

print "Lowest average", bottom

print "Bottom day of

the week", np.argmin(averages)

输出结

果如下： 

Highest average

352.136666667 

Top day

of the week 2

Lowest average 350.022857143

Bottom day of the

week 4 

刚才

做了些什么

argmin函数返回的

是averages数组中最

小元素的索

引值，这里是

4，也就是星期

五。而

argmax函数返

回的是averages数组

中最大元素

的索引值，这

里是2，也就是

星期三。示例

代码

见weekdays.py文件

。 

import

numpy as np

from datetime import datetime

# 星期一 0

# 星期

二 1

# 星期三 2

# 星

期四 3

# 星期五

4 

#

星期六 5 

#

星期

日 6 

def

datestr2num(s): 

 return

datetime.strptime(s, "%d-%m-%Y").date().weekday() 

dates,

close=np.loadtxt('data.csv', delimiter=',', usecols=(1,6), converters={1:

datestr2num}, unpack=True) 

print

"Dates =", dates

averages = np.zeros(5)

for i in range(5):

图灵社区

会员 heruihong 专享 尊

重版权

48 第 3 章

常用函数

indices = np.where(dates ==

i) 

 prices

= np.take(close, indices)

avg = np.mean(prices)

print "Day", i, "prices",

prices, "Average", avg

averages[i] = avg

top = np.max(averages)

print "Highest average", top

print "Top day of

the week", np.argmax(averages)

bottom = np.min(averages)

print "Lowest average", bottom

print "Bottom day of

the week", np.argmin(averages)

勇

敢出发：计算

VWAP和TWAP 

这一节的

内容很有趣

！在示例数据

中，你的苹果

股票在星期

五是最便宜

的一天而星

期三是

最值

钱的一天。先

不管我们的

数据量有多

小，思考一下

是否有更合

理的计算平

均值的方式

？我

们是不是

应该考虑成

交量呢？如果

计算时间加

权的平均值

是不是更有

意义呢？快尝

试一下吧！

请

计算VWAP和TWAP，你可

以在本章的

开头部分找

到一些相关

的提示。

3.15 周汇

总

在之前的

“动手实践”教

程中，我们用

的是盘后数

据。也就是说

，这些数据是

将一整天的

交

易数据汇

总得到的。如

果你对棉花

市场感兴趣

，并且有数十

年的数据，你

可能希望对

数据做进一

步的汇总和

压缩。开始动

手吧。我们来

把苹果股票

数据按周进

行汇总。

3.16 动手

实践：汇总数

据

我们将要

汇总整个交

易周中从周

一到周五的

所有数据。数

据覆盖的时

间段内有一

个节假日：

2月

21日是总统纪

念日。这天是

星期一，美国

股市休市，因

此在我们的

示例数据中

没有这一天

的

数据记录

。数据中的第

一天为星期

五，处理起来

不太方便。按

照如下步骤

来汇总数据

。

(1)

为了简单起

见，我们只考

虑前三周的

数据，这样就

避免了节假

日造成的数

据缺失。你可

以稍后尝试

对其进行拓

展。 

close =

close[:16] 

dates =

dates[:16] 

代码基于

3.14节的教程。

(2)

首

先我们来找

到示例数据

中的第一个

星期一。回忆

一下，在Python中星

期一对应的

编码

是0，这可

以作为where函数

的条件。接着

，我们要取出

数组中的首

个元素，其索

引值为0。但where

图

灵社区会员

heruihong 专享

尊重版

权

3.16 动手实践

：汇总数据 49

1 

2

3 

4

5

11 

6

7

8 

9

10 

函

数返回的结

果是一个多

维数组，因此

要用ravel函数将

其展平。

# 找到

第一个星期

一

first_monday =

np.ravel(np.where(dates == 0))[0]

print "The first Monday

index is", first_monday

输出结果

如下：

The first Monday

index is 1

(3) 下面要

做的是找到

示例数据的

最后一个星

期五，方法和

找第一个星

期一类似。星

期五相

对应

的编码是4。此

外，我们用1作

为索引值来

定位数组的

最后一个元

素。

# 找到最后

一个星期五

last_friday = np.ravel(np.where(dates

== 4))[-2] 

print

"The last Friday index

is", last_friday 

输出结果如

下：

The last Friday index

is 15 

接下来创

建一个数组

，用于存储三

周内每一天

的索引值。

weeks_indices = np.arange(first_monday, last_friday

+ 1) 

print

"Weeks indices initial", weeks_indices

(4) 按

照每个子数

组5个元素，用

split函数切分数

组： 

weeks_indices

= np.split(weeks_indices, 5)

print "Weeks indices after

split", weeks_indices 

输出结果

如下：

Weeks indices after split

[array([1, 2, 3, 4,

5]), array([ 6, 7,

8, 9, 10]), array([11,

12, 13, 14, 15])]

(5) 在NumPy中，数

组的维度也

被称作轴。现

在我们来熟

悉一下apply_along_axis函数

。

这个函数会

调用另外一

个由我们给

出的函数，作

用于每一个

数组元素上

。目前我们的

数组中有3

个

元素，分别对

应于示例数

据中的3个星

期，元素中的

索引值对应

于示例数据

中的1天。在调

用

apply_along_axis时提供我

们自定义的

函数名summarize，并指

定要作用的

轴或维度的

编号

（如取1）、目

标数组以及

可变数量的

summarize函数的参数

。

weeksummary =

np.apply_along_axis(summarize, 1, weeks_indices,open, high,

low, close) 

print

"Week summary", weeksummary

(6) 编写summarize函数。该

函数将为每

一周的数据

返回一个元

组，包含这一

周的开盘价

、

最高价、最低

价和收盘价

，类似于每天

的盘后数据

。

def summarize(a, o, h,

l, c):

monday_open = o[a[0]]

week_high = np.max( np.take(h,

a) )

week_low = np.min( np.take(l,

a) ) 

图灵社区会

员

heruihong 专享 尊重

版权

50

第 3 章 常

用函数

friday_close = c[a[-1]]

return("APPL", monday_open, week_high, week_low,

friday_close) 

注意

，我们用take函数

来根据索引

值获取数组

元素的值，并

用max和min函数轻

松计算出一

周的最高股

价和最低股

价。一周的开

盘价即为周

一的开盘价

，而一周的收

盘价即为周

五的收盘价

。

Week

summary [['APPL' '335.8' '346.7'

'334.3' '346.5']

['APPL' '347.89' '360.0' '347.64'

'356.85'] 

 ['APPL'

'356.79' '364.9' '349.52' '350.56']]

(7) 使用NumPy中的savetxt函

数，将数据保

存至文件。 

np.savetxt("weeksummary.csv",

weeksummary, delimiter=",", fmt="%s")

如

代码中所示

，我们指定了

文件名、需要

保存的数组

名、分隔符（在

这个例子中

为英文标点

逗号）以及存

储浮点数的

格式。

格式字

符串以一个

百分号开始

。接下来是一

个可选的标

志字符：-表示

结果左对齐

，0表示

左端补

0，+表示输出符

号（正号+或负

号-）。第三部分

为可选的输

出宽度参数

，表示输出的

最小

位数。第

四部分是精

度格式符，以

"."开头，后面跟

一个表示精

度的整数。最

后是一个类

型指定字

符

，在我们的例

子中指定为

字符串类型

。

字符编码 含

义

c

单个字符

d或i 十进制有

符号整数

e或

E 科学记数法

表示的浮点

数

f 浮点数

g或

G 自动在e、E和f中

选择合适的

表示法

o 八进

制有符号整

数

s 字符串

u 十

进制无符号

整数

x或X 十六

进制无符号

整数

用你喜

欢的文本编

辑器打开刚

刚生成的文

件，或在命令

行中输入如

下命令：

cat weeksummary.csv

APPL,335.8,346.7,334.3,346.5 

APPL,347.89,360.0,347.64,356.85

APPL,356.79,364.9,349.52,350.56 

刚才

做了些什么

我们刚刚完

成的事情在

其他编程语

言中几乎是

无法完成的

。我们定义了

一个函数

summarize，把

它作为参数

传给了apply_along_axis函数

，而summarize的参数也

通过

图灵社

区会员 heruihong 专享

尊重版权

3.16

动

手实践：汇总

数据 51 

1

2 

3

4

5 

11

6

7 

8

9 

10

apply_along_axis的参数

列表便捷地

传递了过去

。示例代码见

weeksummary.py文件。

import numpy as

np 

from datetime

import datetime 

#

星期一

0 

# 星期二

1 

# 星期

三

2 

# 星期四

3 

# 星

期五

4 

# 星期六

5

# 星期日 6

def datestr2num(s):

return datetime.strptime(s, "%d-%m-%Y").date().weekday()

dates, open, high, low,

close=np.loadtxt('data.csv', delimiter=',', usecols=(1, 3,

4, 

5, 6),

converters={1: datestr2num}, unpack=True)

close = close[:16]

dates = dates[:16]

# get first Monday

first_monday = np.ravel(np.where(dates ==

0))[0] 

print "The

first Monday index is",

first_monday 

# get

last Friday 

last_friday

= np.ravel(np.where(dates == 4))[-1]

print "The last Friday

index is", last_friday

weeks_indices = np.arange(first_monday, last_friday

+ 1) 

print

"Weeks indices initial", weeks_indices

weeks_indices = np.split(weeks_indices, 3)

print "Weeks indices after

split", weeks_indices 

def

summarize(a, o, h, l,

c): 

 monday_open

= o[a[0]]

week_high = np.max( np.take(h,

a) )

week_low = np.min( np.take(l,

a) )

friday_close = c[a[-1]]

return("APPL", monday_open, week_high, week_low,

friday_close) 

weeksummary =

np.apply_along_axis(summarize, 1, weeks_indices, open,

high, low, close)

print "Week summary", weeksummary

np.savetxt("weeksummary.csv", weeksummary, delimiter=",", fmt="%s")

勇敢

出发：优化代

码

改进代码

，使其能够处

理节假日休

市的情况。对

代码进行性

能分析，考察

apply_along_ 

axis函数的使用

能带来多少

速度上的提

升。

图灵社区

会员 heruihong 专享 尊

重版权

52 第 3 章

常用函数

3.17 真

实波动幅度

均值（ATR）

ATR（Average True

Range，真实波

动幅度均值

）是一个用来

衡量股价波

动性的技术

指标。

ATR的计算

并不是重点

，只是作为演

示几个NumPy函数

的例子，包括

maximum函数。

3.18 动手实

践：计算真实

波动幅度均

值

按照如下

步骤计算真

实波动幅度

均值。

(1) ATR是基于

N个交易日的

最高价和最

低价进行计

算的，通常取

最近20个交易

日。

N = int(sys.argv[1])

h = h[-N:]

l = l[-N:]

(2) 我们还需

要知道前一

个交易日的

收盘价。 

previousclose

= c[-N -1: -1]

对于

每一个交易

日，计算以下

各项。

 h –

l 当日股

价范围，即当

日最高价和

最低价之差

。

 h

– previousclose 当日最高价

和前一个交

易日收盘价

之差。



previousclose – l 前一个

交易日收盘

价和当日最

低价之差。

(3) max函

数返回数组

中的最大值

。基于上面计

算的3个数值

，我们来计算

所谓的真实

波动幅

度，也

就是这三者

的最大值。现

在我们想在

一组数组之

间按照元素

挑选最大值

——也就是在所

有

的数组中

第一个元素

的最大值、第

二个元素的

最大值等。为

此，需要用NumPy中

的maximum函数，

而不

是max函数。

truerange = np.maximum(h

- l, h -

previousclose, previousclose - l)

(4) 创建

一个长度为

N的数组atr，并初

始化数组元

素为0。 

atr

= np.zeros(N) 

(5)

这个数

组的首个元

素就是truerange数组

元素的平均

值。

atr[0] = np.mean(truerange)

用如下公

式计算其他

元素的值：

图

灵社区会员

heruihong 专享 尊重版

权

3.18 动手实践

：计算真实波

动幅度均值

53 

1

2 

3

4

5 

11

6

7 

8

9 

10

这里，PATR表示前

一个交易日

的ATR值，TR即当日

的真实波动

幅度。

for i in

range(1, N):

atr[i] = (N -

1) * atr[i -

1] + truerange[i]

atr[i] /= N

刚才做

了些什么

我

们生成了3个

数组，分别表

示3种范围——当

日股价范围

，当日最高价

和前一个交

易日收盘

价

之差，以及前

一个交易日

收盘价和当

日最低价之

差。这告诉我

们股价波动

的范围，也就

是波动

性的

大小。ATR的算法

要求我们找

出三者的最

大值。而之前

使用的max函数

只能给出一

个数组内

的

最大元素值

，并非这里所

需要的。我们

要在一组数

组之间挑选

每一个元素

位置上的最

大值，也

就是

在所有的数

组中第一个

元素的最大

值、第二个元

素的最大值

等。在这一节

的“动手实践

”教

程中，我们

了解到maximum函数

可以做到这

一点。最终，我

们根据每一

天的真实波

动幅度值计

算

出一个移

动平均值。示

例代码见atr.py文

件。

import numpy as np

import sys 

h,

l, c = np.loadtxt('data.csv',

delimiter=',', usecols=(4, 5, 6),

unpack=True) 

N =

int(sys.argv[1]) 

h =

h[-N:] 

l =

l[-N:] 

print "len(h)",

len(h), "len(l)", len(l)

print "Close", c

previousclose = c[-N -1:

-1] 

print "len(previousclose)",

len(previousclose) 

print "Previous

close", previousclose 

truerange

= np.maximum(h - l,

h - previousclose, previousclose

- l) 

print

"True range", truerange

atr = np.zeros(N)

atr[0] = np.mean(truerange)

for i in range(1,

N): 

 atr[i]

= (N - 1)

* atr[i - 1]

+ truerange[i]

atr[i] /= N

print "ATR", atr

在随后的

教程中，我们

将学习更好

的计算移动

平均值的方

法。

图灵社区

会员 heruihong 专享

尊

重版权

54 第 3

章

常用函数

勇

敢出发：尝试

minimum函数

除了maximum函

数，NumPy中还有一

个minimum函数。你可

能已经猜到

了这个函数

的功能。

请创

建一小段脚

本或在IPython中创

建一个会话

，以证明你的

猜想。

3.19 简单移

动平均线

简

单移动平均

线（simple moving

average）通常用于

分析时间序

列上的数据

。为了计算它

，

我们需要定

义一个N个周

期的移动窗

口，在我们的

例子中即N个

交易日。我们

按照时间序

列滑动

这个

窗口，并计算

窗口内数据

的均值。

3.20

动手

实践：计算简

单移动平均

线

移动平均

线只需要少

量的循环和

均值函数即

可计算得出

，但使用NumPy还有

更优的选

择

——convolve函数。简单移

动平均线只

不过是计算

与等权重的

指示函数的

卷积，当然，也

可

以是不等

权重的。

卷积

是分析数学

中一种重要

的运算，定义

为一个函数

与经过翻转

和平移的另

一个函数的

乘积的积分

。

按照如下步

骤计算简单

移动平均线

。

(1) 使用ones函数创

建一个长度

为N的元素均

初始化为1的

数组，然后对

整个数组除

以N，即

可得到

权重。如下所

示： 

N =

int(sys.argv[1]) 

weights =

np.ones(N) / N

print "Weights", weights

在N = 5时，输出

结果如下：

Weights [ 0.2 0.2

0.2 0.2 0.2]

(2) 使

用这些权重

值，调用convolve函数

： 

c

= np.loadtxt('data.csv', delimiter=',', usecols=(6,),

unpack=True) 

sma =

np.convolve(weights, c)[N-1:-N+1] 

(3)

我们从convolve函数

返回的数组

中，取出中间

的长度为N的

部分①。下面的

代码将创建

一个存储时

间值的数组

，并使用Matplotlib进行

绘图。我们会

在后续章节

学习这个绘

图库。

—————————— 

①

即两者

做卷积运算

时完全重叠

的区域。——译者

注

图灵社区

会员 heruihong 专享

尊

重版权

3.20 动手

实践：计算简

单移动平均

线 55

1 

2

3 

4

5

11 

6

7

8 

9

10 

c =

np.loadtxt('data.csv', delimiter=',', usecols=(6,), unpack=True)

sma = np.convolve(weights, c)[N-1:-N+1]

t = np.arange(N -

1, len(c)) 

plot(t,

c[N-1:], lw=1.0) 

plot(t,

sma, lw=2.0) 

show()

在下图中

，相对较平滑

的粗线描绘

的是5日移动

平均线，而锯

齿状的细线

描绘的是每

天的收

盘价

。 

刚才做了些

什么

我们计

算出了收盘

价数据的简

单移动平均

线。是的，你掌

握了很重要

的知识，那就

是简单移

动

平均线可以

用信号处理

技术求解——与

1/N的权重进行

卷积运算，N为

移动平均窗

口的大小。我

们还学习了

ones函数的用法

，即可以创建

元素均为1的

数组，以及convolve函

数，计算一组

数

据与指定

权重的卷积

。示例代码见

sma.py文件。

import

numpy as np

import sys 

from

matplotlib.pyplot import plot

from matplotlib.pyplot import show

N = int(sys.argv[1])

weights = np.ones(N) /

N 

print "Weights",

weights 

c =

np.loadtxt('data.csv', delimiter=',', usecols=(6,), unpack=True)

sma = np.convolve(weights, c)[N-1:-N+1]

图灵社

区会员 heruihong 专享

尊重版权

56

第

3 章 常用函数

t =

np.arange(N - 1, len(c))

plot(t, c[N-1:], lw=1.0)

plot(t, sma, lw=2.0)

show() 

3.21 指数移动平

均线

除了简

单移动平均

线，指数移动

平均线（exponential moving average）也是

一种流行的

技术

指标。指

数移动平均

线使用的权

重是指数衰

减的。对历史

上的数据点

赋予的权重

以指数速度

减小，

但永远

不会到达0。我

们将在计算

权重的过程

中学习exp和linspace函

数。

3.22 动手实践

：计算指数移

动平均线

给

定一个数组

，exp函数可以计

算出每个数

组元素的指

数。例如，看下

面的代码：

x = np.arange(5)

print "Exp", np.exp(x)

输

出结果如下

： 

Exp [

1. 2.71828183 7.3890561 20.08553692

54.59815003] 

linspace函数需要一

个起始值和

一个终止值

参数，以及可

选的元素个

数的参数，它

将返回

一个

元素值在指

定的范围内

均匀分布的

数组。如下所

示：

print "Linspace", np.linspace(-1, 0,

5) 

输出结果

如下：

Linspace [-1. -0.75 -0.5

-0.25 0. ]

下面我

们来对示例

数据计算指

数移动平均

线。

(1) 还是回到

权重的计算

——这次使用exp和

linspace函数。

N

= int(sys.argv[1]) 

weights

= np.exp(np.linspace(-1. , 0.

, N)) 

(2)

对权重

值做归一化

处理。我们将

用到ndarray对象的

sum方法。

weights /= weights.sum()

print "Weights", weights

在N = 5时，我

们得到的权

重值如下：

Weights [ 0.11405072 0.14644403

0.18803785 0.24144538 0.31002201]

图

灵社区会员

heruihong 专享 尊重版

权

3.22

动手实践

：计算指数移

动平均线 57 

1

2 

3

4

5 

11

6

7 

8

9 

10

(3) 接

下来就很容

易了，我们只

需要使用在

简单移动平

均线一节中

学习到的convolve函

数即

可。同样

，我们还是将

结果绘制出

来。

c

= np.loadtxt('data.csv', delimiter=',', usecols=(6,),

unpack=True) 

ema =

np.convolve(weights, c)[N-1:-N+1] 

t

= np.arange(N - 1,

len(c)) 

plot(t, c[N-1:],

lw=1.0) 

plot(t, ema,

lw=2.0) 

show()

我们再次

得到了曼妙

的折线图。与

之前一样，相

对比较平滑

的粗线描绘

的是指数移

动平均线，

而

锯齿状的细

线描绘的是

每天的收盘

价。 

刚才做了

些什么

我们

对收盘价数

据计算了指

数移动平均

线。首先，我们

使用exp和linspace函数

计算出指

数

衰减的权重

值。linspace函数返回

的是一个元

素值均匀分

布的数组，随

后我们计算

出它们的

指

数。为了将这

些权重值归

一化，我们调

用了ndarray对象的

sum方法。最后，我

们再次应用

了

在前面简

单移动平均

线一节中学

习到的convolve函数

，最终计算出

指数移动平

均线。示例代

码

见ema.py文件。

import numpy as

np 

import sys

from matplotlib.pyplot import plot

from matplotlib.pyplot import show

x = np.arange(5)

print "Exp", np.exp(x)

图

灵社区会员

heruihong 专享 尊重版

权

58

第 3 章 常用

函数

print "Linspace", np.linspace(-1, 0,

5) 

N =

int(sys.argv[1]) 

weights =

np.exp(np.linspace(-1., 0., N))

weights /= weights.sum()

print "Weights", weights

c = np.loadtxt('data.csv', delimiter=',',

usecols=(6,), unpack=True) 

ema

= np.convolve(weights, c)[N-1:-N+1]

t = np.arange(N -

1, len(c)) 

plot(t,

c[N-1:], lw=1.0) 

plot(t,

ema, lw=2.0) 

show()

3.23 布林带

布林带（Bollinger band）又是

一种技术指

标。是的，股票

市场的确有

成千上万种

技术指标。

布

林带是以发

明者约翰·布

林格（John

Bollinger）的名字

命名的，用以

刻画价格波

动的区间。布

林带的基本

型态是由三

条轨道线组

成的带状通

道（中轨和上

、下轨各一条

）。

 中轨 简单移

动平均线。

 上

轨 比简单移

动平均线高

两倍标准差

的距离。这里

的标准差是

指计算简单

移动平均线

所用数据的

标准差。



下轨

比简单移动

平均线低两

倍标准差的

距离。

3.24 动手实

践：绘制布林

带

我们已经

掌握了计算

简单移动平

均线的方法

。如有需要，请

复习3.20节“动手

实践：计算简

单移动平均

线”的内容。接

下来的例子

将介绍NumPy中的

fill函数。fill函数可

以将数组元

素

的值全部

设置为一个

指定的标量

值，它的执行

速度比使用

array.flat = scalar或者用循环

遍

历数组赋

值的方法更

快。按照如下

步骤绘制布

林带。

(1) 我们已

经有一个名

为sma的数组，包

含了简单移

动平均线的

数据。因此，我

们首先要遍

历和这些值

有关的数据

子集。数据子

集构建完成

后，计算其标

准差。注意，从

某种意义上

来说，

我们必

须去计算每

一个数据点

与相应平均

值之间的差

值。如果不使

用NumPy，我们只能

遍历所有

的

数据点并逐

一减去相应

的平均值。幸

运的是，NumPy中的

fill函数可以构

建元素值完

全相同

的数

组。这可以让

我们省去一

层循环，当然

也就省去了

这个循环内

作差的步骤

。 

deviation =

[] 

C =

len(c) 

for i

in range(N - 1,

C): 

图灵社区会

员 heruihong

专享 尊重

版权

3.24 动手实

践：绘制布林

带

59 

1

2 

3

4

5 

11

6

7 

8

9 

10

if i + N

< C:

dev = c[i: i

+ N]

else: 

 dev

= c[-N:]

averages = np.zeros(N)

averages.fill(sma[i - N -

1]) 

 dev

= dev - averages

dev = dev

** 2

dev = np.sqrt(np.mean(dev))

deviation.append(dev) 

deviation =

2 * np.array(deviation)

upperBB = sma +

deviation 

lowerBB =

sma - deviation

(2) 使用如下

代码绘制布

林带（不必担

心，我们将在

第9章中学习

绘图方面的

知识）： 

t

= numpy.arange(N - 1,

C) 

plot(t, c_slice,

lw=1.0) 

plot(t, sma,

lw=2.0) 

plot(t, upperBB,

lw=3.0) 

plot(t, lowerBB,

lw=4.0) 

show()

下图是

用我们的示

例数据绘制

出来的布林

带。中间锯齿

状的细线描

绘的是每天

的收盘价，而

稍微粗一点

也平滑一点

的穿过它的

曲线即为简

单移动平均

线。 

刚才做了

些什么

我们

在示例数据

上计算得到

了布林带。更

重要的是，我

们还了解了

NumPy中fill函数的用

图灵社区会

员

heruihong 专享 尊重

版权

60

第 3 章 常

用函数

法。该

函数可以用

一个指定的

标量值填充

数组，而这个

标量值也是

fill函数唯一的

参数。示例

代

码见bollingerbands.py文件。

import numpy

as np 

import

sys 

from matplotlib.pyplot

import plot 

from

matplotlib.pyplot import show

N = int(sys.argv[1])

weights = np.ones(N) /

N 

print "Weights",

weights 

c =

np.loadtxt('data.csv', delimiter=',', usecols=(6,), unpack=True)

sma = np.convolve(weights, c)[N-1:-N+1]

deviation = []

C = len(c)

for i in range(N

- 1, C):

if i + N

< C:

dev = c[i: i

+ N]

else: 

 dev

= c[-N:]

averages = np.zeros(N)

averages.fill(sma[i - N -

1]) 

 dev

= dev - averages

dev = dev

** 2

dev = np.sqrt(np.mean(dev))

deviation.append(dev) 

deviation =

2 * np.array(deviation)

print len(deviation), len(sma)

upperBB = sma +

deviation 

lowerBB =

sma - deviation

c_slice = c[N-1:]

between_bands = np.where((c_slice <

upperBB) & (c_slice >

lowerBB)) 

print lowerBB[between_bands]

print c[between_bands] 

print

upperBB[between_bands] 

between_bands =

len(np.ravel(between_bands)) 

print "Ratio

between bands", float(between_bands)/len(c_slice)

t = np.arange(N -

1, C) 

plot(t,

c_slice, lw=1.0) 

plot(t,

sma, lw=2.0) 

plot(t,

upperBB, lw=3.0) 

plot(t,

lowerBB, lw=4.0) 

show()

图

灵社区会员

heruihong 专享 尊重版

权

3.26

动手实践

：用线性模型

预测价格 61 

1

2 

3

4

5 

11

6

7 

8

9 

10

勇

敢出发：转换

为指数移动

平均线

人们

通常将简单

移动平均线

作为布林带

的中轨线。而

以指数移动

平均线作为

中轨线也是

一

种流行的

做法，因此我

们将它留作

练习。如果需

要提示，你可

以在本章中

找到合适的

示例。

验证一

下fill函数的执

行速度是否

真的比使用

array.flat

= scalar或者用循环

遍历

数组赋

值的方法更

快。

3.25

线性模型

许多科学研

究中都会用

到线性关系

的模型。NumPy的linalg包

是专门用于

线性代数计

算的。

下面的

工作基于一

个假设，就是

一个价格可

以根据N个之

前的价格利

用线性模型

计算得出。

3.26 动

手实践：用线

性模型预测

价格

我们姑

且假设，一个

股价可以用

之前股价的

线性组合表

示出来，也就

是说，这个股

价等于之

前

的股价与各

自的系数相

乘后再做加

和的结果，这

些系数是需

要我们来确

定的。用线性

代数的术

语

来讲，这就是

解一个最小

二乘法的问

题。步骤如下

。

(1)

首先，获取一

个包含N个股

价的向量b。 

b =

c[-N:] 

b =

b[::-1] 

print "b",

b 

输

出结果如下

：

b

[ 351.99 346.67 352.47

355.76 355.36] 

(2)

第二步，初始

化一个N×N的二

维数组A，元素

全部为0。 

A =

np.zeros((N, N), float)

print "Zeros N by

N", A 

Zeros

N by N [[

0. 0. 0. 0.

0.] 

 [

0. 0. 0. 0.

0.] 

 [

0. 0. 0. 0.

0.] 

 [

0. 0. 0. 0.

0.] 

 [

0. 0. 0. 0.

0.]] 

(3) 第三

步，用b向量中

的N个股价值

填充数组A。

for i in range(N):

A[i, ] =

c[-N - 1 -

i: - 1 -

i] 

print "A",

A 

图

灵社区会员

heruihong 专享

尊重版

权

62 第 3

章 常用

函数

现在，数

组A变成了这

样：

A [[ 360. 355.36

355.76 352.47 346.67]

[ 359.56 360. 355.36

355.76 352.47]

[ 352.12 359.56 360.

355.36 355.76]

[ 349.31 352.12 359.56

360. 355.36]

[ 353.21 349.31 352.12

359.56 360. ]]

(4) 我们的目

标是确定线

性模型中的

那些系数，以

解决最小平

方和的问题

。我们使用linalg

包

中的lstsq函数来

完成这个任

务。

(x, residuals, rank, s)

= np.linalg.lstsq(A, b)

print x, residuals, rank,

s 

输出结果

如下：

[ 0.78111069 -1.44411737 1.63563225

-0.89905126 0.92009049] 

[]

5 [ 1.77736601e+03 1.49622969e+01

8.75528492e+00 5.15099261e+00 1.75199608e+00]

返回的

元组中包含

稍后要用到

的系数向量

x、一个残差数

组、A的秩以及

A的奇异值。

(5) 一

旦得到了线

性模型中的

系数，我们就

可以预测下

一次的股价

了。使用NumPy中的

dot

函数计算系

数向量与最

近N个价格构

成的向量的

点积（dot

product）。

print numpy.dot(b, x)

这个点

积就是向量

b中那些价格

的线性组合

，系数由向量

x提供。我们得

到如下结果

： 

357.939161015

我查了一下

记录，下一个

交易日实际

的收盘价为

353.56。因此，我们用

N = 5做出的预测

结果

并没有

差得很远。

刚

才做了些什

么

我们预测

了明天的股

价。如果这真

的有效，我们

就可以提早

退休了！你看

，买这本书是

多么

正确的

投资！我们为

股价预测建

立了一个线

性模型，于是

这个金融问

题就变成了

一个线性代

数问

题。NumPy中的

linalg包里有一个

lstsq函数，帮助我

们求出了问

题的解——即估

计线性模型

中的系数。在

得到解之后

，我们将系数

应用于NumPy中的

dot函数，通过线

性回归的方

法预测了

下

一次的股价

。示例代码见

linearmodel.py文件。

import numpy as

np 

import sys

N = int(sys.argv[1])

c = np.loadtxt('data.csv', delimiter=',',

usecols=(6,), unpack=True) 

图灵社

区会员

heruihong 专享

尊重版权

3.28 动

手实践：绘制

趋势线

63 

1

2 

3

4

5 

11

6

7 

8

9 

10

b = c[-N:]

b = b[::-1]

print "b", b

A = np.zeros((N, N),

float) 

print "Zeros

N by N", A

for i in range(N):

A[i, ] =

c[-N - 1 -

i: - 1 -

i] 

print "A",

A 

(x, residuals,

rank, s) = np.linalg.lstsq(A,

b) 

print x,

residuals, rank, s

print np.dot(b, x)

3.27 趋势

线

趋势线，是

根据股价走

势图上很多

所谓的枢轴

点绘成的曲

线。顾名思义

，趋势线描绘

的是价

格变

化的趋势。过

去的股民们

在纸上用手

绘制趋势线

，而现在我们

可以让计算

机来帮助我

们作图。

在这

一节的教程

中，我们将用

非常简易的

方法来绘制

趋势线，可能

在实际生活

中不是很奏

效，但

这应该

能将趋势线

的原理阐述

清楚。

3.28 动手实

践：绘制趋势

线

按照如下

步骤绘制趋

势线。

(1) 首先，我

们需要确定

枢轴点的位

置。这里，我们

假设它们等

于最高价、最

低价和收盘

价

的算术平

均值。

h, l, c =

np.loadtxt('data.csv', delimiter=',', usecols=(4, 5,

6), unpack=True) 

pivots

= (h + l

+ c ) /

3 

print "Pivots",

pivots 

从这些

枢轴点出发

，我们可以推

导出所谓的

阻力位和支

撑位。阻力位

是指股价上

升时遇到阻

力，在转跌前

的最高价格

；支撑位是指

股价下跌时

遇到支撑，在

反弹前的最

低价格。需要

提醒的

是，阻

力位和支撑

位并非客观

存在，它们只

是一个估计

量。基于这些

估计量，我们

就可以绘制

出

阻力位和

支撑位的趋

势线。我们定

义当日股价

区间为最高

价与最低价

之差。

(2) 定义一

个函数用直

线y= at

+ b来拟合数

据，该函数应

返回系数a和

b。这里需要再

次用

到linalg包中

的lstsq函数。将直

线方程重写

为y =

Ax的形式，其

中A = [t 1]，x

= [a b]。

使用ones_like和vstack函

数来构造数

组A。

图灵社区

会员 heruihong 专享 尊

重版权

64 第 3 章

常用函数

def fit_line(t, y):

A = np.vstack([t, np.ones_like(t)]).T

return np.linalg.lstsq(A, y)[0]

(3) 假

设支撑位在

枢轴点下方

一个当日股

价区间的位

置，而阻力位

在枢轴点上

方一个当日

股

价区间的

位置，据此拟

合支撑位和

阻力位的趋

势线。

t = np.arange(len(c))

sa, sb = fit_line(t,

pivots - (h -

l)) 

ra, rb

= fit_line(t, pivots +

(h - l))

support = sa *

t + sb

resistance = ra *

t + rb

(4) 到这里

我们已经获

得了绘制趋

势线所需要

的全部数据

。但是，我们最

好检查一下

有多少

个数

据点落在支

撑位和阻力

位之间。显然

，如果只有一

小部分数据

在这两条趋

势线之间，这

样的

设定就

没有意义。设

置一个判断

数据点是否

位于趋势线

之间的条件

，作为where函数的

参数。

condition = (c >

support) & (c <

resistance) 

print "Condition",

condition 

between_bands =

np.where(condition) 

以下是

根据条件判

断的布尔值

：

Condition [False False True

True True True True

False False True False

False 

 False

False False True False

False False True True

True True False False

True True 

True

False True] 

复查一下具

体取值：

print support[between_bands] 

print

c[between_bands] 

print resistance[between_bands]

注意

，where函数返回的

是一个秩为

2的数组，因此

在使用len函数

之前需要调

用ravel函数。 

between_bands =

len(np.ravel(between_bands)) 

print "Number

points between bands", between_bands

print "Ratio between bands",

float(between_bands)/len(c) 

你将

得到如下结

果：

Number points between bands

15 

Ratio between

bands 0.5 

我们还得

到了一个额

外的奖励：一

个新的预测

模型。我们可

以用这个模

型来预测下

一个交易

日

的阻力位和

支撑位。 

print "Tomorrows

support", sa * (t[-1]

+ 1) + sb

print "Tomorrows resistance", ra

* (t[-1] + 1)

+ rb 

输出

结果如下：

Tomorrows support 349.389157088

图

灵社区会员

heruihong 专享 尊重版

权

3.28

动手实践

：绘制趋势线

65 

1

2 

3

4

5 

11

6

7 

8

9 

10

Tomorrows resistance 360.749340996

此外，还有另

外一种计算

支撑位和阻

力位之间数

据点个数的

方法：使用[]和

intersect1d

函数。在[]操作

符里面定义

选取条件，然

后用intersect1d函数计

算两者相交

的结果。

a1 =

c[c > support]

a2 = c[c <

resistance] 

print "Number

of points between bands

2nd approach" ,len(np. intersect1d(a1,

a2)) 

如我

们所料，得到

的结果如下

：

Number of points between

bands 2nd approach 15

(5) 我们再次将

结果绘制出

来，如下所示

： 

plot(t,

c) 

plot(t, support)

plot(t, resistance) 

show()

绘制结果如

下图所示，其

中包含了股

价数据以及

对应的支撑

位和阻力位

。

刚才做了些

什么

我们用

NumPy画出了趋势

线，省去了用

尺、铅笔和绘

图纸的麻烦

。我们定义了

一个用直线

拟

合数据的

函数，其中用

到NumPy中的vstack、ones_like和lstsq函

数。拟合数据

是为了得到

支撑位和阻

力位两条趋

势线的方程

。随后，我们用

两种不同的

方法分别计

算了有多少

个数据点落

在支撑位和

阻力位之间

的范围内，并

得到了一致

的结果。

图灵

社区会员 heruihong 专

享 尊重版权

66

第 3 章 常用函

数

第一种方

法使用where函数

和一个条件

表达式。第二

种方法使用

[]操作符和intersect1d函

数。intersect1d函数返回

一个由两个

数组的所有

公共元素构

成的数组。示

例代码见trendline.py

文

件。

import numpy

as np 

from

matplotlib.pyplot import plot

from matplotlib.pyplot import show

def fit_line(t, y):

A = np.vstack([t, np.ones_like(t)]).T

return np.linalg.lstsq(A, y)[0]

h, l, c =

np.loadtxt('data.csv', delimiter=',' , usecols=(4,

5, 6), unpack=True)

pivots = (h +

l + c )

/ 3 

print

"Pivots", pivots 

t

= np.arange(len(c)) 

sa,

sb = fit_line(t, pivots

- (h - l))

ra, rb = fit_line(t,

pivots + (h -

l)) 

support =

sa * t +

sb 

resistance =

ra * t +

rb 

condition =

(c > support) &

(c < resistance)

print "Condition", condition

between_bands = np.where(condition)

print support[between_bands] 

print

c[between_bands] 

print resistance[between_bands]

between_bands = len(np.ravel(between_bands))

print "Number points between

bands", between_bands 

print

"Ratio between bands", float(between_bands)/len(c)

print "Tomorrows support", sa

* (t[-1] + 1)

+ sb 

print

"Tomorrows resistance", ra *

(t[-1] + 1) +

rb 

a1 =

c[c > support]

a2 = c[c <

resistance] 

print "Number

of points between bands

2nd approach" ,len(np. intersect1d(a1,

a2)) 

plot(t, c)

plot(t, support) 

plot(t,

resistance) 

show()

3.29 ndarray 对象的方

法

NumPy中的ndarray类定

义了许多方

法，可以在数

组对象上直

接调用。通常

情况下，这些

方

法会返回

一个数组。你

可能已经注

意到了，很多

NumPy函数都有对

应的相同的

名字和功能

的

ndarray对象。这主

要是由NumPy发展

过程中的历

史原因造成

的。

图灵社区

会员 heruihong

专享 尊

重版权

3.32 动手

实践：计算阶

乘

67 

1

2 

3

4

5 

11

6

7 

8

9 

10

ndarray对象的方

法相当多，我

们无法在这

里逐一介绍

。前面遇到的

var、sum、std、argmax、

argmin以及mean函数也

均为ndarray方法。

数

组的修剪和

压缩请参见

下一节中的

内容。

3.30

动手实

践：数组的修

剪和压缩

这

里给出少量

使用ndarray方法的

例子。按如下

步骤对数组

进行修剪和

压缩操作。

(1) clip方

法返回一个

修剪过的数

组，也就是将

所有比给定

最大值还大

的元素全部

设为给定

的

最大值，而所

有比给定最

小值还小的

元素全部设

为给定的最

小值。例如，设

定范围1到2对

0到4

的整数数

组进行修剪

：

a =

np.arange(5) 

print "a

=", a 

print

"Clipped", a.clip(1, 2)

输出结果如

下： 

a =

[0 1 2 3

4] 

Clipped [1

1 2 2 2]

(2) compress方法返回

一个根据给

定条件筛选

后的数组。例

如： 

a

= np.arange(4) 

print

a 

print "Compressed",

a.compress(a > 2)

输出结果

如下： 

[0 1

2 3] 

Compressed

[3] 

刚才做

了些什么

我

们创建了一

个0到3的整数

数组a，然后调

用compress方法并指

定条件a

> 2，从而

获取到

了该

数组中的最

后一个元素

3。

3.31

阶乘

许多程

序设计类的

书籍都会给

出计算阶乘

的例子，我们

应该保持这

个传统。

3.32 动手

实践：计算阶

乘

ndarray类有一个

prod方法，可以计

算数组中所

有元素的乘

积。按如下步

骤计算阶乘

。

图灵社区会

员 heruihong 专享

尊重

版权

68 第 3

章 常

用函数

(1) 计算

8的阶乘。为此

，先生成一个

1~8的整数数组

，并调用prod方法

。

b = np.arange(1, 9)

print "b =", b

print "Factorial", b.prod()

你可以用计

算器检查一

下结果是否

正确：

b = [1

2 3 4 5

6 7 8]

Factorial 40320 

这很不

错，但如果我

们想知道1~8的

所有阶乘值

呢？

(2) 没问题！调

用cumprod方法，计算

数组元素的

累积乘积。

print "Factorials",

b.cumprod() 

再

次检查一下

结果吧：

Factorials

[ 1 2 6

24 120 720 5040

40320] 

刚才

做了些什么

我们使用prod和

cumprod方法计算了

阶乘。示例代

码见ndarraymethods.py文件。

import

numpy as np

a = np.arange(5)

print "a =", a

print "Clipped", a.clip(1, 2)

a = np.arange(4)

print a 

print

"Compressed", a.compress(a > 2)

b = np.arange(1, 9)

print "b =", b

print "Factorial", b.prod()

print "Factorials", b.cumprod()

3.33 本

章小结

本章

我们学习了

很多常用的

NumPy函数。我们用

loadtxt读文件，用savetxt写

文件，用

eye函数

创建单位矩

阵，用loadtxt函数从

一个CSV文件中

读取股价数

据。NumPy中的average

和mean函

数可以用来

计算数据的

加权平均数

和算术平均

数。

本章还提

到了一些常

用的统计函

数。首先，我们

使用min和max函数

来确定股价

的范围；然

图

灵社区会员

heruihong 专享

尊重版

权

3.33 本章小结

69

1 

2

3 

4

5

11 

6

7

8 

9

10 

后，用median函数获

取数据的中

位数；最后，用

std和var函数计算

数据的标准

差和方差。

diff函

数可以返回

数组中相邻

元素的差值

，因此我们用

它来计算股

票的简单收

益率。log

函数可

以计算数组

元素的自然

对数。

loadtxt函数默

认将所有数

据转换为浮

点数类型，它

有一个特定

的参数可以

完成转换。这

个

参数就是

converters，它是一个可

以将数据列

和所谓的转

换函数连接

起来的参数

。

我们自定义

了一个函数

并将其作为

参数传给了

apply_along_axis函数。我们实

现了一个

可

以在多个数

组间找出每

个位置上最

大元素的算

法。

我们了解

到ones函数可以

创建一个全

为1的数组，而

且convolve函数可以

根据指定的

权重

计算卷

积。

我们用exp和

linspace函数得到了

一组指数衰

减的权重值

。linspace可以给出一

个均匀分

布

的数组，然后

我们计算出

该数组元素

的指数。我们

还调用ndarray类的

sum方法对权重

值做归

一化

处理。

我们还

接触到了fill函

数，这个函数

可以用一个

指定的标量

值填充数组

，而这个标量

值也

是其唯

一的参数。

结

束了本章的

NumPy常用函数之

旅，我们将来

到NumPy便捷函数

的世界。下一

章将学习

polyfit、sign和

piecewise等NumPy函数。

图灵

社区会员 heruihong

专

享 尊重版权

70 第 4

章 便捷函

数

便捷函数

你可能已经

发现，NumPy中包含

大量的函数

。其实很多函

数的设计初

衷

都是为了

让你能更方

便地使用。了

解这些函数

，你可以大大

提升自己的

工作

效率。这

些函数包括

数组元素的

选取（例如，根

据某个条件

表达式）和多

项

式运算等

。计算股票收

益率相关性

的例子将让

你浅尝NumPy数据

分析。

本章涵

盖以下内容

：



数据选取；

 简

单数据分析

；



收益率相关

性；

 多项式；



线

性代数的计

算函数。

在前

一章中，我们

只用到了一

个数据文件

。本章将有重

要的改进——我

们同时用到

两个数据

文

件。让我们继

续前进，携手

NumPy一起探索数

据吧。

4.1

相关性

不知你是否

注意过这样

的现象：某公

司的股价被

另外一家公

司的股价紧

紧跟随，并且

它们通

常是

同领域的竞

争对手。对于

这种现象，理

论上的解释

是：因为这两

家公司经营

的业务类型

相同，

它们面

临同样的挑

战，需要相同

的原料和资

源，并且争夺

同类型的客

户。

你可能会

想到很多这

样的例子，但

还想检验一

下它们是否

真的存在关

联。一种方法

就是看看

两

个公司股票

收益率的相

关性，强相关

性意味着它

们之间存在

一定的关联

性。当然，这不

是严格

的证

明，特别是当

我们所用的

数据不够充

足时。

第4章

图

灵社区会员

heruihong

专享 尊重版

权

4.2 动手实践

：股票相关性

分析

71 

1

2 

3

4

5 

11

6

7 

8

9 

10

4.2 动手实

践：股票相关

性分析

在本

节的教程中

，我们将使用

2个示例数据

集提供收盘

价数据，其中

包含收盘价

的最小值。

第

一家公司是

BHP

Billiton（BHP），其主要业务

是石油、金属

和钻石的开

采。第二家公

司是Vale

（VALE），也是一

家金属开采

业的公司。因

此，这两家公

司有部分业

务是重合的

，尽管不是100%

相

同。按照如下

步骤分析它

们股票的相

关性。

(1)

首先，从

CSV文件（本章示

例代码文件

夹中）中读入

两只股票的

收盘价数据

，并计算收

益

率。如果你不

记得该怎样

做，在前一章

中有很多可

以参阅的例

子。

(2) 协方差描

述的是两个

变量共同变

化的趋势，其

实就是归一

化前的相关

系数。使用cov函

数计算股票

收益率的协

方差矩阵（并

非必须这样

做，但我们可

以据此展示

一些矩阵操

作的方法）。

covariance = np.cov(bhp_returns, vale_returns)

print "Covariance", covariance

得

到的协方差

矩阵如下： 

Covariance [[

0.00028179 0.00019766]

[ 0.00019766 0.00030123]]

(3) 使

用diagonal函数查看

对角线上的

元素： 

print

"Covariance diagonal", covariance.diagonal()

得到协

方差矩阵的

对角线元素

如下： 

Covariance diagonal

[ 0.00028179 0.00030123]

协方差

矩阵中对角

线上的元素

并不相等，这

与相关系数

矩阵是不同

的。

(4) 使用trace函数

计算矩阵的

迹，即对角线

上元素之和

：

print "Covariance trace", covariance.trace()

计算出协方

差矩阵的迹

如下： 

Covariance trace

0.00058302354992 

(5) 两个向

量的相关系

数被定义为

协方差除以

各自标准差

的乘积。计算

向量a和b的相

关系数

的公

式如下。 

图灵

社区会员 heruihong

专

享 尊重版权

72 第 4

章 便捷函

数

尝试一下

：

print covariance/ (bhp_returns.std() *

vale_returns.std()) 

得到的矩阵

如下：①

[[

1.00173366 0.70264666] 

[

0.70264666 1.0708476 ]]

(6) 我们将

用相关系数

来度量这两

只股票的相

关程度。相关

系数的取值

范围在-1到1之

间。

根据定义

，一组数值与

自身的相关

系数等于1。这

是严格线性

关系的理想

值，实际上如

果得到稍

小

一些的值，我

们仍然会很

高兴。使用corrcoef函

数计算相关

系数（或者更

精确地，相关

系数

矩阵）： 

print "Correlation

coefficient", np.corrcoef(bhp_returns, vale_returns)

得

到的相关系

数矩阵如下

： 

[[ 1.

0.67841747] 

[ 0.67841747

1. ]] 

对角线上的

元素即BHP和VALE与

自身的相关

系数，因此均

为1，很可能并

非真的经过

计算得

出。相

关系数矩阵

是关于对角

线对称的，因

此另外两个

元素的值相

等，表示BHP与VALE的

相关

系数等

于VALE和BHP的相关

系数。看起来

它们的相关

程度似乎不

是很强。

(7) 另外

一个要点是

判断两只股

票的价格走

势是否同步

。如果它们的

差值偏离了

平均差值2

倍

于标准差的

距离，则认为

这两只股票

走势不同步

。

若判断为不

同步，我们可

以进行股票

交易，等待它

们重新回到

同步的状态

。计算这两只

股票

收盘价

的差值，以判

断是否同步

：

difference = bhp -

vale 

检查最后一

次收盘价是

否在同步状

态，代码如下

：

—————————— 

① 本书作者将

该矩阵称为

相关系数矩

阵，译者保留

不同观点。我

们知道，相关

系数矩阵的

主对角线元

素为随机变

量

与自身的

相关系数，应

该等于1。因此

这一步得到

的矩阵并非

相关系数矩

阵，而下一步

中的才是。读

者可能有这

样的疑问，为

何这里按照

相关系数的

定义手动计

算出来的矩

阵并非相关

系数矩阵呢

？主要有两点

原因：(1) 分母

不

应为定值，而

要根据分子

上的协方差

计算对象确

定。以左上角

的元素为例

，由于其分子

为cov(a, a)，即随机

变

量a和其自身

的协方差，则

分母对应为

(bhp_returns.std() * bhp_returns.std())。其他位置的

元素计算

同

理。(2)

即使按照

这一步给出

的算式，副对

角线上的元

素也应该是

正确的相关

系数，但为何

与下一步中

的副对

角线

仍不一致呢

？这是由于NumPy在

计算协方差

时，自由度参

数默认为1，即

分母为N1而不

是N，从而求得

总体

协方差

的无偏估计

。而调用.std()计算

标准差时，自

由度参数默

认为0，从而求

得的是样本

标准差，而非

总体标

准差

的无偏估计

。因此，这一步

计算的副对

角线元素也

并非正确的

相关系数。译

者测试了作

者提供的源

代码，如

果在

调用.std()方法时

指定ddof=1，即自由

度设为1，就可

以得到与下

一步计算结

果相同的副

对角线元素

。如前

所述，若

分别计算各

个元素的分

母，即可得到

主对角线为

1、完全正确的

相关系数矩

阵。——译者注

图

灵社区会员

heruihong 专享

尊重版

权

4.2 动手实践

：股票相关性

分析 73

1 

2

3 

4

5

11 

6

7

8 

9

10 

avg =

np.mean(difference) 

dev =

np.std(difference) 

print "Out

of sync", np.abs(difference[-1] -

avg) > 2 *

dev 

遗憾的

是，我们暂时

不能进行交

易：

Out of sync False

(8) 绘图需要

Matplotlib库，我们将在

第9章中详细

讲解。使用如

下代码进行

绘图： 

t

= np.arange(len(bhp_returns)) 

plot(t,

bhp_returns, lw=1) 

plot(t,

vale_returns, lw=2) 

show()

结果如

下。

刚才做了

些什么

我们

分析了两只

股票BHP和VALE收盘

价的相关性

。更准确地说

，我们计算了

其收益率的

相

关系数。这

可以用corrcoef函数

来计算。我们

还了解了协

方差矩阵的

计算过程，并

可以据此计

算相关系数

。我们也因此

展示了diagonal函数

和trace函数的用

法，分别可以

给出矩阵的

对角

线元素

和矩阵的迹

。示例代码见

correlation.py文件。 

import numpy

as np 

from

matplotlib.pyplot import plot

from matplotlib.pyplot import show

bhp = np.loadtxt('BHP.csv', delimiter=',',

usecols=(6,), unpack=True) 

图灵社

区会员

heruihong 专享

尊重版权

74 第

4

章 便捷函数

bhp_returns = np.diff(bhp)

/ bhp[ : -1]

vale = np.loadtxt('VALE.csv', delimiter=',',

usecols=(6,), unpack=True) 

vale_returns

= np.diff(vale) / vale[

: -1] 

covariance

= np.cov(bhp_returns, vale_returns)

print "Covariance", covariance

print "Covariance diagonal", covariance.diagonal()

print "Covariance trace", covariance.trace()

print covariance/ (bhp_returns.std() *

vale_returns.std()) 

print "Correlation

coefficient", np.corrcoef(bhp_returns, vale_ returns)

difference = bhp -

vale 

avg =

np.mean(difference) 

dev =

np.std(difference) 

print "Out

of sync", np.abs(difference[-1] -

avg) > 2 *

dev 

t =

np.arange(len(bhp_returns)) 

plot(t, bhp_returns,

lw=1) 

plot(t, vale_returns,

lw=2) 

show()

突击测验：计

算协方差

问

题1 以下哪个

函数返回的

是两个数组

的协方差？

(1)

covariance

(2) covar

(3)

cov

(4) cvar

4.3

多

项式

你喜欢

微积分吗？我

非常喜欢！在

微积分里有

泰勒展开的

概念，也就是

用一个无穷

级数来表

示

一个可微的

函数。实际上

，任何可微的

（从而也是连

续的）函数都

可以用一个

N次多项式来

估

计，而比N次

幂更高阶的

部分为无穷

小量可忽略

不计。

4.4 动手实

践：多项式拟

合

NumPy中的ployfit函数

可以用多项

式去拟合一

系列数据点

，无论这些数

据点是否来

自连续

图灵

社区会员

heruihong 专

享 尊重版权

4.4 动手实践：多

项式拟合

75 

1

2 

3

4

5 

11

6

7 

8

9 

10

函

数都适用。

(1) 我

们继续使用

BHP和VALE的股票价

格数据。用一

个三次多项

式去拟合两

只股票收盘

价的

差价：

bhp=np.loadtxt('BHP.csv', delimiter=',', usecols=(6,), unpack=True)

vale=np.loadtxt('VALE.csv', delimiter=',', usecols=(6,),unpack=True)

t = np.arange(len(bhp))

poly = np.polyfit(t, bhp

- vale, int(sys.argv[1]))

print "Polynomial fit", poly

拟

合的结果为

（在这个例子

中是一个三

次多项式）： 

Polynomial fit

[ 1.11655581e-03 -5.28581762e-02 5.80684638e-01

5.79791202e+01] 

(2) 上

面看到的那

些数字就是

多项式的系

数。用我们刚

刚得到的多

项式对象以

及polyval函

数，就可

以推断下一

个值： 

print "Next

value", np.polyval(poly, t[-1] +

1) 

预测的

下一个值为

：

Next value 57.9743076081

(3) 理想情况下

，BHP和VALE股票收盘

价的差价越

小越好。在极

限情况下，差

值可以在某

个

点为0。使用

roots函数找出我

们拟合的多

项式函数什

么时候到达

0值：

print "Roots", np.roots(poly)

解出多项

式的根为： 

Roots [35.48624287+30.62717062j

35.48624287-30.62717062j -23.63210575 +0.j]

(4) 我

们在微积分

课程中还学

习过求极值

的知识——极值

可能是函数

的最大值或

最小值。

记住

微积分中的

结论，这些极

值点位于函

数的导数为

0的位置。使用

polyder函数对多项

式函

数求导

：

der = np.polyder(poly)

print "Derivative", der

多项式函数

的导函数（仍

然是一个多

项式函数）的

系数如下： 

Derivative [

0.00334967 -0.10571635 0.58068464]

你

看到的这些

数字即为导

函数的系数

。

(5) 求出导数函

数的根，即找

出原多项式

函数的极值

点：

print "Extremas", np.roots(der)

图灵社区

会员 heruihong 专享 尊

重版权

76 第 4 章

便捷函数

得

到的极值点

为： 

Extremas [

24.47820054 7.08205278] 

我们来复

核一下结果

，使用polyval计算多

项式函数的

值：

vals = np.polyval(poly, t)

(6) 现在，使用

argmax和argmin找出最大

值点和最小

值点：

vals =

np.polyval(poly, t) 

print

np.argmax(vals) 

print np.argmin(vals)

这将给

出如下的结

果：

7 

24

与上一步

中的结果不

完全一致，不

过回到第1步

可以看到，t是

用arange函数定义

的。

(7) 绘制源数

据和拟合函

数如下：

plot(t,

bhp - vale)

plot(t, vals) 

show()

生成

的折线图如

下。 

显然，光滑

曲线为拟合

函数，而锯齿

状的为源数

据。拟合得不

算很好，因此

你可以尝试

更高

阶的多

项式拟合。

图

灵社区会员

heruihong 专享 尊重版

权

4.5

净额成交

量 77 

1

2 

3

4

5 

11

6

7 

8

9 

10

刚才做了

些什么

我们

使用polyfit函数对

数据进行了

多项式拟合

。我们学习使

用polyval函数计算

多项式的

取

值，使用roots函数

求得多项式

函数的根，以

及polyder函数求解

多项式函数

的导函数。示

例

代码见polynomials.py文

件。

import numpy as np

import sys 

from

matplotlib.pyplot import plot

from matplotlib.pyplot import show

bhp=np.loadtxt('BHP.csv', delimiter=',', usecols=(6,), unpack=True)

vale=np.loadtxt('VALE.csv', delimiter＝',', usecols=(6,), unpack=True)

t = np.arange(len(bhp))

poly = np.polyfit(t, bhp

- vale, int(sys.argv[1]))

print "Polynomial fit", poly

print "Next value", np.polyval(poly,

t[-1] + 1)

print "Roots", np.roots(poly)

der = np.polyder(poly)

print "Derivative", der

print "Extremas", np.roots(der)

vals = np.polyval(poly, t)

print np.argmax(vals) 

print

np.argmin(vals) 

plot(t, bhp

- vale) 

plot(t,

vals) 

show()

勇敢出发

：改进拟合函

数

本节中的

拟合函数有

很多可以改

进的地方。尝

试使用三次

方之外的不

同指数，或者

考虑在

拟合

前对数据进

行平滑处理

。使用移动平

均线就是一

种数据平滑

的方法。计算

简单移动平

均线

和指数

移动平均线

的示例可参

阅前面的章

节。

4.5 净额成交

量

成交量（volume）是

投资中一个

非常重要的

变量，它可以

表示价格波

动的大小。OBV

（On-Balance

Volume，净

额成交量或

叫能量潮指

标）是最简单

的股价指标

之一，它可以

由当日收

盘

价、前一天的

收盘价以及

当日成交量

计算得出。这

里我们以前

一日为基期

计算当日的

OBV值（可

以认为

基期的OBV值为

0）。若当日收盘

价高于前一

日收盘价，则

本日OBV等于基

期OBV加上当

图

灵社区会员

heruihong

专享 尊重版

权

78 第

4 章 便捷

函数

日成交

量。若当日收

盘价低于前

一日收盘价

，则本日OBV等于

基期OBV减去当

日成交量。若

当

日收盘价

相比前一日

没有变化，则

当日成交量

以0计算。

4.6 动手

实践：计算 OBV

换

言之，我们需

要在成交量

前面乘上一

个由收盘价

变化决定的

正负号。在本

节教程中，我

们

将学习该

问题的两种

解决方法，一

种是使用NumPy中

的sign函数，另一

种是使用NumPy的

piecewise函数。

(1) 把BHP数据

分别加载到

收盘价和成

交量的数组

中：

c, v=np.loadtxt('BHP.csv', delimiter=',', usecols=(6,

7), unpack=True) 

为了判断

计算中成交

量前的正负

号，我们先使

用diff函数计算

收盘价的变

化量。diff函数可

以

计算数组

中两个连续

元素的差值

，并返回一个

由这些差值

组成的数组

： 

change =

np.diff(c) 

print "Change",

change 

收盘价差值

的计算结果

如下：

Change [ 1.92 -1.08

-1.26 0.63 -1.54 -0.28

0.25 -0.6 2.15 0.69

-1.33 1.16

1.59 -0.26 -1.29 -0.13

-2.12 -3.91 1.28 -0.57

-2.07 -2.07 2.5 1.18

-0.88 1.31 1.24 -0.59]

(2) NumPy中的sign函

数可以返回

数组中每个

元素的正负

符号，数组元

素为负时返

回-1，为

正时返

回1，否则返回

0。对change数组使用

sign函数：

signs = np.sign(change)

print "Signs", signs

change数组中

各元素的正

负符号如下

所示： 

Signs [

1. -1. -1. 1.

-1. -1. 1. -1.

1. 1. -1. 1.

1. -1. -1. -1.

-1. -1. -1. -1.

-1. 

1. 1.

1. -1. 1. 1.

-1.] 

另外，我

们也可以使

用piecewise函数来获

取数组元素

的正负。顾名

思义，piecewise①函

数可

以分段给定

取值。使用合

适的返回值

和对应的条

件调用该函

数：

pieces = np.piecewise(change, [change

< 0, change >

0], [-1, 1])

print "Pieces", pieces

再次输出

数组元素的

正负，结果如

下： 

Pieces [

1. -1. -1. 1.

-1. -1. 1. -1.

1. 1. -1. 1.

1. -1. -1. -1.

-1. -1. -1. -1.

-1. 

1. 1.

1. -1. 1. 1.

-1.] 

——————————

① 英语中piecewise意

为“分段的”。——译

者注

图灵社

区会员 heruihong

专享

尊重版权

4.7 交

易过程模拟

79

1 

2

3 

4

5

11 

6

7

8 

9

10 

检查两次的

输出是否一

致：

print "Arrays equal?", np.array_equal(signs,

pieces) 

结果如下

：

Arrays equal? True

(3) OBV值的计算依

赖于前一日

的收盘价，所

以在我们的

例子中无法

计算首日的

OBV值： 

print

"On balance volume", v[1:]

* signs 

计算结果

如下：

[2620800. -2461300. -3270900. 2650200.

-4667300. -5359800. 7768400.

-4799100. 3448300. 4719800. -3898900.

3727700. 3379400. -2463900.

-3590900. -3805000. -3271700. -5507800.

2996800. -3434800. -5008300.

-7809799. 3947100. 3809700. 3098200.

-3500200. 4285600. 3918800.

-3632200.] 

刚才做

了些什么

我

们刚刚计算

了OBV值，它依赖

于收盘价的

变化量。我们

分别使用了

NumPy中的sign函数

和

piecewise函数这两种

不同的方法

来判断收盘

价变化量的

正负。示例代

码见obv.py文件. 

import numpy

as np 

c,

v=np.loadtxt('BHP.csv', delimiter=',', usecols=(6, 7),

unpack=True) 

change =

np.diff(c) 

print "Change",

change 

signs =

np.sign(change) 

print "Signs",

signs 

pieces =

np.piecewise(change, [change < 0,

change > 0], [-1,

1]) 

print "Pieces",

pieces 

print "Arrays

equal?", np.array_equal(signs, pieces)

print "On balance volume",

v[1:] * signs

4.7 交

易过程模拟

你可能经常

想尝试干一

些事情，做一

些实验，但又

不希望造成

任何不良后

果。而NumPy就是

用

于实验的完

美工具。我们

将使用NumPy来模

拟一个交易

日，当然，这不

会造成真正

的资金损失

。

许多人喜欢

抄底，也就是

等股价下跌

后才买入。类

似的还有当

股价比当日

开盘价下跌

一小部分（比

如0.1%）时买入。

图

灵社区会员

heruihong 专享 尊重版

权

80

第 4 章 便捷

函数

4.8 动手实

践：避免使用

循环

使用vectorize函

数可以减少

你的程序中

使用循环的

次数。我们将

用它来计算

单个交易日

的利润。

(1)

首先

，读入数据： 

o, h,

l, c = np.loadtxt('BHP.csv',

delimiter=',', usecols=(3, 4, 5,

6), unpack=True) 

(2)

NumPy中

的vectorize函数相当

于Python中的map函数

。调用vectorize函数并

给定

calc_profit函数作

为参数，尽管

我们还没有

编写这个函

数： 

func

= np.vectorize(calc_profit) 

(3)

我们现在

可以先把func当

做函数来使

用。对股价数

组使用我们

得到的func函数

: 

profits =

func(o, h, l, c)

(4) calc_profit函数非常简

单。首先，我们

尝试以比开

盘价稍低一

点的价格买

入股票。如果

这个价格不

在当日的股

价范围内，则

尝试买入失

败，没有获利

，也没有亏损

，我们均返回

0。否则，

我们将

以当日收盘

价卖出，所获

得的利润即

买入和卖出

的差价。事实

上，计算相对

利润更为直

观：

def calc_profit((open, high, low,

close): 

 #

以比开盘

价稍低的价

格买入

 buy =

open * float(sys.argv[1])

# daily range

if low < buy

< high :

return (close - buy)/buy

else:

return 0 

print

"Profits", profits 

(5)

在所

有交易日中

有两个零利

润日，即没有

利润也没有

损失。我们选

择非零利润

的交易日

并

计算平均值

： 

real_trades

= profits[profits != 0]

print "Number of trades",

len(real_trades), round(100.0 * len(real_trades)/len(c),

2),"%" 

print "Average

profit/loss %", round(np.mean(real_trades) *

100, 2) 

交易结果如

下：

Number of trades 28

93.33 % 

Average

profit/loss % 0.02

(6) 乐观的人

们对于正盈

利的交易更

感兴趣。选择

正盈利的交

易日并计算

平均利润： 

winning_trades

= profits[profits > 0]

print "Number of winning

trades", len(winning_trades), 

round(100.0

* len(winning_trades)/len(c), 2), "%"

图

灵社区会员

heruihong 专享 尊重版

权

4.8

动手实践

：避免使用循

环 81 

1

2 

3

4

5 

11

6

7 

8

9 

10

print "Average profit %",

round(np.mean(winning_trades) * 100, 2)

正盈利交

易的分析结

果如下： 

Number of

winning trades 16 53.33

% 

Average profit

% 0.72 

(7)

悲观

的人们对于

负盈利的交

易更感兴趣

，选择负盈利

的交易日并

计算平均损

失： 

losing_trades =

profits[profits < 0]

print "Number of losing

trades", len(losing_trades), 

round(100.0

* len(losing_trades)/len(c), 2), "%"

print "Average loss %",

round(np.mean(losing_trades) * 100, 2)

负盈利交

易的分析结

果如下： 

Number of

losing trades 12 40.0

% 

Average loss

% -0.92 

刚才

做了些什么

我们矢量化

了一个函数

，这是一种可

以避免使用

循环的技巧

。我们使用一

个能返回当

日相对

利润

的函数来模

拟一个交易

日，并分别打

印出正盈利

和负盈利交

易的概况。示

例代码见

simulation.py文

件。 

import

numpy as np

import sys 

o,

h, l, c =

np.loadtxt('BHP.csv', delimiter=',', usecols=(3, 4,

5, 6), unpack=True)

def calc_profit(open, high, low,

close): 

 #

在开盘时

买入 

 buy

= open * float(sys.argv[1])

# 当日股

价区间

if low < buy

< high:

return (close - buy)/buy

else:

return 0 

func

= np.vectorize(calc_profit) 

profits

= func(o, h, l,

c) 

print "Profits",

profits 

real_trades =

profits[profits != 0]

print "Number of trades",

len(real_trades), round(100.0 * len(real_

trades)/len(c), 

2), "%"

print "Average profit/loss %",

round(np.mean(real_trades) * 100, 2)

winning_trades = profits[profits >

0] 

print "Number

of winning trades", len(winning_trades),

round(100.0 * 

len(winning_trades)/len(c),

2), "%" 

图灵

社区会员

heruihong 专

享 尊重版权

82 第

4 章 便捷函

数

print

"Average profit %", round(np.mean(winning_trades)

* 100, 2)

losing_trades = profits[profits <

0] 

print "Number

of losing trades", len(losing_trades),

round(100.0 * 

len(losing_trades)/len(c),

2), "%" 

print

"Average loss %", round(np.mean(losing_trades)

* 100, 2)

勇敢出发

：分析连续盈

利和亏损

尽

管平均利润

为正值，但我

们仍需要了

解这段过程

中是否有长

期连续亏损

的状况出现

。这

一点很重

要，因为如果

出现了连续

亏损，我们可

能会面临资

本耗尽的情

形，那么计算

出来的平

均

利润就不可

信了。

请检查

是否出现过

这样的连续

亏损。如果你

乐意，也可以

检查是否有

长时间的连

续盈利。

4.9 数据

平滑

噪声数

据往往很难

处理，因此我

们通常需要

对其进行平

滑处理。除了

用计算移动

平均线的方

法，我们还可

以使用NumPy中的

一个函数来

平滑数据。

hanning函

数是一个加

权余弦的窗

函数。在后面

的章节中，我

们还将更为

详细地介绍

其他窗

函数

。

4.10 动手实践：使

用

hanning 函数平滑

数据

我们将

使用hanning函数平

滑股票收益

率的数组，步

骤如下。

(1)

调用

hanning函数计算权

重，生成一个

长度为N的窗

口（在这个示

例中N取8）： 

N =

int(sys.argv[1]) 

weights =

np.hanning(N) 

print "Weights",

weights 

得到

的权重如下

：

Weights [ 0. 0.1882551

0.61126047 0.95048443 0.95048443 0.61126047

0.1882551 0. ]

(2) 使用convolve函数计

算BHP和VALE的股票

收益率，以归

一化处理后

的weights作为参数

： 

bhp

= np.loadtxt('BHP.csv', delimiter=',', usecols=(6,),unpack=True)

bhp_returns = np.diff(bhp) /

bhp[ : -1]

smooth_bhp = np.convolve(weights/weights.sum(), bhp_returns)

[N-1:-N+1] 

vale =

np.loadtxt('VALE.csv', delimiter=',', usecols=(6,),unpack=True)

vale_returns = np.diff(vale) /

vale[ : -1]

smooth_vale = np.convolve(weights/weights.sum(), vale_returns)

[N-1:-N+1] 

图灵社区会

员 heruihong

专享 尊重

版权

4.10 动手实

践：使用

hanning 函数

平滑数据 83

1 

2

3 

4

5

11 

6

7

8 

9

10 

(3) 用

Matplotlib绘图：

t = np.arange(N -

1, len(bhp_returns)) 

plot(t,

bhp_returns[N-1:], lw=1.0) 

plot(t,

smooth_bhp, lw=2.0) 

plot(t,

vale_returns[N-1:], lw=1.0) 

plot(t,

smooth_vale, lw=2.0) 

show()

绘制的

折线图如下

。

图中的细线

为股票收益

率，粗线为平

滑处理后的

结果。如你所

见，图中的折

线有交叉。这

些

交叉点很

重要，因为它

们可能就是

股价趋势的

转折点，至少

可以表明BHP和

VALE之间的股价

关

系发生了

变化。这些转

折点可能会

经常出现，我

们可以利用

它们预测未

来的股价走

势。

(4) 使用多项

式拟合平滑

后的数据： 

K

= int(sys.argv[1]) 

t

= np.arange(N - 1,

len(bhp_returns)) 

poly_bhp =

np.polyfit(t, smooth_bhp, K)

poly_vale = np.polyfit(t, smooth_vale,

K) 

(5) 现

在，我们需要

解出上面的

两个多项式

何时取值相

等，即在哪些

地方存在交

叉点。这等

价

于先对两个

多项式函数

作差，然后对

所得的多项

式函数求根

。使用polysub函数对

多项式作差

: 

poly_sub =

np.polysub(poly_bhp, poly_vale) 

xpoints

= np.roots(poly_sub) 

print

"Intersection points", xpoints

解出的交叉

点如下： 

图灵

社区会员 heruihong

专

享 尊重版权

84 第 4

章 便捷函

数

Intersection points

[ 27.73321597+0.j 27.51284094+0.j 24.32064343+0.j

18.86423973+0.j 12.43797190+1.73218179j 12.43797190-1.73218179j

6.34613053+0.62519463j 6.34613053-0.62519463j] 

(6)

得到的结

果为复数，这

不利于我们

后续处理，除

非时间也有

实部和虚部

。因此，这里需

要用isreal函数来

判断数组元

素是否为实

数： 

reals =

np.isreal(xpoints) 

print "Real

number?", reals 

结果如下

：

Real number? [ True

True True True False

False False False]

可以看到有

一部分数据

为实数，因此

我们用select函数

选出它们。select函

数可以根据

一

组给定的

条件，从一组

元素中挑选

出符合条件

的元素并返

回数组： 

xpoints

= np.select([reals], [xpoints])

xpoints = xpoints.real

print "Real intersection points",

xpoints 

得到

的实数交叉

点如下所示

：

Real intersection points [

27.73321597 27.51284094 24.32064343 18.86423973

0. 0. 0. 0.]

(7) 我们需要去

掉其中为0的

元素。trim_zeros函数可

以去掉一维

数组中开头

和末尾为0的

元素： 

print

"Sans 0s", np.trim_zeros(xpoints)

去掉0元

素后，输出结

果如下所示

：

Sans 0s [

27.73321597 27.51284094 24.32064343 18.86423973]

刚才做了些

什么

我们使

用hanning函数对股

票收益率数

组进行了平

滑处理，使用

polysub函数对两个

多项式

作差

运算，以及使

用isreal函数判断

数组元素是

否为实数，并

用select函数选出

了实数元素

。

最后，我们用

trim_zeros函数去掉数

组首尾的0元

素。示例代码

见smoothing.py文件。

import numpy as np

import sys 

from

matplotlib.pyplot import plot

from matplotlib.pyplot import show

N = int(sys.argv[1])

weights = np.hanning(N)

print "Weights", weights

图灵

社区会员 heruihong 专

享 尊重版权

4.11

本章小结 85 

1

2 

3

4

5 

11

6

7 

8

9 

10

bhp = np.loadtxt('BHP.csv', delimiter=',',

usecols=(6,), unpack=True) 

bhp_returns

= np.diff(bhp) / bhp[

: -1] 

smooth_bhp

= np.convolve(weights/weights.sum(), bhp_returns)[N-1: -N+1]

vale = np.loadtxt('VALE.csv', delimiter=',',

usecols=(6,), un pack=True)

vale_returns = np.diff(vale) /

vale[ : -1]

smooth_vale = np.convolve(weights/weights.sum(), vale_returns)[N-1:

-N+1] 

K =

int(sys.argv[1]) 

t =

np.arange(N - 1, len(bhp_returns))

poly_bhp = np.polyfit(t, smooth_bhp,

K) 

poly_vale =

np.polyfit(t, smooth_vale, K)

poly_sub = np.polysub(poly_bhp, poly_vale)

xpoints = np.roots(poly_sub)

print "Intersection points", xpoints

reals = np.isreal(xpoints)

print "Real number?", reals

xpoints = np.select([reals], [xpoints])

xpoints = xpoints.real

print "Real intersection points",

xpoints 

print "Sans

0s", np.trim_zeros(xpoints) 

plot(t,

bhp_returns[N-1:], lw=1.0) 

plot(t,

smooth_bhp, lw=2.0) 

plot(t,

vale_returns[N-1:], lw=1.0) 

plot(t,

smooth_vale, lw=2.0) 

show()

勇

敢出发：尝试

各种平滑函

数

请尝试使

用其他的平

滑函数，如hamming、blackman、bartlett以

及kaiser。它们的

使

用方法和hanning函

数类似。

4.11

本章

小结

在本章

中，我们使用

corrcoef函数计算了

两只股票收

益率的相关

性。另外，我们

还顺便学

习

了diagonal和trace函数的

用法，分别可

以给出矩阵

的对角线元

素和矩阵的

迹。

我们使用

polyfit函数拟合一

系列数据点

，用polyval函数计算

多项式函数

的取值，roots

函数

求解多项式

的根，以及polyder函

数求解多项

式函数的导

函数。

希望通

过本章的内

容，可以帮助

读者提高工

作效率，以便

更好地学习

下一章中矩

阵和通用函

数（ufuncs）的相关内

容。

图灵社区

会员 heruihong

专享 尊

重版权

86 第

5 章

矩阵和通用

函数

矩阵和

通用函数

本

章我们将学

习矩阵和通

用函数（universal

functions，即ufuncs）的

相关

内容。矩

阵作为一种

重要的数学

概念，在NumPy中也

有专门的表

示方法。通

用

函数可以逐

个处理数组

中的元素，也

可以直接处

理标量。通用

函数的输入

是一组标量

，输出也是一

组标量，它们

通常可以对

应于基本数

学运算，如加

、

减、乘、除等。我

们还将介绍

三角函数、位

运算函数和

比较函数。

本

章涵盖以下

内容：

 矩阵创

建；



矩阵运算

；

 基本通用函

数；



三角函数

；

 位运算函数

；



比较函数。

5.1 矩

阵

在NumPy中，矩阵

是ndarray的子类，可

以由专用的

字符串格式

来创建。与数

学概念中的

矩

阵一样，NumPy中

的矩阵也是

二维的。如你

所料，矩阵的

乘法运算和

NumPy中的普通乘

法运算不

同

。幂运算当然

也不一样。我

们可以使用

mat、matrix以及bmat函数来

创建矩阵。

5.2 动

手实践：创建

矩阵

mat函数创

建矩阵时，若

输入已为matrix或

ndarray对象，则不会

为它们创建

副本。因此，调

用mat函数和调

用matrix(data, copy=False)等价。 我们

还将展示矩

阵转置和矩

阵求逆的方

法。

第5章

图灵

社区会员 heruihong 专

享 尊重版权

5.2

动手实践：创

建矩阵 87 

1

2 

3

4

5 

11

6

7 

8

9 

10

(1) 在创

建矩阵的专

用字符串中

，矩阵的行与

行之间用分

号隔开，行内

的元素之间

用空格隔

开

。使用如下的

字符串调用

mat函数创建矩

阵：

A = np.mat('1 2

3; 4 5 6;

7 8 9')

print "Creation from string",

A 

输出的矩

阵如下：

Creation from string [[1

2 3]

[4 5 6]

[7 8 9]]

(2) 用T属

性获取转置

矩阵： 

print

"transpose A", A.T

转置矩

阵如下： 

transpose A

[[1 4 7]

[2 5 8]

[3 6 9]]

(3) 用I属

性获取逆矩

阵： 

print

"Inverse A", A.I

求得的逆

矩阵如下（注

意：计算复杂

度为O(n3)）： 

Inverse A

[[ -4.50359963e+15 9.00719925e+15 -4.50359963e+15]

[ 9.00719925e+15 -1.80143985e+16

9.00719925e+15] 

 [

-4.50359963e+15 9.00719925e+15 -4.50359963e+15]]

(4) 除了使

用字符串创

建矩阵以外

，我们还可以

使用NumPy数组进

行创建： 

print

"Creation from array", np.mat(np.arange(9).reshape(3,

3)) 

创建

的矩阵如下

：

Creation from array [[0

1 2]

[3 4 5]

[6 7 8]]

刚才做了些

什么

我们使

用mat函数创建

了矩阵，用T属

性获取了转

置矩阵，用I属

性获取了逆

矩阵。示例代

码

见matrixcreation.py文件。

import numpy as np

A = np.mat('1 2

3; 4 5 6;

7 8 9')

print "Creation from string",

A 

图

灵社区会员

heruihong 专享

尊重版

权

88 第 5

章 矩阵

和通用函数

print "transpose A",

A.T 

print "Inverse

A", A.I 

print

"Check Inverse", A *

A.I 

print "Creation

from array", np.mat(np.arange(9).reshape(3, 3))

5.3 从已有矩阵

创建新矩阵

有些时候，我

们希望利用

一些已有的

较小的矩阵

来创建一个

新的大矩阵

。这可以用bmat函

数来实现。这

里的b表示“分

块”，bmat即分块矩

阵（block matrix）。

5.4

动手实践

：从已有矩阵

创建新矩阵

我们将利用

两个较小的

矩阵创建一

个新的矩阵

，步骤如下。

(1) 首

先，创建一个

2×2的单位矩阵

：

A = np.eye(2)

print "A", A

该单位矩阵

如下所示： 

A [[

1. 0.]

[ 0. 1.]]

创

建另一个与

A同型的矩阵

，并乘以2： 

B =

2 * A

print "B", B

第二

个矩阵如下

所示： 

B [[

2. 0.]

[ 0. 2.]]

(2) 使用字

符串创建复

合矩阵，该字

符串的格式

与mat函数中一

致，只是在这

里你可以用

矩

阵变量名

代替数字：

print "Compound matrix\n", np.bmat("A

B; A B")

创

建的复合矩

阵如下所示

： 

Compound matrix

[[ 1. 0. 2.

0.] 

 [

0. 1. 0. 2.]

[ 1. 0.

2. 0.]

[ 0. 1. 0.

2.]] 

图灵社区会

员 heruihong

专享 尊重

版权

5.6 动手实

践：创建通用

函数

89 

1

2 

3

4

5 

11

6

7 

8

9 

10

刚才做

了些什么

我

们使用bmat函数

，从两个小矩

阵创建了一

个分块复合

矩阵。我们用

矩阵变量名

替代了数

字

，并将字符串

传给bmat函数。示

例代码见bmatcreation.py文

件。

import numpy as np

A = np.eye(2)

print "A", A

B = 2 *

A 

print "B",

B 

print "Compound

matrix\n", np.bmat("A B; A

B") 

突击测验

： 使用字符串

定义矩阵

问

题1 在使用mat和

bmat函数创建矩

阵时，需要输

入字符串来

定义矩阵。在

字符串中，

以

下哪一个英

文标点符号

是矩阵的行

分隔符？

(1)

分号

“;”

(2) 冒号 “:”

(3) 逗号 “,”

(4)

空

格 “ ”

5.5

通用函数

通用函数的

输入是一组

标量，输出也

是一组标量

，它们通常可

以对应于基

本数学运算

，如加、

减、乘、除

等。

5.6 动手实践

：创建通用函

数

我们可以

使用NumPy中的frompyfunc函

数，通过一个

Python函数来创建

通用函数，步

骤如下。 

(1) 定义

一个回答宇

宙、生命及万

物的终极问

题的Python函数（问

题和答案来

源于《银河系

漫游指南》，如

果你没看过

，可以忽略）：

def ultimate_answer(a): 

到

这里为止还

没有什么特

别的。我们将

这个函数命

名为ultimate_answer，并为之

定义了

一个

参数a。

(2) 使用zeros_like函

数创建一个

和a形状相同

，并且元素全

部为0的数组

result：

result = np.zeros_like(a)

图灵社区会

员 heruihong 专享 尊重

版权

90 第 5 章

矩

阵和通用函

数

(3) 现在，我们

将刚刚生成

的数组中的

所有元素设

置为“终极答

案”其值为42，并

返回这个

结

果。完整的函

数代码如下

所示。flat属性为

我们提供了

一个扁平迭

代器，可以逐

个设置数组

元素的值：

def ultimate_answer(a):

result = np.zeros_like(a)

result.flat = 42

return result

(4) 使

用frompyfunc创建通用

函数。指定输

入参数的个

数为1，随后的

1为输出参数

的个数：

ufunc = np.frompyfunc(ultimate_answer, 1,

1) 

print "The

answer", ufunc(np.arange(4)) 

输出

结果如下所

示：

The answer [42 42

42 42] 

我们可以

对二维数组

进行完全一

样的操作，代

码如下：

print "The answer", ufunc(np.arange(4).reshape(2,

2)) 

输出

结果如下所

示：

The answer [[42 42]

[[42 42]

[42 42]] 

刚才做了

些什么

我们

定义了一个

Python函数。其中，我

们使用zeros_like函数

根据输入参

数的形状初

始化

一个全

为0的数组，然

后利用ndarray对象

的flat属性将所

有的数组元

素设置为“终

极答案”其

值

为42。示例代码

见answer42.py文件。

import numpy as np

def ultimate_answer(a):

result = np.zeros_like(a)

result.flat = 42

return result 

ufunc

= np.frompyfunc(ultimate_answer, 1, 1)

print "The answer", ufunc(np.arange(4))

print "The answer", ufunc(np.arange(4).reshape(2,

2)) 

5.7 通用

函数的方法

函数竟然也

可以拥有方

法？如前所述

，其实通用函

数并非真正

的函数，而是

能够表示函

数的

图灵社

区会员 heruihong 专享

尊重版权

5.8

动

手实践：在 add 上

调用通用函

数的方法 91

1 

2

3 

4

5

11 

6

7

8 

9

10 

对

象。通用函数

有四个方法

，不过这些方

法只对输入

两个参数、输

出一个参数

的ufunc对象有效

，

例如add函数。其

他不符合条

件的ufunc对象调

用这些方法

时将抛出ValueError异

常。因此只能

在二元通用

函数上调用

这些方法。以

下将逐一介

绍这4个方法

：

 reduce 



accumulate 

 reduceat

 outer 

5.8

动手实践：在

add 上调用通用

函数的方法

我们将在add函

数上分别调

用4个方法。 

(1)

沿

着指定的轴

，在连续的数

组元素之间

递归调用通

用函数，即可

得到输入数

组的规约

（reduce）计

算结果。对于

add函数，其对数

组的reduce计算结

果等价于对

数组元素求

和。调用

reduce方法

：

a = np.arange(9)

print "Reduce", np.add.reduce(a)

计算结果如

下： 

Reduce 36

(2) accumulate方法同样

可以递归作

用于输入数

组。但是与reduce方

法不同的是

，它将存

储运

算的中间结

果并返回。因

此在add函数上

调用accumulate方法，等

价于直接调

用cumsum函

数。在add函

数上调用accumulate方

法：

print "Accumulate", np.add.accumulate(a)

计算结果

如下： 

Accumulate [

0 1 3 6

10 15 21 28

36] 

(3) reduceat方法解

释起来有点

复杂，我们先

运行一次，再

一步一步来

看它的算法

。

reduceat方法需要输

入一个数组

以及一个索

引值列表作

为参数。

print "Reduceat", np.add.reduceat(a,

[0, 5, 2, 7])

运行

结果如下： 

Reduceat [10

5 20 15]

第

一步用到索

引值列表中

的0和5，实际上

就是对数组

中索引值在

0到5之间的元

素进行reduce

操作

。 

图灵社区会

员

heruihong 专享 尊重

版权

92

第 5 章 矩

阵和通用函

数

print "Reduceat step I",

np.add.reduce(a[0:5]) 

第一步的

输出如下：

Reduceat step I 10

第

二步用到索

引值5和2。由于

2比5小，所以直

接返回索引

值为5的元素

： 

print "Reduceat

step II", a[5]

第二步的结

果如下： 

Reduceat step

II 5 

第三

步用到索引

值2和7。这一步

是对索引值

在2到7之间的

数组元素进

行reduce操作：

print "Reduceat step III",

np.add.reduce(a[2:7]) 

第三

步的结果如

下：

Reduceat step III 20

第四步用

到索引值7。这

一步是对索

引值从7开始

直到数组末

端的元素进

行reduce操作： 

print "Reduceat

step IV", np.add.reduce(a[7:])

第四

步的结果如

下： 

Reduceat step

IV 15 

(4)

outer方法返回

一个数组，它

的秩（rank）等于两

个输入数组

的秩的和。它

会作用于两

个

输入数组

之间存在的

所有元素对

。在add函数上调

用outer方法： 

print

"Outer", np.add.outer(np.arange(3), a)

输出

结果如下： 

Outer [[

0 1 2 3

4 5 6 7

8] 

 [

1 2 3 4

5 6 7 8

9] 

 [

2 3 4 5

6 7 8 9

10]] 

刚

才做了些什

么

我们在通

用函数add上调

用了四个方

法：reduce、accumulate、reduceat以及outer。

示例

代码见ufuncmethods.py文件

。 

import numpy

as np 

a

= np.arange(9) 

print

"Reduce", np.add.reduce(a) 

图灵社区会

员

heruihong 专享 尊重

版权

5.10

动手实

践：数组的除

法运算 93 

1

2 

3

4

5 

11

6

7 

8

9 

10

print "Accumulate", np.add.accumulate(a)

print "Reduceat", np.add.reduceat(a, [0,

5, 2, 7])

print "Reduceat step I",

np.add.reduce(a[0:5]) 

print "Reduceat

step II", a[5]

print "Reduceat step III",

np.add.reduce(a[2:7]) 

print "Reduceat

step IV", np.add.reduce(a[7:])

print "Outer", np.add.outer(np.arange(3), a)

5.9 算术

运算

在NumPy中，基

本算术运算

符+、-和*隐式关

联着通用函

数add、subtract和multiply。

也就是

说，当你对NumPy数

组使用这些

算术运算符

时，对应的通

用函数将自

动被调用。除

法包含

的过

程则较为复

杂，在数组的

除法运算中

涉及三个通

用函数divide、true_divide和

floor_division，以

及两个对应

的运算符/和

//。

5.10 动手实践：数

组的除法运

算

让我们在

实践中了解

数组的除法

运算。

(1) divide函数在

整数和浮点

数除法中均

只保留整数

部分：

a = np.array([2, 6,

5]) 

b =

np.array([1, 2, 3])

print "Divide", np.divide(a, b),

np.divide(b, a) 

divide函数的

运算结果如

下：

Divide [2 3 1]

[0 0 0]

如你所见

，运算结果的

小数部分被

截断了。

(2) true_divide函数

与数学中的

除法定义更

为接近，即返

回除法的浮

点数结果而

不作截断：

print "True Divide", np.true_divide(a,

b), np.true_divide(b, a)

true_divide函

数的运算结

果如下： 

True Divide

[2. 3. 1.66666667] [0.5

0.33333333 0.6 ]

(3) floor_divide函数

总是返回整

数结果，相当

于先调用divide函

数再调用floor函

数。

floor函数将对

浮点数进行

向下取整并

返回整数：

print "Floor Divide", np.floor_divide(a,

b), np.floor_divide(b, a) c

= 3.14 * b

print "Floor Divide 2",

np.floor_divide(c, b), np.floor_divide(b, c)

floor_divide函

数的运算结

果如下： 

图灵

社区会员 heruihong

专

享 尊重版权

94 第 5

章 矩阵和

通用函数

Floor Divide

[2 3 1] [0

0 0] 

Floor

Divide 2 [ 3.

3. 3.] [ 0.

0. 0.] 

(4)

默

认情况下，使

用/运算符相

当于调用divide函

数： 

from__future__import division

但如果在

Python程序的开头

有上面那句

代码，则改为

调用true_divide函数。代

码如下： 

print "/

operator", a/b, b/a

计算

结果如下： 

/ operator

[ 2. 3. 1.66666667]

[ 0.5 

0.33333333

0.6 ] 

(5)

运

算符//对应于

floor_divide函数。例如下

面的代码： 

print "//

operator", a//b, b//a

print "// operator 2",

c//b, b//c 

计

算结果如下

：

// operator [2 3

1] [0 0 0]

// operator 2 [

3. 3. 3.] [

0. 0. 0.]

刚才做了些

什么

我们学

习了NumPy中三种

不同的除法

函数。其中，divide函

数在整数和

浮点数除法

中均只

保留

整数部分，true_divide函

数不作截断

返回浮点数

结果，而floor_divide函数

同样返回整

数结果并等

价于先调用

divide函数再调用

floor函数。示例代

码见dividing.py文件。

from__future__import division 

import

numpy as np

a = np.array([2, 6,

5]) 

b =

np.array([1, 2, 3])

print "Divide", np.divide(a, b),

np.divide(b, a) 

print

"True Divide", np.true_divide(a, b),

np.true_divide(b, a) 

print

"Floor Divide", np.floor_divide(a, b),

np.floor_divide(b, a) 

c

= 3.14 * b

print "Floor Divide 2",

np.floor_divide(c, b), np.floor_divide(b, c)

print "/ operator", a/b,

b/a 

print "//

operator", a//b, b//a

print "// operator 2",

c//b, b//c 

勇

敢出发

： 尝试

__future__.division

动手实验，验

证引入__future__.division的效

果。

图灵社区

会员

heruihong 专享 尊

重版权

5.12

动手

实践：模运算

95 

1

2 

3

4

5 

11

6

7 

8

9 

10

5.11 模运算

计算

模数或者余

数，可以使用

NumPy中的mod、remainder和fmod函数

。当然，也可以

使

用%运算符

。这些函数的

主要差异在

于处理负数

的方式。fmod函数

在这方面异

于其他函数

。

5.12 动手实践：模

运算

我们将

逐一调用前

面提到的函

数。

(1)

remainder函数逐个

返回两个数

组中元素相

除后的余数

。如果第二个

数字为0，则直

接

返回0： 

a

= np.arange(-4, 4)

print "Remainder", np.remainder(a, 2)

计算

结果如下： 

Remainder [0

1 0 1 0

1 0 1]

(2) mod函

数与remainder函数的

功能完全一

致： 

print

"Mod", np.mod(a, 2)

计算结果

如下： 

Mod [0

1 0 1 0

1 0 1]

(3) %操作符

仅仅是remainder函数

的简写： 

print

"% operator", a %

2 

计算

结果如下：

% operator [0 1

0 1 0 1

0 1] 

(4)

fmod函

数处理负数

的方式与remainder、mod和

%不同。所得余

数的正负由

被除数决定

，

与除数的正

负无关： 

print

"Fmod", np.fmod(a, 2)

计算

结果如下： 

Fmod [

0 -1 0 -1

0 1 0 1]

刚

才做了些什

么

我们学习

了NumPy中的mod、remainder和fmod等

模运算函数

。示例代码见

modulo.py文件。 

图灵社

区会员

heruihong 专享

尊重版权

96 第

5

章 矩阵和通

用函数

import numpy

as np 

a

= np.arange(-4, 4)

print "Remainder", np.remainder(a, 2)

print "Mod", np.mod(a, 2)

print "% operator", a

% 2 

print

"Fmod", np.fmod(a, 2)

5.13 斐波

那契数列

斐

波那契（Fibonacci）数列

是基于递推

关系生成的

。直接用NumPy代码

来解释递推

关系是比

较

麻烦的，不过

我们可以用

矩阵的形式

或者黄金分

割公式来解

释它。因此，我

们将介绍matrix

和

rint函数。使用matrix函

数创建矩阵

，rint函数对浮点

数取整，但结

果仍为浮点

数类型。

5.14 动手

实践：计算斐

波那契数列

斐波那契数

列的递推关

系可以用矩

阵来表示。斐

波那契数列

的计算等价

于矩阵的连

乘。

(1)

创建斐波

那契矩阵： 

F =

np.matrix([[1, 1], [1, 0]])

print "F", F

创

建的斐波那

契矩阵如下

所示： 

F [[1

1] 

 [1

0]] 

(2) 计算斐

波那契数列

中的第8个数

，即矩阵的幂

为8减去1。计算

出的斐波那

契数位于矩

阵的

对角线

上： 

print "8th

Fibonacci", (F ** 7)[0,

0] 

输出的第

8个斐波那契

数为：

8th Fibonacci 21

(3) 利用黄

金分割公式

或通常所说

的比奈公式

（Binet’ s Formula），加上取整函

数，就可以直

接计算斐波

那契数。计算

前8个斐波那

契数：

n = np.arange(1, 9)

sqrt5 = np.sqrt(5)

phi = (1 +

sqrt5)/2 

fibonacci =

np.rint((phi**n - (-1/phi)**n)/sqrt5)

print "Fibonacci", fibonacci

输出的

斐波那契数

为： 

图灵社区

会员 heruihong

专享 尊

重版权

5.16 动手

实践：绘制利

萨茹曲线

97 

1

2 

3

4

5 

11

6

7 

8

9 

10

Fibonacci [ 1. 1.

2. 3. 5. 8.

13. 21.] 

刚

才做了些什

么

我们分别

用两种方法

计算了斐波

那契数列。在

这个过程中

，我们学习使

用matrix函数创建

矩阵，以及使

用rint函数对浮

点数取整但

不改变浮点

数类型。示例

代码见fibonacci.py文件

。 

import numpy

as np 

F

= np.matrix([[1, 1], [1,

0]]) 

print "F",

F 

print "8th

Fibonacci", (F ** 7)[0,

0] 

n =

np.arange(1, 9) 

sqrt5

= np.sqrt(5) 

phi

= (1 + sqrt5)/2

fibonacci = np.rint((phi**n -

(-1/phi)**n)/sqrt5) 

print "Fibonacci",

fibonacci 

勇敢出发：分

析计算耗时

你可能很想

知道究竟哪

种方法计算

更快，那就分

析一下它们

的耗时吧。使

用frompyfunc

创建一个

计算斐波那

契数列的通

用函数，并进

行计时。

5.15 利萨

茹曲线

在NumPy中

，所有的标准

三角函数如

sin、cos、tan等均有对应

的通用函数

。利萨茹曲线

（Lissajous curve）是一种很有

趣的使用三

角函数的方

式。我至今仍

记得在物理

实验室的示

波器上

显示

出利萨茹曲

线时的情景

。利萨茹曲线

由以下参数

方程定义： 

x =

A sin(at + n/2)

y = B sin(bt)

5.16 动

手实践：绘制

利萨茹曲线

利萨茹曲线

的参数包括

A、B、a和b。为简单起

见，我们令A和

B均为1。

(1) 使用linspace函

数初始化变

量t，即从-pi到pi上

均匀分布的

201个点：

a = float(sys.argv[1])

b = float(sys.argv[2])

t = np.linspace(-np.pi, np.pi,

201) 

(2) 使用sin函

数和NumPy常量pi计

算变量x：

图灵

社区会员 heruihong 专

享 尊重版权

98

第 5 章 矩阵和

通用函数

x = np.sin(a *

t + np.pi/2)

(3) 使

用sin函数计算

变量y： 

y

= np.sin(b * t)

(4) 我们将

在第9章中详

细讲解Matplotlib的用

法。绘制的曲

线如下所示

。

plot(x, y)

show() 

这里设置的

参数为a=9，b=8。

刚才

做了些什么

我们根据参

数方程的定

义，以参数A=B=1、a=9和

b=8绘制了利萨

茹曲线。我们

还使用了sin

和

linspace函数，以及NumPy常

量pi。示例代码

见lissajous.py文件。 

import numpy

as np 

from

matplotlib.pyplot import plot

from matplotlib.pyplot import show

import sys 

a

= float(sys.argv[1]) 

b

= float(sys.argv[2]) 

t

= np.linspace(-np.pi, np.pi, 201)

x = np.sin(a *

t + np.pi/2)

y = np.sin(b *

t) 

plot(x, y)

show() 

图灵

社区会员 heruihong

专

享 尊重版权

5.18 动手实践：绘

制方波 99

1 

2

3 

4

5

11 

6

7

8 

9

10 

5.17 方波

方波也是一

种可以在示

波器上显示

的波形。方波

可以近似表

示为多个正

弦波的叠加

。事实上，

任意

一个方波信

号都可以用

无穷傅里叶

级数来表示

。

傅里叶级数

（Fourier series）是以正弦函

数和余弦函

数为基函数

的无穷级数

，

以著名的法

国数学家Jean-Baptiste

Fourier命

名。

方波可以

表示为如下

的傅里叶级

数。

5.18 动手实践

：绘制方波

与

前面的教程

中一样，我们

仍将以相同

的方式初始

化t和k。我们需

要累加很多

项级数，且

级

数越多结果

越精确，这里

取k=99以保证足

够的精度。绘

制方波的步

骤如下。

(1) 我们

从初始化t和

k开始，并将函

数值初始化

为0：

t = np.linspace(-np.pi, np.pi,

201) 

k =

np.arange(1, float(sys.argv[1])) 

k

= 2 * k

- 1 

f

= np.zeros_like(t) 

(2)

接下来，直

接使用sin和sum函

数进行计算

： 

for i

in range(len(t)):

f[i] = np.sum(np.sin(k *

t[i])/k) 

f =

(4 / np.pi) *

f 

(3) 绘制波形的

代码和前面

的教程中几

乎一模一样

：

plot(t, f) 

show()

采用k=99绘制出

的方波曲线

如下所示。

刚

才做了些什

么

我们使用

sin函数生成了

一个方波，或

者起码是非

常接近于方

波的波形。函

数的输入值

是用

图灵社

区会员

heruihong 专享

尊重版权

100 第

5

章 矩阵和通

用函数

linspace产生

的，而一组k值

是用arange函数生

成的。示例代

码见squarewave.py文件。

import numpy as np

from matplotlib.pyplot import plot

from matplotlib.pyplot import show

import sys 

t

= np.linspace(-np.pi, np.pi, 201)

k = np.arange(1, float(sys.argv[1]))

k = 2 *

k - 1

f = np.zeros_like(t)

for i in range(len(t)):

f[i] = np.sum(np.sin(k

* t[i])/k) 

f

= (4 / np.pi)

* f 

plot(t,

f) 

show()

勇

敢出发：摆脱

循环语句

你

可能已经注

意到，在代码

中有一个循

环语句。使用

NumPy函数摆脱循

环，并确保你

的代

码性能

因此而得到

提升。

5.19

锯齿波

和三角波

在

示波器上，锯

齿波和三角

波也是常见

的波形。和方

波类似，我们

也可以将它

们表示成无

穷

傅里叶级

数。对锯齿波

取绝对值即

可得到三角

波。锯齿波的

无穷级数表

达式如下：

图

灵社区会员

heruihong

专享 尊重版

权

5.20 动手实践

：绘制锯齿波

和三角波

101 

1

2 

3

4

5 

11

6

7 

8

9 

10

5.20 动

手实践：绘制

锯齿波和三

角波

与前面

的教程中一

样，我们仍将

以相同的方

式初始化t和

k。同样，取k=99以保

证足够的精

度。绘制锯齿

波和三角波

的步骤如下

。

(1)

将函数值初

始化为0： 

t =

np.linspace(-ny.pi, np.pi, 201)

k = np.arange(1, float(sys.argv[1]))

f = np.zeros_like(t)

(2) 同样

，直接使用sin和

sum函数进行计

算： 

for

i in range(len(t)):

f[i] = np.sum(np.sin(2 *

np.pi * k *

t[i])/k) 

f =

(-2 / np.pi) *

f 

(3) 同时绘制

锯齿波和三

角波并不难

，因为三角波

函数的取值

恰好是锯齿

波函数值的

绝对值。

使用

如下代码绘

制波形： 

plot(t, f,

lw=1.0) 

plot(t, np.abs(f),

lw=2.0) 

show()

在下

图中，较粗的

曲线为三角

波。

图灵社区

会员 heruihong 专享

尊

重版权

102 第 5

章

矩阵和通用

函数

刚才做

了些什么

我

们使用sin函数

绘制了锯齿

波。函数的输

入值是用linspace产

生的，而一组

k值是用

arange函数

生成的。三角

波则是对锯

齿波取绝对

值得到的。示

例代码见sawtooth.py文

件。

import numpy as np

from matplotlib.pyplot import plot

from matplotlib.pyplot import show

import sys 

t

= np.linspace(-np.pi, np.pi, 201)

k = np.arange(1, float(sys.argv[1]))

f = np.zeros_like(t)

for i in range(len(t)):

f[i] = np.sum(np.sin(2

* np.pi * k

* t[i])/k) 

f

= (-2 / np.pi)

* f 

plot(t,

f, lw=1.0) 

plot(t,

np.abs(f), lw=2.0) 

show()

勇敢出发

：摆脱循环语

句

你是否愿

意接受挑战

，摆脱代码中

的循环语句

？使用NumPy函数应

该可以完成

这个任务，

并

且代码性能

可以翻倍。

5.21

位

操作函数和

比较函数

位

操作函数可

以在整数或

整数数组的

位上进行操

作，它们都是

通用函数。^、&、|、<<、>>

等

位操作符在

NumPy中也有对应

的部分，<、>、==等比

较运算符也

是如此。有了

这些操作符

，

你可以在代

码中玩一些

高级技巧以

提升代码的

性能。不过，它

们会使代码

变得难以理

解，因此需

谨

慎使用。

5.22 动手

实践：玩转二

进制位

我们

将学习三个

小技巧——检查

两个整数的

符号是否一

致，检查一个

数是否为2的

幂数，以

及计

算一个数被

2的幂数整除

后的余数。我

们会分别展

示两种方法

，即使用位操

作符和使用

相应

的NumPy函数

。

(1) 第一个小技

巧需要用XOR或

者^操作符。XOR操

作符又被称

为不等运算

符，因此当两

个操

作数的

符号不一致

时，XOR操作的结

果为负数。在

NumPy中，^操作符对

应于bitwise_xor函数，

<操

作符对应于

less函数。

图灵社

区会员 heruihong

专享

尊重版权

5.22 动

手实践：玩转

二进制位 103

1 

2

3 

4

5

11 

6

7

8 

9

10 

x =

np.arange(-9, 9) 

y

= -x 

print

"Sign different?", (x ^

y) < 0

print "Sign different?", np.less(np.bitwise_xor(x,

y), 0) 

结

果如下：

Sign different? [ True

True True True True

True True True True

False True True True

True True True True

True] 

Sign different?

[ True True True

True True True True

True True False True

True True 

True

True True True True]

不出

所料，除了都

等于0的情况

，所有整数对

的符号均相

异。

(2) 在二进制

数中，2的幂数

表示为一个

1后面跟一串

0的形式，例如

10、100、1000等。而比

2的幂

数小1的数表

示为一串二

进制的1，例如

11、111、1111（即十进制里

的3、7、15）等。如

果我

们在2的幂数

以及比它小

1的数之间执

行位与操作

AND，那么应该得

到0。在NumPy中，&操作

符对应于bitwise_and函

数，==操作符对

应于equal函数。 

print "Power

of 2?\n", x, "\n",

(x & (x -

1)) == 0

print "Power of 2?\n",

x, "\n", np.equal(np.bitwise_and(x, (x

- 1)), 0)

结

果如下： 

Power of

2? 

[-9 -8

-7 -6 -5 -4

-3 -2 -1 0

1 2 3 4

5 6 7 8]

[False False False False

False False False False

False True True

True 

False True

False False False True]

Power of 2?

[-9 -8 -7 -6

-5 -4 -3 -2

-1 0 1 2

3 4 5 6

7 8] 

[False

False False False False

False False False False

True True 

True

False True False False

False True] 

(3)

计算

余数的技巧

实际上只在

模为2的幂数

（如4、8、16等）时有效

。二进制的位

左移一位，

则

数值翻倍。在

前一个小技

巧中我们看

到，将2的幂数

减去1可以得

到一串1组成

的二进制数

，如

11、111、1111等。这为我

们提供了掩

码（mask），与这样的

掩码做位与

操作AND即可得

到以2

的幂数

作为模的余

数。在NumPy中，<<操作

符对应于left_shift函

数。

print "Modulus 4\n", x,

"\n", x & ((1

<< 2) - 1)

print "Modulus 4\n", x,

"\n", np.bitwise_and(x, np.left_shift(1, 2)

- 1) 

结果如下

：

Modulus 4 

[-9

-8 -7 -6 -5

-4 -3 -2 -1

0 1 2 3

4 5 6 7

8] 

[3 0

1 2 3 0

1 2 3 0

1 2 3 0

1 2 3 0]

Modulus 4 

[-9

-8 -7 -6 -5

-4 -3 -2 -1

0 1 2 3

4 5 6 7

8] 

[3 0

1 2 3 0

1 2 3 0

1 2 3 0

1 2 3 0]

图灵社区会

员 heruihong 专享 尊重

版权

104 第 5 章

矩

阵和通用函

数

刚才做了

些什么

我们

学习了三个

运用位操作

的小技巧——检

查两个整数

的符号是否

一致，检查一

个数是否为

2的幂数，以及

计算一个数

被2的幂数整

除后的余数

。我们看到了

NumPy中对应于^、&、<<、<等

操作符的通

用函数。示例

代码见bittwiddling.py文件

。

import numpy as np

x = np.arange(-9, 9)

y = -x

print "Sign different?", (x

^ y) < 0

print "Sign different?", np.less(np.bitwise_xor(x,

y), 0) 

print

"Power of 2?\n", x,

"\n", (x & (x

- 1)) == 0

print "Power of 2?\n",

x, "\n", np.equal(np.bitwise_and(x, (x

- 1)), 0)

print "Modulus 4\n", x,

"\n", x & ((1

<< 2) - 1)

print "Modulus 4\n", x,

"\n", np.bitwise_and(x, np.left_shift(1, 2)

- 1) 

5.23

本章小结

在

本章中，我们

学习了NumPy中的

矩阵和通用

函数，包括如

何创建矩阵

以及通用函

数的工作

方

式。我们还简

单介绍了算

术运算函数

、三角函数、位

操作函数和

比较函数等

通用函数。

下

一章中，我们

将开始学习

NumPy模块的相关

内容。

图灵社

区会员 heruihong 专享

尊重版权

6.2

动

手实践：计算

逆矩阵 105 

1

2 

3

4

5 

11

6

7 

8

9 

10

深入

学习NumPy模块

 NumPy中

有很多模块

是从它的前

身Numeric继承下来

的。这些模块

有一

部分在

SciPy中也有对应

的部分，并且

功能可能更

加丰富，我们

将在后续章

节

中讨论相

关内容。numpy.dual模块

包含同时在

NumPy和SciPy中定义的

函数。

在本章

中讨论的模

块也属于numpy.dual的

一部分。

本章

涵盖以下内

容：



linalg模块；

 fft模块

；



随机数；

 连续

分布和离散

分布。

6.1

线性代

数

线性代数

是数学的一

个重要分支

。numpy.linalg模块包含线

性代数的函

数。使用这个

模块，

我们可

以计算逆矩

阵、求特征值

、解线性方程

组以及求解

行列式等。

6.2

动

手实践：计算

逆矩阵

在线

性代数中，矩

阵A与其逆矩

阵A1

相乘后会

得到一个单

位矩阵I。该定

义可以写为

A *A1

=I。

numpy.linalg模块中的inv函

数可以计算

逆矩阵。我们

按如下步骤

来对矩阵求

逆。

(1) 与前面的

教程中一样

，我们将使用

mat函数创建示

例矩阵：

A = np.mat("0 1

2;1 0 3;4 -3

8") 

print "A\n",

A 

第6章

图灵社区会

员 heruihong

专享 尊重

版权

106 第

6 章 深

入学习 NumPy

模块

输出的矩阵

A如下所示：

 A

[[ 0 1 2]

[ 1 0

3] 

 [

4 -3 8]]

(2) 现

在，我们使用

inv函数计算逆

矩阵：

inverse =

np.linalg.inv(A) 

print "inverse

of A\n", inverse

输出的

逆矩阵如下

：

inverse of A

[[-4.5 7. -1.5]

[-2. 4. -1. ]

[ 1.5 -2.

0.5]] 

如果输入矩

阵是奇异的

或非方阵①，则

会抛出LinAlgError异常

。我们将此

作

为练习留给

读者，如果你

愿意，可以动

手尝试一下

。

(3) 我们来检查

一下原矩阵

和求得的逆

矩阵相乘的

结果：

print "Check\n",

A * inverse

不出所

料，结果确实

是一个单位

矩阵：

Check 

[[

1. 0. 0.]

[ 0. 1. 0.]

[ 0. 0.

1.]] 

刚才做

了些什么

我

们使用numpy.linalg模块

中的inv函数计

算了逆矩阵

，并检查了原

矩阵与求得

的逆矩阵

相

乘的结果确

为单位矩阵

。示例代码见

inversion.py文件。

import numpy as

np 

A =

np.mat("0 1 2;1 0

3;4 -3 8")

print "A\n", A

inverse = np.linalg.inv(A)

print "inverse of A\n",

inverse 

——————————

① 奇异矩

阵即行列式

等于0的矩阵

。方阵即行数

与列数一样

多的矩阵。——译

者注

图灵社

区会员 heruihong

专享

尊重版权

6.4 动

手实践：求解

线性方程组

107

1 

2

3 

4

5

11 

6

7

8 

9

10 

print "Check\n",

A * inverse

突击测验：如

何创建矩阵

问题1 以下哪

个函数可以

创建矩阵？

(1) array

(2) create_matrix

(3) mat

(4) vector

勇

敢出发：创建

新矩阵并计

算其逆矩阵

请自行创建

一个新的矩

阵并计算其

逆矩阵。注意

，你的矩阵必

须是方阵且

可逆，否则会

抛

出LinAlgError异常。

6.3 求

解线性方程

组

矩阵可以

对向量进行

线性变换，这

对应于数学

中的线性方

程组。numpy.linalg中的函

数

solve可以求解

形如

Ax = b 的线性

方程组，其中

A

为矩阵，b 为一

维或二维的

数组，x 是未知

变

量。我们将

练习使用dot函

数，用于计算

两个浮点数

数组的点积

。

6.4 动手实践：求

解线性方程

组

让我们求

解一个线性

方程组实例

，步骤如下。

(1)

创

建矩阵A和数

组b： 

A =

np.mat("1 -2 1;0 2

-8;-4 5 9")

print "A\n", A

b = np.array([0, 8,

-9]) 

print "b\n",

b 

矩阵A和数

组b如下所示

：

图灵社区会

员

heruihong 专享 尊重

版权

108

第 6 章 深

入学习

NumPy 模块

(2) 调用solve函数求

解线性方程

组：

x = np.linalg.solve(A, b)

print "Solution", x

求解结果

如下： 

Solution [

29. 16. 3.]

(3) 使用dot函

数检查求得

的解是否正

确： 

print

"Check\n", np.dot(A , x)

结果和预

期的一致： 

Check

[[ 0. 8. -9.]]

刚

才做了些什

么

我们使用

NumPy的linalg模块中的

solve函数求解了

线性方程组

，并使用dot函数

验证了求

解

的正确性。示

例代码见solution.py文

件。

import numpy as np

A = np.mat("1 -2

1;0 2 -8;-4 5

9") 

print "A\n",

A 

b =

np.array([0, 8, -9])

print "b\n", b

x = np.linalg.solve(A, b)

print "Solution", x

print "Check\n", np.dot(A ,

x) 

6.5 特征值和

特征向量

特

征值（eigenvalue）即方程

Ax = ax 的根，是一个

标量。其中，A

是

一个二维矩

阵，x 是一

个一

维向量。特征

向量（eigenvector）是关于

特征值的向

量。在numpy.linalg模块中

，eigvals

函数可以计

算矩阵的特

征值，而eig函数

可以返回一

个包含特征

值和对应的

特征向量的

元组。

6.6 动手实

践：求解特征

值和特征向

量

我们来计

算矩阵的特

征值和特征

向量，步骤如

下。

图灵社区

会员

heruihong 专享 尊

重版权

6.6

动手

实践：求解特

征值和特征

向量 109 

1

2 

3

4

5 

11

6

7 

8

9 

10

(1) 创建一

个矩阵： 

A

= np.mat("3 -2;1 0")

print "A\n", A

创建

的矩阵如下

所示： 

A

[[ 3 -2]

[ 1 0]]

(2) 调用eigvals函

数求解特征

值： 

print

"Eigenvalues", np.linalg.eigvals(A) 

求得的特

征值如下：

Eigenvalues [ 2. 1.]

(3) 使

用eig函数求解

特征值和特

征向量。该函

数将返回一

个元组，按列

排放着特征

值和对

应的

特征向量，其

中第一列为

特征值，第二

列为特征向

量。

eigenvalues, eigenvectors = np.linalg.eig(A)

print "First tuple of

eig", eigenvalues 

print

"Second tuple of eig\n",

eigenvectors 

求得的特

征值和特征

向量如下所

示：

First tuple of eig

[ 2. 1.]

Second tuple of eig

[[ 0.89442719 0.70710678]

[ 0.4472136 0.70710678]]

(4) 使用dot函数

验证求得的

解是否正确

。分别计算等

式 Ax =

ax 的左半部

分和右半部

分，

检查是否

相等。

for i in range(len(eigenvalues)):

print "Left", np.dot(A,

eigenvectors[:,i]) 

 print

"Right", eigenvalues[i] * eigenvectors[:,i]

print 

输出结

果如下：

Left [[ 1.78885438]

[ 0.89442719]] 

Right

[[ 1.78885438]

[ 0.89442719]] 

Left

[[ 0.70710678]

[ 0.70710678]] 

Right

[[ 0.70710678]

[ 0.70710678]] 

图灵

社区会员

heruihong 专

享 尊重版权

110 第

6 章 深入学

习 NumPy

模块

刚才

做了些什么

我们使用numpy.linalg模

块中的eigvals和eig函

数求解了矩

阵的特征值

和特征向量

，并

使用dot函数

进行了验证

。示例代码见

eigenvalues.py文件。

import numpy as np

A = np.mat("3 -2;1

0") 

print "A\n",

A 

print "Eigenvalues",

np.linalg.eigvals(A) 

eigenvalues, eigenvectors

= np.linalg.eig(A) 

print

"First tuple of eig",

eigenvalues 

print "Second

tuple of eig\n", eigenvectors

for i in range(len(eigenvalues)):

print "Left", np.dot(A,

eigenvectors[:,i]) 

 print

"Right", eigenvalues[i] * eigenvectors[:,i]

print 

6.7

奇异值

分解

SVD（Singular Value Decomposition，奇异值

分解）是一种

因子分解运

算，将一个矩

阵分解

为3个

矩阵的乘积

。奇异值分解

是前面讨论

过的特征值

分解的一种

推广。在numpy.linalg模块

中的svd函数可

以对矩阵进

行奇异值分

解。该函数返

回3个矩阵——U、Sigma和

V，其中U和V是

正

交矩阵，Sigma包含

输入矩阵的

奇异值。

星号

表示厄米共

轭（Hermitian conjugate）或共轭转

置（conjugate

transpose）。

6.8 动手实践

：分解矩阵

现

在，我们来对

矩阵进行奇

异值分解，步

骤如下。

(1) 首先

，创建一个矩

阵： 

A

= np.mat("4 11 14;8

7 -2") 

print

"A\n", A 

创建的矩

阵如下所示

：

A 

[[ 4

11 14]

[ 8 7 -2]]

图灵社区会

员 heruihong 专享 尊重

版权

6.8 动手实

践：分解矩阵

111 

1

2 

3

4

5 

11

6

7 

8

9 

10

(2) 使用svd函数分

解矩阵： 

U,

Sigma, V = np.linalg.svd(A,

full_matrices=False) 

print "U"

print U 

print

"Sigma" 

print Sigma

print "V" 

print

V 

得到

的结果包含

等式中左右

两端的两个

正交矩阵U和

V，以及中间的

奇异值矩阵

Sigma：

U 

[[-0.9486833 -0.31622777]

[-0.31622777 0.9486833 ]]

Sigma 

[ 18.97366596

9.48683298] 

V

[[-0.33333333 -0.66666667 -0.66666667]

[ 0.66666667 0.33333333 -0.66666667]]

(3) 不过，我们并

没有真正得

到中间的奇

异值矩阵——得

到的只是其

对角线上的

值，而非对

角

线上的值均

为0。我们可以

使用diag函数生

成完整的奇

异值矩阵。将

分解出的3个

矩阵相乘，

如

下所示：

print "Product\n", U *

np.diag(Sigma) * V

相乘

的结果如下

： 

Product

[[ 4. 11. 14.]

[ 8. 7.

-2.]] 

刚才做了些

什么

我们分

解了一个矩

阵，并使用矩

阵乘法验证

了分解的结

果。我们使用

了NumPy

linalg模块

中的

svd函数。示例代

码见decomposition.py文件。 

import

numpy as np

A = np.mat("4 11

14;8 7 -2")

print "A\n", A

U, Sigma, V =

np.linalg.svd(A, full_matrices=False) 

print

"U" 

print U

print "Sigma" 

print

Sigma 

图

灵社区会员

heruihong 专享

尊重版

权

112 第 6

章 深入

学习 NumPy 模块

print "V" 

print

V 

print "Product\n",

U * np.diag(Sigma) *

V 

6.9 广

义逆矩阵

摩

尔·彭罗斯广

义逆矩阵（Moore-Penrose pseudoinverse）可

以使用numpy.linalg模块

中的

pinv函数进

行求解（广义

逆矩阵的具

体定义请访

问http://en.wikipedia.org/wiki/Moore%E2%80%-

93Penrose_pseudoinverse）。计算广义

逆矩阵需要

用到奇异值

分解。inv函数只

接受方阵作

为输入

矩阵

，而pinv函数则没

有这个限制

。

6.10 动手实践：计

算广义逆矩

阵

我们来计

算矩阵的广

义逆矩阵，步

骤如下。

(1) 首先

，创建一个矩

阵：

A = np.mat("4 11

14;8 7 -2")

print "A\n", A

创建的矩

阵如下所示

： 

A

[[ 4 11 14]

[ 8 7

-2]] 

(2) 使用pinv函数计

算广义逆矩

阵：

pseudoinv = np.linalg.pinv(A)

print "Pseudo inverse\n", pseudoinv

计算结果

如下： 

Pseudo inverse

[[-0.00555556 0.07222222]

[ 0.02222222 0.04444444]

[ 0.05555556 -0.05555556]]

(3) 将原矩

阵和得到的

广义逆矩阵

相乘： 

print

"Check", A * pseudoinv

得到的

结果并非严

格意义上的

单位矩阵，但

非常近似，如

下所示： 

Check [[

1.00000000e+00 0.00000000e+00]

[ 8.32667268e-17 1.00000000e+00]]

图灵

社区会员 heruihong 专

享 尊重版权

6.12

动手实践：计

算矩阵的行

列式 113 

1

2 

3

4

5 

11

6

7 

8

9 

10

刚才做

了些什么

我

们使用numpy.linalg模块

中的pinv函数计

算了矩阵的

广义逆矩阵

。在验证时，用

原矩

阵与广

义逆矩阵相

乘，得到的结

果为一个近

似单位矩阵

。示例代码见

pseudoinversion.py文件。

import numpy as np

A = np.mat("4 11

14;8 7 -2")

print "A\n", A

pseudoinv = np.linalg.pinv(A)

print "Pseudo inverse\n", pseudoinv

print "Check", A *

pseudoinv 

6.11 行列式

行列式（determinant）是与

方阵相关的

一个标量值

，在数学中得

到广泛应用

（更详细的介

绍请访问http://en.wikipedia.org/wiki/Determinant）。对

于一个n×n的实

数矩阵，行列

式描述的是

一个线性变

换对“有向体

积”所造成的

影响。行列式

的值为正表

示保持了空

间的定向（顺

时针

或逆时

针），为负则表

示颠倒了空

间的定向。numpy.linalg模

块中的det函数

可以计算矩

阵的

行列式

。

6.12 动手实践：计

算矩阵的行

列式

计算矩

阵的行列式

，步骤如下。

(1) 创

建一个矩阵

：

A = np.mat("3 4;5

6") 

print "A\n",

A 

创建的矩阵

如下所示：

A 

[[ 3.

4.] 

 [

5. 6.]] 

(2)

使

用det函数计算

行列式： 

print "Determinant",

np.linalg.det(A) 

计算

结果如下：

Determinant -2.0 

图

灵社区会员

heruihong

专享 尊重版

权

114 第

6 章 深入

学习 NumPy

模块

刚

才做了些什

么

我们使用

numpy.linalg模块中的det函

数计算了矩

阵的行列式

。示例代码见

determinant.py

文件。

import numpy as np

A = np.mat("3 4;5

6") 

print "A\n",

A 

print "Determinant",

np.linalg.det(A) 

6.13 快速傅

里叶变换

FFT（Fast Fourier Transform，快

速傅里叶变

换）是一种高

效的计算DFT（Discrete Fourier

Transform，离

散傅里叶变

换）的算法。FFT算

法比根据定

义直接计算

更快，计算复

杂度为

O(NlogN) 。DFT在信

号处理、图像

处理、求解偏

微分方程等

方面都有应

用。在NumPy中，有一

个名为fft的模

块提供了快

速傅里叶变

换的功能。在

这个模块中

，许多函数都

是成对存在

的，也

就是说

许多函数存

在对应的逆

操作函数。例

如，fft和ifft函数就

是其中的一

对。

6.14 动手实践

：计算傅里叶

变换

首先，我

们将创建一

个信号用于

变换。计算傅

里叶变换的

步骤如下。

(1)

创

建一个包含

30个点的余弦

波信号，如下

所示： 

x =

np.linspace(0, 2 * np.pi,

30) 

wave =

np.cos(x) 

(2) 使用fft函

数对余弦波

信号进行傅

里叶变换。

transformed = np.fft.fft(wave)

(3) 对

变换后的结

果应用ifft函数

，应该可以近

似地还原初

始信号。 

print

np.all(np.abs(np.fft.ifft(transformed) - wave) <

10 ** -9)

结果

如下： 

True

(4) 使用Matplotlib绘

制变换后的

信号。 

plot(transformed)

show() 

图灵社

区会员 heruihong

专享

尊重版权

6.15 移

频 115

1 

2

3 

4

5

11 

6

7

8 

9

10 

绘制的结

果展示了傅

里叶变换后

的波形。

刚才

做了些什么

我们在余弦

波信号上应

用了fft函数，随

后又对变换

结果应用ifft函

数还原了信

号。示例代

码

见fourier.py文件。

import numpy as

np 

from matplotlib.pyplot

import plot, show

x = np.linspace(0, 2

* np.pi, 30)

wave = np.cos(x)

transformed = np.fft.fft(wave)

print np.all(np.abs(np.fft.ifft(transformed) - wave)

< 10 ** -9)

plot(transformed) 

show()

6.15 移频

numpy.linalg模块中的fftshift函

数可以将FFT输

出中的直流

分量移动到

频谱的中央

。

ifftshift函数则是其

逆操作。

图灵

社区会员

heruihong 专

享 尊重版权

116 第

6 章 深入学

习 NumPy

模块

6.16 动手

实践：移频

我

们将创建一

个信号用于

变换，然后进

行移频操作

，步骤如下。

(1) 创

建一个包含

30个点的余弦

波信号。 

x

= np.linspace(0, 2 *

np.pi, 30) 

wave

= np.cos(x) 

(2)

使用

fft函数对余弦

波信号进行

傅里叶变换

。 

transformed =

np.fft.fft(wave) 

(3) 使用fftshift函数进

行移频操作

。

shifted = np.fft.fftshift(transformed)

(4) 用ifftshift函数进行

逆操作，这将

还原移频操

作前的信号

。 

print

np.all((np.fft.ifftshift(shifted) - transformed) <

10 ** -9)

结果如下： 

True

(5) 使

用Matplotlib分别绘制

变换和移频

处理后的信

号。 

plot(transformed,

lw=2) 

plot(shifted, lw=3)

show() 

绘制的结

果展示了傅

里叶变换后

再做移频操

作的波形。

图

灵社区会员

heruihong

专享 尊重版

权

6.18 动手实践

：硬币赌博游

戏

117 

1

2 

3

4

5 

11

6

7 

8

9 

10

刚才做了

些什么

我们

在傅里叶变

换后的余弦

波信号上应

用了fftshift函数，随

后又应用ifftshift函

数还

原了信

号。示例代码

见fouriershift.py文件。

import numpy as np

from matplotlib.pyplot import plot,

show 

x =

np.linspace(0, 2 * np.pi,

30) 

wave =

np.cos(x) 

transformed =

np.fft.fft(wave) 

shifted =

np.fft.fftshift(transformed) 

print np.all(np.abs(np.fft.ifftshift(shifted)

- transformed) < 10

** -9) 

plot(transformed,

lw=2) 

plot(shifted, lw=3)

show() 

6.17 随机

数

随机数在

蒙特卡罗方

法（Monto Carlo method）、随机积分

等很多方面

都有应用。真

随机数的

产

生很困难，因

此在实际应

用中我们通

常使用伪随

机数。在大部

分应用场景

下，伪随机数

已经足

够随

机，当然一些

特殊应用除

外。有关随机

数的函数可

以在NumPy的random模块

中找到。随机

数发生器的

核心算法是

基于马特赛

特旋转演算

法（Mersenne Twister algorithm）的。随机数

可以

从离散

分布或连续

分布中产生

。分布函数有

一个可选的

参数size，用于指

定需要产生

的随机数

的

数量。该参数

允许设置为

一个整数或

元组，生成的

随机数将填

满指定形状

的数组。支持

的离散

分布

包括几何分

布、超几何分

布和二项分

布等。

6.18 动手实

践：硬币赌博

游戏

二项分

布是n个独立

重复的是/非

试验中成功

次数的离散

概率分布，这

些概率是固

定不变的，

与

试验结果无

关。

设想你来

到了一个17世

纪的赌场，正

在对一个硬

币赌博游戏

下8份赌注。每

一轮抛9枚硬

币，

如果少于

5枚硬币正面

朝上，你将损

失8份赌注中

的1份；否则，你

将赢得1份赌

注。我们来模

拟

一下赌博

的过程，初始

资本为1000份赌

注。为此，我们

需要使用random模

块中的binomial 

函数

。

为了理解binomial函

数的用法，请

完成如下步

骤。

(1) 初始化一

个全0的数组

来存放剩余

资本。以参数

10000调用binomial函数，意

味着我们

将

在赌场中玩

10 000轮硬币赌博

游戏。

图灵社

区会员 heruihong 专享

尊重版权

118

第

6 章 深入学习

NumPy 模块

cash = np.zeros(10000)

cash[0] = 1000

outcome = np.random.binomial(9, 0.5,

size=len(cash)) 

(2) 模拟每

一轮抛硬币

的结果并更

新cash数组。打印

出outcome的最小值

和最大值，以

检查

输出中

是否有任何

异常值： 

for i

in range(1, len(cash)):

if outcome[i] < 5:

cash[i] = cash[i

- 1] - 1

elif outcome[i] <

10: 

 cash[i]

= cash[i - 1]

+ 1

else: 

 raise

AssertionError("Unexpected outcome " +

outcome) 

print outcome.min(),

outcome.max() 

不出

所料，所有的

结果值都在

0~9之间：

0 9 

(3)

使用Matplotlib绘

制cash数组： 

plot(np.arange(len(cash)), cash)

show() 

从下

图中可以看

到，我们的剩

余资本呈随

机游走（random walk）状态

。

刚才做了些

什么

我们使

用NumPy random模块中的

binomial函数模拟了

随机游走。示

例代码见headortail.py

文

件。

图灵社区

会员 heruihong 专享 尊

重版权

6.20 动手

实践：模拟游

戏秀节目 119

1 

2

3 

4

5

11 

6

7

8 

9

10 

import numpy

as np 

from

matplotlib.pyplot import plot, show

cash = np.zeros(10000)

cash[0] = 1000

outcome = np.random.binomial(9, 0.5,

size=len(cash)) 

for i

in range(1, len(cash)):

if outcome[i] < 5:

cash[i] = cash[i

- 1] - 1

elif outcome[i] <

10: 

 cash[i]

= cash[i - 1]

+ 1

else: 

 raise

AssertionError("Unexpected outcome " +

outcome) 

print outcome.min(),

outcome.max() 

plot(np.arange(len(cash)), cash)

show() 

6.19 超

几何分布

超

几何分布（hypergeometric distribution）是

一种离散概

率分布，它描

述的是一个

罐子里有

两

种物件，无放

回地从中抽

取指定数量

的物件后，抽

出指定种类

物件的数量

。NumPy random模

块中的hypergeometric函

数可以模拟

这种分布。

6.20 动

手实践：模拟

游戏秀节目

设想有这样

一个游戏秀

节目，每当参

赛者回答对

一个问题，他

们可以从一

个罐子里摸

出3个

球并放

回。罐子里有

一个“倒霉球

”，一旦这个球

被摸出，参赛

者会被扣去

6分。而如果他

们摸出

的3个

球全部来自

其余的25个普

通球，那么可

以得到1分。因

此，如果一共

有100道问题被

正确回

答，得

分情况会是

怎样的呢？为

了解决这个

问题，请完成

如下步骤。

(1) 使

用hypergeometric函数初始

化游戏的结

果矩阵。该函

数的第一个

参数为罐中

普通球

的数

量，第二个参

数为“倒霉球

”的数量，第三

个参数为每

次采样（摸球

）的数量。 

points =

np.zeros(100) 

outcomes =

np.random.hypergeometric(25, 1, 3, size=len(points))

(2) 根据

上一步产生

的游戏结果

计算相应的

得分。 

for

i in range(len(points)):

if outcomes[i] == 3:

points[i] = points[i

- 1] + 1

elif outcomes[i] ==

2: 

 points[i]

= points[i - 1]

- 6 

图灵社

区会员

heruihong 专享

尊重版权

120 第

6

章 深入学习

NumPy 模块

else: 

 print

outcomes[i] 

(3) 使用Matplotlib绘

制points数组。

plot(np.arange(len(points)), points) 

show()

下图

展示了得分

的变化情况

。

刚才做了些

什么

我们使

用NumPy random模块中的

hypergeometric函数模拟了

一个游戏秀

节目。这个游

戏

的得分取

决于每一轮

从罐子里摸

出的球的种

类。示例代码

见urn.py文件。 

import numpy

as np 

from

matplotlib.pyplot import plot, show

points = np.zeros(100)

outcomes = np.random.hypergeometric(25, 1,

3, size=len(points)) 

for

i in range(len(points)):

if outcomes[i] == 3:

points[i] = points[i

- 1] + 1

elif outcomes[i] ==

2: 

 points[i]

= points[i - 1]

- 6

else: 

 print

outcomes[i] 

plot(np.arange(len(points)), points)

show() 

图灵

社区会员 heruihong

专

享 尊重版权

6.22 动手实践：绘

制正态分布

121

1 

2

3 

4

5

11 

6

7

8 

9

10 

6.21 连续分布

连

续分布可以

用PDF（Probability Density Function，概率密度

函数）来描述

。随机变量落

在某

一区间

内的概率等

于概率密度

函数在该区

间的曲线下

方的面积。NumPy的

random模块中有一

系列

连续分

布的函数——beta、chisquare、exponential、f、gamma、gumbel、laplace、lognormal、

logistic、multivariate_normal、noncentral_chisquare、noncentral_f、normal等

。

6.22 动手实践：绘

制正态分布

随机数可以

从正态分布

中产生，它们

的直方图能

够直观地刻

画正态分布

。按照如下步

骤绘制

正态

分布。

(1) 使用NumPy random模

块中的normal函数

产生指定数

量的随机数

。

N=10000 

normal_values =

np.random.normal(size=N) 

(2) 绘制分布直

方图和理论

上的概率密

度函数（均值

为0、方差为1的

正态分布）曲

线。我们

将使

用Matplotlib进行绘图

。 

dummy, bins,

dummy = plt.hist(normal_values, np.sqrt(N),

normed=True, lw=1) 

sigma

= 1 

mu

= 0 

plt.plot(bins,

1/(sigma * np.sqrt(2 *

np.pi)) * np.exp( -

(bins -mu)**2 / (2

* 

sigma**2) ),lw=2)

plt.show() 

从下图中，我

们可以看到

熟悉的钟形

曲线。

图灵社

区会员

heruihong 专享

尊重版权

122 第

6

章 深入学习

NumPy 模块

刚才做

了些什么

我

们画出了NumPy random模

块中的normal函数

模拟的正态

分布。我们将

该函数生成

的

随机数绘

制成分布直

方图，并同时

绘制了标准

正态分布的

钟形曲线。示

例代码见normaldist.py

文

件。 

import numpy

as np 

import

matplotlib.pyplot as plt

N=10000 

normal_values =

np.random.normal(size=N) 

dummy, bins,

dummy = plt.hist(normal_values, np.sqrt(N),

normed=True, lw=1) 

sigma

= 1 

mu

= 0 

plt.plot(bins,

1/(sigma * np.sqrt(2 *

np.pi)) * np.exp( -

(bins -mu)**2 / (2

* 

sigma**2) ),lw=2)

plt.show() 

6.23 对数正态

分布

对数正

态分布（lognormal distribution） 是自

然对数服从

正态分布的

任意随机变

量的概率分

布。NumPy random模块中的

lognormal函数模拟了

这个分布。

6.24 动

手实践：绘制

对数正态分

布

我们绘制

出对数正态

分布的概率

密度函数以

及对应的分

布直方图，步

骤如下。

(1)

使用

NumPy random模块中的normal函

数产生随机

数。 

N=10000

lognormal_values = np.random.lognormal(size=N)

(2) 绘制分布

直方图和理

论上的概率

密度函数（均

值为0、方差为

1）。我们将使用

Matplotlib进

行绘图。

dummy, bins, dummy =

plt.hist(lognormal_values,np.sqrt(N), normed=True, lw=1)

sigma = 1

mu = 0

x = np.linspace(min(bins), max(bins),

len(bins)) 

pdf =

np.exp(-(numpy.log(x) - mu)**2 /

(2 * sigma**2))/ (x

*sigma * np.sqrt(2 *

np.pi)) 

plt.plot(x, pdf,lw=3)

plt.show() 

如

你所见，直方

图和理论概

率密度函数

的曲线吻合

得很好。

图灵

社区会员

heruihong 专

享 尊重版权

6.25 本章小结

123 

1

2 

3

4

5 

11

6

7 

8

9 

10

刚

才做了些什

么

我们画出

了NumPy random模块中的

lognormal函数模拟的

对数正态分

布。我们将该

函数生

成的

随机数绘制

成分布直方

图，并同时绘

制了理论上

的概率密度

函数曲线。示

例代码见

lognormaldist.py文

件。 

import numpy

as np 

import

matplotlib.pyplot as plt

N=10000 

lognormal_values =

np.random.lognormal(size=N) 

dummy, bins,

dummy = plt.hist(lognormal_values, np.sqrt(N),normed=True,

lw=1) 

sigma =

1 

mu =

0 

x =

np.linspace(min(bins), max(bins), len(bins))

pdf = np.exp(-(np.log(x) -

mu)**2 / (2 *

sigma**2))/ (x * sigma

* np.sqrt(2 * np.pi))

plt.plot(x, pdf,lw=3) 

plt.show()

6.25 本章小结

在本章中，我

们学习了很

多NumPy模块的知

识，涵盖了线

性代数、快速

傅里叶变换

、连续分

布和

离散分布以

及随机数等

内容。

在下一

章中，我们将

学习一些专

用函数。这些

函数可能不

会经常用到

，但当你需要

时会非常

有

用。

图灵社区

会员 heruihong 专享

尊

重版权

124 第 7

章

专用函数

专

用函数

作为

NumPy用户，我们有

时会发现自

己在金融计

算或信号处

理方面有一

些特殊的需

求。幸运的是

，NumPy能满足我们

的大部分需

求。本章将讲

述

NumPy中的部分

专用函数。

本

章涵盖以下

内容：

 排序和

搜索；



特殊函

数；

 金融函数

；



窗口函数。

7.1 排

序

NumPy提供了多

种排序函数

，如下所示：

 sort函

数返回排序

后的数组；

 lexsort函

数根据键值

的字典序进

行排序；

 argsort函数

返回输入数

组排序后的

下标；

 ndarray类的sort方

法可对数组

进行原地排

序；

 msort函数沿着

第一个轴排

序；

 sort_complex函数对复

数按照先实

部后虚部的

顺序进行排

序。

在上面的

列表中，argsort和sort函

数可用来对

NumPy数组类型进

行排序。

7.2 动手

实践：按字典

序排序

NumPy中的

lexsort函数返回输

入数组按字

典序排序后

的下标。我们

需要给lexsort函数

提

第7章

图灵

社区会员 heruihong 专

享

尊重版权

7.2 动手实践：按

字典序排序

125 

1

2 

3

4

5 

11

6

7 

8

9 

10

供排序所依

据的键值数

组或元组。步

骤如下。

(1) 回顾

一下第3章中

我们使用的

AAPL股价数据，现

在我们要将

这些很久以

前的数据用

在完

全不同

的地方。我们

将载入收盘

价和日期数

据。是的，处理

日期总是很

复杂，我们为

其准备了专

门的转换函

数。

def datestr2num(s):

return datetime.datetime.strptime (s, "%d-%m-%Y").toordinal()

dates,closes=np.loadtxt('AAPL.csv', delimiter=',',

usecols=(1,6), converters={1:datestr2num}, unpack=True)

(2) 使用lexsort函数

排序。数据本

身已经按照

日期排序，不

过我们现在

优先按照收

盘价

排序：

indices = np.lexsort((dates, closes))

print "Indices", indices

print ["%s %s" %

(datetime.date.fromordinal(dates[i]), closes[i]) for i

in indices] 

输

出结果如下

：

['2011-01-28 336.1', '2011-02-22 338.61',

'2011-01-31 339.32', 

'2011-02-23

342.62', '2011-02-24 342.88', '2011-02-03

343.44', 

'2011-02-02 344.32',

'2011-02-01 345.03', '2011-02-04 346.5',

'2011-03-10 346.67', '2011-02-25 348.16',

'2011-03-01 349.31', 

'2011-02-18

350.56', '2011-02-07 351.88', '2011-03-11

351.99', 

'2011-03-02 352.12',

'2011-03-09 352.47', '2011-02-28 353.21',

'2011-02-10 354.54', '2011-02-08 355.2',

'2011-03-07 355.36', 

'2011-03-08

355.76', '2011-02-11 356.85', '2011-02-09

358.16', 

'2011-02-17 358.3',

'2011-02-14 359.18', '2011-03-03 359.56',

'2011-02-15 359.9', '2011-03-04 360.0',

'2011-02-16 363.13'] 

刚才做了些

什么

我们使

用NumPy中的lexsort函数

对AAPL的收盘价

数据进行了

排序。该函数

返回了排序

后

的数组下

标。示例代码

见lex.py文件。 

import

numpy as np

import datetime 

def

datestr2num(s): 

 return

datetime.datetime.strptime(s, "%d-%m-%Y").toordinal() 

dates,closes=np.loadtxt('AAPL.csv',

delimiter=',', usecols=(1, 6),

converters={1:datestr2num}, unpack=True) 

indices

= np.lexsort((dates, closes))

print "Indices", indices

print ["%s %s" %

(datetime.date.fromordinal(int(dates[i])), 

closes[i]) for

i in indices]

图灵

社区会员 heruihong 专

享 尊重版权

126

第 7 章 专用函

数

勇敢出发

：尝试不同的

排序次序

我

们按照收盘

价和日期的

顺序进行了

排序。请尝试

不同的排序

次序。使用我

们在上一章

中

学习的random模

块生成随机

数并用lexsort对它

们进行排序

。

7.3 复数

复数包

含实数部分

和虚数部分

。如同在前面

的章节中提

到的，NumPy中有专

门的复数类

型，

使用两个

浮点数来表

示复数。这些

复数可以使

用NumPy的sort_complex函数进

行排序。该函

数

按照先实

部后虚部的

顺序排序。

7.4 动

手实践：对复

数进行排序

我们将创建

一个复数数

组并进行排

序，步骤如下

。

(1)

生成5个随机

数作为实部

，5个随机数作

为虚部。设置

随机数种子

为42： 

np.random.seed(42)

complex_numbers = np.random.random(5) +

1j * np.random.random(5)

print "Complex numbers\n", complex_numbers

(2) 调用sort_complex函数

对上面生成

的复数进行

排序： 

print

"Sorted\n", np.sort_complex(complex_numbers) 

排序后

的结果如下

：

Sorted 

[ 0.39342751+0.34955771j

0.40597665+0.77477433j 

0.41516850+0.26221878j

0.86631422+0.74612422j 0.92293095+0.81335691j] 

刚才做了些

什么

我们生

成了随机的

复数并使用

sort_complex函数对它们

进行了排序

。示例代码见

sortcomplex.py文件。 

import numpy

as np 

np.random.seed(42)

complex_numbers = np.random.random(5) +

1j * np.random.random(5)

print "Complex numbers\n", complex_numbers

print "Sorted\n", np.sort_complex(complex_numbers)

图灵社

区会员 heruihong 专享

尊重版权

7.6

动

手实践：使用

searchsorted 函数 127

1 

2

3 

4

5

11 

6

7

8 

9

10 

突击测

验：生成随机

数

问题1

以下

哪一个NumPy模块

可以生成随

机数？

(1) randnum

(2)

random

(3) randomutil

(4)

rand

7.5 搜索

NumPy中

有多个函数

可以在数组

中进行搜索

，如下所示。

 argmax函

数返回数组

中最大值对

应的下标。 

>>>

a = np.array([2, 4,

8]) 

>>> np.argmax(a)

2 

 nanargmax函

数提供相同

的功能，但忽

略NaN值。

>>> b = np.array([np.nan,

2, 4]) 

>>>

np.nanargmax(b) 

2

 argmin和nanargmin函数

的功能类似

，只不过换成

了最小值。

 argwhere函

数根据条件

搜索非零的

元素，并分组

返回对应的

下标。

>>> a = np.array([2,

4, 8]) 

>>>

np.argwhere(a <= 4)

array([[0], 

 [1]])

 searchsorted函数可

以为指定的

插入值寻找

维持数组排

序的索引位

置。该函数使

用二分

搜索

算法，计算复

杂度为O(log(n))。我们

随后将具体

学习这个函

数。



extract函数返回

满足指定条

件的数组元

素。

7.6 动手实践

：使用 searchsorted

函数

searchsorted函

数为指定的

插入值返回

一个在有序

数组中的索

引位置，从这

个位置插入

可

以保持数

组的有序性

。下面的例子

可以解释得

更清楚。请完

成如下步骤

。

(1)

我们需要一

个排序后的

数组。使用arange函

数创建一个

升序排列的

数组： 

图灵社

区会员 heruihong

专享

尊重版权

128 第

7 章

专用函数

a = np.arange(5)

(2) 现在，我们来

调用searchsorted函数： 

indices

= np.searchsorted(a, [-2, 7])

print "Indices", indices

下

面的索引即

可以维持数

组排序的插

入位置： 

Indices [0

5] 

(3) 使用

insert函数构建完

整的数组：

print "The full array",

np.insert(a, indices, [-2, 7])

结

果如下： 

The full

array [-2 0 1

2 3 4 7]

刚才

做了些什么

searchsorted函数为7和2返

回了索引5和

0。用这些索引

作为插入位

置，我们生成

了数组

[-2, 0, 1,

2, 3, 4, 7]，这样

就维持了数

组的排序。示

例代码见sortedsearch.py文

件。

import numpy as np

a = np.arange(5)

indices = np.searchsorted(a, [-2,

7]) 

print "Indices",

indices 

print "The

full array", np.insert(a, indices,

[-2, 7]) 

7.7

数组元素

抽取

NumPy的extract函数

可以根据某

个条件从数

组中抽取元

素。该函数和

我们在第3章

中遇到

过的

where函数相似。nonzero函

数专门用来

抽取非零的

数组元素。

7.8

动

手实践：从数

组中抽取元

素

我们要从

一个数组中

抽取偶数元

素，步骤如下

。

(1) 使用arange函数创

建数组：

a = np.arange(7)

(2) 生成

选择偶数元

素的条件变

量： 

condition

= (a % 2)

== 0 

图灵社区

会员

heruihong 专享 尊

重版权

7.9

金融

函数 129 

1

2 

3

4

5 

11

6

7 

8

9 

10

(3) 使用extract函

数基于生成

的条件从数

组中抽取元

素： 

print

"Even numbers", np.extract(condition, a)

输出数组

中的偶数元

素，如下所示

： 

Even numbers

[0 2 4 6]

(4) 使用nonzero函数抽

取数组中的

非零元素： 

print

"Non zero", np.nonzero(a)

输

出结果如下

： 

Non zero

(array([1, 2, 3, 4,

5, 6]),) 

刚才做了些

什么

我们使

用extract函数根据

一个指定的

布尔条件从

数组中抽取

了偶数元素

。示例代码见

extracted.py文件。 

import numpy

as np 

a

= np.arange(7) 

condition

= (a % 2)

== 0 

print

"Even numbers", np.extract(condition, a)

print "Non zero", np.nonzero(a)

7.9 金融函

数

NumPy中有很多

金融函数，如

下所示。



fv函数

计算所谓的

终值（future value），即基于

一些假设给

出的某个金

融资产在未

来某一

时间

点的价值。



pv函

数计算现值

（present value），即金融资产

当前的价值

。

 npv函数返回的

是净现值（net

present value），即

按折现率计

算的净现金

流之和。

 pmt函数

根据本金和

利率计算每

期需支付的

金额。

 irr函数计

算内部收益

率（internal rate of

return）。内部收益

率是是净现

值为0时的有

效利

率，不考

虑通胀因素

。

 mirr函数计算修

正后内部收

益率（modified

internal rate of return），是内部

收益率的改

进

版本。

 nper函数

计算定期付

款的期数。



rate函

数计算利率

（rate of interest）。

图灵社区会

员

heruihong 专享 尊重

版权

130

第 7 章 专

用函数

7.10 动手

实践：计算终

值

终值是基

于一些假设

给出的某个

金融资产在

未来某一时

间点的价值

。终值决定于

4个参

数——利率

、期数、每期支

付金额以及

现值。在本节

的教程中，我

们以利率3%、每

季度支付金

额10、存款周期

5年以及现值

1

000为参数计算

终值。

使用正

确的参数调

用fv函数，计算

终值： 

print

"Future value", np.fv(0.03/4, 5

* 4, -10, -1000)

结果如

下： 

Future value

1376.09633204 

这相当于

利率3%的5年期

存款并且每

季度额外存

入10个单位的

资金。如果我

们改变存款

的年

数并保

持其他参数

不变，将得到

如下的散点

图。

刚才做了

些什么

我们

以利率3%、每季

度支付金额

10、存款周期5年

以及现值1 000为

参数，使用NumPy中

的

fv函数计算

了终值。我们

针对不同的

存款周期绘

制了终值的

散点图。示例

代码见futurevalue.py

文件

。 

图灵社区会

员 heruihong

专享 尊重

版权

7.13 净现值

131

1 

2

3 

4

5

11 

6

7

8 

9

10 

import numpy

as np 

from

matplotlib.pyplot import plot, show

print "Future value", np.fv(0.03/4,

5 * 4, -10,

-1000) 

fvals =

[] 

for i

in xrange(1, 10):

fvals.append(np.fv(.03/4, i * 4,

-10, -1000)) 

plot(fvals,

'bo') 

show()

7.11 现值

现值（present value）是

指资产在当

前时刻的价

值。NumPy中的pv函数

可以计算现

值。该函

数和

fv函数是镜像

对称的，同样

需要利率、期

数、每期支付

金额这些参

数，不过这里

输入为终值

，

输出为现值

。

7.12 动手实践：计

算现值

我们

来进行逆向

计算——使用前

一节教程中

的数值计算

现值。

使用7.10节

使用的数值

来计算现值

。 

print

"Present value", np.pv(0.03/4, 5

* 4, -10, 1376.09633204)

除去微小的

数值误差，我

们预期的计

算结果应该

为1000。而实际上

，这里有一个

表示形式上

的问题。由于

我们计算的

是支出的现

金流，因此结

果前面有一

个负号。 

Present value

-999.999999999 

刚才

做了些什么

我们对上一

节教程中的

终值进行了

逆向计算，得

到了现值。这

是用NumPy中的pv函

数完

成的。

7.13 净

现值

净现值

（net present

value）定义为按折

现率计算的

净现金流之

和。NumPy中的npv函数

返回

净现值

。该函数需要

两个参数，即

利率和一个

表示现金流

的数组。

图灵

社区会员 heruihong

专

享 尊重版权

132 第 7

章 专用函

数

7.14 动手实践

：计算净现值

我们将为一

组随机生成

的现金流计

算净现值。步

骤如下。

(1) 生成

5个随机数作

为现金流的

取值。插入-100作

为初始值。 

cashflows

= np.random.randint(100, size=5)

cashflows = np.insert(cashflows, 0,

-100) 

print "Cashflows",

cashflows 

生

成的现金流

如下所示：

Cashflows [-100 38 48

90 17 36]

(2) 根

据上一步生

成的现金流

数据，调用npv函

数计算净现

值。利率按3%计

算。 

print

"Net present value", np.npv(0.03,

cashflows) 

计算出的

净现值如下

：

Net present value 107.435682443

刚才做了些

什么

我们使

用npv函数为一

组随机生成

的现金流数

据计算了净

现值。示例代

码见netpresentvalue.py

文件。

import numpy as np

cashflows = np.random.randint(100, size=5)

cashflows = np.insert(cashflows, 0,

-100) 

print "Cashflows",

cashflows 

print "Net

present value", np.npv(0.03, cashflows)

7.15 内

部收益率

内

部收益率（internal rate

of return）是

净现值为0时

的有效利率

，不考虑通胀

因素。NumPy

中的irr函

数根据给定

的现金流数

据返回对应

的内部收益

率。

7.16

动手实践

：计算内部收

益率

这里我

们复用7.14节中

的现金流数

据。 

图灵社区

会员

heruihong 专享 尊

重版权

7.19

付款

期数 133 

1

2 

3

4

5 

11

6

7 

8

9 

10

使用之

前教程中生

成的现金流

数组，调用irr函

数。 

print "Internal

rate of return", np.irr([-100,

38, 48, 90, 17,

36]) 

计算出的

内部收益率

如下：

Internal rate of return

0.373420226888 

刚才做

了些什么

我

们使用之前

的“动手实践

”教程中生成

的现金流数

据，计算了对

应的内部收

益率。这是用

NumPy中的irr函数完

成的。

7.17 分期付

款

NumPy中的pmt函数

可以根据利

率和期数计

算贷款每期

所需支付的

资金。

7.18

动手实

践：计算分期

付款

假设你

贷款100万，年利

率为10%，要用30年

时间还完贷

款，那么每月

你必须支付

多少资金

呢

？我们来计算

一下。

使用刚

才提到的参

数值，调用pmt函

数。

print "Payment", np.pmt(0.10/12, 12

* 30, 1000000)

计算出的

月供如下所

示： 

Payment -8775.71570089

刚才做了

些什么

我们

计算了贷款

100万、年利率10%的

情况下的月

供金额。设定

还款时间为

30年，pmt函数告

诉

我们每月需

要偿还的资

金为8 775.715

700 89。

7.19 付款期

数

NumPy中的nper函数

可以计算分

期付款所需

的期数。所需

的参数为贷

款利率、固定

的月供

以及

贷款额。

图灵

社区会员 heruihong

专

享 尊重版权

134 第 7

章 专用函

数

7.20 动手实践

：计算付款期

数

考虑贷款

9 000，年利率10%，每月

固定还款为

100的情形。

通过

nper函数计算出

付款期数。

print "Number of payments",

np.nper(0.10/12, -100, 9000)

计

算出的付款

期数如下： 

Number of

payments 167.047511801 

刚

才做了些什

么

我们计算

了贷款9000、年利

率10%、每月固定

还款100的情形

下所需的付

款期数。结果

为167

个月。

7.21 利率

NumPy中的rate函数根

据给定的付

款期数、每期

付款资金、现

值和终值计

算利率。

7.22 动手

实践：计算利

率

我们使用

7.20节中的数值

进行逆向计

算，由其他参

数得出利率

。

填入之前教

程中的数值

作为参数。

print "Interest rate", 12

* np.rate(167, -100, 9000,

0) 

如

我们所料，计

算出的利率

约为10%。

Interest rate 0.0999756420664

刚才做

了些什么

我

们使用了NumPy的

rate函数和之前

的“动手实践

”教程中的数

值，计算了贷

款利率。忽

略

舍入误差，我

们得到了原

先的利率10%。

7.23

窗

函数

窗函数

（window function）是信号处理

领域常用的

数学函数，相

关应用包括

谱分析和滤

波器设

图灵

社区会员

heruihong 专

享 尊重版权

7.25 布莱克曼窗

135

1 

2

3 

4

5

11 

6

7

8 

9

10 

计等。这些窗

函数除在给

定区间之外

取值均为0。NumPy中

有很多窗函

数，如bartlett、blackman、

hamming、hanning和kaiser。关于

hanning函数的例子

可以在第4章

和第3章中找

到。

7.24 动手实践

：绘制巴特利

特窗

巴特利

特窗（Bartlett window）是一种

三角形平滑

窗。按如下步

骤绘制巴特

利特窗。

(1) 调用

NumPy中的bartlett函数，以

计算巴特利

特窗。 

window

= np.bartlett(42) 

(2)

使用Matplotlib绘

制巴特利特

窗，非常简单

。 

plot(window)

show() 

绘制结果如

下图所示，形

状确实为三

角形。

刚才做

了些什么

我

们使用NumPy中的

bartlett函数绘制了

巴特利特窗

。

7.25 布莱克曼窗

布莱克曼窗

（Blackman

window）形式上为三

项余弦值的

加和，如下所

示：

图灵社区

会员 heruihong 专享

尊

重版权

136 第 7

章

专用函数

NumPy中

的blackman函数返回

布莱克曼窗

。该函数唯一

的参数为输

出点的数量

。如果数量

为

0或小于0，则返

回一个空数

组。

7.26

动手实践

：使用布莱克

曼窗平滑股

价数据

我们

对AAPL股价的小

数据文件中

的收盘价数

据进行平滑

处理。完成如

下步骤。

(1) 将数

据载入NumPy数组

。调用blackman函数生

成一个平滑

窗并用它来

平滑股价数

据。

closes=np.loadtxt('AAPL.csv', delimiter=',', usecols=(6,),

converters={1:datestr2num}, unpack=True) 

N

= int(sys.argv[1]) 

window

= np.blackman(N) 

smoothed

= np.convolve(window/window.sum(), closes, mode='same')

(2) 使用Matplotlib绘制

平滑后的股

价图。在这个

例子中，我们

将省略最前

面5个和最后

面5个

数据点

。这是由于存

在很强的边

界效应。

plot(smoothed[N:-N], lw=2, label="smoothed")

plot(closes[N:-N], label="closes") 

legend(loc='best')

show() 

经过

布莱克曼窗

平滑后的AAPL收

盘价数据如

下所示。

图灵

社区会员

heruihong 专

享 尊重版权

7.28 动手实践：绘

制汉明窗

137 

1

2 

3

4

5 

11

6

7 

8

9 

10

刚

才做了些什

么

我们使用

NumPy中的blackman函数生

成的布莱克

曼窗对AAPL收盘

价数据进行

了平滑处

理

，并用Matplotlib绘制了

平滑前后的

股价图。示例

代码见plot_blackman.py文件

。

import numpy as np

from matplotlib.pyplot import plot,

show, legend 

from

matplotlib.dates import datestr2num

import sys 

closes=np.loadtxt('AAPL.csv',

delimiter=',', usecols=(6,), 

converters={1:datestr2num},

unpack=True) 

N =

int(sys.argv[1]) 

window =

np.blackman(N) 

smoothed =

np.convolve(window/window.sum(), closes, mode='same')

plot(smoothed[N:-N], lw=2, label="smoothed")

plot(closes[N:-N], label="closes") 

legend(loc='best')

show() 

7.27 汉明窗

汉明

窗（Hamming window）形式上是

一个加权的

余弦函数。公

式如下所示

。 

2

( ) 0.54 0.46cos

0 1 1

n

w n n M

M

  

   

   

≤ ≤

NumPy中的hamming函数返

回汉明窗。该

函数唯一的

参数为输出

点的数量。如

果数量为0或

小于0，则返回

一个空数组

。

7.28

动手实践：绘

制汉明窗

我

们来绘制汉

明窗。完成如

下步骤。

(1) 调用

hamming函数，以计算

汉明窗：

window = np.hamming(42)

(2) 使用

Matplotlib绘制汉明窗

：

plot(window)

show() 

绘制结果如

下图所示。

刚

才做了些什

么

我们使用

NumPy中的hamming函数绘

制了汉明窗

。

图灵社区会

员 heruihong

专享 尊重

版权

138 第

7 章 专

用函数

7.29

凯泽

窗

凯泽窗（Kaiser window）是

以贝塞尔函

数（Bessel function）定义的，公

式如下所示

。

2

0 0 2

4 () 1 /

( ) ( 1)

n wn I I

M  



   

   

 

这里的I0即为

零阶的贝塞

尔函数。NumPy中的

kaiser函数返回凯

泽窗。该函数

的第一个参

数为输出点

的数量。如果

数量为0或小

于0，则返回一

个空数组。第

二个参数为

β值。

7.30

动手实践

：绘制凯泽窗

我们来绘制

凯泽窗。完成

如下步骤。

(1) 调

用kaiser函数，以计

算凯泽窗：

window

= np.kaiser(42, 14)

(2) 使

用Matplotlib绘制凯泽

窗：

plot(window)

show() 

图灵社区

会员 heruihong

专享 尊

重版权

7.32 动手

实践：绘制修

正的贝塞尔

函数

139 

1

2 

3

4

5 

11

6

7 

8

9 

10

绘制结

果如下图所

示。

刚才做了

些什么

我们

使用NumPy中的kaiser函

数绘制了凯

泽窗。

7.31

专用数

学函数

我们

将以一些专

用数学函数

结束本章的

内容。贝塞尔

函数（Bessel function）是贝塞

尔微分

方程

的标准解函

数（详见http://en.wikipedia.org/wiki/Bessel_function）。在NumPy中

，以i0

表示第

一

类修正的零

阶贝塞尔函

数。sinc函数在NumPy中

有同名函数

sinc，并且该函数

也有一个二

维

版本。sinc是一

个三角函数

，更多详细内

容请访问http://en.wikipedia.org/wiki/Sinc_function。

7.32

动

手实践：绘制

修正的贝塞

尔函数

我们

来看看第一

类修正的零

阶贝塞尔函

数绘制出来

是什么形状

。

(1) 使用NumPy的linspace函数

生成一组均

匀分布的数

值。

x = np.linspace(0, 4,

100) 

图灵社区

会员 heruihong

专享 尊

重版权

140 第

7 章

专用函数

(2) 调

用i0函数进行

计算：

vals = np.i0(x)

(3) 使用Matplotlib绘

制修正的贝

塞尔函数： 

plot(x,

vals) 

show()

绘

制结果如下

图所示。 

刚才

做了些什么

我们使用NumPy中

的i0函数绘制

了第一类修

正的零阶贝

塞尔函数。

7.33

sinc 函

数

sinc函数在数

学和信号处

理领域被广

泛应用。NumPy中有

同名函数sinc，并

且也存在一

个

二维版本

。

7.34 动手实践：绘

制 sinc 函数

我们

将绘制sinc函数

。完成如下步

骤。

图灵社区

会员 heruihong 专享

尊

重版权

7.34 动手

实践：绘制 sinc

函

数 141 

1

2 

3

4

5 

11

6

7 

8

9 

10

(1) 使用NumPy的linspace函

数生成一组

均匀分布的

数值。 

x

= np.linspace(0, 4, 100)

(2) 调用sinc函

数进行计算

： 

vals

= np.sinc(x) 

(3)

使用Matplotlib绘制sinc函

数： 

plot(x, vals)

show() 

绘制结果

如下图所示

。

sinc2d函数需要输

入一个二维

数组。我们可

以用outer函数生

成二维数组

，便得到下图

。 

刚才做了些

什么

我们使

用NumPy中的sinc函数

绘制了著名

的sinc函数。示例

代码见plot_sinc.py文件

。

import numpy as np

from matplotlib.pyplot import plot,

show 

x =

np.linspace(0, 4, 100)

vals = np.sinc(x)

plot(x, vals) 

show()

图灵社区会

员 heruihong 专享 尊重

版权

142 第 7 章

专

用函数

我们

用相同的方

法绘制了二

维的sinc函数。示

例代码见sinc2d.py文

件。

import numpy

as np 

from

matplotlib.pyplot import imshow, show

x = np.linspace(0, 4,

100) 

xx =

np.outer(x, x) 

vals

= np.sinc(xx) 

imshow(vals)

show() 

7.35 本章小结

本章介绍了

一些专用性

较强的NumPy功能

，包括排序和

搜索、专用函

数、金融函数

以及窗函

数

等。

在下一章

中，我们将学

习非常重要

的程序测试

方面的知识

。

图灵社区会

员 heruihong

专享 尊重

版权

8.1 断言函

数

143 

1

2 

3

4

5 

11

6

7 

8

9 

10

质量控制

有些程序员

只在产品中

做测试。如果

你不是他们

中的一员，你

可能会对

单

元测试的概

念耳熟能详

。单元测试是

由程序员编

写的自动测

试模块，用来

测试他或者

她的代码。这

些单元测试

可以测试某

个函数或函

数中的某个

独立

的部分

。每一个单元

测试仅仅对

一小部分代

码进行测试

。单元测试可

以带来

诸多

好处，如提高

代码质量、可

重复性测试

等，使软件副

作用更为清

晰。

Python 本身对单

元测试就有

良好的支持

。此外， NumPy 中也有

numpy.testing包可以支持

NumPy代码的单元

测试。

TDD（Test Driven Development，测试驱

动的开发）是

软件开发史

上最重要的

里程碑之一

。

TDD主要专注于

自动单元测

试，它的目标

是尽最大限

度自动化测

试代码。如果

代码被改动

，我们

仍可以

运行测试并

捕捉可能存

在的问题。换

言之，测试对

于已经存在

的功能模块

依然有效。

本

章涵盖以下

内容：

 单元测

试；

 断言机制

；

 浮点数精度

。

8.1 断言函数

单

元测试通常

使用断言函

数作为测试

的组成部分

。在进行数值

计算时，我们

经常遇到比

较两

个近似

相等的浮点

数这样的基

本问题。整数

之间的比较

很简单，但浮

点数却非如

此，这是由于

计

算机对浮

点数的表示

本身就是不

精确的。numpy.testing包中

有很多实用

的工具函数

考虑了浮

点

数比较的问

题，可以测试

前提是否成

立。

第8章

图灵

社区会员

heruihong 专

享 尊重版权

144 第

8 章 质量控

制

函

数 描 述

assert_almost_equal

如果两个数

字的近似程

度没有达到

指定精度，就

抛出异常

assert_approx_equal 如

果两个数字

的近似程度

没有达到指

定有效数字

，就抛出异常

assert_array_almost_equal 如果两个数

组中元素的

近似程度没

有达到指定

精度，就抛出

异常

assert_array_equal 如果两

个数组对象

不相同，就抛

出异常

assert_array_less 两个

数组必须形

状一致，并且

第一个数组

的元素严格

小于第二个

数组的元素

，否则

就抛出

异常

assert_equal 如果两

个对象不相

同，就抛出异

常

assert_raises

若用填写

的参数调用

函数没有抛

出指定的异

常，则测试不

通过

assert_warns 若没有

抛出指定的

警告，则测试

不通过

assert_string_equal

断言

两个字符串

变量完全相

同

assert_allclose 如果两个

对象的近似

程度超出了

指定的容差

限，就抛出异

常

8.2

动手实践

：使用 assert_almost_equal 断言近

似相等

假设

你有两个很

接近的数字

。我们用assert_almost_equal函数

来检查它们

是否近似

相

等。

(1) 调用函数

，指定较低的

精度（小数点

后7位）：

print "Decimal 6", np.testing.assert_almost_equal(0.123456789,

0.123456780, 

decimal=7)

注意，这

里没有抛出

异常，如下所

示： 

Decimal 6

None 

(2) 调用函数

，指定较高的

精度（小数点

后8位）：

print "Decimal 7", np.testing.assert_almost_equal(0.123456789,

0.123456780, 

decimal=8)

结果如

下： 

Decimal 7

Traceback (most recent call

last): 

 ...

raiseAssertionError(msg) 

AssertionError:

Arrays are not almost

equal 

 ACTUAL:

0.123456789 

 DESIRED:

0.12345678 

图灵社区

会员 heruihong

专享 尊

重版权

8.4 动手

实践：使用

assert_approx_equal 断

言近似相等

145 

1

2 

3

4

5 

11

6

7 

8

9 

10

刚才做了些

什么

我们使

用NumPy testing包中的assert_almost_equal函

数在不同的

精度要求下

检查了

两个

浮点数0.123456789和0.123456780是

否近似相等

。

突击测验：指

定精度

问题

1 以下哪一个

是assert_almost_equal函数的参

数，用来指定

小数点后的

精度？

(1)

decimal

(2) precision

(3)

tolerance

(4) significant

8.3 近似相

等

如果两个

数字的近似

程度没有达

到指定的有

效数字要求

，assert_approx_equal函数将抛

出

异常。该函数

触发异常的

条件如下：

abs(actual - expected) >=

10**-(significant - 1)

8.4 动

手实践：使用

assert_approx_equal 断言近似相

等

我们仍使

用前面“动手

实践”教程中

的数字，并使

用assert_approx_equal函数对它

们进

行比较

。

(1) 调用函数，指

定较低的有

效数字位：

print "Significance 8", np.testing.assert_approx_equal(0.123456789,

0.123456780,significant=8) 

结

果如下：

Significance 8 None

(2) 调用

函数，指定较

高的有效数

字位： 

print

"Significance 9", np.testing.assert_approx_equal(0.123456789, 0.123456780,

significant=9) 

抛出了

一个异常：

Significance 9 

Traceback

(most recent call last):

图

灵社区会员

heruihong 专享 尊重版

权

146

第 8 章 质量

控制

... 

raiseAssertionError(msg)

AssertionError: 

Items are

not equal to 9

significant digits:

ACTUAL: 0.123456789

DESIRED: 0.12345678 

刚才做

了些什么

我

们使用numpy.testing包中

的assert_approx_equal函数在不

同的精度要

求下检查了

两个浮点数

0.123456789和0.123456780是否近似

相等。 

8.5 数组近

似相等

如果

两个数组中

元素的近似

程度没有达

到指定的精

度要求， assert_array_ 

almost_equal函数

将抛出异常

。该函数首先

检查两个数

组的形状是

否一致，然后

逐一比较两

个

数组中的

元素：

|expected - actual|

< 0.5 10-decimal

8.6 动手实

践：断言数组

近似相等

我

们使用前面

“动手实践”教

程中的数字

，并各加上一

个0来构造两

个数组。

(1)

调用

函数，指定较

低的精度： 

print "Decimal

8", np.testing.assert_array_almost_equal([0, 0.123456789], [0,

0.123456780], decimal=8) 

结

果如下：

Decimal 8 None

(2) 调用

函数，指定较

高的精度： 

print

"Decimal 9", np.testing.assert_array_almost_equal([0, 0.123456789],

[0, 

0.123456780], decimal=9)

抛

出了一个异

常： 

Decimal 9

Traceback (most recent call

last): 

 ...

assert_array_compare 

raiseAssertionError(msg)

AssertionError: 

图灵社区

会员 heruihong

专享 尊

重版权

8.8 动手

实践：比较数

组

147 

1

2 

3

4

5 

11

6

7 

8

9 

10

Arrays are not almost

equal 

(mismateh 50.0%)

x: array([ 0. ,

0.12345679]) 

y: array([

0. , 0.12345678])

刚才做了

些什么

我们

使用NumPy中的assert_array_almost_equal函

数比较了两

个数组。

勇敢

出发：比较形

状不一致的

数组

使用NumPy的

assert_array_almost_equal函数比较两

个形状不一

致的数组。

8.7 数

组相等

如果

两个数组对

象不相同，assert_array_equal函

数将抛出异

常。两个数组

相等必须形

状一致且元

素也严格相

等，允许数组

中存在NaN元素

。

此外，比较数

组也可以使

用assert_allclose函数。该函

数有参数atol（absolute

tolerance，

绝

对容差限）和

rtol（relative tolerance，相对容差限

）。对于两个数

组a和b，将测试

是否满足以

下等式：

|a

- b| <= (atol

+ rtol * |b|)

8.8 动手

实践：比较数

组

我们使用

刚刚提到的

函数来比较

两个数组。我

们仍使用前

面“动手实践

”教程中的数

组，并

增加一

个NaN元素。

(1) 调用

assert_allclose函数： 

print

"Pass", np.testing.assert_allclose([0, 0.123456789, np.nan],

[0, 0.123456780, 

np.nan],

rtol=1e-7, atol=0) 

结果如

下：

Pass None 

(2)

调用assert_array_equal函数

： 

print "Fail",

np.testing.assert_array_equal([0, 0.123456789, np.nan], [0,

0.123456780, 

np.nan])

图灵社区会

员 heruihong 专享 尊重

版权

148 第 8 章

质

量控制

抛出

了一个异常

： 

Fail

Traceback (most recent call

last): 

 ...

assert_array_compare 

raiseAssertionError(msg)

AssertionError: 

Arrays are

not equal 

(mismatch

50.0%) 

x: array([

0. ,0.12345679, nan]

y: array([ 0. ,0.12345678,

nan]) 

刚才做了些

什么

我们分

别使用assert_allclose和assert_array_equal函

数比较了两

个数组。

8.9 数组

排序

两个数

组必须形状

一致并且第

一个数组的

元素严格小

于第二个数

组的元素，否

则assert_

array_less函数将抛

出异常。

8.10 动手

实践：核对数

组排序

我们

来检查一个

数组是否严

格大于另一

个数组。

(1) 调用

assert_array_less函数比较两

个有严格顺

序的数组： 

print

"Pass", np.testing.assert_array_less([0, 0.123456789, np.nan],

[1, 0.23456780, 

np.nan])

结

果如下： 

Pass None

(2) 调用

assert_array_less函数，使测试

不通过： 

print

"Fail", np.testing.assert_array_less([0, 0.123456789, np.nan],

[0, 0.123456780, 

np.nan])

抛出

了一个异常

： 

Fail

Traceback (most recent call

last): 

 ...

raiseAssertionError(msg) 

AssertionError:

图灵社区会

员 heruihong 专享 尊重

版权

8.13 字符串

比较 149

1 

2

3 

4

5

11 

6

7

8 

9

10 

Arrays are

not less-ordered 

(mismatch

100.0%) 

x: array([

0. , 0.12345679, nan])

y: array([ 0. ,

0.12345678, nan]) 

刚才做

了些什么

我

们使用assert_array_less函数

比较了两个

数组的大小

顺序。

8.11 对象比

较

如果两个

对象不相同

，assert_equal函数将抛出

异常。这里的

对象不一定

为NumPy数组，

也可

以是Python中的列

表、元组或字

典。

8.12 动手实践

：比较对象

假

设你需要比

较两个元组

。我们可以用

assert_equal函数来完成

。

(1) 调用assert_equal函数： 

print

"Equal?", np.testing.assert_equal((1, 2), (1,

3)) 

抛

出了一个异

常：

Equal? 

Traceback (most

recent call last):

... 

raiseAssertionError(msg)

AssertionError: 

Items are

not equal: 

item=1

ACTUAL: 2

DESIRED: 3 

刚才做了

些什么

我们

使用assert_equal函数比

较了两个元

组——两个元组

并不相同，因

此抛出了异

常。 

8.13 字符串比

较

assert_string_equal函数断言

两个字符串

变量完全相

同。如果测试

不通过，将会

抛出异

常并

显示两个字

符串之间的

差异。该函数

区分字符大

小写。

图灵社

区会员 heruihong

专享

尊重版权

150 第

8 章

质量控制

8.14 动手实践：比

较字符串

比

较两个均为

NumPy的字符串。

(1)

调

用assert_string_equal函数，比较

一个字符串

和其自身。显

然，该测试应

通过： 

print "Pass",

np.testing.assert_string_equal("NumPy", "NumPy") 

测试通

过：

Pass None 

(2)

调用assert_string_equal函数

，比较一个字

符串和另一

个字母完全

相同但大小

写有

区别的

字符串。该测

试应抛出异

常： 

print

"Fail", np.testing.assert_string_equal("NumPy", "Numpy")

抛出了一

个异常： 

Fail

Traceback (most recent call

last): 

 ...

raiseAssertionError(msg) 

AssertionError: Differences

in strings: 

-

NumPy? ^ 

+

Numpy? ^ 

刚才

做了些什么

我们使用assert_string_equal函

数比较了两

个字符串。当

字符大小写

不匹配时抛

出

异常。 

8.15 浮点

数比较

浮点

数在计算机

中是以不精

确的方式表

示的，这给比

较浮点数带

来了问题。NumPy中

的

assert_array_almost_equal_nulp和assert_array_max_ulp函数可

以提供可靠

的浮点数

比

较功能。ULP是Unit of

Least Precision的

缩写，即浮点

数的最小精

度单位。根据

IEEE 754标准，

四则运

算的误差必

须保持在半

个ULP之内。你可

以用刻度尺

来做对比。公

制刻度尺的

刻度通常精

确到毫米，而

更高精度的

部分只能估

读，误差上界

通常认为是

最小刻度值

的一半，即半

毫米。

机器精

度（machine epsilon）是指浮点

运算中的相

对舍入误差

上界。机器精

度等于ULP相对

于1的值。NumPy中的

finfo函数可以获

取机器精度

。Python标准库也可

以给出机器

精度值，并

应

该与NumPy给出的

结果一致。

图

灵社区会员

heruihong

专享 尊重版

权

8.18 动手实践

：设置

maxulp 并比较

浮点数 151

1 

2

3 

4

5

11 

6

7

8 

9

10 

8.16 动手

实践：使用

assert_array_almost_equal_nulp 比

较

浮点数

我

们在实践中

学习assert_array_almost_equal_nulp函数。

(1) 使

用finfo函数确定

机器精度： 

eps

= np.finfo(float).eps 

print

"EPS", eps 

精

度如下：

EPS 2.22044604925e-16 

(2)

使用

assert_array_almost_equal_nulp函数比较两

个近似相等

的浮点数1.0和

1.0 

+ eps（epsilon），然后对1.0

+ 2 * eps做同

样的比较：

print "1", 

np.testing.assert_array_almost_equal_nulp(1.0,

1.0 + eps)

print "2", 

np.testing.assert_array_almost_equal_nulp(1.0,

1.0 + 2 *

eps) 

结

果如下：

1 None 

2

Traceback (most recent call

last): 

 ...

assert_array_almost_equal_nulp 

raiseAssertionError(msg)

AssertionError: X and Y

are not equal to

1 ULP (max is

2) 

刚才

做了些什么

我们使用finfo函

数获取了机

器精度。随后

，我们使用assert_array_almost_equal_nulp

函

数比较了1.0和

1.0

+ eps，测试通过，再

加上一个机

器精度则抛

出了异常。 

8.17

多

ULP 的浮点数比

较

assert_array_max_ulp函数可以

指定ULP的数量

作为允许的

误差上界。参

数maxulp接受

整数

作为ULP数量的

上限，默认值

为1。

8.18 动手实践

：设置 maxulp 并比较

浮点数

我们

仍使用前面

“动手实践”教

程中比较的

浮点数，但在

需要的时候

设置maxulp为2。

图灵

社区会员 heruihong 专

享

尊重版权

152 第 8 章

质量控

制

(1) 使用finfo函数

确定机器精

度：

eps = np.finfo(float).eps

print "EPS", eps

精度如下

： 

EPS 2.22044604925e-16

(2) 与前面的“动

手实践”教程

做相同的比

较，但这里我

们使用assert_array_max_ulp函

数

和适当的maxulp参

数值：

print "1", np.testing.assert_array_max_ulp(1.0, 1.0

+ eps) 

print

"2", np.testing.assert_array_max_ulp(1.0, 1 +

2 * eps, maxulp=2)

输出结

果如下： 

1 1.0

2 2.0 

刚才

做了些什么

我们仍比较

了前面“动手

实践”教程中

的浮点数，但

在第二次比

较时将maxulp设置

为2。我

们使用

assert_array_max_ulp函数和适当

的maxulp参数值通

过了比较测

试，并返回了

指定的

ULP数量

。 

8.19

单元测试

单

元测试是对

代码的一小

部分进行自

动化测试的

单元，通常是

一个函数或

方法。Python中有

用

于单元测试

的PyUnit API（Application

Programming Interface，应用程序

编程接口）。作

为NumPy

用户，我们

还可以使用

前面学习过

的断言函数

。

8.20

动手实践：编

写单元测试

我们将为一

个简单的阶

乘函数编写

测试代码，检

查所谓的程

序主逻辑以

及非法输入

的情况。

(1) 首先

，我们编写一

个阶乘函数

：

def factorial(n):

if n == 0:

return 1

if n < 0:

raise ValueError, "Unexpected

negative value"

return np.arange(1, n+1).cumprod()

图灵社区会

员 heruihong 专享 尊重

版权

8.20 动手实

践：编写单元

测试 153

1 

2

3 

4

5

11 

6

7

8 

9

10 

代码中

使用了我们

已经掌握的

创建数组和

累乘计算函

数arange和cumprod，并增加

了一些

边界

条件的判断

。

(2) 现在我们来

编写单元测

试。编写一个

包含单元测

试的类，继承

Python标准库unittest模

块

中的TestCase类。我们

对阶乘函数

进行如下调

用测试：

 一个

正数，测试程

序主逻辑；

 测

试边界条件

0；

 测试负数，应

抛出异常。

class FactorialTest(unittest.TestCase):

def test_factorial(self):

# 计

算3的阶乘，测

试通过

 self.assertEqual(6,

factorial(3)[-1]) 

 np.testing.assert_equal(np.array([1,

2, 6]), factorial(3))

def test_zero(self):

# 计算

0的阶乘，测试

通过

 self.assertEqual(1,

factorial(0)) 

 def

test_negative(self): 

 #

计算负

数的阶乘，测

试不通过

 # 这

里应抛出ValueError异

常，但我们断

言其抛出IndexError异

常

self.assertRaises(IndexError, factorial(-10)) 

我们有意

使得其中一

项测试不通

过，输出结果

如下所示：



python unit_test.py 

.E.

==================================================================================

==== 

ERROR:

test_negative (__main__.FactorialTest) 

----------------------------------------------------------------------------------

---- 

Traceback (most

recent call last):

File "unit_test.py", line 26,

in test_negative 

self.assertRaises(IndexError,

factorial(-10)) 

 File

"unit_test.py", line 9, in

factorial 

raiseValueError, "Unexpected

negative value" 

ValueError:

Unexpected negative value

----------------------------------------------------------------------------------

---- 

Ran

3 tests in 0.003s

FAILED (errors=1) 

刚才做了些

什么

我们对

阶乘函数的

程序主逻辑

代码进行了

测试，并有意

使得边界条

件的测试不

通过。示例代

码见unit_test.py文件。 

图

灵社区会员

heruihong 专享

尊重版

权

154 第 8

章 质量

控制

import numpy

as np 

import

unittest 

def factorial(n):

if n ==

0: 

 return

1 

 if

n < 0:

raise ValueError, "Unexpected negative

value" 

 return

np.arange(1, n+1).cumprod() 

class

FactorialTest(unittest.TestCase): 

 def

test_factorial(self): 

 #

计算3的

阶乘，测试通

过

 self.assertEqual(6, factorial(3)[-1])

np.testing.assert_equal(np.array([1, 2, 6]),

factorial(3)) 

def test_zero(self):

# 计算0的阶

乘，测试通过

self.assertEqual(1,

factorial(0)) 

def test_negative(self):

# 计算负数的

阶乘，测试不

通过

# 这里应

抛出ValueError异常，但

我们断言其

抛出IndexError异常

 self.assertRaises(IndexError,

factorial(-10)) 

if _name_

== '_main_':

unittest.main() 

8.21 nose

和

测试装饰器

鼻子（nose）是长在

嘴上方的器

官，人和动物

的呼吸和闻

都依赖于它

。nose同时也是一

种

Python框架，使得

（单元）测试更

加容易。nose可以

帮助你组织

测试代码。根

据nose的文档，“任

何能够匹配

testMatch正则表达式

（默认为(?:^|[b_.-])[Tt]est）的Python源

代码文件、文

件夹或库都

将被收集用

于测试”。nose充分

利用了装饰

器（decorator）。Python装饰器是

有一定含

义

的对函数或

方法的注解

。numpy.testing模块中有很

多装饰器。

装

饰

器 描 述

numpy.testing.decorators.deprecated

在

运行测试时

过滤掉过期

警告

numpy.testing.decorators.knownfailureif 根据条

件抛出KnownFailureTest异常

numpy.testing.decorators.setastest 将函数标记

为测试函数

或非测试函

数

numpy.testing.decorators. skipif 根据条件

抛出SkipTest异常

numpy.testing.decorators.slow

将

测试函数标

记为“运行缓

慢”

图灵社区

会员 heruihong 专享

尊

重版权

8.22 动手

实践：使用测

试装饰器 155

1 

2

3 

4

5

11 

6

7

8 

9

10 

此

外，我们还可

以调用decorate_methods函数

，将装饰器应

用到能够匹

配正则表达

式或

字符串

的类方法上

。

8.22 动手实践：使

用测试装饰

器

我们将直

接在测试函

数上使用setastest装

饰器。我们在

另一个方法

上也使用该

装饰器，

但将

其禁用。此外

，我们还将跳

过一个测试

，并使得另一

个测试不通

过。如果你仍

未安装nose，

请先

完成安装步

骤。

(1) 使用setuptools安装

nose：

easy_install nose 

或者使用pip安

装：

pip install nose

(2) 我们将一

个函数用于

测试，另一个

不用于测试

。 

@setastest(False)

def test_false():

pass 

@setastest(True)

def test_true():

pass 

(3) 我们可以使

用skipif装饰器跳

过测试。这里

，我们使用一

个条件使得

该测试总是

被跳过。

@skipif(True) 

def test_skip():

pass 

(4)

添加

一个空函数

用于测试，并

使用knownfailureif装饰器

使得该测试

总是不通过

。 

@knownfailureif(True)

def test_alwaysfail():

pass 

(5) 定义一些可

以被nose执行的

函数和对应

的测试类：

class TestClass():

def test_true2(self):

pass 

class TestClass2():

def test_false2(self):

pass 

(6) 我

们将上一步

的第二个函

数在测试中

禁用：

图灵社

区会员 heruihong 专享

尊重版权

156

第

8 章 质量控制

decorate_methods(TestClass2, setastest(False),

'test_false2') 

(7) 执行如下命

令，运行测试

：

nosetests -v decorator_setastest.py

decorator_setastest.TestClass.test_true2 ... ok

decorator_setastest.test_true ... ok

decorator_test.test_skip ... SKIP: Skipping

test: test_skipTest 

skipped

due to test condition

decorator_test.test_alwaysfail ... ERROR

==================================================================================

==== 

ERROR:

decorator_test.test_alwaysfail 

----------------------------------------------------------------------------------

----

Traceback (most recent call

last): 

 File

".../nose/case.py", line 197, in

runTest 

self.test(*self.arg)

File ".../numpy/testing/decorators.py", line 213,

in knownfailer 

raiseKnownFailureTest(msg)

KnownFailureTest: Test skipped due

to known failure

----------------------------------------------------------------------------------

---- 

Ran

4 tests in 0.001s

FAILED (SKIP=1, errors=1)

刚才做了些

什么

我们使

用装饰器将

一些函数和

方法在测试

中禁用，使得

它们被nose忽略

。我们还直接

使用

装饰器

和decorate_methods函数跳过

了一个测试

，并使得另一

个测试不通

过。示例代码

见

decorator_test.py文件。

from numpy.testing.decorators import setastest

from numpy.testing.decorators import skipif

from numpy.testing.decorators import knownfailureif

from numpy.testing import decorate_methods

@setastest(False) 

def test_false():

pass 

@setastest(True)

def test_true():

pass 

@skipif(True)

def test_skip():

pass 

@knownfailureif(True)

图灵

社区会员 heruihong 专

享 尊重版权

8.24

动手实践：执

行文档字符

串测试 157 

1

2 

3

4

5 

11

6

7 

8

9 

10

def test_alwaysfail():

pass 

class TestClass():

def test_true2(self):

pass 

class TestClass2():

def test_false2(self):

pass 

decorate_methods(TestClass2, setastest(False),

'test_false2') 

8.23 文档

字符串

文档

字符串（docstring）是内

嵌在Python代码中

的类似交互

式会话的字

符串。这些字

符串可以

用

于某些测试

，也可以仅用

于提供使用

示例。numpy.testing模块中

有一个函数

可以运行这

些测试。

8.24 动手

实践：执行文

档字符串测

试

我们来编

写一个简单

的计算阶乘

的例子，但不

考虑所有的

边界条件。换

言之，编写一

些测试

不能

通过的例子

。

(1) 文档字符串

看起来就像

你在Python

shell中看到

的文本一样

（包括命令提

示符）。我们将

有

意使得其

中一项测试

不通过，看看

会发生什么

。 

"""

Test for the factorial

of 3 that should

pass. 

>>> factorial(3)

6 

Test for

the factorial of 0

that should fail.

>>> factorial(0) 

1

""" 

(2) 我们将用下

面这一行NumPy代

码来计算阶

乘：

return np.arange(1, n+1).cumprod()[-1]

为了演示

目的，这行代

码有时会出

错。

(3) 我们可以

在Python shell中通过调

用numpy.testing模块的rundocs函

数，从而执行

文档

字符串

测试。 

>>>from numpy.testing

import rundocs 

>>>rundocs('docstringtest.py')

图灵社

区会员 heruihong 专享

尊重版权

158

第

8 章 质量控制

Traceback (most

recent call last):

File "<stdin>", line 1,

in <module>

File ".../numpy/testing/utils.py", line 998,

in rundocs 

raiseAssertionError("Some

doctests failed:\n%s" % "\n".join(msg))

AssertionError: Some doctests failed:

********************************************************************** 

****

File "docstringtest.py", line 10,

in docstringtest.factorial 

Failed

example: 

factorial(0)

Exception raised: 

Traceback

(most recent call last):

File ".../doctest.py", line

1254, in_run compileflags, 1)

in test.globs

File "<doctestdocstringtest.factorial[1]>", line 1,

in <module> 

factorial(0)

File "docstringtest.py", line

13, in factorial

return np.arange(1, n+1).cumprod()[-1]

IndexError: index -1 is

out of bounds for

axis 0 with size

0 

刚才做了些

什么

我们编

写了一个文

档字符串测

试，在对应的

阶乘函数中

没有考虑0和

负数的情况

。我们使用

numpy.testing模

块中的rundocs函数

执行了测试

，并得到了“索

引错误”的结

果。示例代码

见docstringtest.py文件。 

import numpy

as np 

def

factorial(n): 

 """

Test for the

factorial of 3 that

should pass.

>>> factorial(3)

6 

 Test

for the factorial of

0 that should fail.

>>> factorial(0)

1 

 """

return np.arange(1, n+1).cumprod()[-1]

8.25 本章

小结

在本章

中，我们学习

了代码测试

和NumPy中的测试

工具。 涵盖的

内容包括单

元测试、文档

字符串测试

、断言函数和

浮点数精度

。大部分NumPy断言

函数都与浮

点数精度有

关。我们演示

了

可以被nose使

用的Numpy装饰器

的用法。装饰

器使得测试

更加容易使

用，并体现开

发者的意图

。

下一章将要

讨论的是Matplotlib——开

源的Python科学可

视化和绘图

工具库。

图灵

社区会员 heruihong

专

享 尊重版权

9.2 动手实践：绘

制多项式函

数 159

1 

2

3 

4

5

11 

6

7

8 

9

10 

使用Matplotlib绘图

Matplotlib是一个非常

有用的Python绘图

库。它和NumPy结合

得很好，但

本

身是一个单

独的开源项

目。你可以访

问http://matplotlib.sourceforge.net/

gallery.html查看美妙

的示例图库

。

Matplotlib中有一些功

能函数可以

从雅虎财经

频道下载并

处理数据。我

们

将看到几

个股价图的

例子。

本章涵

盖以下内容

：

 简单绘图；

 子

图；

 直方图；

 定

制绘图；

 三维

绘图；

 等高线

图；

 动画；

 对数

坐标图。

9.1 简单

绘图

matplotlib.pyplot包中包

含了简单绘

图功能。需要

记住的是，随

后调用的函

数都会改变

当前的绘图

。最终，我们会

将绘图存入

文件或使用

show函数显示出

来。不过如果

我们用的是

运

行在Qt或Wx后

端的IPython，图形将

会交互式地

更新，而不需

要等待show函数

的结果。这类

似于

屏幕上

输出文本的

方式，可以源

源不断地打

印出来。

9.2 动手

实践：绘制多

项式函数

为

了说明绘图

的原理，我们

来绘制多项

式函数的图

像。我们将使

用NumPy的多项式

函数

第9章

图

灵社区会员

heruihong 专享 尊重版

权

160 第 9 章

使用

Matplotlib 绘图

poly1d来创建

多项式。

(1)

以自

然数序列作

为多项式的

系数，使用poly1d函

数创建多项

式。 

func =

np.poly1d(np.array([1, 2, 3, 4]).astype(float))

(2) 使用NumPy的linspace函

数创建x轴的

数值，在-10和10之

间产生30个均

匀分布的值

。 

x

= np.linspace(-10, 10, 30)

(3) 计算我们在

第一步中创

建的多项式

的值。 

y

= func(x) 

(4)

调用plot函

数，这并不会

立刻显示函

数图像。 

plt.plot(x, y)

(5) 使用

xlabel函数添加x轴

标签。 

plt.xlabel('x')

(6) 使用ylabel函

数添加y轴标

签。 

plt.ylabel('y(x)')

(7) 调用show函数

显示函数图

像。 

plt.show()

绘制的多

项式函数如

下图所示。

图

灵社区会员

heruihong 专享 尊重版

权

9.4 动手实践

：绘制多项式

函数及其导

函数 161

1 

2

3 

4

5

11 

6

7

8 

9

10 

刚才做

了些什么

我

们绘制了多

项式函数的

图像并显示

在屏幕上。我

们对x轴和y轴

添加了文本

标签。示例代

码

见polyplot.py文件。 

import numpy

as np 

import

matplotlib.pyplot as plt

func = np.poly1d(np.array([1, 2,

3, 4]).astype(float)) 

x

= np.linspace(-10, 10, 30)

y = func(x)

plt.plot(x, y) 

plt.xlabel('x')

plt.ylabel('y(x)') 

plt.show()

突

击测验：plot函数

问题1 plot函数的

作用是什么

？

(1) 在屏幕上显

示二维绘图

的结果

(2) 将二

维绘图的结

果存入文件

(3) 1和2都是

(4)

1、2、3都不

是 

9.3 格式字符

串

plot函数可以

接受任意个

数的参数。在

前面一节中

，我们给了两

个参数。我们

还可以使用

可选的格式

字符串参数

指定线条的

颜色和风格

，默认为b-即蓝

色实线。你可

以指定为其

他颜色和

风

格，如红色虚

线。

9.4 动手实践

：绘制多项式

函数及其导

函数

我们来

绘制一个多

项式函数，以

及使用derive函数

和参数m为1得

到的其一阶

导函数。我们

已经在之前

的“动手实践

”教程中完成

了第一部分

。我们希望用

两种不同风

格的曲线来

区分两条

函

数曲线。

(1) 创建

多项式函数

及其导函数

。

func = np.poly1d(np.array([1, 2,

3, 4]).astype(float) 

func1

= func.deriv(m=1) 

图灵社区会

员

heruihong 专享 尊重

版权

162

第 9 章 使

用

Matplotlib 绘图

x =

np.linspace(-10, 10, 30)

y = func(x)

y1 = func1(x)

(2)以两

种不同风格

绘制多项式

函数及其导

函数：红色圆

形和绿色虚

线。你可能无

法在本书

的

印刷版中看

到彩色图像

，因此只能自

行尝试绘制

图像。 

plt.plot(x,

y, 'ro', x, y1,

'g--') 

plt.xlabel('x')

plt.ylabel('y') 

plt.show()

绘制结

果如下图所

示。 

刚才做了

些什么

我们

使用两种不

同风格的曲

线绘制了一

个多项式函

数及其导函

数，并只调用

了一次plot函

数

。示例代码见

polyplot2.py文件。 

import numpy

as np 

import

matplotlib.pyplot as plt

func = np.poly1d(np.array([1, 2,

3, 4]).astype(float)) 

func1

= func.deriv(m=1) 

x

= np.linspace(-10, 10, 30)

y = func(x)

y1 = func1(x)

图灵社

区会员 heruihong 专享

尊重版权

9.6

动

手实践：绘制

多项式函数

及其导函数

163 

1

2 

3

4

5 

11

6

7 

8

9 

10

plt.plot(x, y, 'ro', x,

y1, 'g--') 

plt.xlabel('x')

plt.ylabel('y') 

plt.show()

9.5 子图

绘图时

可能会遇到

图中有太多

曲线的情况

，而你希望分

组绘制它们

。这可以使用

subplot

函数完成。

9.6 动

手实践：绘制

多项式函数

及其导函数

我们来绘制

一个多项式

函数及其一

阶和二阶导

函数。为了使

绘图更加清

晰，我们将绘

制3张

子图。

(1)

创

建多项式函

数及其导函

数。 

func =

np.poly1d(np.array([1, 2, 3, 4]).astype(float))

x = np.linspace(-10, 10,

30) 

y =

func(x) 

func1 =

func.deriv(m=1) 

y1 =

func1(x) 

func2 =

func.deriv(m=2) 

y2 =

func2(x) 

(2) 使用subplot函数

创建第一个

子图。该函数

的第一个参

数是子图的

行数，第二个

参数

是子图

的列数，第三

个参数是一

个从1开始的

序号。另一种

方式是将这

3个参数结合

成一个数

字

，如311。这样，子图

将被组织成

3行1列。设置子

图的标题为

Polynomial，使用红色实

线

绘制。

plt.subplot(311) 

plt.plot(x, y,

'r-') 

plt.title("Polynomial")

(3) 使用

subplot函数创建第

二个子图。设

置子图的标

题为First Derivative，使用蓝

色

三角形绘

制。

plt.subplot(312) 

plt.plot(x, y1,

'b^') 

plt.title("First Derivative")

(4) 使用subplot函数

创建第三个

子图。设置子

图的标题为

Second Derivative，使用绿

色圆

形绘制。

plt.subplot(313) 

plt.plot(x, y2,

'go') 

图灵

社区会员 heruihong

专

享 尊重版权

164 第 9

章 使用 Matplotlib 绘

图

plt.title("Second Derivative") 

plt.xlabel('x')

plt.ylabel('y') 

plt.show()

以1、2、3、4为系数

的多项式函

数，及其一阶

和二阶导数

的图像如以

下3个子图所

示。 

刚才做了

些什么

我们

使用3种不同

风格的曲线

在3张子图中

分别绘制了

一个多项式

函数及其一

阶和二阶导

函

数，子图排

列成3行1列。示

例代码见polyplot3.py文

件。 

import numpy

as np 

import

matplotlib.pyplot as plt

func = np.poly1d(np.array([1, 2,

3, 4]).astype(float)) 

x

= np.linspace(-10, 10, 30)

y = func(x)

func1 = func.deriv(m=1)

y1 = func1(x)

func2 = func.deriv(m=2)

y2 = func2(x)

plt.subplot(311) 

plt.plot(x, y,

'r-' ) 

plt.title("Polynomial")

图灵社区

会员 heruihong 专享 尊

重版权

9.8 动手

实践：绘制全

年股票价格

165 

1

2 

3

4

5 

11

6

7 

8

9 

10

plt.subplot(312) 

plt.plot(x, y1,

'b^') 

plt.title("First Derivative")

plt.subplot(313) 

plt.plot(x, y2,

'go') 

plt.title("Second Derivative")

plt.xlabel('x') 

plt.ylabel('y')

plt.show() 

9.7 财经

Matplotlib可以帮

助我们监控

股票投资。使

用matplotlib.finance包中的函

数可以从雅

虎

财经频道

（http://finance.yahoo.com/）下载股价数

据，并绘制成

K线图（candlestick）。

9.8 动手实

践：绘制全年

股票价格

我

们可以使用

matplotlib.finance包绘制全年

的股票价格

。获取数据源

需要连接到

雅虎

财经频

道。

(1) 将当前的

日期减去1年

作为起始日

期。

from matplotlib.dates import DateFormatter

from matplotlib.dates import DayLocator

from matplotlib.dates import MonthLocator

from matplotlib.finance import quotes_historical_yahoo

from matplotlib.finance import candlestick

import sys 

from

datetime import date

import matplotlib.pyplot as plt

today = date.today()

start = (today.year -

1, today.month, today.day)

(2) 我们需要

创建所谓的

定位器（locator），这些

来自matplotlib.dates包中的

对象可以在

x轴上定位月

份和日期。 

alldays

= DayLocator() 

months

= MonthLocator() 

(3)

创

建一个日期

格式化器（date formatter）以

格式化x轴上

的日期。该格

式化器将创

建一个

字符

串，包含简写

的月份和年

份。

month_formatter = DateFormatter("%b %Y")

(4) 从雅虎财

经频道下载

股价数据。 

quotes

= quotes_historical_yahoo(symbol, start, today)

图

灵社区会员

heruihong 专享 尊重版

权

166

第 9 章 使用

Matplotlib

绘图

(5) 创建一

个Matplotlib的figure对象——这

是绘图组件

的顶层容器

。

fig = plt.figure()

(6) 增加一个子

图。 

ax

= fig.add_subplot(111) 

(7)

将x轴上的

主定位器设

置为月定位

器。该定位器

负责x轴上较

粗的刻度。 

ax.xaxis.set_major_locator(months)

(8) 将

x轴上的次定

位器设置为

日定位器。该

定位器负责

x轴上较细的

刻度。 

ax.xaxis.set_minor_locator(alldays)

(9) 将x轴上

的主格式化

器设置为月

格式化器。该

格式化器负

责x轴上较粗

刻度的标签

。 

ax.xaxis.set_major_formatter(month_formatter)

(10) matplotlib.finance包中的一个

函数可以绘

制K线图。这样

，我们就可以

使用获取的

股价数据来

绘制K线图。我

们可以指定

K线图的矩形

宽度，现在先

使用默认值

。 

candlestick(ax,

quotes) 

(11) 将x轴上的标

签格式化为

日期。为了更

好地适应x轴

的长度，标签

将被旋转。

fig.autofmt_xdate() 

plt.show()

绘

制DISH （Dish Network公司）的K线

图如下图所

示。

图灵社区

会员

heruihong 专享 尊

重版权

9.10

动手

实践：绘制股

价分布直方

图 167 

1

2 

3

4

5 

11

6

7 

8

9 

10

刚才做了

些什么

我们

从雅虎财经

频道下载了

某股票的全

年股价数据

，并据此绘制

了K线图。示例

代码见

candlesticks.py文件

。

from matplotlib.dates import DateFormatter

from matplotlib.dates import DayLocator

from matplotlib.dates import MonthLocator

from matplotlib.finance import quotes_historical_yahoo

from matplotlib.finance import candlestick

import sys 

from

datetime import date

import matplotlib.pyplot as plt

today = date.today()

start = (today.year -

1, today.month, today.day)

alldays = DayLocator()

months = MonthLocator()

month_formatter = DateFormatter("%b %Y")

symbol = 'DISH'

if len(sys.argv) == 2:

symbol = sys.argv[1]

quotes = quotes_historical_yahoo(symbol, start,

today) 

fig =

plt.figure() 

ax =

fig.add_subplot(111) 

ax.xaxis.set_major_locator(months)

ax.xaxis.set_minor_locator(alldays) 

ax.xaxis.set_major_formatter(month_formatter)

candlestick(ax, quotes) 

fig.autofmt_xdate()

plt.show() 

9.9 直方图

直方

图（histogram）可以将数

据的分布可

视化。Matplotlib中有便

捷的hist函数可

以绘制直

方

图。该函数的

参数中有这

样两项——包含

数据的数组

以及柱形的

数量。

9.10 动手实

践：绘制股价

分布直方图

我们来绘制

从雅虎财经

频道下载的

股价数据的

分布直方图

。

图灵社区会

员 heruihong 专享 尊重

版权

168 第 9 章

使

用 Matplotlib 绘图

(1)

下载

一年以来的

数据：

today = date.today()

start = (today.year -

1, today.month, today.day)

quotes = quotes_historical_yahoo(symbol, start,

today) 

(2) 上一步

得到的股价

数据存储在

Python列表中。将其

转化为NumPy数组

并提取出收

盘价

数据：

quotes = np.array(quotes)

close = quotes.T[4]

(3) 指

定合理数量

的柱形，绘制

分布直方图

：

plt.hist(close, np.sqrt(len(close)))

plt.show() 

DISH收盘价的分

布直方图如

下图所示。

刚

才做了些什

么

我们绘制

了DISH股价的分

布直方图。示

例代码见stockhistogram.py文

件。 

from

matplotlib.finance import quotes_historical_yahoo

import sys 

图灵社区

会员

heruihong 专享 尊

重版权

9.12

动手

实践：绘制股

票成交量 169 

1

2 

3

4

5 

11

6

7 

8

9 

10

from datetime import date

import matplotlib.pyplot as plt

import numpy as np

today = date.today()

start = (today.year -

1, today.month, today.day)

symbol = 'DISH'

if len(sys.argv) == 2:

symbol = sys.argv[1]

quotes = quotes_historical_yahoo(symbol, start,

today) 

quotes =

np.array(quotes) 

close =

quotes.T[4] 

plt.hist(close, np.sqrt(len(close)))

plt.show() 

勇

敢出发：绘制

钟形曲线

使

用股价的平

均值结合标

准差绘制一

条钟形曲线

（即高斯分布

或正态分布

）。当然，这只

是

作为练习。 

9.11 对

数坐标图

当

数据的变化

范围很大时

，对数坐标图

（logarithmic plot）很有用。Matplotlib中有

semilogx

函数（对x轴取

对数）、semilogy函数（对

y轴取对数）和

loglog函数（同时对

x轴和y轴取

对

数）。

9.12 动手实践

：绘制股票成

交量

股票成

交量变化很

大，因此我们

需要对其取

对数后再绘

制。首先，我们

需要从雅虎

财经

频道下

载历史数据

，从中提取出

日期和成交

量数据，创建

定位器和日

期格式化器

，创建图像

并

以子图的方

式添加。在前

面的“动手实

践”教程中我

们已经完成

过这些步骤

，因此这里不

再赘述。

(1) 使用

对数坐标绘

制成交量数

据。

plt.semilogy(dates, volume) 

现在，我们

将设置定位

器并将x轴格

式化为日期

。你可以在前

一节中找到

这些步骤的

说明。

使用对

数坐标图绘

制的DISH股票成

交量如下图

所示。 

图灵社

区会员 heruihong

专享

尊重版权

170 第

9 章

使用 Matplotlib 绘图

刚才做了些

什么

我们绘

制了股票成

交量的对数

坐标图。示例

代码见logy.py文件

。

from matplotlib.finance import quotes_historical_yahoo

from matplotlib.dates import DateFormatter

from matplotlib.dates import DayLocator

from matplotlib.dates import MonthLocator

import sys 

from

datetime import date

import matplotlib.pyplot as plt

import numpy as np

today = date.today()

start = (today.year -

1, today.month, today.day)

symbol = 'DISH'

if len(sys.argv) == 2:

symbol = sys.argv[1]

quotes = quotes_historical_yahoo(symbol, start,

today) 

quotes =

np.array(quotes) 

dates =

quotes.T[0] 

volume =

quotes.T[5] 

alldays =

DayLocator() 

months =

MonthLocator() 

month_formatter =

DateFormatter("%b %Y") 

fig

= plt.figure() 

图灵社区会

员

heruihong 专享 尊重

版权

9.14

动手实

践：绘制股票

收益率和成

交量变化的

散点图 171 

1

2 

3

4

5 

11

6

7 

8

9 

10

ax = fig.add_subplot(111)

plt.semilogy(dates, volume) 

ax.xaxis.set_major_locator(months)

ax.xaxis.set_minor_locator(alldays) 

ax.xaxis.set_major_formatter(month_formatter)

fig.autofmt_xdate() 

plt.show

9.13 散点

图

散点图（scatter plot）用

于绘制同一

数据集中的

两种数值变

量。Matplotlib的scatter函数可

以创建散点

图。我们可以

指定数据点

的颜色和大

小，以及图像

的alpha透明度。

9.14 动

手实践：绘制

股票收益率

和成交量变

化的散点图

我们可以便

捷地绘制股

票收益率和

成交量变化

的散点图。同

样，我们先从

雅虎财经频

道下载

所需

的数据。

(1)

得到

的quotes数据存储

在Python列表中。将

其转化为NumPy数

组并提取出

收盘价和成

交

量数据。 

dates

= quotes.T[4] 

volume

= quotes.T[5] 

(2)

计

算股票收益

率和成交量

的变化值。 

ret =

np.diff(close)/close[:-1] 

volchange =

np.diff(volume)/volume[:-1] 

(3) 创

建一个Matplotlib的figure对

象。

fig = pyplot.figure()

(4) 在图像中

添加一个子

图。 

ax

= fig.add_subplot(111) 

(5)

创建散点

图，并使得数

据点的颜色

与股票收益

率相关联，数

据点的大小

与成交量的

变化

相关联

。 

ax.scatter(ret,

volchange, c=ret * 100,

s=volchange * 100, alpha=0.5)

(6) 设置图像的

标题并添加

网格线。 

ax.set_title('Close

and volume returns')

ax.grid(True) 

图灵

社区会员 heruihong

专

享 尊重版权

172 第 9

章 使用 Matplotlib 绘

图

pyplot.show() 

DISH的散点图

如下所示。

刚

才做了些什

么

我们绘制

了DISH的股票收

益率和成交

量变化的散

点图。示例代

码见scatterprice.py文件。 

from matplotlib.finance

import quotes_historical_yahoo 

import

sys 

from datetime

import date 

import

matplotlib.pyplot as plt

import numpy as np

today = date.today()

start = (today.year -

1, today.month, today.day)

symbol = 'DISH'

if len(sys.argv) == 2:

symbol = sys.argv[1]

quotes = quotes_historical_yahoo(symbol, start,

today) 

quotes =

np.array(quotes) 

close =

quotes.T[4] 

volume =

quotes.T[5] 

图

灵社区会员

heruihong 专享

尊重版

权

9.16 动手实践

：根据条件进

行着色 173

1 

2

3 

4

5

11 

6

7

8 

9

10 

ret =

np.diff(close)/close[:-1] 

volchange =

np.diff(volume)/volume[:-1] 

fig =

plt.figure() 

ax =

fig.add_subplot(111) 

ax.scatter(ret, volchange,

c=ret * 100, s=volchange

* 100, alpha=0.5)

ax.set_title('Close and volume returns')

ax.grid(True) 

plt.show()

9.15 着色

fill_between函数使用指

定的颜色填

充图像中的

区域。我们也

可以选择alpha通

道的取值。

该

函数的where参数

可以指定着

色的条件。

9.16

动

手实践：根据

条件进行着

色

假设你想

对股票曲线

图进行着色

，并将低于均

值和高于均

值的收盘价

填充为不同

颜色。

fill_between函数是

完成这项工

作的最佳选

择。我们仍将

省略下载一

年以来历史

数据、提取日

期和收盘价

数据以及创

建定位器和

日期格式化

器的步骤。

(1)

创

建一个Matplotlib的figure对

象。 

fig =

plt.figure() 

(2) 在图像中

添加一个子

图。

ax = fig.add_subplot(111)

(3) 绘制收盘

价数据。 

ax.plot(dates,

close) 

(4) 对收

盘价下方的

区域进行着

色，依据低于

或高于平均

收盘价使用

不同的颜色

填充。

plt.fill_between(dates, close.min(), close,

where=close>close.mean(), facecolor="green", alpha=0.4)

plt.fill_between(dates, close.min(), close,

where=close<close.mean(), facecolor="red", alpha=0.4)

现在，我

们将设置定

位器并将x轴

格式化为日

期，从而完成

绘制。根据条

件进行着色

的DISH

股价如下

图所示。 

图灵

社区会员

heruihong 专

享 尊重版权

174 第

9 章 使用 Matplotlib

绘

图

刚才做了

些什么

我们

对股价图进

行了着色，低

于平均值的

收盘价使用

了一种颜色

，高于平均值

的收盘价使

用

了另外一

种不同的颜

色。示例代码

见fillbetween.py文件。

from matplotlib.finance import quotes_historical_yahoo

from matplotlib.dates import DateFormatter

from matplotlib.dates import DayLocator

from matplotlib.dates import MonthLocator

import sys 

from

datetime import date

import matplotlib.pyplot as plt

import numpy as np

today = date.today()

start = (today.year -

1, today.month, today.day)

symbol = 'DISH'

if len(sys.argv) == 2:

symbol = sys.argv[1]

quotes = quotes_historical_yahoo(symbol, start,

today) 

quotes =

np.array(quotes) 

dates =

quotes.T[0] 

close =

quotes.T[4] 

alldays =

DayLocator() 

months =

MonthLocator() 

month_formatter =

DateFormatter("%b %Y") 

fig

= plt.figure() 

图灵

社区会员

heruihong 专

享 尊重版权

9.18 动手实践：使

用图例和注

释

175 

1

2 

3

4

5 

11

6

7 

8

9 

10

ax = fig.add_subplot(111)

ax.plot(dates, close) 

plt.fill_between(dates,

close.min(), close, where=close>close.mean(), facecolor="green",

alpha=0.4) 

plt.fill_between(dates, close.min(),

close, where=close<close.mean(), 

facecolor="red",

alpha=0.4) 

ax.xaxis.set_major_locator(months)

ax.xaxis.set_minor_locator(alldays) 

ax.xaxis.set_major_formatter(month_formatter)

ax.grid(True) 

fig.autofmt_xdate()

plt.show() 

9.17 图例和注

释

对于高质

量的绘图，图

例和注释是

至关重要的

。我们可以用

legend函数创建透

明的图例，

并

由Matplotlib自动确定

其摆放位置

。同时，我们可

以用annotate函数在

图像上精确

地添加注释

，

并有很多可

选的注释和

箭头风格。

9.18

动

手实践：使用

图例和注释

在第3章中我

们学习了如

何计算股价

的指数移动

平均线。我们

将绘制一只

股票的收盘

价和对

应的

三条指数移

动平均线。为

了清楚地描

述图像的含

义，我们将添

加一个图例

，并用注释标

明两

条平均

曲线的交点

。部分重复的

步骤将被略

去。

(1)

计算并绘

制指数移动

平均线：如果

需要，请回到

第3章中复习

一下指数移

动平均线的

计算

方法。分

别使用9、12和15作

为周期数计

算和绘制指

数移动平均

线。 

emas

= [] 

for

i in range(9, 18,

3): 

 weights

= np.exp(np.linspace(-1., 0., i))

weights /= weights.sum()

ema = np.convolve(weights,

close)[i-1:-i+1] 

 idx

= (i - 6)/3

ax.plot(dates[i-1:], ema, lw=idx,

label="EMA(%s)" % (i))

data = np.column_stack((dates[i-1:], ema))

emas.append(np.rec.fromrecords( data, names=["dates",

"ema"])) 

注意，调用

plot函数时需要

指定图例的

标签。我们将

指数移动平

均线的值存

在数组中，为

下一步做准

备。

(2) 我们来找

到两条指数

移动平均曲

线的交点。 

first

= emas[0]["ema"].flatten() 

second

= emas[1]["ema"].flatten() 

bools

= np.abs(first[-len(second):] - second)/second

< 0.0001 

xpoints

= np.compress(bools, emas[1])

图

灵社区会员

heruihong 专享 尊重版

权

176

第 9 章 使用

Matplotlib

绘图

(3) 我们将

找到的交点

用注释和箭

头标注出来

，并确保注释

文本在交点

的不远处。

for xpoint in xpoints:

ax.annotate('x', xy=xpoint, textcoords='offset

points', 

 xytext=(-50,

30), 

 arrowprops=dict(arrowstyle="->"))

(4) 添

加一个图例

并由Matplotlib自动确

定其摆放位

置。 

leg

= ax.legend(loc='best', fancybox=True)

(5) 设置alpha通道

值，将图例透

明化。 

leg.get_frame().set_alpha(0.5)

包含图

例和注释的

股价及指数

移动平均线

图如下所示

。

刚才做了些

什么

我们绘

制了股票收

盘价和对应

的三条指数

移动平均线

。我们添加了

一个图例，并

使用注释将

其中两条曲

线的交点标

注了出来。示

例代码见emalegend.py文

件。

from matplotlib.finance import quotes_historical_yahoo

from matplotlib.dates import DateFormatter

from matplotlib.dates import DayLocator

from matplotlib.dates import MonthLocator

import sys 

from

datetime import date

import matplotlib.pyplot as plt

import numpy as np

today = date.today()

图灵社区

会员 heruihong 专享 尊

重版权

9.19 三维

绘图 177

1 

2

3 

4

5

11 

6

7

8 

9

10 

start =

(today.year - 1, today.month,

today.day) 

symbol =

'DISH' 

if len(sys.argv)

== 2:

symbol = sys.argv[1]

quotes = quotes_historical_yahoo(symbol, start,

today) 

quotes =

np.array(quotes) 

dates =

quotes.T[0] 

close =

quotes.T[4] 

fig =

plt.figure() 

ax =

fig.add_subplot(111) 

emas =

[] 

for i

in range(9, 18, 3):

weights = np.exp(np.linspace(-1.,

0., i))

weights / = weights.sum()

ema = np.convolve(weights,

close)[i-1:-i+1] 

 idx

= (i - 6)/3

ax.plot(dates[i-1:], ema, lw=idx,

label="EMA(%s)" % (i))

data = np.column_stack((dates[i-1:], ema))

emas.append(np.rec.fromrecords(data, names=["dates", "ema"]))

first = emas[0]["ema"].flatten()

second = emas[1]["ema"].flatten()

bools = np.abs(first[-len(second):] -

second)/second < 0.0001

xpoints = np.compress(bools, emas[1])

for xpoint in xpoints:

ax.annotate('x', xy=xpoint, textcoords='offset

points', 

 xytext=(-50,

30), 

 arrowprops=dict(arrowstyle="->"))

leg = ax.legend(loc='best', fancybox=True)

leg.get_frame().set_alpha(0.5) 

alldays =

DayLocator() 

months =

MonthLocator() 

month_formatter =

DateFormatter("%b %Y") 

ax.plot(dates,

close, lw=1.0, label="Close")

ax.xaxis.set_major_locator(months) 

ax.xaxis.set_minor_locator(alldays)

ax.xaxis.set_major_formatter(month_formatter) 

ax.grid(True)

fig.autofmt_xdate() 

plt.show()

9.19 三维绘

图

三维绘图

非常壮观华

丽，因此我们

必须涵盖这

部分内容。对

于3D作图，我们

需要一个和

三

图灵社区

会员

heruihong 专享 尊

重版权

178

第 9 章

使用 Matplotlib

绘图

维

投影相关的

Axes3D对象。

9.20 动手实

践：在三维空

间中绘图

我

们将在三维

空间中绘制

一个简单的

三维函数。

2 2 zx

y  

(1)

我

们需要使用

3d关键字来指

定图像的三

维投影。 

ax =

fig.add_subplot(111, projection='3d') 

(2)

我们

将使用meshgrid函数

创建一个二

维的坐标网

格。这将用于

变量x和y的赋

值。 

u =

np.linspace(-1, 1, 100)

x, y = np.meshgrid(u,

u) 

(3) 我们将指

定行和列的

步幅，以及绘

制曲面所用

的色彩表（color

map）。步

幅决定曲面

上“瓦

片”的大

小，而色彩表

的选择取决

于个人喜好

。 

ax.plot_surface(x,

y, z, rstride=4, cstride=4,

cmap=cm.YlGnBu_r) 

3D绘图的结果

如下所示。

刚

才做了些什

么

我们绘制

了一个三维

空间中的函

数。示例代码

见three_d.py文件。 

图灵

社区会员 heruihong

专

享 尊重版权

9.22 动手实践：绘

制色彩填充

的等高线图

179

1 

2

3 

4

5

11 

6

7

8 

9

10 

from mpl_toolkits.mplot3d

import Axes3D 

import

matplotlib.pyplot as plt

import numpy as np

from matplotlib import cm

fig = plt.figure()

ax = fig.add_subplot(111, projection='3d')

u = np.linspace(-1, 1,

100) 

x, y

= np.meshgrid(u, u)

z = x **

2 + y **

2 

ax.plot_surface(x, y,

z, rstride=4, cstride=4, cmap=cm.YlGnBu_r)

plt.show() 

9.21 等高线图

Matplotlib中

的等高线3D绘

图有两种风

格——填充的和

非填充的。我

们可以使用

contour函

数创建一

般的等高线

图。对于色彩

填充的等高

线图，可以使

用contourf绘制。

9.22 动手

实践：绘制色

彩填充的等

高线图

我们

将对前面“动

手实践”中的

三维数学函

数绘制色彩

填充的等高

线图。代码也

非常简单，

一

个重要的区

别是我们不

再需要指定

三维投影的

参数。使用下

面这行代码

绘制等高线

图： 

ax.contourf(x,

y, z) 

输出结果

如下图所示

。

图灵社区会

员 heruihong 专享 尊重

版权

180 第 9 章

使

用 Matplotlib 绘图

刚才

做了些什么

我们对一个

三维数学函

数绘制了色

彩填充的等

高线图。示例

代码见contour.py文件

。

import matplotlib.pyplot as plt

import numpy as np

from matplotlib import cm

fig = plt.figure()

ax = fig.add_subplot(111)

u = np.linspace(-1, 1,

100) 

x, y

= np.meshgrid(u, u)

z = x **

2 + y **

2 

ax.contourf(x, y,

z) 

plt.show()

9.23 动画

Matplotlib提供酷

炫的动画功

能。Matplotlib中有专门

的动画模块

。我们需要定

义一个回调

函

数，用于定

期更新屏幕

上的内容。我

们还需要一

个函数来生

成图中的数

据点。

9.24 动手实

践：制作动画

我们将绘制

三个随机生

成的数据集

，分别用圆形

、小圆点和三

角形来显示

。不过，我们将

只

用随机值

更新其中的

两个数据集

。

(1)

我们将用不

同颜色的圆

形、小圆点和

三角形来绘

制三个数据

集中的数据

点。 

circles, triangles,

dots = ax.plot(x, 'ro',

y, 'g^', z, 'b.')

(2) 下面的函

数将被定期

调用以更新

屏幕上的内

容。我们将随

机更新两个

数据集中的

y坐

标值。

def update(data):

circles.set_ydata(data[0]) 

 triangles.set_ydata(data[1])

return circles, triangles

(3) 使用

NumPy生成随机数

。 

def

generate(): 

 while

True: yield np.random.rand(2, N)

以下是生成

的动画的截

图。 

图灵社区

会员 heruihong

专享 尊

重版权

9.24 动手

实践：制作动

画

181 

1

2 

3

4

5 

11

6

7 

8

9 

10

刚才做了

些什么

我们

使用随机数

据点制作了

一个动画。示

例代码见animation.py文

件。 

import

numpy as np

import matplotlib.pyplot as plt

import matplotlib.animation as animation

fig = plt.figure()

ax = fig.add_subplot(111)

N = 10

x = np.random.rand(N)

y = np.random.rand(N)

z = np.random.rand(N)

circles, triangles, dots =

ax.plot(x, 'ro', y, 'g^',

z, 'b.') 

ax.set_ylim(0,

1) 

plt.axis('off')

def update(data):

circles.set_ydata(data[0]) 

 triangles.set_ydata(data[1])

return circles, triangles

def generated:

while True: yield np.random.rand(2,

N) 

anim =

animation.FuncAnimation(fig, update, generate, interval=150)

plt.show() 

图灵社区

会员 heruihong

专享 尊

重版权

182 第

9 章

使用 Matplotlib 绘图

9.25 本

章小结

本章

围绕Matplotlib——一个Python绘

图库展开，涵

盖简单绘图

、直方图、定制

绘图、子图、

3D绘

图、等高线图

和对数坐标

图等内容。我

们还学习了

几个绘制股

票数据的例

子。显然，我们

还只是领略

了冰山一角

。Matplotlib的功能非常

丰富，因此我

们没有足够

的篇幅来讲

述LaTex支持、

极坐

标支持以及

其他功能。

Matplotlib的

作者John Hunter于2012年8月

离开了我们

。本书的审稿

人之一建议

在此提及John

Hunter纪

念基金（John Hunter Memorial Fund，请访

问http://numfocus.org/johnhunter/）。该基金由

NumFocus

Foundation发起，可以这

么说，它给了

我们这些John Hunter作

品的粉丝们

一个回报的

机

会。更多详

情，请访问前

面的NumFocus网站链

接。

下一章中

，我们将学习

SciPy——一个建立在

NumPy之上的Python科学

计算架构。

图

灵社区会员

heruihong 专享 尊重版

权

10.2

动手实践

：保存和加载

.mat 文件 183

1 

2

3 

4

5

11 

6

7

8 

9

10 

NumPy的扩展

：SciPy

SciPy是世界著名

的Python开源科学

计算库，建立

在NumPy之上。它增

加

的功能包

括数值积分

、最优化、统计

和一些专用

函数。

本章涵

盖以下内容

：



文件输入/输

出；

 统计；



信号

处理；

 最优化

；



插值；

 图像和

音频处理。

10.1

MATLAB 和

Octave 

MATLAB以及其开源

替代品Octave都是

流行的数学

工具。scipy.io包的函

数可以在Python

中

加载或保存

MATLAB和Octave的矩阵和

数组。loadmat函数可

以加载.mat文件

。savemat函

数可以将

数组和指定

的变量名字

典保存为.mat文

件。

10.2 动手实践

：保存和加载

.mat

文件

如果我

们一开始使

用了NumPy数组，随

后希望在MATLAB或

Octave环境中使用

这些数组，那

么最简单的

办法就是创

建一个.mat文件

，然后在MATLAB或Octave中

加载这个文

件。请完成如

下步骤。

(1) 创建

NumPy数组并调用

savemat创建一个.mat文

件。该函数有

两个参数——一

个文件名

和

一个包含变

量名和取值

的字典。 

第 10

章

图灵社区会

员 heruihong 专享 尊重

版权

184 第 10 章

NumPy 的

扩展：SciPy 

a

= np.arange(7) 

io.savemat("a.mat",

{"array": a}) 

(2)

在MATLAB或Octave环

境中加载.mat文

件，并检查数

组中存储的

元素。 

octave-3.4.0:7> load

a.mat 

octave-3.4.0:8> a

octave-3.4.0:8> array 

array

= 

0

1 

2

3 

4

5 

6

刚才做

了些什么

我

们使用NumPy代码

创建了一个

.mat文件并在Octave中

成功加载。我

们检查了之

前创建的

NumPy数

组的元素。示

例代码见scipyio.py文

件。

import numpy as np

from scipy import io

a = np.arange(7)

io.savemat("a.mat", {"array": a})

突击测验

：加载.mat类型的

文件

问题1 以

下哪个函数

可以加载.mat类

型的文件？

(1)

Loadmatlab

(2) loadmat

(3)

loadoct

(4) frommat

10.3 统

计

SciPy的统计模

块是scipy.stats，其中有

一个类是连

续分布的实

现，一个类是

离散分布的

实现。此外，该

模块中还有

很多用于统

计检验的函

数。

图灵社区

会员

heruihong 专享 尊

重版权

10.4

动手

实践：分析随

机数 185 

1

2 

3

4

5 

11

6

7 

8

9 

10

10.4 动手实

践：分析随机

数

我们将按

正态分布生

成随机数，并

使用scipy.stats包中的

统计函数分

析生成的数

据。请

完成如

下步骤。

(1) 使用

scipy.stats包按正态分

布生成随机

数。 

generated

= stats.norm.rvs(size=900) 

(2)

用正态分

布去拟合生

成的数据，得

到其均值和

标准差： 

print "Mean",

"Std", stats.norm.fit(generated) 

均值

和标准差如

下所示：

Mean Std (0.0071293257063200707, 0.95537708218972528)

(3) 偏度

（skewness）描述的是概

率分布的偏

斜（非对称）程

度。我们来做

一个偏度检

验。

该检验有

两个返回值

，其中第二个

返回值为p-value，即

观察到的数

据集服从正

态分布的概

率，取

值范围

为0~1。

print "Skewtest", "pvalue", stats.skewtest(generated)

偏度检验

返回的结果

如下： 

Skewtest pvalue

(-0.62120640688766893, 0.5344638245033837) 

因此，该

数据集有53%的

概率服从正

态分布。

(4) 峰度

（kurtosis）描述的是概

率分布曲线

的陡峭程度

。我们来做一

个峰度检验

。该检验与

偏

度检验类似

，当然这里是

针对峰度。

print "Kurtosistest", "pvalue", stats.kurtosistest(generated)

峰

度检验返回

的结果如下

： 

Kurtosistest pvalue

(1.306538101953 6981, 0.19136963054975586)

(5) 正态性检验

（normality test）可以检查数

据集服从正

态分布的程

度。我们来做

一个正态性

检验。该检验

同样有两个

返回值，其中

第二个返回

值为p-value。

print "Normaltest", "pvalue", stats.normaltest(generated)

正态性

检验返回的

结果如下： 

Normaltest pvalue

(2.09293921181506, 0.35117535059841687) 

(6)

使

用SciPy我们可以

很方便地得

到数据所在

的区段中某

一百分比处

的数值： 

图灵

社区会员 heruihong

专

享 尊重版权

186 第 10

章 NumPy 的扩展

：SciPy

print "95 percentile", stats.scoreatpercentile(generated,

95) 

得到95%处的数

值如下：

95 percentile 1.54048860252

(7) 将前

一步反过来

，我们也可以

从数值1出发

找到对应的

百分比： 

print

"Percentile at 1", stats.percentileofscore(generated,

1) 

得到

对应的百分

比如下：

Percentile at 1 85.5555555556

(8) 使用

Matplotlib绘制生成数

据的分布直

方图。有关Matplotlib的

详细介绍可

以在前一章

中

找到。

plt.hist(generated) 

plt.show()

生成

随机数的直

方图如下所

示。 

刚才做了

些什么

我们

按正态分布

生成了一个

随机数据集

，并使用scipy.stats模块

分析了该数

据集。示例

代

码见statistics.py文件。 

from scipy

import stats 

import

matplotlib.pyplot as plt

图

灵社区会员

heruihong 专享 尊重版

权

10.6

动手实践

：比较股票对

数收益率 187 

1

2 

3

4

5 

11

6

7 

8

9 

10

generated = stats.norm.rvs(size=900)

print "Mean", "Std", stats.norm.fit(generated)

print "Skewtest", "pvalue", stats.skewtest(generated)

print "Kurtosistest", "pvalue", stats.kurtosistest(generated)

print "Normaltest", "pvalue", stats.normaltest(generated)

print "95 percentile", stats.scoreatpercentile(generated,

95) 

print "Percentile

at 1", stats.percentileofscore(generated, 1)

plt.hist(generated) 

plt.show()

勇

敢出发：改进

数据生成

从

本节中的直

方图来看，数

据生成仍有

改进的空间

。尝试使用NumPy或

调节scipy.stats. 

norm.rvs函数的

参数。

10.5 样本比

对和 SciKits

我们经

常会遇到两

组数据样本

，它们可能来

自不同的实

验，但互相有

一些关联。统

计检验可

以

进行样本比

对。scipy.stats模块中已

经实现了部

分统计检验

。

另一种笔者

喜欢的统计

检验是scikits.statsmodels.stattools中的

Jarque-Bera正态性

检验

。SciKits是Python的小型实

验工具包，它

并不是SciPy的一

部分。此外还

有pandas（Python

Data 

Analysis Library），它是scikits.statsmodels的分

支。你可以访

问https://scikits.appspot.

com/scikits查阅SciKits的模

块索引。你可

以使用setuptools安装

statsmodels，命令如下：

easy_install statsmodels

10.6 动

手实践：比较

股票对数收

益率

我们将

使用Matplotlib下载一

年以来的两

只股票的数

据。如同前面

的章节中所

述，我们可以

从雅虎财经

频道获取股

价数据。我们

将比较DIA和SPY收

盘价的对数

收益率。我们

还将在两只

股

票对数收

益率的差值

上应用Jarque-Bera正态

性检验。请完

成如下步骤

。

(1) 编写一个函

数，用于返回

指定股票的

收盘价数据

。 

def

get_close(symbol): 

 today

= date.today()

start = (today.year -

1, today.month, today.day)

quotes = quotes_historical_yahoo(symbol, start,

today) 

 quotes

= np.array(quotes) 

图灵社区会

员

heruihong 专享 尊重

版权

188

第 10 章 NumPy

的

扩展：SciPy 

 return

quotes.T[4] 

(2) 计算DIA和

SPY的对数收益

率。先对收盘

价取自然对

数，然后计算

连续值之间

的差值，即

得

到对数收益

率。 

spy =

np.diff(np.log(get_close("SPY"))) 

dia =

np.diff(np.log(get_close("DIA"))) 

(3) 均值检验

可以检查两

组不同的样

本是否有相

同的均值。返

回值有两个

，其中第二个

为

p-value，取值范围

为0~1。 

print "Means

comparison", stats.ttest_ind(spy, dia)

均值检验

的结果如下

： 

Means comparison

(-0.017995865641886155, 0.98564930169871368) 

因此有98%的概

率两组样本

对数收益率

的均值相同

。

(4) Kolmogorov-Smirnov检验可以判

断两组样本

同分布的可

能性。 

print

"Kolmogorov smirnov test", stats.ks_2samp(spy,

dia) 

同样，该

函数有两个

返回值，其中

第二个为p-value。

Kolmogorov smirnov test (0.063492063492063516,

0.67615647616238039) 

(5) 在

两只股票对

数收益率的

差值上应用

Jarque-Bera正态性检验

。

print "Jarque Bera test",

jarque_bera(spy - dia)[1]

Jarque-Bera正态性检验

得到的p-value如下

： 

Jarque Bera

test 0.596125711042 

(6)

使用Matplotlib绘制对

数收益率以

及其差值的

直方图。 

plt.hist(spy, histtype="step",

lw=1, label="SPY") 

plt.hist(dia,

histtype="step", lw=2, label="DIA")

plt.hist(spy - dia, histtype="step",

lw=3,label="Delta") 

plt.legend()

plt.show() 

绘制

结果如下图

所示。

刚才做

了些什么

我

们比较了DIA和

SPY样本数据的

对数收益率

，还对它们的

差值应用了

Jarque-Bera正态性检

验

。示例代码见

pair.py文件。

图灵社

区会员 heruihong 专享

尊重版权

10.6

动

手实践：比较

股票对数收

益率 189 

1

2 

3

4

5 

11

6

7 

8

9 

10

from matplotlib.finance import quotes_historical_yahoo

from datetime import date

import numpy as np

from scipy import stats

from statsmodels.stats.stattools import jarque_bera

import matplotlib.pyplot as plt

def get_close(symbol):

today = date.today()

start = (today.year -

1, today.month, today.day)

quotes = quotes_historical_yahoo(symbol, start,

today) 

 quotes

= np.array(quotes)

return quotes.T[4] 

spy

= np.diff(np.log(get_close("SPY"))) 

dia

= np.diff(np.log(get_close("DIA"))) 

print

"Means comparison", stats.ttest_ind(spy, dia)

print "Kolmogorov smirnov test",

stats.ks_2samp(spy, dia) 

print

"Jarque Bera test", jarque_bera(spy

- dia)[1] 

plt.hist(spy,

histtype="step", lw=1, label="SPY")

plt.hist(dia, histtype="step", lw=2, label="DIA")

plt.hist(spy - dia, histtype="step",

lw=3, label="Delta") 

plt.legend()

plt.show() 

图灵社

区会员 heruihong

专享

尊重版权

190 第

10 章

NumPy 的扩展：SciPy 

10.7

信

号处理

scipy.signal模块

中包含滤波

函数和B样条

插值（B-spline interpolation）函数。

样

条插值使用

称为样条的

多项式进行

插值。插值过

程将分段多

项式连接起

来

拟合数据

。B样条是样条

的一种类型

。

SciPy中以一组数

值来定义信

号。我们以detrend函

数作为滤波

器的一个例

子。该函数可

以

对信号进

行线性拟合

，然后从原始

输入数据中

去除这个线

性趋势。

10.8

动手

实践：检测 QQQ 股

价的线性趋

势

相比于去

除数据样本

的趋势，我们

通常更关心

的是趋势本

身。在去除趋

势的操作之

后，我们

仍然

很容易获取

该趋势。我们

将对QQQ一年以

来的股价数

据进行这些

处理分析。 

(1) 编

写代码获取

QQQ的收盘价和

对应的日期

数据。

today = date.today()

start = (today.year -

1, today.month, today.day)

quotes = quotes_historical_yahoo("QQQ", start,

today) 

quotes =

np.array(quotes) 

dates =

quotes.T[0] 

qqq =

quotes.T[4] 

(2) 去除信

号中的线性

趋势。

y = signal.detrend(qqq)

(3) 创建月

定位器和日

定位器。 

alldays

= DayLocator() 

months

= MonthLocator ()

(4) 创建

一个日期格

式化器以格

式化x轴上的

日期。该格式

化器将创建

一个字符串

，包含简写

的

月份和年份

。

month_formatter = DateFormatter("%b %Y")

(5) 创建图像和

子图。 

fig

= plt.figure() 

ax

= fig.add_subplot(111) 

图灵社

区会员

heruihong 专享

尊重版权

10.8 动

手实践：检测

QQQ

股价的线性

趋势 191 

1

2 

3

4

5 

11

6

7 

8

9 

10

(6) 绘制股

价数据以及

将去除趋势

后的信号从

原始数据中

减去所得到

的潜在趋势

。 

plt.plot(dates,

qqq, 'o', dates, qqq

- y, '-')

(7) 设置定位器

和格式化器

。 

ax.xaxis.set_minor_locator(alldays)

ax.xaxis.set_major_locator(months) 

ax.xaxis.set_major_formatter(month_formatter)

(8) 将x轴上的标

签格式化为

日期。 

fig.autofmt_xdate()

plt.show() 

QQQ的股价

以及趋势线

如下图所示

。

刚才做了些

什么

我们绘

制了QQQ的收盘

价数据以及

对应的趋势

线。示例代码

见trend.py文件。 

from

matplotlib.finance import quotes_historical_yahoo

from datetime import date

import numpy as np

from scipy import signal

import matplotlib.pyplot as plt

from matplotlib.dates import DateFormatter

from matplotlib.dates import DayLocator

from matplotlib.dates import MonthLocator

today = date.today()

start = (today.year -

1, today.month, today.day)

图灵

社区会员 heruihong 专

享 尊重版权

192

第 10 章 NumPy

的扩展

：SciPy 

quotes =

quotes_historical_yahoo("QQQ", start, today)

quotes = np.array(quotes)

dates = quotes.T[0]

qqq = quotes.T[4]

y = signal.detrend(qqq)

alldays = DayLocator()

months = MonthLocator()

month_formatter = DateFormatter("%b %Y")

fig = plt.figure()

ax = fig.add_subplot(111)

plt.plot(dates, qqq, 'o', dates,

qqq - y, '-')

ax.xaxis.set_minor_locator(alldays) 

ax.xaxis.set_major_locator(months)

ax.xaxis.set_major_formatter(month_formatter) 

fig.autofmt_xdate()

plt.show() 

10.9 傅里叶分析

现实世界中

的信号往往

具有周期性

。傅里叶变换

（Fourier

transform）是处理这些

信号的常

用

工具。傅里叶

变换是一种

从时域到频

域的变换，也

就是将周期

信号线性分

解为不同频

率的正弦

和

余弦函数。

傅

里叶变换的

函数可以在

scipy.fftpack模块中找到

（NumPy也有自己的

傅里叶工具

包，

即numpy.fft）。这个模

块包含快速

傅里叶变换

、微分算子和

拟微分算子

以及一些辅

助函数。

MATLAB用户

会很高兴，因

为scipy.fftpack模块中的

很多函数与

MATLAB对应的函数

同名，

且功能

也很相近。

10.10

动

手实践：对去

除趋势后的

信号进行滤

波处理

在10.8节

我们学习了

如何去除信

号中的趋势

。去除趋势后

的信号可能

有周期性的

分量，我们

将

其显现出来

。一些步骤已

在前面的“动

手实践”教程

中出现过，如

下载数据和

设置Matplotlib

对象。这

些步骤将被

略去。

(1) 应用傅

里叶变换，得

到信号的频

谱。 

amps

= np.abs(fftpack.fftshift(fftpack.rfft(y))) 

(2)

滤除噪声

。如果某一频

率分量的大

小低于最强

分量的10%，则将

其滤除。 

amps[amps <

0.1 * amps.max()] =

0 

图灵

社区会员 heruihong

专

享 尊重版权

10.10 动手实践：对

去除趋势后

的信号进行

滤波处理 193

1 

2

3 

4

5

11 

6

7

8 

9

10 

(3) 将

滤波后的信

号变换回时

域，并和去除

趋势后的信

号一起绘制

出来。

plt.plot(dates, y, 'o', label="detrended")

plt.plot(dates,-fftpack.irfft(fftpack.ifftshift(amps)), label="filtered") 

(4)

将x轴上

的标签格式

化为日期，并

添加一个特

大号的图例

。 

fig.autofmt_xdate()

plt.legend(prop={'size':'x-large'}) 

(5) 添加第二个

子图，绘制滤

波后的频谱

。

ax2 = fig.add_subplot(212)

N = len(qqq)

plt.plot(np.linspace(-N/2, N/2, N), amps,

label="transformed") 

(6) 显示图像和

图例。

plt.legend(prop={'size':'x-large'}) 

plt.show()

绘制的

信号和频谱

如下图所示

。 

刚才做了些

什么

我们去

除了一个信

号的趋势，并

使用scipy.fftpack模块对

其应用了一

个简单的滤

波器。

示例代

码见frequencies.py文件。 

from matplotlib.finance

import quotes_historical_yahoo 

from

datetime import date

import numpy as np

from scipy import signal

import matplotlib.pyplot as plt

图

灵社区会员

heruihong 专享 尊重版

权

194

第 10 章 NumPy

的扩

展：SciPy 

from scipy

import fftpack 

from

matplotlib.dates import DateFormatter

from matplotlib.dates import DayLocator

from matplotlib.dates import MonthLocator

today = date.today()

start = (today.year -

1, today.month, today.day)

quotes = quotes_historical_yahoo("QQQ", start,

today) 

quotes =

np.array(quotes) 

dates =

quotes.T[0] 

qqq =

quotes.T[4] 

y =

signal.detrend(qqq) 

alldays =

DayLocator() 

months =

MonthLocator() 

month_formatter =

DateFormatter("%b %Y") 

fig

= plt.figure() 

fig.subplots_adjust(hspace=.3)

ax = fig.add_subplot(211)

ax.xaxis.set_minor_locator(alldays) 

ax.xaxis.set_major_locator(months)

ax.xaxis.set_major_formatter(month_formatter) 

# 调大字号

ax.tick_params(axis='both',

which='major', labelsize='x-large') 

amps

= np.abs(fftpack.fftshift(fftpack.rfft(y))) 

amps[amps

< 0.1 * amps.max()]

= 0 

plt.plot(dates,

y, 'o', label="detrended")

plt.plot(dates, -fftpack.irfft(fftpack.ifftshift(amps)), label="filtered")

fig.autofmt_xdate() 

plt.legend(prop={'size':'x-large'})

ax2 = fig.add_subplot(212)

ax2.tick_params(axis='both', which='major', labelsize='x-large')

N = len(qqq)

plt.plot(np.linspace(-N/2, N/2, N), amps,

label="transformed") 

plt.legend(prop={'size':'x-large'})

plt.show() 

10.11 数学优化

优

化算法（optimization algorithm）尝试

寻求某一问

题的最优解

，例如找到函

数的最大值

或

最小值，函

数可以是线

性或者非线

性的。解可能

有一些特定

的约束，例如

不允许有负

数。在

scipy.optimize模块中

提供了一些

优化算法，最

小二乘法函

数leastsq就是其中

之一。当调用

图灵社区会

员

heruihong 专享 尊重

版权

10.12

动手实

践：拟合正弦

波 195 

1

2 

3

4

5 

11

6

7 

8

9 

10

这个函数

时，我们需要

提供一个残

差（误差项）函

数。这样，leastsq将最

小化残差的

平方和。

得到

的解与我们

使用的数学

模型有关。我

们还需要为

算法提供一

个起始点，这

应该是一个

最好的

猜测

——尽可能接近

真实解。否则

，程序执行800轮

迭代后将停

止。

10.12

动手实践

：拟合正弦波

在10.10节中，我们

为去除趋势

后的数据创

建了一个简

单的滤波器

。现在，我们使

用一个限

制

性更强的滤

波器，只保留

主频率部分

。我们将拟合

一个正弦波

并绘制结果

。该模型有4个

参数——

振幅、频

率、相位和垂

直偏移。请完

成如下步骤

。

(1)

根据正弦波

模型，定义residuals函

数：

def residuals(p, y,

x): 

 A,k,theta,b

= p

err = y-A *

np.sin(2* np.pi* k *

x + theta) +

b 

 return

err 

(2) 将滤波后

的信号变换

回时域：

filtered = -fftpack.irfft(fftpack.ifftshift(amps))

(3) 猜测

参数的值，尝

试估计从时

域到频域的

变换函数： 

N

= len(qqq) 

f

= np.linspace(-N/2, N/2, N)

p0 = [filtered.max(), f[amps.argmax()]/(2*N),

0, 0] 

print

"P0", p0 

初

始值如下所

示：

P0 [2.6679532410065212, 0.00099598469163686377, 0,

0] 

(4) 调用leastsq函数

：

plsq = optimize.leastsq(residuals, p0,

args=(filtered,dates)) 

p =

plsq[0] 

print "P",

p 

最终的参数

值如下所示

：

P [2.67678014e+00 2.73033206e-03 -8.00007036e+03

-5.01260321e-03] 

(5) 在第一个子

图中绘制去

除趋势后的

数据、滤波后

的数据及其

拟合曲线。将

x轴格式化为

日

期，并添加

一个图例。 

plt.plot(dates, y,

'o', label="detrended") 

plt.plot(dates,

filtered, label="filtered") 

图

灵社区会员

heruihong

专享 尊重版

权

196 第

10 章 NumPy 的扩

展：SciPy

plt.plot(dates, p[0] * np.sin(2

* np.pi * dates

* p[1] + p[2])

+ p[3], '^', label="fit")

fig.autofmt_xdate() 

plt.legend(prop={'size':'x-large'})

(6) 添加第二

个子图，绘制

主频率部分

的频谱图和

图例。 

ax2

= fig.add_subplot(212) 

plt.plot(f,

amps, label="transformed") 

绘制结

果如下图所

示。

刚才做了

些什么

我们

对一年以来

的QQQ股价数据

进行了去趋

势处理。然后

进行了滤波

处理，仅保留

了频谱

上的

主频率部分

。我们使用scipy.optimize模

块对滤波后

的信号拟合

了一个正弦

波函数。示例

代码见optfit.py文件

。

from matplotlib.finance import quotes_historical_yahoo

import numpy as np

import matplotlib.pyplot as plt

from scipy import fftpack

from scipy import signal

from matplotlib.dates import DateFormatter

from matplotlib.dates import DayLocator

from matplotlib.dates import MonthLocator

from scipy import optimize

start = (2010, 7,

25) 

end =

(2011, 7, 25)

quotes = quotes_historical_yahoo("QQQ", start,

end) 

quotes =

np.array(quotes) 

dates =

quotes.T[0] 

图灵社区会

员 heruihong

专享 尊重

版权

10.13 数值积

分

197 

1

2 

3

4

5 

11

6

7 

8

9 

10

qqq = quotes.T[4]

y = signal.detrend(qqq)

alldays = DayLocator()

months = MonthLocator()

month_formatter = DateFormatter("%b %Y")

fig = plt.figure()

fig.subplots_adjust(hspace=.3) 

ax =

fig.add_subplot(211) 

ax.xaxis.set_minor_locator(alldays)

ax.xaxis.set_major_locator(months) 

ax.xaxis.set_major_formatter(month_formatter)

ax.tick_params(axis='both', which='major', labelsize='x-large')

amps = np.abs(fftpack.fftshift(fftpack.rfft(y)))

amps[amps < amps.max()] =

0 

def residuals(p,

y, x):

A,k,theta,b = p

err = y-A *

np.sin(2* np.pi* k *

x + theta) +

b 

 return

err 

filtered =

-fftpack.irfft(fftpack.ifftshift(amps)) 

N =

len(qqq) 

f =

np.linspace(-N/2, N/2, N)

p0 = [filtered.max(), f[amps.argmax()]/(2*N),

0, 0] 

print

"P0", p0 

plsq

= optimize.leastsq(residuals, p0, args=(filtered,

dates)) 

p =

plsq[0] 

print "P",

p 

plt.plot(dates, y,

'o', label="detrended") 

plt.plot(dates,

filtered, label="filtered") 

plt.plot(dates,

p[0] * np.sin(2 *

np.pi * dates *

p[1] + p[2]) +

p[3], '^', label="fit")

fig.autofmt_xdate() 

plt.legend(prop={'size':'x-large'})

ax2 = fig.add_subplot(212)

ax2.tick_params(axis='both', which='major', labelsize='x-large')

plt.plot(f, amps, label="transformed")

plt.legend(prop={'size':'x-large'}) 

plt.show()

10.13 数值积分

SciPy中有数值积

分的包scipy.integrate，在NumPy中

没有相同功

能的包。quad函数

可

图灵社区

会员 heruihong

专享 尊

重版权

198 第

10 章

NumPy 的扩展：SciPy

以求

单变量函数

在两点之间

的积分，这些

点之间的距

离可以是无

穷小或无穷

大。该函数使

用最简

单的

数值积分方

法即梯形法

则（trapezoid rule）进行计算

。

10.14

动手实践：计

算高斯积分

高斯积分（Gaussian integral）出

现在误差函

数（数学中记

为erf）的定义中

，但高斯积分

本

身的积分

区间是无穷

的，它的值等

于pi的平方根

。我们将使用

quad函数计算它

。

使用quad函数计

算高斯积分

。

print "Gaussian integral", np.sqrt(np.pi),

integrate.quad(lambda x: np.exp(-x**2), -np.inf,

np.inf) 

计算结果和

对应的误差

如下所示：

Gaussian integral 1.77245385091 (1.7724538509055159,

1.4202636780944923e- 08) 

刚

才做了些什

么

我们使用

quad函数计算了

高斯积分。 

10.15 插

值

插值（interpolation）即在

数据集已知

数据点之间

“填补空白”。scipy.interpolate函

数

可以根据

实验数据进

行插值。interp1d类可

以创建线性

插值（linear interpolation）或三次

插值

（cubic

interpolation）的函数

。默认将创建

线性插值函

数，三次插值

函数可以通

过设置kind参数

来创建。interp2d类的

工作方式相

同，只不过用

于二维插值

。

10.16 动手实践：一

维插值

我们

将使用sinc函数

创建数据点

并添加一些

随机噪音。随

后，我们将进

行线性插值

和三次

插值

，并绘制结果

。请完成如下

步骤。

(1) 创建数

据点并添加

噪音：

x = np.linspace(-18, 18,

36) 

noise =

0.1 * np.random.random(len(x))

signal = np.sinc(x) +

noise 

(2) 创建一

个线性插值

函数，并应用

于有5倍数据

点个数的输

入数组：

interpreted = interpolate.interp1d(x, signal)

图灵

社区会员 heruihong 专

享 尊重版权

10.16

动手实践：一

维插值 199 

1

2 

3

4

5 

11

6

7 

8

9 

10

x2 = np.linspace(-18, 18,

180) 

y =

interpreted(x2) 

(3) 执行

与前一步相

同的操作，不

过这里使用

三次插值。

cubic = interpolate.interp1d(x, signal,

kind="cubic") 

y2 =

cubic(x2) 

(4) 使

用Matplotlitb绘制结果

。

plt.plot(x, signal, 'o', label="data")

plt.plot(x2, y, '-', label="linear")

plt.plot(x2, y2, '-', lw=2,

label="cubic") 

plt.legend()

plt.show() 

绘制的数据

点、线性插值

和三次插值

结果如下图

所示。

刚才做

了些什么

我

们用sinc函数创

建了一个数

据集并加入

了噪音，然后

使用scipy.interpolate模块中

的

interp1d类进行了

线性插值和

三次插值。示

例代码见sincinterp.py文

件。

import numpy as np

from seipy import interpolate

import matplotlib.pyplot as plt

x = np.linspaee(-18, 18,

36) 

noise =

0.1 * np.random.random(len(x))

signal = np.sinc(x) +

noise 

interpreted =

interpolate.interpld(x, signal) 

图灵社区

会员

heruihong 专享 尊

重版权

200

第 10 章

NumPy 的扩展：SciPy

x2 = np.linspace(-18, 18,

180) 

y =

interpreted(x2) 

cubic =

interpolate.interpld(x, signal, kind="cubic")

y2 = cubic(x2)

plt.plot(x, signal, 'o', label="data")

plt.plot(x2, y, '-', label="linear")

plt.plot(x2, y2, '-', lw=2,

label="cubic" ) 

plt.legend()

plt.show() 

10.17 图像

处理

我们可

以使用scipy.ndimage包进

行图像处理

。该模块包含

各种图像滤

波器和工具

函数。

10.18 动手实

践：处理 Lena

图像

在scipy.misc模块中，有

一个函数可

以载入Lena图像

。这幅Lena Soderberg的图像

是被用做

图

像处理的经

典示例图像

。我们将在该

图像上应用

一些滤波器

，并进行旋转

操作。请完成

如下

步骤。

(1) 载

入Lena图像，并使

用灰度颜色

表将其在子

图中显示出

来。 

image

= misc.lena().astype(np.float32) 

plt.subplot(221)

plt.title("Original Image") 

img

= plt.imshow(image, cmap=plt.cm.gray)

注意，我们

处理的是一

个float32类型的数

组。

(2) 中值滤波

器扫描信号

的每一个数

据点，并替换

为相邻数据

点的中值。对

图像应用中

值滤

波器并

显示在第二

个子图中。

plt.subplot(222) 

plt.title("Median Filter")

filtered = ndimage.median_filter(image, size=(42,42))

plt.imshow(filtered, cmap=plt.cm.gray) 

(3)

旋

转图像并显

示在第三个

子图中。 

plt.subplot(223)

plt.title("Rotated") 

rotated =

ndimage.rotate(image, 90) 

plt.imshow(rotated,

cmap=plt.cm.gray) 

图灵

社区会员 heruihong

专

享 尊重版权

10.18 动手实践：处

理 Lena

图像 201 

1

2 

3

4

5 

11

6

7 

8

9 

10

(4) Prewitt滤波

器是基于图

像强度的梯

度计算。对图

像应用Prewitt滤波

器并显示在

第四个子

图

中。

plt.subplot(224) 

plt.title("Prewitt Filter")

filtered = ndimage.prewitt(image)

plt.imshow(filtered, cmap=plt.cm.gray) 

plt.show()

结果如下

图所示。 

刚才

做了些什么

我们使用scipy.ndimage模

块对Lena图像进

行了一些处

理操作。示例

代码见images.py文件

。

from scipy import misc

import numpy as np

import matplotlib.pyplot as plt

from scipy import ndimage

image = misc.lena().astype(np.float32)

plt.subplot(221) 

plt.title("Original Image")

img = plt.imshow(image, cmap=plt.cm.gray)

plt.axis("off") 

plt.subplot(222)

plt.title("Median Filter") 

图灵社区会

员

heruihong 专享 尊重

版权

202

第 10 章 NumPy

的

扩展：SciPy 

filtered =

ndimage.median_filter(image, size=(42,42)) 

plt.imshow(filtered,

cmap=plt.cm.gray) 

plt.axis("off" )

plt.subplot(223) 

plt.title("Rotated")

rotated = ndimage.rotate(image, 90)

plt.imshow(rotated, cmap=plt.cm.gray) 

plt.axis("off")

plt.subplot(224) 

plt.title("Prewitt Filter")

filtered = ndimage.prewitt(image)

plt.imshow(filtered, cmap=plt.cm.gray) 

plt.axis("off")

plt.show() 

10.19 音频处

理

既然我们

已经完成了

一些图像处

理的操作，你

可能不会惊

讶我们也可

以对WAV文件进

行处

理。我们

将下载一个

WAV文件并将其

重复播放几

次。下载音频

的部分将被

省略，只保留

常规的

Python代码

。

10.20

动手实践：重

复音频片段

我们将下载

一个WAV文件，来

自电影《王牌

大贱谍》（Austin Powers）中的

一声呼喊：

“Smashing，baby!”使

用scipy.io.wavfile模块中的

read函数可以将

该文件转换

为一个NumPy

数组

。在本节教程

的最后，我们

将使用同一

模块中的write函

数写入一个

新的WAV文件。我

们将

使用tile函

数来重复播

放音频片段

。请完成如下

步骤。

(1) 使用read函

数读入文件

：

sample_rate,

data = wavfile.read(WAV_FILE)

该函数有两

个返回值——采

样率和音频

数据。在本节

教程中，我们

只需要用到

音频数据。

(2) 应

用tile函数：

repeated

= np.tile(data, int(sys.argv[1]))

(3) 使用

write函数写入一

个新文件：

wavfile.write("repeated_yababy.wav", sample_rate,

repeated) 

原

始音频数据

和重复四遍

的音频片段

如下图所示

。

图灵社区会

员

heruihong 专享 尊重

版权

10.20

动手实

践：重复音频

片段 203 

1

2 

3

4

5 

11

6

7 

8

9 

10

刚才做

了些什么

我

们读入了一

个音频片段

，将其重复四

遍并将新数

组写入了一

个新的WAV文件

。示例代码

见

repeat_audio.py文件。

from scipy.io import wavfile

import matplotlib.pyplot as plt

import urllib2 

import

numpy as np

import sys 

response

= urllib2.urlopen('http://www.thesoundarchive.com/austinpowers/ 

smashingbaby.wav')

print response.info() 

WAV_FILE

= 'smashingbaby.wav' 

filehandle

= open(WAV_FILE, 'w')

filehandle.write(response.read()) 

filehandle.close()

sample_rate, data = wavfile.read(WAV_FILE)

print "Data type", data.dtype,

"Shape", data.shape 

plt.subplot(2,

1, 1) 

plt.title("Original"

) 

plt.plot(data)

plt.subplot(2, 1, 2)

# 重复音

频片段

repeated =

np.tile(data, int(sys.argv[1])) 

#

绘制

音频数据

图

灵社区会员

heruihong 专享 尊重版

权

204 第 10 章

NumPy 的扩

展：SciPy 

plt.title("Repeated")

plt.plot(repeated) 

wavfile.write("repeated_yababy.wav", sample_rate,

repeated) 

plt.show ()

10.21 本章小结

在本章中，我

们只是触及

了SciPy和SciKits的皮毛

，学习了一点

关于文件输

入/输出、统计

、

信号处理、数

学优化、插值

以及音频和

图像处理的

知识。

在下一

章中，我们将

使用Pygame制作一

些简单但有

趣的游戏。Pygame是

一个开源的

Python

游戏库。在这

个过程中，我

们将学习NumPy和

Pygame的集成、SciKits机器

学习模块以

及其他

内容

。

图灵社区会

员 heruihong

专享 尊重

版权

11.2 动手实

践：安装

Pygame 205 

1

2 

3

4

5 

11

6

7 

8

9 

10

玩转

Pygame 

本章写给需

要使用NumPy和Pygame快

速并且简易

地进行游戏

制作的开

发

者。基本的游

戏开发经验

对于阅读本

章内容有帮

助，但并不是

必需的。

本章

涵盖以下内

容：

 Pygame基础；



Matplotlib集成

；

 屏幕像素矩

阵；



人工智能

；

 动画；



OpenGL。

11.1 Pygame

Pygame最初是

由Pete Shinners编写的一

套Python架构。顾名

思义，Pygame可以用

于制作电子

游戏。自2004年起

，Pygame成为GPL（General Public License，通用公

共许可证）下

的开源免费

软件，这意味

着你可以使

用它制作任

何类型的游

戏。Pygame基于SDL（Simple

DirectMedia Layer，

简易

直控媒体层

）。SDL是一套C语言

架构，可用于

在各种操作

系统中（包括

Linux、Mac OS

X和

Windows）访问图形

、声音、键盘以

及其他输入

设备。

11.2 动手实

践：安装

Pygame 

在本

节教程中，我

们将安装Pygame。Pygame基

本上可以与

所有版本的

Python兼容。不过在

编写本书的

时候，和Python 3仍有

一些兼容问

题，但这些问

题很可能不

久就会被修

复。请完成如

下步骤安装

Pygame。

第 11 章

图灵社

区会员

heruihong 专享

尊重版权

206 第

11

章 玩转 Pygame

(1) 根据

你所使用的

操作系统，选

择一种方式

安装Pygame。

 Debian和Ubuntu

Pygame可以

在Debian软件库中

找到：

http://packages.qa.debian.org/p/ pygame.html。



Windows 根据所

使用的Python版本

，我们可以从

Pygame的网站上（http://www.pygame. 

org/download.shtml）下

载合适的二

进制安装包

。

 Mac Pygame在Mac OS

X 10.3及以上版

本的二进制

安装包也可

以在这里下

载：

http://www.pygame.org/download.shtml。

(2)

Pygame支持distutils系统

进行编译和

安装。按照默

认选项安装

Pygame，只需要简单

执

行如下命

令： 

python

setup.py 

如果你需

要关于安装

选项的更多

信息，请输入

：

python setup.py help

(3) 编译代码需

要操作系统

上的编译器

支持。配置编

译器环境超

出了本书的

范畴。更多关

于

在Windows系统上

编译Pygame的信息

请访问http://pygame.org/wiki/CompileWindows。更多

关于在

Mac

OS X系统

上编译Pygame的信

息请访问http://pygame.org/wiki/MacCompile。 

11.3

Hello World 

我

们将制作一

个简单的游

戏，并在本章

后续内容中

加以改进。按

照程序设计

类书籍的传

统，

我们将从

一个Hello World示例程

序开始。

11.4 动手

实践：制作简

单游戏

值得

注意的是，所

有的动作都

会在所谓的

游戏主循环

中发生，以及

使用font模块来

呈现文

本。在

这个程序中

，我们将利用

Pygame的Surface对象进行

绘图，并处理

一个退出事

件。请完

成如

下步骤。

(1)

首先

，导入所需要

的Pygame模块。如果

Pygame已经正确安

装，将不会有

任何报错；否

则，

请返回安

装教程。 

import

pygame, sys 

from

pygame.locals import *

(2) 我们

将初始化Pygame，创

建一块400 × 300像素

大小的显示

区域，并将窗

口标题设置

为

Hello World!。 

图灵社区

会员

heruihong 专享 尊

重版权

11.4

动手

实践：制作简

单游戏 207 

1

2 

3

4

5 

11

6

7 

8

9 

10

pygame.init() 

screen =

pygame.display.set_mode((400, 300)) 

pygame.display.set_caption('Hello

World!') 

(3) 游戏

通常会有一

个主循环一

直运行，直到

退出事件的

发生。在本例

中，我们仅仅

在坐标

(100, 100)处设

置一个Hello World文本

标签，文本的

字体大小为

19，颜色为红色

。

while True:

sysFont = pygame.font.SysFont("None", 19)

rendered = sysFont.render

('Hello World', 0, (255,

100, 100))

screen.blit(rendered, (100, 100))

for event in pygame.event.get():

if event.type ==

QUIT: 

 pygame.quit()

sys.exit()

pygame.display.update() 

得到的结果

如下图所示

。

示例程序Hello World的

完整代码： 

import

pygame, sys 

from

pygame.locals import *

pygame.init() 

screen =

pygame.display.set_mode((400, 300)) 

pygame.display.set_caption('Hello

World!') 

while True:

sysFont = pygame.font.SysFont("None",

19) 

 rendered

= sysFont.render ('Hello World',

0, (255, 100, 100))

screen.blit(rendered, (100, 100))

for event in

pygame.event.get(): 

图

灵社区会员

heruihong 专享

尊重版

权

208 第 11

章 玩转

Pygame

if event.type == QUIT:

pygame.quit()

sys.exit() 

 pygame.display.update()

刚才做了些

什么

在本节

教程中，虽然

看起来内容

不多，但其实

我们已经学

习了很多。我

们将出现过

的函数总

结

在下面的表

格中。

函

数 描

述

pygame.init() 该函数用

于初始化，需

要在调用其

他Pygame函数前被

调用

pygame.display.set_mode((400, 300)) 该函数

创建所谓的

Surface对象用于绘

图。我们为该

函数提

供一

个元组来表

示对象的大

小

pygame.display.set_caption('Hello World!') 该函数可

将窗口标题

设置为指定

的字符串

pygame.font.SysFont("None",

19) 该

函数根据英

文逗号隔开

的系统字体

列表字符串

（在本例中

为

None）和字体大小

创建字体对

象

sysFont.render('Hello

World', 0, (255, 100,

100)) 

该函数在

Surface对象上呈现

文本。最后一

个参数是一

个元

组，即以

RGB值表示的颜

色

screen.blit(rendered, (100, 100)) 该函数在

Surface对象上进行

绘制

pygame.event.get() 该函数

用于获取Event对

象列表。Event对象

表示系统中

的

一些特殊

事件，如用户

退出游戏

pygame.quit()

该

函数清理Pygame使

用的资源。在

退出游戏前

调用此函数

pygame.display.update() 该函数刷新

屏幕上显示

的内容

11.5 动画

大部分游戏

，即使是最“静

态”的那些，也

有一定程度

的动画部分

。从一个程序

员的角度来

看，动画只不

过是不同的

时间在不同

地点显示对

象，从而模拟

对象的移动

。

Pygame提供Clock对象，用

于控制每秒

钟绘图的帧

数。这可以保

证动画与CPU的

快慢无关。

11.6 动

手实践：使用

NumPy 和

Pygame 制作动画

对象 

我们将

载入一个图

像并使用NumPy定

义一条沿屏

幕的顺时针

路径。请完成

如下步骤。

(1) 创

建一个Pygame的Clock对

象，如下所示

： 

clock

= pygame.time.Clock() 

图灵社区会

员

heruihong 专享 尊重

版权

11.6

动手实

践：使用 NumPy 和 Pygame

制

作动画对象

209 

1

2 

3

4

5 

11

6

7 

8

9 

10

(2) 和本书配套

的源代码文

件一起，有一

张头部的图

片。我们将载

入这张图片

，并使之在屏

幕上移动。 

img

= pygame.image.load('head.jpg') 

(3)

我

们将定义一

些数组来储

存动画中图

片的位置坐

标。既然对象

可以被移动

，那么应该有

四个方向——上

、下、左、右。每一

个方向上都

有40个等距的

步长。我们将

各方向上的

值全部初

始

化为0。 

steps

= np.linspace(20, 360, 40).astype(int)

right = np.zeros((2, len(steps)))

down = np.zeros((2, len(steps)))

left = np.zeros((2, len(steps)))

up = np.zeros((2, len(steps)))

(4) 设置图

片的位置坐

标是一件很

烦琐的事情

。不过，有一个

小技巧可以

用上——[::-1]可

以获

得倒序的数

组元素。

right[0] = steps

right[1] = 20

down[0] = 360

down[1] = steps

left[0] = steps[::-1]

left[1] = 360

up[0] = 20

up[1] = steps[::-1]

(5) 四个

方向的路径

可以连接在

一起，但需要

先用T操作符

对数组进行

转置操作，使

得它们以

正

确的方式对

齐。

pos = np.concatenate((right.T, down.T,

left.T, up.T)) 

(6)

在主循环

中，我们设置

时钟周期为

每秒30帧： 

clock.tick(30)

以下

是动画的截

图。 

图灵社区

会员 heruihong

专享 尊

重版权

210 第

11 章

玩转 Pygame

你可以

访问https://www.youtube.com/watch?v=m2TagGiq1fs观看本

动画的视频

。

本例中的代

码用到了几

乎我们学习

到的所有内

容，不过应该

很容易理解

： 

import

pygame, sys 

from

pygame.locals import *

import numpy as np

pygame.init() 

clock =

pygame.time.Clock() 

screen =

pygame.display.set_mode((400, 400)) 

pygame.display.set_caption('Animating

Objects') 

img =

pygame.image.load('head.jpg') 

steps =

np.linspace(20, 360, 40).astype(int)

right = np.zeros((2, len(steps)))

down = np.zeros((2, len(steps)))

left = np.zeros((2, len(steps)))

up = np.zeros((2, len(steps)))

right[0] = steps

right[1] = 20

down[0] = 360

down[1] = steps

left[0] = steps[::-1]

left[1] = 360

up[0] = 20

up[1] = steps[::-1]

pos = np.concatenate((right.T, down.T,

left.T, up.T)) 

i

= 0 

while

True: 

 #

清屏

 screen.fill((255, 255,

255)) 

 if

i >= len(pos):

i = 0

screen.blit(img, pos[i])

i += 1

for event in pygame.event.get():

if event.type ==

QUIT: 

 pygame.quit()

sys.exit()

pygame.display.update() 

 clock.tick(30)

刚才做

了些什么

在

本节教程中

我们学习了

一点关于动

画的内容，其

中最重要的

就是时钟的

概念。我们将

使用

图灵社

区会员 heruihong

专享

尊重版权

11.8 动

手实践：在 Pygame

中

使用 Matplotlib 211

1 

2

3 

4

5

11 

6

7

8 

9

10 

到的新

函数总结在

下面的表格

中。

函

数 描 述

pygame.time.Clock() 该函数创建

一个游戏中

的时钟对象

clock.tick(30)

该函数设置

时钟周期。这

里的30即每秒

钟的帧数

11.7 Matplotlib

我

们在第9章中

学习过Matplotlib，这是

一个可以便

捷绘图的开

源工具库。我

们可以在Pygame

中

集成Matplotlib，绘制各

种各样的图

像。

11.8 动手实践

：在 Pygame

中使用 Matplotlib 

在

本节教程中

，我们将使用

前一节教程

中的位置坐

标并为其绘

制图像。请完

成如下步骤

。

(1) 使用非交互

式的后台：为

了在Pygame中集成

Matplotlib，我们需要使

用一个非交

互式的后

台

，否则Matplotlib会默认

显示一个GUI窗

口。我们将引

入Matplotlib主模块并

调用use函数。该

函

数必须在

引入Matplotlib主模块

后并引入其

他Matplotlib模块前立

即调用。

import matplotlib as mpl

mpl.use("Agg") 

(2) 非交

互式绘图可

以在Matplotlib画布（canvas）上

完成。创建画

布需要引入

模块、创建图

像和子图。我

们将指定图

像大小为3

× 3英

寸。更多细节

请参阅本节

末尾的代码

。 

import

matplotlib.pyplot as plt

import matplotlib.backends.backend_agg as agg

fig = plt.figure(figsize=[3, 3])

ax = fig.add_subplot(111)

canvas = agg.FigureCanvasAgg(fig)

(3) 在非交互模

式下绘图比

在默认模式

下稍复杂一

点。由于我们

要反复多次

绘图，因此有

必

要将绘图

代码组织成

一个函数。图

像最终应绘

制在画布上

，这使得我们

的步骤变得

复杂了一些

。

在本例的最

后，你可以找

到这些函数

更为详细的

说明。

def plot(data):

ax.plot(data) 

 canvas.draw()

renderer = canvas.get_renderer()

raw_data = renderer.tostring_rgb()

size = canvas.get_width_height()

return pygame.image.fromstring(raw_data, size,

"RGB") 

图灵社

区会员 heruihong

专享

尊重版权

212 第

11 章

玩转 Pygame 

动画

的截图如下

所示。你也可

以访问YouTube观看

本例的视频

，地址为https://www.youtube.

com/watch?v=t6qTeXxtnl4。 

(4) 改动

后的代码如

下所示：

import pygame, sys

from pygame.locals import *

import numpy as np

import matplotlib as mpl

mpl.use("Agg") 

import matplotlib.pyplot

as plt 

import

matplotlib.backends.backend_agg as agg

fig = plt.figure(figsize=[3, 3])

ax = fig.add_subplot(111)

canvas = agg.FigureCanvasAgg(fig)

def plot(data):

ax.plot(data) 

 canvas.draw()

renderer = canvas.get_renderer()

raw_data = renderer.tostring_rgb()

size = canvas.get_width_height()

return pygame.image.fromstring(raw_data, size,

"RGB") 

pygame.init()

clock = pygame.time.Clock()

图灵

社区会员 heruihong 专

享 尊重版权

11.8

动手实践：在

Pygame 中使用 Matplotlib 213

1 

2

3 

4

5

11 

6

7

8 

9

10 

screen =

pygame.display.set_mode((400, 400)) 

pygame.display.set_caption('Animating

Objects') 

img =

pygame.image.load('head.jpg') 

steps =

np.linspace(20, 360, 40).astype(int)

right = np.zeros((2, len(steps)))

down = np.zeros((2, len(steps)))

left = np.zeros((2, len(steps)))

up = np.zeros((2, len(steps)))

right[0] = steps

right[1] = 20

down[0] = 360

down[1] = steps

left[0] = steps[::-1]

left[1] = 360

up[0] = 20

up[1] = steps[::-1]

pos = np.concatenate((right.T, down.T,

left.T, up.T)) 

i

= 0 

history

= np.array([]) 

surf

= plot(history) 

while

True: 

 #

清屏

screen.fill((255, 255, 255))

if i >=

len(pos): 

 i

= 0

surf = plot(history)

screen.blit(img, pos[i])

history = np.append(history, pos[i])

screen.blit(surf,(100, 100))

i += 1

for event in pygame.event.get():

if event.type ==

QUIT: 

 pygame.quit()

sys.exit()

pygame.display.update() 

 clock.tick(30)

刚才做了些

什么

下表给

出了绘图相

关函数的说

明。

图灵社区

会员 heruihong

专享 尊

重版权

214 第

11 章

玩转 Pygame

函 数 描

述

mpl.use("Agg")

该函数指

定使用非交

互式后端

plt.figure(figsize=[3, 3]) 该

函数创建一

个大小为3

× 3平

方英寸的图

像

agg.FigureCanvasAgg(fig) 该函数在

非交互模式

下创建一个

画布

canvas.draw() 该函数

在画布上进

行绘制

canvas.get_renderer() 该函

数获取画布

的渲染器

11.9 屏

幕像素

Pygame的surfarray模

块可以处理

PygameSurface对象和NumPy数组

之间的转换

。你或许

还记

得，NumPy可以快速

、高效地处理

大规模数组

。

11.10 动手实践：访

问屏幕像素

在本节教程

中，我们将平

铺一张小图

片以填充游

戏界面。请完

成如下步骤

。

(1) array2d函数将像素

存入一个二

维数组。还有

相似的函数

，将像素存入

三维数组。我

们

将avatar头像图

片的像素存

入数组： 

pixels =

pygame.surfarray.array2d(img) 

(2) 我们

使用shape属性获

取像素数组

pixels的形状，并据

此创建游戏

界面。游戏界

面的长

和宽

都将是像素

数组的7倍大

小。 

X =

pixels.shape[0] * 7

Y = pixels.shape[1] *

7 

screen =

pygame.display.set_mode((X, Y)) 

(3)

使用tile函数

可以轻松平

铺图片。由于

颜色是定义

为整数的，像

素数据需要

被转换成

整

数。 

new_pixels

= np.tile(pixels, (7, 7)).astype(int)

(4) surfarray模块中有

一个专用函

数blit_array，可以将数

组中的像素

呈现在屏幕

上。 

pygame.surfarray.blit_array(screen,

new_pixels) 

效果如下

图所示。

平铺

图片的完整

代码如下： 

import pygame,

sys 

from pygame.locals

import * 

import

numpy as np

图

灵社区会员

heruihong 专享 尊重版

权

11.10

动手实践

：访问屏幕像

素 215 

1

2 

3

4

5 

11

6

7 

8

9 

10

pygame.init() 

img =

pygame.image.load('head.jpg') 

pixels =

pygame.surfarray.array2d(img) 

X =

pixels.shape[0] * 7

Y = pixels.shape[1] *

7 

screen =

pygame.display.set_mode((X, Y)) 

pygame.display.set_caption('Surfarray

Demo') 

new_pixels =

np.tile(pixels, (7, 7)).astype(int)

while True:

screen.fill((255, 255, 255))

pygame.surfarray.blit_array(screen, new_pixels)

for event in pygame.event.get():

if event.type ==

QUIT: 

 pygame.quit()

sys.exit()

pygame.display.update() 

刚才做了

些什么

下面

的表格给出

了新函数及

其属性的简

单说明。

函 数

描 述

pygame.surfarray.array2d(img)

该函数

将像素数据

存入一个二

维数组

pygame.surfarray.blit_array(screen, new_pixels) 该函

数将数组中

的像素呈现

在屏幕上

图

灵社区会员

heruihong 专享 尊重版

权

216

第 11 章 玩转

Pygame

11.11 人工智能

在

游戏中，我们

通常需要模

拟一些智能

行为。scikit-learn项目旨

在提供机器

学习的API，

我最

喜欢的是其

出色的文档

。我们可以使

用操作系统

的包管理器

来安装scikit-learn，这取

决

于你所使

用的操作系

统是否支持

，但应该是最

为简便的安

装方式。Windows用户

可以直接从

项目

网站上

下载安装包

。

在Debian和Ubuntu上，该项

目名为python-sklearn。在MacPorts命

名为py26-scikits￾learn和py27-scikits-learn。我们

也可以从源

代码安装或

使用easy_install工具，还

有第

三方发

行版如Python(x,

y)、Enthought和NetBSD。

我

们可以在命

令行中键入

如下命令安

装scikit-learn：

pip install

-U scikit-learn 

也可以使

用如下命令

：

easy_install -U scikit-learn

这个命令可

能会由于权

限设置无法

工作，因此你

可能需要在

命令前面加

上sudo或以管理

员

身份登陆

系统。

11.12 动手实

践：数据点聚

类

我们将随

机生成一些

数据点并对

它们进行聚

类，也就是将

相近的点放

到同一个聚

类中。这只

是

scikit-learn提供的众多

技术之一。聚

类是一种机

器学习算法

，即依据相似

度对数据点

进行分

组。随

后，我们将计

算一个关联

矩阵。关联矩

阵即包含关

联值的矩阵

，如点与点之

间的距离。最

后，

我们将使

用scikit-learn中的AffinityPropagation类对

数据点进行

聚类。请完成

如下步骤。

(1) 我

们将在400 × 400像素

的方块内随

机生成30个坐

标点：

positions = np.random.randint(0, 400,

size=(30, 2)) 

(2)

我们将

使用欧氏距

离（Euclidean distance）来初始化

关联矩阵。 

positions_norms

= np.sum(positions ** 2,

axis=1) 

S =

- positions_norms[:, np.newaxis] -

positions_norms[np.newaxis, :] + 2

* 

np.dot(positions, positions.T)

(3) 将

前一步的结

果提供给AffinityPropagation类

。该类将为每

一个数据点

标记合适的

聚类编号。 

aff_pro

= sklearn.cluster.AffinityPropagation().fit(S) 

图

灵社区会员

heruihong

专享 尊重版

权

11.12 动手实践

：数据点聚类

217

1 

2

3 

4

5

11 

6

7

8 

9

10 

labels =

aff_pro.labels_ 

(4) 我们将为每

一个聚类绘

制多边形。该

函数需要的

参数包括Surface对

象、颜色（本例

中

使用红色

）和数据点列

表。 

pygame.draw.polygon(screen, (255,

0, 0), polygon_points[i])

绘制结果

如下图所示

。 

聚类程序的

示例代码如

下：

import numpy as np

import sklearn.cluster 

import

pygame, sys 

from

pygame.locals import *

positions = np.random.randint(0, 400,

size=(30, 2)) 

positions_norms

= np.sum(positions ** 2,

axis=1) 

S =

- positions_norms[:, np.newaxis] -

positions_norms[np.newaxis, :] + 2

* 

np.dot(positions, positions.T)

aff_pro = sklearn.cluster.AffinityPropagation().fit(S)

labels = aff_pro.labels_

polygon_points = []

for i in xrange(max(labels)

+ 1):

polygon_points.append([]) 

# 对数据点

进行聚类

图

灵社区会员

heruihong 专享 尊重版

权

218

第 11 章 玩转

Pygame

for i in xrange(len(labels)):

polygon_points[labels[i]].append(positions[i]) 

pygame.init()

screen = pygame.display.set_mode((400, 400))

while True:

for i in xrange(len(polygon_points)):

pygame.draw.polygon(screen, (255, 0,

0), polygon_points[i])

for event in pygame.event.get():

if event.type ==

QUIT: 

 pygame.quit()

sys.exit()

pygame.display.update() 

刚才做了些

什么

下面的

表格给出了

人工智能示

例代码中最

重要的几个

函数的功能

说明。

函 数 描

述

sklearn.cluster.AffinityPropagation().fit(S)

该函数创

建AffinityPropagation对象并根

据关联矩阵

进行聚类

pygame.draw.polygon(screen, (255, 0,0),

polygon 

points[i]) 该

函数根据指

定的Surface对象、颜

色（在本例中

为红色）

和数

据点列表绘

制多边形

11.13 OpenGL 和

Pygame

OpenGL是专业的用

于二维和三

维图形的计

算机图形应

用程序接口

（API），由函数和一

些常

数构成

。我们将重点

关注其Python的实

现，即PyOpenGL。使用如

下命令安装

PyOpenGL： 

pip

install PyOpenGL PyOpenGL_accelerate

你可能需要

根权限来执

行这条命令

。以下是相应

的easy_install命令： 

easy_install PyOpenGL

PyOpenGL_accelerate 

11.14 动手

实践：绘制谢

尔宾斯基地

毯

为了演示

OpenGL的功能，我们

将使用OpenGL绘制

谢尔宾斯基

地毯（Sierpinski gasket），亦

称作

谢尔宾斯基

三角形（Sierpinski triangle）或谢

尔宾斯基筛

子（Sierpinski

sieve）。这是一种

三

角形形状

的分形（fractal），由数

学家瓦茨瓦

夫·谢尔宾斯

基（Waclaw Sierpinski）提出。这个

三

角形是经

过原则上无

穷的递归过

程得到的。请

完成如下步

骤绘制谢尔

宾斯基地毯

。

图灵社区会

员 heruihong 专享 尊重

版权

11.14 动手实

践：绘制谢尔

宾斯基地毯

219 

1

2 

3

4

5 

11

6

7 

8

9 

10

(1) 首先，我们将

初始化一些

OpenGL相关的基本

要素，包括设

置显示模式

和背景颜色

等。在

本节的

末尾可以找

到相关函数

的详细说明

。

def display_openGL(w, h):

pygame.display.set_mode((w,h), 

 pygame.OPENGL|pygame.DOUBLEBUF)

glClearColor(0.0, 0.0, 0.0,

1.0) 

 glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)

glu0rtho2D(0, w, 0,

h) 

(2) 依据分形的

算法，我们应

该尽可能多

地准确地绘

制结点。第一

步，我们将绘

制颜色设置

为红色。第二

步，我们定义

三角形的顶

点。随后，我们

定义随机挑

选的索引，即

从三角形的

3个

顶点中任

意选出其中

一个。从三角

形靠中间的

位置随意指

定一点——这个

点在哪里并

不重要。然

后

，我们在前一

次的点和随

机选出的三

角形顶点之

间的中点处

进行绘制。最

后，我们强制

刷新缓

冲以

保证绘图命

令全部得以

执行。

glColor3f(1.0, 0, 0)

vertices = np.array([[0, 0],

[DIM/2, DIM], [DIM, 0]])

NPOINTS = 9000

indices = np.random.random_integers(0, 2,

NPOINTS) 

point =

[175.0, 150.0] 

for

i in xrange(NPOINTS):

glBegin(GL_POINTS) 

 point

= (point + vertices

[indices[i]])/2.0 glVertex2fv(point) glEnd()

glFlush() 

谢尔宾

斯基三角形

如下图所示

。

图灵社区会

员 heruihong 专享 尊重

版权

220 第 11 章

玩

转 Pygame 

绘制谢尔

宾斯基地毯

的完整代码

如下：

import pygame 

from

pygame.locals import *

import numpy as np

from OpenGL.GL import *

from OpenGL.GLU import *

def display_openGL(w, h):

pygame.display.set_mode((w,h), pygame.OPENGL|pygame.DOUBLEBUF)

glClearColor(0.0, 0.0, 0.0, 1.0)

glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)

glu0rtho2D(0, w, 0, h)

def main():

pygame.init() 

 pygame.display.set_caption('0penGL

Demo') 

 DIM

= 400

display_openGL(DIM, DIM)

glColor3f(1.0, 0, 0)

vertices = np.array([[0, 0],

[DIM/2, DIM], [DIM, 0]])

NPOINTS = 9000

indices = np.random.random_integers(0,

2, NPOINTS)

point = [175.0, 150.0]

for i in

xrange(NPOINTS): 

 glBegin(GL_POINTS)

point = (point

+ vertices[indices[i]])/2.0

glVertex2fv(point) 

 glEnd()

glFlush()

pygame.display.flip() 

 while

True: 

 for

event in pygame.event.get():

if event.type == QUIT:

return 

if

__name__ == '__main__':

main() 

刚才做

了些什么

如

前所述，下面

的表格给出

了示例代码

中最重要的

一些函数的

功能说明。

图

灵社区会员

heruihong 专享 尊重版

权

11.16

动手实践

：模拟生命 221 

1

2 

3

4

5 

11

6

7 

8

9 

10

函

数 描 述

pygame.display.set_mode((w,h),

pygame.OPENGL|pygame.DOUBLEBUF) 该函

数将显示模

式设置为指

定的宽度、高

度和OpenGL对

应的

显示类型

glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)

该

函数使用掩

码清空缓冲

区。在本例中

，我们清空的

是颜

色和深

度缓冲区

glu0rtho2D(0, w,

0, h) 该

函数根据上

、下、左、右的裁

切平面坐标

定义一个2D

的

正交投影矩

阵

glColor3f(1.0, 0, 0) 该函数根

据三个浮点

数表示的RGB颜

色来设置当

前的绘

图颜

色。在本例中

为红色

glBegin(GL_P0INTS) 该函

数限定一组

或多组图元

的定点定义

glVertex2fv(point) 该函数根据

一个顶点产

生一个点

glEnd() 该

函数结束以

glBegin开始的代码

段

glFlush() 该函数强

制刷新缓冲

区，执行绘图

命令

11.15 模拟游

戏

作为最后

一个示例，我

们将根据生

命游戏（Conway’ s

Game of Life）来完

成一个模拟

生命的

游戏

。原始的生命

游戏是基于

几个基本规

则的。我们从

一个随机初

始化的二维

方形网格开

始。网

格中每

一个细胞的

状态可能是

生或死，由其

相邻的8个细

胞决定。在这

个规则下可

以使用卷积

进

行计算，我

们需要SciPy的工

具包完成卷

积运算。

11.16 动手

实践：模拟生

命

下面的代

码实现了生

命游戏，并做

了如下修改

：

 单击鼠标绘

制一个十字

架；



按下r 键将

网格重置为

随机状态；

 按

下b

键在鼠标

位置创建一

个方块；

 按下

g 键创建一个

形如滑翔机

的图案。

本例

的代码中最

重要的数据

结构就是一

个二维数组

，用于维护游

戏界面上像

素的颜色值

。该

数组被随

机初始化，然

后在游戏主

循环中每一

轮迭代重新

计算一次。在

本节的末尾

可以找到相

关

函数的更

多信息。

(1)

根据

游戏规则，我

们将使用卷

积进行计算

。 

def get_pixar(arr,

weights): 

 states

= ndimage.convolve(arr, weights, mode='wrap')

图灵社区会

员 heruihong 专享 尊重

版权

222 第 11 章

玩

转 Pygame

bools = (states ==

13) | (states ==

12 ) | (states

== 3)

return bools.astype(int) 

(2)

我们可以

使用在第2章

中学到的索

引技巧绘制

十字架。 

def draw_cross(pixar):

(posx, posy) =

pygame.mouse.get_pos() 

 pixar[posx,

:] = 1

pixar[:, posy] = 1

(3) 随机

初始化网格

：

def random_init(n):

return np.random.random_integers(0, 1,

(n, n)) 

本例的完整

代码如下：

import os, pygame

from pygame.locals import *

import numpy as np

from scipy import ndimage

def get_pixar(arr, weights):

states = ndimage.convolve(arr, weights,

mode='wrap') 

 bools

= (states == 13)

| (states == 12

) | (states ==

3) 

 return

bools.astype(int) 

def draw_cross(pixar):

(posx, posy) =

pygame.mouse.get_pos() 

 pixar[posx,

:] = 1

pixar[:, posy] = 1

def random_init(n):

return np.random.random_integers(0, 1, (n,

n)) 

def draw_pattern(pixar,

pattern): 

 print

pattern 

 if

pattern == 'glider':

coords = [(0,1), (1,2),

(2,0), (2,1), (2,2)]

elif pattern == 'block':

coords = [(3,3),

(3,2), (2,3), (2,2)]

elif pattern == 'exploder':

coords = [(0,1),

(1,2), (2,0), (2,1), (2,2),

(3,3)] 

 elif

pattern == 'fpentomino':

coords = [(2,3),(3,2),(4,2),(3,3),(3,4)]

pos = pygame.mouse.get_pos()

xs = np.arange(0, pos[0],

10) 

 ys

= np.arange(0, pos[1], 10)

图

灵社区会员

heruihong 专享 尊重版

权

11.16

动手实践

：模拟生命 223 

1

2 

3

4

5 

11

6

7 

8

9 

10

for x in xs:

for y in

ys: 

 for

i, j in coords:

pixar[x + i,

y + j] =

1 

def main():

pygame.init ()

N = 400

pygame.display.set_mode((N, N))

pygame.display.set_caption("Life Demo")

screen = pygame.display.get_surface()

pixar = random_init(N)

weights = np.array([[1,1,1], [1,10,1],

[1,1,1]]) 

 cross_on

= False

while True:

pixar = get_pixar(pixar, weights)

if cross_on:

draw_cross(pixar) 

 pygame.surfarray.blit_array(screen,

pixar * 255 **

3) 

 pygame.display.flip()

for event in

pygame.event.get(): 

 if

event.type == QUIT:

return 

 if

event.type == MOUSEBUTTONDOWN:

cross_on = not cross_on

if event.type ==

KEYDOWN: 

 if

event.key == ord('r'):

pixar = random_init(N)

print "Random init"

if event.key == ord('g'):

draw_pattern(pixar, 'glider')

if event.key == ord('b'):

draw_pattern(pixar, 'block')

if event.key == ord('e'):

draw_pattern(pixar, 'exploder')

if event.key == ord('f'):

draw_pattern(pixar, 'fpentomino')

if _name_ == '_main_':

main() 

你

可以访问YouTube观

看本例的视

频，地址为https://www.youtube.com/watch?v=NNsU￾yWTkXM。以

下是游戏运

行时的截图

。

图灵社区会

员 heruihong 专享 尊重

版权

224 第 11 章

玩

转 Pygame 

刚才做了

些什么

我们

使用的一些

NumPy和SciPy的函数需

要进一步说

明，参见下面

的表格。 

函 数

描

述

ndimage.convolve(arr, weights,

mode='wrap') 该函数

在包络模式

下对指定的

数组进行卷

积操作。该模

式会处理数

组的边界

bools.astype(int) 该

函数将布尔

数组转换为

整数数组

np.arange(0, pos[0], 10) 该

函数创建一

个范围从0到

pos[0]，且元素间隔

为10的数组。所

以如果

pos[0] 为1000，我

们将得到0, 10, 20,

…, 990 

11.17

本

章小结

一开

始，你可能会

觉得在本书

中提到Pygame有些

奇怪。希望你

在阅读完本

章内容后，觉

察

到一起使

用NumPy和Pygame的妙处

。毕竟游戏需

要很多计算

，因此NumPy和SciPy是理

想的选择。

游

戏也需要人

工智能，如scikit-learn中

可以找到相

应的支持。总

之，编写游戏

是一件有趣

的

事情，我们

希望最后一

章的内容如

同前面十章

教程的正餐

之后的甜点

或咖啡。如果

你还没有“吃

饱”，请参阅本

书作者的另

一本著作《NumPy攻

略：Python科学计算

与数据分析

》①（Packt），比

本书更为

深入且与本

书内容互不

重叠。

——————————

① 已由人

民邮电出版

社图灵公司

出版。——编者注

图灵社区会

员 heruihong 专享

尊重

版权

错误！文

档中没有指

定样式的文

字。 225

1 

2

3 

4

5

11 

6

7

8 

9

10 

突击测验

答案

第

1 章 NumPy 快

速入门

arrange(5)的作

用是什么 创

建一个包含

5个元素的NumPy数

组，取值分别

为0~4的整数

第

2 章

NumPy 基础

ndarray对象

的维度属性

是以下列哪

种方式存储

的 存储在元

组中

第 3 章 常

用函数

以下

哪个函数可

以返回数组

元素的加权

平均值 average 

第

4 章

便捷函数

以

下哪个函数

返回的是两

个数组的协

方差 cov

第 5 章 矩

阵和通用函

数

在使用mat和

bmat函数创建矩

阵时，需要输

入字符串来

定义矩阵。在

字符串中，以

下哪一个英

文

标点符号

是矩阵的行

分隔符

分号

“;”

第

6 章 深入学

习 NumPy

模块

以下

哪个函数可

以创建矩阵

mat 

图灵社区会

员

heruihong 专享 尊重

版权

226

突击测

验答案

第 7 章

专用函数

以

下哪一个NumPy模

块可以生成

随机数 random 

第

8 章

质量控制

以

下哪一个是

assert_almost_equal函数的参数

，用来指定小

数点后的精

度 decimal

第 9 章 使用

Matplotlib

绘图

plot函数的

作用是什么

1、2、3都不是

第 10

章

NumPy 的扩展：SciPy

以下

哪个函数可

以加载.mat型文

件 loadmat

图灵社区

会员 heruihong 专享 尊

重版权

图灵

社区会员 heruihong 专

享 尊重版权

最前沿的IT类

电⼦书发售平

台

电子出版

的时代已经

来临。在许多

出版界同行

还在犹

豫彷

徨的时候，图

灵社区已经

采取实际行

动拥抱这个

出版业巨变

。作为国内第

一家发售电

子图书的IT类

出

版商，图灵

社区目前为

读者提供两

种DRM-free的阅读

体

验：在线阅读

和PDF。

相比纸质

书，电子书具

有许多明显

的优势。它不

仅发

布快，更

新容易，而且

尽可能采用

了彩色图片

（即使

有的书

纸质版是黑

白印刷的）。读

者还可以方

便地进

行搜

索、剪贴、复制

和打印。

ituring.com.cn

图灵

社区进一步

把传统出版

流程与电子

书出版业务

紧密结合，目

前已实现作

译者网上交

稿、编辑网上

审稿、按章发

布的电子出

版模式。这种

新的出版模

式，我们称之

为“敏捷出版

”，它可以让读

者以较

快的

速度了解到

国外最新技

术图书的内

容，弥补以

往

翻译版技术

书“出版即过

时”的缺憾。同

时，敏

捷出版

使得作、译、编

、读的交流更

为方便，可以

提前消灭书

稿中的错误

，最大程度地

保证图书出

版

的质量。

欢

迎加⼊

图灵社

区

最⽅便的开

放出版平台

图灵社区向

读者开放在

线写作功能

，协助你实现

自出

版和开

源出版的梦

想。利用“合集

”功能，你就能

联

合二三好

友共同创作

一部技术参

考书，以免费

或收费

的形

式提供给读

者。（收费形式

须经过图灵

社区立项

评

审。）这极大地

降低了出版

的门槛。只要

你有写作

的

意愿，图灵社

区就能帮助

你实现这个

梦想。成熟的

书稿，有机会

入选出版计

划，同时出版

纸质书。

图灵

社区引进出

版的外文图

书，都将在立

项后马上在

社区公布。如

果你有意翻

译哪本图书

，欢迎你来社

区

申请。只要

你通过试译

的考验，即可

签约成为图

灵的

译者。当

然，要想成功

地完成一本

书的翻译工

作，是

需要有

坚强的毅力

的。

最直接的

读者交流平

台

在图灵社

区，你可以十

分方便地写

作文章、提交

勘

误、发表评

论，以各种方

式与作译者

、编辑人员和

其他读者进

行交流互动

。提交勘误还

能够获赠社

区

银子。

你可

以积极参与

社区经常开

展的访谈、审

读、评选

等多

种活动，赢取

积分和银子

，积累个人声

望。

图灵社区

会员 heruihong 专享 尊

重版权
