
























   im

gs_li

st = 

[]



     

   fo

r img

s in 

image

s:



     

     

  img

s_lis

t.app

end(s

elf.n

umpy_

to_pi

l(img

s))



     

   re

turn 

imgs_

list





    #

 Copi

ed fr

om di

ffuse

rs.pi

pelin

es.st

able_

diffu

sion.

pipel

ine_s

table

_diff

usion

.Stab

leDif

fusio

nPipe

line.

prepa

re_ex

tra_s

tep_k

wargs



    d

ef pr

epare

_extr

a_ste

p_kwa

rgs(s

elf, 

gener

ator,

 eta)

:



     

   # 

prepa

re ex

tra k

wargs

 for 

the s

chedu

ler s

tep, 

since

 not 

all s

chedu

lers 

have 

the s

ame s

ignat

ure



     

   # 

eta (

η) is

 only

 used

 with

 the 

DDIMS

chedu

ler, 

it wi

ll be

 igno

red f

or ot

her s

chedu

lers.



     

   # 

eta c

orres

ponds

 to η

 in D

DIM p

aper:

 http

s://a

rxiv.

org/a

bs/20

10.02

502



     

   # 

and s

hould

 be b

etwee

n [0,

 1]





     

   ac

cepts

_eta 

= "et

a" in

 set(

inspe

ct.si

gnatu

re(se

lf.sc

hedul

er.st

ep).p

arame

ters.

keys(

))



     

   ex

tra_s

tep_k

wargs

 = {}



     

   if

 acce

pts_e

ta:



     

     

  ext

ra_st

ep_kw

args[

"eta"

] = e

ta





     

   # 

check

 if t

he sc

hedul

er ac

cepts

 gene

rator



     

   ac

cepts

_gene

rator

 = "g

enera

tor" 

in se

t(ins

pect.

signa

ture(

self.

sched

uler.

step)

.para

meter

s.key

s())



     

   if

 acce

pts_g

enera

tor:



     

     

  rai

se Ru

ntime

Error

("If 

you f

ixed 

the l

ogic 

for g

enera

tor, 

pleas

e rem

ove t

his. 

Other

wise,

 plea

se us

e oth

er sa

mpler

.")



     

     

  ext

ra_st

ep_kw

args[

"gene

rator

"] = 

gener

ator



     

   re

turn 

extra

_step

_kwar

gs





    d

ef de

code_

laten

ts(se

lf, l

atent

s):



     

   # 

decod

e lat

ents 

with 

5-dim

s



     

   la

tents

 = 1 

/ sel

f.vae

.conf

ig.sc

aling

_fact

or * 

laten

ts





     

   bs

 = le

n(lat

ents)



     

   la

tents

 = re

arran

ge(la

tents

, 'b 

c ...

 -> (

b c) 

...')



     

   im

age =

 self

.vae.

decod

e(lat

ents)

.samp

le



     

   im

age =

 rear

range

(imag

e, '(

b c) 

... -

> b c

 ...'

, b=b

s)





     

   im

age =

 (ima

ge / 

2 + 0

.5).c

lamp(

0, 1)



     

   # 

we al

ways 

cast 

to fl

oat32

 as t

his d

oes n

ot ca

use s

ignif

icant

 over

head 

and i

s com

patib

le wi

th bf

loat1

6



     

   im

age =

 rear

range

(imag

e.cpu

(), '

... c

 h w 

-> ..

. h w

 c').

float

().nu

mpy()



     

   re

turn 

image





    @

torch

.no_g

rad()



    d

ef __

call_

_(



     

   se

lf,



     

   pr

ompt:

 Unio

n[str

, Lis

t[str

]],



     

   im

age: 

torch

.Floa

tTens

or,



     

   ca

mera_

param

: Uni

on[to

rch.T

ensor

, Non

e],



     

   he

ight:

 int,



     

   wi

dth: 

int,



     

   nu

m_inf

erenc

e_ste

ps: i

nt = 

50,



     

   gu

idanc

e_sca

le: f

loat 

= 7.5

,



     

   ne

gativ

e_pro

mpt: 

Optio

nal[U

nion[

str, 

List[

str]]

] = N

one,



     

   nu

m_ima

ges_p

er_pr

ompt:

 Opti

onal[

int] 

= 1,



     

   et

a: fl

oat =

 0.0,



     

   ge

nerat

or: O

ption

al[to

rch.G

enera

tor] 

= Non

e,



     

   la

tents

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   pr

ompt_

embed

s: Op

tiona

l[tor

ch.Fl

oatTe

nsor]

 = No

ne,



     

   ne

gativ

e_pro

mpt_e

mbeds

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   ou

tput_

type:

 Opti

onal[

str] 

= "pi

l",



     

   re

turn_

dict:

 bool

 = Tr

ue,



     

   ca

llbac

k: Op

tiona

l[Cal

lable

[[int

, int

, tor

ch.Fl

oatTe

nsor]

, Non

e]] =

 None

,



     

   ca

llbac

k_ste

ps: i

nt = 

1,



     

   cr

oss_a

ttent

ion_k

wargs

: Opt

ional

[Dict

[str,

 Any]

] = N

one,



     

   co

ntrol

net_c

ondit

ionin

g_sca

le: f

loat 

= 1,



     

   gu

ess_m

ode: 

bool 

= Fal

se,



     

   us

e_zer

o_map

_as_u

ncond

ition

al: b

ool =

 Fals

e,



     

   be

v_con

troln

et_kw

args 

= {},



     

   bb

ox_ma

x_len

gth =

 None

,



    )

:



     

   r"

""



     

   Fu

nctio

n inv

oked 

when 

calli

ng th

e pip

eline

 for 

gener

ation

.





     

   Ar

gs:



     

     

  pro

mpt (

`str`

 or `

List[

str]`

, *op

tiona

l*):



     

     

     

 The 

promp

t or 

promp

ts to

 guid

e the

 imag

e gen

erati

on. I

f not

 defi

ned, 

one h

as to

 pass

 `pro

mpt_e

mbeds

`.



     

     

     

 inst

ead.



     

     

  ima

ge (`

torch

.Floa

tTens

or`, 

`PIL.

Image

.Imag

e`, `

List[

torch

.Floa

tTens

or]`,

 `Lis

t[PIL

.Imag

e.Ima

ge]`,



     

     

     

     

`List

[List

[torc

h.Flo

atTen

sor]]

`, or

 `Lis

t[Lis

t[PIL

.Imag

e.Ima

ge]]`

):



     

     

     

 The 

Contr

olNet

 inpu

t con

ditio

n. Co

ntrol

Net u

ses t

his i

nput 

condi

tion 

to ge

nerat

e gui

dance

 to U

net. 

If



     

     

     

 the 

type 

is sp

ecifi

ed as

 `Tor

ch.Fl

oatTe

nsor`

, it 

is pa

ssed 

to Co

ntrol

Net a

s is.

 `PIL

.Imag

e.Ima

ge` c

an



     

     

     

 also

 be a

ccept

ed as

 an i

mage.

 The 

dimen

sions

 of t

he ou

tput 

image

 defa

ults 

to `i

mage`

's di

mensi

ons. 

If



     

     

     

 heig

ht an

d/or 

width

 are 

passe

d, `i

mage`

 is r

esize

d acc

ordin

g to 

them.

 If m

ultip

le Co

ntrol

Nets 

are



     

     

     

 spec

ified

 in i

nit, 

image

s mus

t be 

passe

d as 

a lis

t suc

h tha

t eac

h ele

ment 

of th

e lis

t can

 be c

orrec

tly



     

     

     

 batc

hed f

or in

put t

o a s

ingle

 cont

rolne

t.



     

     

  hei

ght (

`int`

, *op

tiona

l*, d

efaul

ts to

 self

.unet

.conf

ig.sa

mple_

size 

* sel

f.vae

_scal

e_fac

tor):



     

     

     

 The 

heigh

t in 

pixel

s of 

the g

enera

ted i

mage.



     

     

  wid

th (`

int`,

 *opt

ional

*, de

fault

s to 

self.

unet.

confi

g.sam

ple_s

ize *

 self

.vae_

scale

_fact

or):



     

     

     

 The 

width

 in p

ixels

 of t

he ge

nerat

ed im

age.



     

     

  num

_infe

rence

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 5

0):



     

     

     

 The 

numbe

r of 

denoi

sing 

steps

. Mor

e den

oisin

g ste

ps us

ually

 lead

 to a

 high

er qu

ality

 imag

e at 

the



     

     

     

 expe

nse o

f slo

wer i

nfere

nce.



     

     

  gui

dance

_scal

e (`f

loat`

, *op

tiona

l*, d

efaul

ts to

 7.5)

:



     

     

     

 Guid

ance 

scale

 as d

efine

d in 

[Clas

sifie

r-Fre

e Dif

fusio

n Gui

dance

](htt

ps://

arxiv

.org/

abs/2

207.1

2598)

.



     

     

     

 `gui

dance

_scal

e` is

 defi

ned a

s `w`

 of e

quati

on 2.

 of [

Image

n



     

     

     

 Pape

r](ht

tps:/

/arxi

v.org

/pdf/

2205.

11487

.pdf)

. Gui

dance

 scal

e is 

enabl

ed by

 sett

ing `

guida

nce_s

cale 

>



     

     

     

 1`. 

Highe

r gui

dance

 scal

e enc

ourag

es to

 gene

rate 

image

s tha

t are

 clos

ely l

inked

 to t

he te

xt `p

rompt

`,



     

     

     

 usua

lly a

t the

 expe

nse o

f low

er im

age q

ualit

y.



     

     

  neg

ative

_prom

pt (`

str` 

or `L

ist[s

tr]`,

 *opt

ional

*):



     

     

     

 The 

promp

t or 

promp

ts no

t to 

guide

 the 

image

 gene

ratio

n. If

 not 

defin

ed, o

ne ha

s to 

pass



     

     

     

 `neg

ative

_prom

pt_em

beds`

 inst

ead. 

Ignor

ed wh

en no

t usi

ng gu

idanc

e (i.

e., i

gnore

d if 

`guid

ance_

scale

` is



     

     

     

 less

 than

 `1`)

.



     

     

  num

_imag

es_pe

r_pro

mpt (

`int`

, *op

tiona

l*, d

efaul

ts to

 1):



     

     

     

 The 

numbe

r of 

image

s to 

gener

ate p

er pr

ompt.



     

     

  eta

 (`fl

oat`,

 *opt

ional

*, de

fault

s to 

0.0):



     

     

     

 Corr

espon

ds to

 para

meter

 eta 

(η) i

n the

 DDIM

 pape

r: ht

tps:/

/arxi

v.org

/abs/

2010.

02502

. Onl

y app

lies 

to



     

     

     

 [`sc

hedul

ers.D

DIMSc

hedul

er`],

 will

 be i

gnore

d for

 othe

rs.



     

     

  gen

erato

r (`t

orch.

Gener

ator`

 or `

List[

torch

.Gene

rator

]`, *

optio

nal*)

:



     

     

     

 One 

or a 

list 

of [t

orch 

gener

ator(

s)](h

ttps:

//pyt

orch.

org/d

ocs/s

table

/gene

rated

/torc

h.Gen

erato

r.htm

l)



     

     

     

 to m

ake g

enera

tion 

deter

minis

tic.



     

     

  lat

ents 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

noisy

 late

nts, 

sampl

ed fr

om a 

Gauss

ian d

istri

butio

n, to

 be u

sed a

s inp

uts f

or im

age



     

     

     

 gene

ratio

n. Ca

n be 

used 

to tw

eak t

he sa

me ge

nerat

ion w

ith d

iffer

ent p

rompt

s. If

 not 

provi

ded, 

a lat

ents



     

     

     

 tens

or wi

ll ge

 gene

rated

 by s

ampli

ng us

ing t

he su

pplie

d ran

dom `

gener

ator`

.



     

     

  pro

mpt_e

mbeds

 (`to

rch.F

loatT

ensor

`, *o

ption

al*):



     

     

     

 Pre-

gener

ated 

text 

embed

dings

. Can

 be u

sed t

o eas

ily t

weak 

text 

input

s, *e

.g.* 

promp

t wei

ghtin

g. If

 not



     

     

     

 prov

ided,

 text

 embe

dding

s wil

l be 

gener

ated 

from 

`prom

pt` i

nput 

argum

ent.



     

     

  neg

ative

_prom

pt_em

beds 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

negat

ive t

ext e

mbedd

ings.

 Can 

be us

ed to

 easi

ly tw

eak t

ext i

nputs

, *e.

g.* p

rompt



     

     

     

 weig

hting

. If 

not p

rovid

ed, n

egati

ve_pr

ompt_

embed

s wil

l be 

gener

ated 

from 

`nega

tive_

promp

t` in

put



     

     

     

 argu

ment.



     

     

  out

put_t

ype (

`str`

, *op

tiona

l*, d

efaul

ts to

 `"pi

l"`):



     

     

     

 The 

outpu

t for

mat o

f the

 gene

rate 

image

. Cho

ose b

etwee

n



     

     

     

 [PIL

](htt

ps://

pillo

w.rea

dthed

ocs.i

o/en/

stabl

e/): 

`PIL.

Image

.Imag

e` or

 `np.

array

`.



     

     

  ret

urn_d

ict (

`bool

`, *o

ption

al*, 

defau

lts t

o `Tr

ue`):



     

     

     

 Whet

her o

r not

 to r

eturn

 a [`

~pipe

lines

.stab

le_di

ffusi

on.St

ableD

iffus

ionPi

pelin

eOutp

ut`] 

inste

ad of

 a



     

     

     

 plai

n tup

le.



     

     

  cal

lback

 (`Ca

llabl

e`, *

optio

nal*)

:



     

     

     

 A fu

nctio

n tha

t wil

l be 

calle

d eve

ry `c

allba

ck_st

eps` 

steps

 duri

ng in

feren

ce. T

he fu

nctio

n wil

l be



     

     

     

 call

ed wi

th th

e fol

lowin

g arg

ument

s: `c

allba

ck(st

ep: i

nt, t

imest

ep: i

nt, l

atent

s: to

rch.F

loatT

ensor

)`.



     

     

  cal

lback

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 1

):



     

     

     

 The 

frequ

ency 

at wh

ich t

he `c

allba

ck` f

uncti

on wi

ll be

 call

ed. I

f not

 spec

ified

, the

 call

back 

will 

be



     

     

     

 call

ed at

 ever

y ste

p.



     

     

  cro

ss_at

tenti

on_kw

args 

(`dic

t`, *

optio

nal*)

:



     

     

     

 A kw

args 

dicti

onary

 that

 if s

pecif

ied i

s pas

sed a

long 

to th

e `At

tenti

onPro

cesso

r` as

 defi

ned u

nder



     

     

     

 `sel

f.pro

cesso

r` in



     

     

     

 [dif

fuser

s.cro

ss_at

tenti

on](h

ttps:

//git

hub.c

om/hu

gging

face/

diffu

sers/

blob/

main/

src/d

iffus

ers/m

odels

/cros

s_att

entio

n.py)

.



     

     

  con

troln

et_co

nditi

oning

_scal

e (`f

loat`

 or `

List[

float

]`, *

optio

nal*,

 defa

ults 

to 1.

0):



     

     

     

 The 

outpu

ts of

 the 

contr

olnet

 are 

multi

plied

 by `

contr

olnet

_cond

ition

ing_s

cale`

 befo

re th

ey ar

e add

ed



     

     

     

 to t

he re

sidua

l in 

the o

rigin

al un

et. I

f mul

tiple

 Cont

rolNe

ts ar

e spe

cifie

d in 

init,

 you 

can s

et th

e



     

     

     

 corr

espon

ding 

scale

 as a

 list

.



     

     

  gue

ss_mo

de (`

bool`

, *op

tiona

l*, d

efaul

ts to

 `Fal

se`):



     

     

     

 In t

his m

ode, 

the C

ontro

lNet 

encod

er wi

ll tr

y bes

t to 

recog

nize 

the c

onten

t of 

the i

nput 

image

 even

 if



     

     

     

 you 

remov

e all

 prom

pts. 

The `

guida

nce_s

cale`

 betw

een 3

.0 an

d 5.0

 is r

ecomm

ended

.





     

   Ex

ample

s:





     

   Re

turns

:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] o

r `tu

ple`:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] i

f `re

turn_

dict`

 is T

rue, 

other

wise 

a `tu

ple.



     

     

  Whe

n ret

urnin

g a t

uple,

 the 

first

 elem

ent i

s a l

ist w

ith t

he ge

nerat

ed im

ages,

 and 

the s

econd

 elem

ent i

s a



     

     

  lis

t of 

`bool

`s de

notin

g whe

ther 

the c

orres

pondi

ng ge

nerat

ed im

age l

ikely

 repr

esent

s "no

t-saf

e-for

-work

"



     

     

  (ns

fw) c

onten

t, ac

cordi

ng to

 the 

`safe

ty_ch

ecker

`.



     

   ""

"



     

   # 

0. De

fault

 heig

ht an

d wid

th to

 unet



     

   # 

BEV: 

we ca

nnot 

use t

he si

ze of

 imag

e



     

   # 

heigh

t, wi

dth =

 self

._def

ault_

heigh

t_wid

th(he

ight,

 widt

h, No

ne)





     

   # 

1. Ch

eck i

nputs

. Rai

se er

ror i

f not

 corr

ect



     

   # 

we do

 not 

need 

this,

 only

 some

 type

 asse

rtion



     

   # 

self.

check

_inpu

ts(



     

   # 

    p

rompt

,



     

   # 

    i

mage,



     

   # 

    h

eight

,



     

   # 

    w

idth,



     

   # 

    c

allba

ck_st

eps,



     

   # 

    n

egati

ve_pr

ompt,



     

   # 

    p

rompt

_embe

ds,



     

   # 

    n

egati

ve_pr

ompt_

embed

s,



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

   # 

)





     

   # 

2. De

fine 

call 

param

eters



     

   # 

NOTE:

 we g

et ba

tch_s

ize f

irst 

from 

promp

t, th

en al

ign w

ith i

t.



     

   if

 prom

pt is

 not 

None 

and i

sinst

ance(

promp

t, st

r):



     

     

  bat

ch_si

ze = 

1



     

   el

if pr

ompt 

is no

t Non

e and

 isin

stanc

e(pro

mpt, 

list)

:



     

     

  bat

ch_si

ze = 

len(p

rompt

)



     

   el

se:



     

     

  bat

ch_si

ze = 

promp

t_emb

eds.s

hape[

0]





     

   de

vice 

= sel

f._ex

ecuti

on_de

vice



     

   # 

here 

`guid

ance_

scale

` is 

defin

ed an

alog 

to th

e gui

dance

 weig

ht `w

` of 

equat

ion (

2)



     

   # 

of th

e Ima

gen p

aper:

 http

s://a

rxiv.

org/p

df/22

05.11

487.p

df . 

`guid

ance_

scale

 = 1`



     

   # 

corre

spond

s to 

doing

 no c

lassi

fier 

free 

guida

nce.



     

   do

_clas

sifie

r_fre

e_gui

dance

 = gu

idanc

e_sca

le > 

1.0





     

   ##

# BEV

, che

ck ca

mera_

param

 ###



     

   if

 came

ra_pa

ram i

s Non

e:



     

     

  # u

se un

cond_

cam a

nd di

sable

 clas

sifie

r fre

e gui

dance



     

     

  N_c

am = 

6  # 

TODO:

 hard

-code

d



     

     

  cam

era_p

aram 

= sel

f.con

troln

et.un

cond_

cam_p

aram(

(batc

h_siz

e, N_

cam))



     

     

  do_

class

ifier

_free

_guid

ance 

= Fal

se



     

   ##

# don

e ###





     

   # 

if is

insta

nce(s

elf.c

ontro

lnet,

 Mult

iCont

rolNe

tMode

l) an

d isi

nstan

ce(co

ntrol

net_c

ondit

ionin

g_sca

le, f

loat)

:



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale =

 [con

troln

et_co

nditi

oning

_scal

e] * 

len(s

elf.c

ontro

lnet.

nets)





     

   # 

3. En

code 

input

 prom

pt



     

   # 

NOTE:

 here

 they

 use 

paddi

ng to

 77, 

is th

is ne

cessa

ry?



     

   pr

ompt_

embed

s = s

elf._

encod

e_pro

mpt(



     

     

  pro

mpt,



     

     

  dev

ice,



     

     

  num

_imag

es_pe

r_pro

mpt,



     

     

  do_

class

ifier

_free

_guid

ance,



     

     

  neg

ative

_prom

pt,



     

     

  pro

mpt_e

mbeds

=prom

pt_em

beds,



     

     

  neg

ative

_prom

pt_em

beds=

negat

ive_p

rompt

_embe

ds,



     

   ) 

 # (2

 * b,

 77 +

 1, 7

68)





     

   # 

4. Pr

epare

 imag

e



     

   # 

NOTE:

 if i

mage 

is no

t ten

sor, 

there

 will

 be s

evera

l pro

cess.



     

   as

sert 

not s

elf.c

ontro

l_ima

ge_pr

ocess

or.co

nfig.

do_no

rmali

ze, "

Your 

contr

olnet

 shou

ld no

t nor

maliz

e the

 cont

rol i

mage.

"



     

   im

age =

 self

.prep

are_i

mage(



     

     

  ima

ge=im

age,



     

     

  wid

th=wi

dth,



     

     

  hei

ght=h

eight

,



     

     

  bat

ch_si

ze=ba

tch_s

ize *

 num_

image

s_per

_prom

pt,



     

     

  num

_imag

es_pe

r_pro

mpt=n

um_im

ages_

per_p

rompt

,



     

     

  dev

ice=d

evice

,



     

     

  dty

pe=se

lf.co

ntrol

net.d

type,



     

     

  do_

class

ifier

_free

_guid

ance=

do_cl

assif

ier_f

ree_g

uidan

ce,



     

     

  gue

ss_mo

de=gu

ess_m

ode,



     

   ) 

 # (2

 * b,

 c_26

, 200

, 200

)



     

   if

 use_

zero_

map_a

s_unc

ondit

ional

 and 

do_cl

assif

ier_f

ree_g

uidan

ce:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  _im

ages[

0] = 

torch

.zero

s_lik

e(_im

ages[

0])



     

     

  ima

ge = 

torch

.cat(

_imag

es)





     

   # 

5. Pr

epare

 time

steps



     

   se

lf.sc

hedul

er.se

t_tim

estep

s(num

_infe

rence

_step

s, de

vice=

devic

e)



     

   ti

meste

ps = 

self.

sched

uler.

times

teps





     

   # 

6. Pr

epare

 late

nt va

riabl

es



     

   nu

m_cha

nnels

_late

nts =

 self

.unet

.conf

ig.in

_chan

nels



     

   la

tents

 = se

lf.pr

epare

_late

nts(



     

     

  bat

ch_si

ze * 

num_i

mages

_per_

promp

t,



     

     

  num

_chan

nels_

laten

ts,



     

     

  hei

ght,



     

     

  wid

th,



     

     

  pro

mpt_e

mbeds

.dtyp

e,



     

     

  dev

ice,



     

     

  gen

erato

r,



     

     

  lat

ents,

  # w

ill u

se if

 not 

None,

 othe

rwise

 will

 gene

rate



     

   ) 

 # (b

, c, 

h/8, 

w/8) 

-> (b

s, 4,

 28, 

50)





     

   # 

7. Pr

epare

 extr

a ste

p kwa

rgs.



     

   ex

tra_s

tep_k

wargs

 = se

lf.pr

epare

_extr

a_ste

p_kwa

rgs(g

enera

tor, 

eta)





     

   ##

#### 

BEV: 

here 

we re

const

ruct 

each 

input

 form

at ##

####



     

   as

sert 

camer

a_par

am.sh

ape[0

] == 

batch

_size

, \



     

     

  f"E

xcept

 {bat

ch_si

ze} c

amera

 para

ms, b

ut yo

u hav

e bs=

{len(

camer

a_par

am)}"



     

   N_

cam =

 came

ra_pa

ram.s

hape[

1]



     

   la

tents

 = to

rch.s

tack(

[late

nts] 

* N_c

am, d

im=1)

  # b

s, 6,

 4, 2

8, 50



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ca

mera_

param

 = ca

mera_

param

.to(s

elf.d

evice

)



     

   if

 do_c

lassi

fier_

free_

guida

nce a

nd no

t gue

ss_mo

de:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  kwa

rgs_w

ith_u

ncond

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_kw

args(



     

     

     

 came

ra_pa

ram=c

amera

_para

m,



     

     

     

 imag

e=_im

ages[

0],  

# 0 i

s for

 unco

nditi

onal



     

     

     

 max_

len=b

box_m

ax_le

ngth,



     

     

     

 **be

v_con

troln

et_kw

args,



     

     

  )



     

     

  kwa

rgs_w

ith_u

ncond

.pop(

"max_

len",

 None

)  # 

some 

do no

t tak

e thi

s.



     

     

  cam

era_p

aram 

= kwa

rgs_w

ith_u

ncond

.pop(

"came

ra_pa

ram")



     

     

  _im

ages[

0] = 

kwarg

s_wit

h_unc

ond.p

op("i

mage"

)



     

     

  ima

ge = 

torch

.cat(

_imag

es)



     

     

  bev

_cont

rolne

t_kwa

rgs =

 move

_to(k

wargs

_with

_unco

nd, s

elf.d

evice

)



     

   ##

#### 

BEV e

nd ##

####





     

   # 

8. De

noisi

ng lo

op



     

   nu

m_war

mup_s

teps 

= len

(time

steps

) - n

um_in

feren

ce_st

eps *

 self

.sche

duler

.orde

r



     

   wi

th se

lf.pr

ogres

s_bar

(tota

l=num

_infe

rence

_step

s) as

 prog

ress_

bar:



     

     

  for

 i, t

 in e

numer

ate(t

imest

eps):



     

     

     

 # ex

pand 

the l

atent

s if 

we ar

e doi

ng cl

assif

ier f

ree g

uidan

ce



     

     

     

 # bs

*2, 6

, 4, 

28, 5

0



     

     

     

 late

nt_mo

del_i

nput 

= (



     

     

     

     

torch

.cat(

[late

nts] 

* 2) 

if do

_clas

sifie

r_fre

e_gui

dance

 else

 late

nts



     

     

     

 )



     

     

     

 late

nt_mo

del_i

nput 

= sel

f.sch

edule

r.sca

le_mo

del_i

nput(



     

     

     

     

laten

t_mod

el_in

put, 

t



     

     

     

 )





     

     

     

 # co

ntrol

net(s

) inf

erenc

e



     

     

     

 cont

rolne

t_t =

 t.un

squee

ze(0)



     

     

     

 # gu

ess_m

ode &

 clas

sifie

r_fre

e_gui

dance

 -> o

nly g

uidan

ce us

e con

troln

et



     

     

     

 # no

t gue

ss_mo

de & 

class

ifier

_free

_guid

ance 

-> al

l use

 cont

rolne

t



     

     

     

 # gu

ess_m

ode -

> nor

mal i

nput,

 take

 effe

ct in

 cont

rolne

t



     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

er Co

ntrol

Net o

nly f

or th

e con

ditio

nal b

atch.



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ents



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds

.chun

k(2)[

1]



     

     

     

 else

:



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ent_m

odel_

input



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds



     

     

     

 cont

rolne

t_t =

 cont

rolne

t_t.r

epeat

(len(

contr

olnet

_late

nt_mo

del_i

nput)

)





     

     

     

 # fm

t: of

f



     

     

     

 down

_bloc

k_res

_samp

les, 

mid_b

lock_

res_s

ample

, \



     

     

     

 enco

der_h

idden

_stat

es_wi

th_ca

m = s

elf.c

ontro

lnet(



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput,



     

     

     

     

contr

olnet

_t,



     

     

     

     

camer

a_par

am,  

# for

 BEV



     

     

     

     

encod

er_hi

dden_

state

s=con

troln

et_pr

ompt_

embed

s,



     

     

     

     

contr

olnet

_cond

=imag

e,



     

     

     

     

condi

tioni

ng_sc

ale=c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

     

     

     

guess

_mode

=gues

s_mod

e,



     

     

     

     

retur

n_dic

t=Fal

se,



     

     

     

     

**bev

_cont

rolne

t_kwa

rgs, 

# for

 BEV



     

     

     

 )



     

     

     

 # fm

t: on





     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

ered 

Contr

olNet

 only

 for 

the c

ondit

ional

 batc

h.



     

     

     

     

# To 

apply

 the 

outpu

t of 

Contr

olNet

 to b

oth t

he un

condi

tiona

l and

 cond

ition

al ba

tches

,



     

     

     

     

# add

 0 to

 the 

uncon

ditio

nal b

atch 

to ke

ep it

 unch

anged

.



     

     

     

     

down_

block

_res_

sampl

es = 

[



     

     

     

     

    t

orch.

cat([

torch

.zero

s_lik

e(d),

 d])



     

     

     

     

    f

or d 

in do

wn_bl

ock_r

es_sa

mples



     

     

     

     

]



     

     

     

     

mid_b

lock_

res_s

ample

 = to

rch.c

at(



     

     

     

     

    [

torch

.zero

s_lik

e(mid

_bloc

k_res

_samp

le), 

mid_b

lock_

res_s

ample

]



     

     

     

     

)



     

     

     

     

# add

 unco

nd en

coder

_hidd

en_st

ates_

with_

cam h

ere



     

     

     

     

encod

er_hi

dden_

state

s_wit

h_cam

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_em

b(



     

     

     

     

    p

rompt

_embe

ds.ch

unk(2

)[0],

 N_ca

m,



     

     

     

     

    e

ncode

r_hid

den_s

tates

_with

_cam,



     

     

     

     

)





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # St

ratin

g fro

m her

e, we

 use 

4-dim

 data

.



     

     

     

 # en

coder

_hidd

en_st

ates_

with_

cam: 

(2b x

 N), 

78, 7

68



     

     

     

 # la

tent_

model

_inpu

t: 2b

, N, 

4, 28

, 50 

-> 2b

 x N,

 4, 2

8, 50



     

     

     

 late

nt_mo

del_i

nput 

= rea

rrang

e(



     

     

     

     

laten

t_mod

el_in

put, 

'b n 

... -

> (b 

n) ..

.')



     

     

     

 late

nts =

 rear

range

(late

nts, 

'b n 

... -

> (b 

n) ..

.')





     

     

     

 # pr

edict

 the 

noise

 resi

dual:

 2bxN

, 4, 

28, 5

0



     

     

     

 addi

tiona

l_par

am = 

{}



     

     

     

 nois

e_pre

d = s

elf.u

net(



     

     

     

     

laten

t_mod

el_in

put, 

 # ma

y wit

h unc

ondit

ional



     

     

     

     

t,



     

     

     

     

encod

er_hi

dden_

state

s=enc

oder_

hidde

n_sta

tes_w

ith_c

am,



     

     

     

     

**add

ition

al_pa

ram, 

 # if

 use 

origi

nal u

net, 

it ca

nnot 

take 

kwarg

s



     

     

     

     

cross

_atte

ntion

_kwar

gs=cr

oss_a

ttent

ion_k

wargs

,



     

     

     

     

down_

block

_addi

tiona

l_res

idual

s=dow

n_blo

ck_re

s_sam

ples,



     

     

     

     

mid_b

lock_

addit

ional

_resi

dual=

mid_b

lock_

res_s

ample

,



     

     

     

 ).sa

mple





     

     

     

 # pe

rform

 guid

ance



     

     

     

 if d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# for

 each

: bxN

, 4, 

28, 5

0



     

     

     

     

noise

_pred

_unco

nd, n

oise_

pred_

text 

= noi

se_pr

ed.ch

unk(2

)



     

     

     

     

noise

_pred

 = no

ise_p

red_u

ncond

 + gu

idanc

e_sca

le * 

(



     

     

     

     

    n

oise_

pred_

text 

- noi

se_pr

ed_un

cond



     

     

     

     

)





     

     

     

 # co

mpute

 the 

previ

ous n

oisy 

sampl

e x_t

 -> x

_t-1



     

     

     

 # NO

TE: i

s the

 sche

duler

 use 

rando

mness

, ple

ase h

andle

 the 

logic



     

     

     

 # fo

r gen

erato

r.



     

     

     

 late

nts =

 self

.sche

duler

.step

(



     

     

     

     

noise

_pred

, t, 

laten

ts, *

*extr

a_ste

p_kwa

rgs



     

     

     

 ).pr

ev_sa

mple





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # no

w we 

add d

imens

ion b

ack, 

use 5

-dim 

data.



     

     

     

 # NO

TE: o

nly `

laten

ts` i

s upd

ated 

throu

gh th

e loo

p



     

     

     

 late

nts =

 rear

range

(late

nts, 

'(b n

) ...

 -> b

 n ..

.', n

=N_ca

m)





     

     

     

 # ca

ll th

e cal

lback

, if 

provi

ded



     

     

     

 if i

 == l

en(ti

meste

ps) -

 1 or

 (



     

     

     

     

(i + 

1) > 

num_w

armup

_step

s and

 (i +

 1) %

 self

.sche

duler

.orde

r == 

0



     

     

     

 ):



     

     

     

     

progr

ess_b

ar.up

date(

)



     

     

     

     

if ca

llbac

k is 

not N

one a

nd i 

% cal

lback

_step

s == 

0:



     

     

     

     

    c

allba

ck(i,

 t, l

atent

s)





     

   ##

#### 

BEV: 

here 

rebui

ld th

e sha

pes b

ack. 

post-

proce

ss st

ill a

ssume



     

   # 

laten

ts, n

o nee

d for

 b, n

, 4, 

28, 5

0



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ##

### B

EV en

d





     

   # 

If we

 do s

equen

tial 

model

 offl

oadin

g, le

t's o

ffloa

d une

t and

 cont

rolne

t



     

   # 

manua

lly f

or ma

x mem

ory s

aving

s



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.une

t.to(

"cpu"

)



     

     

  sel

f.con

troln

et.to

("cpu

")



     

     

  tor

ch.cu

da.em

pty_c

ache(

)





     

   if

 outp

ut_ty

pe ==

 "lat

ent":



     

     

  ima

ge = 

laten

ts



     

     

  has

_nsfw

_conc

ept =

 None



     

   el

if ou

tput_

type 

== "p

il":



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

     

  # 1

0. Co

nvert

 to P

IL



     

     

  ima

ge = 

self.

numpy

_to_p

il_do

uble(

image

)



     

   el

se:



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

   # 

Offlo

ad la

st mo

del t

o CPU



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.fin

al_of

fload

_hook

.offl

oad()





     

   if

 not 

retur

n_dic

t:



     

     

  ret

urn (

image

, has

_nsfw

_conc

ept)





     

   re

turn 

BEVSt

ableD

iffus

ionPi

pelin

eOutp

ut(



     

     

  ima

ges=i

mage,

 nsfw

_cont

ent_d

etect

ed=ha

s_nsf

w_con

cept



     

   )



from 

datac

lasse

s imp

ort d

atacl

ass



from 

typin

g imp

ort A

ny, C

allab

le, D

ict, 

List,

 Opti

onal,

 Tupl

e, Un

ion



impor

t ins

pect





impor

t tor

ch



impor

t PIL



impor

t num

py as

 np



from 

einop

s imp

ort r

earra

nge





from 

diffu

sers 

impor

t Sta

bleDi

ffusi

onCon

trolN

etPip

eline



from 

diffu

sers.

utils

 impo

rt Ba

seOut

put



from 

diffu

sers.

image

_proc

essor

 impo

rt Va

eImag

eProc

essor



from 

diffu

sers.

model

s imp

ort A

utoen

coder

KL, U

Net2D

Condi

tionM

odel



from 

diffu

sers.

pipel

ines.

stabl

e_dif

fusio

n imp

ort S

table

Diffu

sionS

afety

Check

er



from 

diffu

sers.

sched

ulers

.sche

dulin

g_uti

ls im

port 

Karra

sDiff

usion

Sched

ulers



from 

trans

forme

rs im

port 

CLIPI

mageP

roces

sor, 

CLIPT

extMo

del, 

CLIPT

okeni

zer





from 

..mis

c.com

mon i

mport

 move

_to







@data

class



class

 BEVS

table

Diffu

sionP

ipeli

neOut

put(B

aseOu

tput)

:



    "

""



    O

utput

 clas

s for

 Stab

le Di

ffusi

on pi

pelin

es.





    A

rgs:



     

   im

ages 

(`Lis

t[PIL

.Imag

e.Ima

ge]` 

or `n

p.nda

rray`

)



     

     

  Lis

t of 

denoi

sed P

IL im

ages 

of le

ngth 

`batc

h_siz

e` or

 nump

y arr

ay of

 shap

e `(b

atch_

size,

 heig

ht, w

idth,



     

     

  num

_chan

nels)

`. PI

L ima

ges o

r num

py ar

ray p

resen

t the

 deno

ised 

image

s of 

the d

iffus

ion p

ipeli

ne.



     

   ns

fw_co

ntent

_dete

cted 

(`Lis

t[boo

l]`)



     

     

  Lis

t of 

flags

 deno

ting 

wheth

er th

e cor

respo

nding

 gene

rated

 imag

e lik

ely r

epres

ents 

"not-

safe-

for-w

ork"



     

     

  (ns

fw) c

onten

t, or

 `Non

e` if

 safe

ty ch

eckin

g cou

ld no

t be 

perfo

rmed.



    "

""





    i

mages

: Uni

on[Li

st[Li

st[PI

L.Ima

ge.Im

age]]

, np.

ndarr

ay]



    n

sfw_c

onten

t_det

ected

: Opt

ional

[List

[bool

]]







class

 Stab

leDif

fusio

nBEVC

ontro

lNetP

ipeli

ne(St

ableD

iffus

ionCo

ntrol

NetPi

pelin

e):



    d

ef __

init_

_(



     

   se

lf,



     

   va

e: Au

toenc

oderK

L,



     

   te

xt_en

coder

: CLI

PText

Model

,



     

   un

et: U

Net2D

Condi

tionM

odel,



     

   co

ntrol

net,



     

   sc

hedul

er: K

arras

Diffu

sionS

chedu

lers,



     

   to

keniz

er: C

LIPTo

keniz

er,



     

   sa

fety_

check

er: S

table

Diffu

sionS

afety

Check

er = 

None,



     

   fe

ature

_extr

actor

: CLI

PImag

eProc

essor

 = No

ne,



     

   re

quire

s_saf

ety_c

hecke

r: bo

ol = 

False

,



    )

:



     

   su

per()

.__in

it__(



     

     

  vae

,



     

     

  tex

t_enc

oder,



     

     

  tok

enize

r,



     

     

  une

t,



     

     

  con

troln

et,



     

     

  sch

edule

r,



     

     

  saf

ety_c

hecke

r,



     

     

  fea

ture_

extra

ctor,



     

     

  req

uires

_safe

ty_ch

ecker

,



     

   )



     

   as

sert 

safet

y_che

cker 

== No

ne, "

Pleas

e do 

not u

se sa

fety_

check

er."



     

   se

lf.co

ntrol

_imag

e_pro

cesso

r = V

aeIma

gePro

cesso

r(



     

     

  vae

_scal

e_fac

tor=s

elf.v

ae_sc

ale_f

actor

,



     

     

  do_

resiz

e=Fal

se,



     

     

  do_

conve

rt_rg

b=Fal

se,



     

     

  do_

norma

lize=

False

,



     

   )





    d

ef nu

mpy_t

o_pil

_doub

le(se

lf, i

mages

):



     

   ""

"



     

   Co

nvert

 a nu

mpy i

mage 

or a 

batch

 of i

mages

 to a

 PIL 

image

.



     

   We

 need

 to h

andle

 5-di

m inp

uts a

nd re

ture 

2-dim

 list

.



     

   ""

"



     

   im

gs_li

st = 

[]



     

   fo

r img

s in 

image

s:



     

     

  img

s_lis

t.app

end(s

elf.n

umpy_

to_pi

l(img

s))



     

   re

turn 

imgs_

list





    #

 Copi

ed fr

om di

ffuse

rs.pi

pelin

es.st

able_

diffu

sion.

pipel

ine_s

table

_diff

usion

.Stab

leDif

fusio

nPipe

line.

prepa

re_ex

tra_s

tep_k

wargs



    d

ef pr

epare

_extr

a_ste

p_kwa

rgs(s

elf, 

gener

ator,

 eta)

:



     

   # 

prepa

re ex

tra k

wargs

 for 

the s

chedu

ler s

tep, 

since

 not 

all s

chedu

lers 

have 

the s

ame s

ignat

ure



     

   # 

eta (

η) is

 only

 used

 with

 the 

DDIMS

chedu

ler, 

it wi

ll be

 igno

red f

or ot

her s

chedu

lers.



     

   # 

eta c

orres

ponds

 to η

 in D

DIM p

aper:

 http

s://a

rxiv.

org/a

bs/20

10.02

502



     

   # 

and s

hould

 be b

etwee

n [0,

 1]





     

   ac

cepts

_eta 

= "et

a" in

 set(

inspe

ct.si

gnatu

re(se

lf.sc

hedul

er.st

ep).p

arame

ters.

keys(

))



     

   ex

tra_s

tep_k

wargs

 = {}



     

   if

 acce

pts_e

ta:



     

     

  ext

ra_st

ep_kw

args[

"eta"

] = e

ta





     

   # 

check

 if t

he sc

hedul

er ac

cepts

 gene

rator



     

   ac

cepts

_gene

rator

 = "g

enera

tor" 

in se

t(ins

pect.

signa

ture(

self.

sched

uler.

step)

.para

meter

s.key

s())



     

   if

 acce

pts_g

enera

tor:



     

     

  rai

se Ru

ntime

Error

("If 

you f

ixed 

the l

ogic 

for g

enera

tor, 

pleas

e rem

ove t

his. 

Other

wise,

 plea

se us

e oth

er sa

mpler

.")



     

     

  ext

ra_st

ep_kw

args[

"gene

rator

"] = 

gener

ator



     

   re

turn 

extra

_step

_kwar

gs





    d

ef de

code_

laten

ts(se

lf, l

atent

s):



     

   # 

decod

e lat

ents 

with 

5-dim

s



     

   la

tents

 = 1 

/ sel

f.vae

.conf

ig.sc

aling

_fact

or * 

laten

ts





     

   bs

 = le

n(lat

ents)



     

   la

tents

 = re

arran

ge(la

tents

, 'b 

c ...

 -> (

b c) 

...')



     

   im

age =

 self

.vae.

decod

e(lat

ents)

.samp

le



     

   im

age =

 rear

range

(imag

e, '(

b c) 

... -

> b c

 ...'

, b=b

s)





     

   im

age =

 (ima

ge / 

2 + 0

.5).c

lamp(

0, 1)



     

   # 

we al

ways 

cast 

to fl

oat32

 as t

his d

oes n

ot ca

use s

ignif

icant

 over

head 

and i

s com

patib

le wi

th bf

loat1

6



     

   im

age =

 rear

range

(imag

e.cpu

(), '

... c

 h w 

-> ..

. h w

 c').

float

().nu

mpy()



     

   re

turn 

image





    @

torch

.no_g

rad()



    d

ef __

call_

_(



     

   se

lf,



     

   pr

ompt:

 Unio

n[str

, Lis

t[str

]],



     

   im

age: 

torch

.Floa

tTens

or,



     

   ca

mera_

param

: Uni

on[to

rch.T

ensor

, Non

e],



     

   he

ight:

 int,



     

   wi

dth: 

int,



     

   nu

m_inf

erenc

e_ste

ps: i

nt = 

50,



     

   gu

idanc

e_sca

le: f

loat 

= 7.5

,



     

   ne

gativ

e_pro

mpt: 

Optio

nal[U

nion[

str, 

List[

str]]

] = N

one,



     

   nu

m_ima

ges_p

er_pr

ompt:

 Opti

onal[

int] 

= 1,



     

   et

a: fl

oat =

 0.0,



     

   ge

nerat

or: O

ption

al[to

rch.G

enera

tor] 

= Non

e,



     

   la

tents

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   pr

ompt_

embed

s: Op

tiona

l[tor

ch.Fl

oatTe

nsor]

 = No

ne,



     

   ne

gativ

e_pro

mpt_e

mbeds

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   ou

tput_

type:

 Opti

onal[

str] 

= "pi

l",



     

   re

turn_

dict:

 bool

 = Tr

ue,



     

   ca

llbac

k: Op

tiona

l[Cal

lable

[[int

, int

, tor

ch.Fl

oatTe

nsor]

, Non

e]] =

 None

,



     

   ca

llbac

k_ste

ps: i

nt = 

1,



     

   cr

oss_a

ttent

ion_k

wargs

: Opt

ional

[Dict

[str,

 Any]

] = N

one,



     

   co

ntrol

net_c

ondit

ionin

g_sca

le: f

loat 

= 1,



     

   gu

ess_m

ode: 

bool 

= Fal

se,



     

   us

e_zer

o_map

_as_u

ncond

ition

al: b

ool =

 Fals

e,



     

   be

v_con

troln

et_kw

args 

= {},



     

   bb

ox_ma

x_len

gth =

 None

,



    )

:



     

   r"

""



     

   Fu

nctio

n inv

oked 

when 

calli

ng th

e pip

eline

 for 

gener

ation

.





     

   Ar

gs:



     

     

  pro

mpt (

`str`

 or `

List[

str]`

, *op

tiona

l*):



     

     

     

 The 

promp

t or 

promp

ts to

 guid

e the

 imag

e gen

erati

on. I

f not

 defi

ned, 

one h

as to

 pass

 `pro

mpt_e

mbeds

`.



     

     

     

 inst

ead.



     

     

  ima

ge (`

torch

.Floa

tTens

or`, 

`PIL.

Image

.Imag

e`, `

List[

torch

.Floa

tTens

or]`,

 `Lis

t[PIL

.Imag

e.Ima

ge]`,



     

     

     

     

`List

[List

[torc

h.Flo

atTen

sor]]

`, or

 `Lis

t[Lis

t[PIL

.Imag

e.Ima

ge]]`

):



     

     

     

 The 

Contr

olNet

 inpu

t con

ditio

n. Co

ntrol

Net u

ses t

his i

nput 

condi

tion 

to ge

nerat

e gui

dance

 to U

net. 

If



     

     

     

 the 

type 

is sp

ecifi

ed as

 `Tor

ch.Fl

oatTe

nsor`

, it 

is pa

ssed 

to Co

ntrol

Net a

s is.

 `PIL

.Imag

e.Ima

ge` c

an



     

     

     

 also

 be a

ccept

ed as

 an i

mage.

 The 

dimen

sions

 of t

he ou

tput 

image

 defa

ults 

to `i

mage`

's di

mensi

ons. 

If



     

     

     

 heig

ht an

d/or 

width

 are 

passe

d, `i

mage`

 is r

esize

d acc

ordin

g to 

them.

 If m

ultip

le Co

ntrol

Nets 

are



     

     

     

 spec

ified

 in i

nit, 

image

s mus

t be 

passe

d as 

a lis

t suc

h tha

t eac

h ele

ment 

of th

e lis

t can

 be c

orrec

tly



     

     

     

 batc

hed f

or in

put t

o a s

ingle

 cont

rolne

t.



     

     

  hei

ght (

`int`

, *op

tiona

l*, d

efaul

ts to

 self

.unet

.conf

ig.sa

mple_

size 

* sel

f.vae

_scal

e_fac

tor):



     

     

     

 The 

heigh

t in 

pixel

s of 

the g

enera

ted i

mage.



     

     

  wid

th (`

int`,

 *opt

ional

*, de

fault

s to 

self.

unet.

confi

g.sam

ple_s

ize *

 self

.vae_

scale

_fact

or):



     

     

     

 The 

width

 in p

ixels

 of t

he ge

nerat

ed im

age.



     

     

  num

_infe

rence

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 5

0):



     

     

     

 The 

numbe

r of 

denoi

sing 

steps

. Mor

e den

oisin

g ste

ps us

ually

 lead

 to a

 high

er qu

ality

 imag

e at 

the



     

     

     

 expe

nse o

f slo

wer i

nfere

nce.



     

     

  gui

dance

_scal

e (`f

loat`

, *op

tiona

l*, d

efaul

ts to

 7.5)

:



     

     

     

 Guid

ance 

scale

 as d

efine

d in 

[Clas

sifie

r-Fre

e Dif

fusio

n Gui

dance

](htt

ps://

arxiv

.org/

abs/2

207.1

2598)

.



     

     

     

 `gui

dance

_scal

e` is

 defi

ned a

s `w`

 of e

quati

on 2.

 of [

Image

n



     

     

     

 Pape

r](ht

tps:/

/arxi

v.org

/pdf/

2205.

11487

.pdf)

. Gui

dance

 scal

e is 

enabl

ed by

 sett

ing `

guida

nce_s

cale 

>



     

     

     

 1`. 

Highe

r gui

dance

 scal

e enc

ourag

es to

 gene

rate 

image

s tha

t are

 clos

ely l

inked

 to t

he te

xt `p

rompt

`,



     

     

     

 usua

lly a

t the

 expe

nse o

f low

er im

age q

ualit

y.



     

     

  neg

ative

_prom

pt (`

str` 

or `L

ist[s

tr]`,

 *opt

ional

*):



     

     

     

 The 

promp

t or 

promp

ts no

t to 

guide

 the 

image

 gene

ratio

n. If

 not 

defin

ed, o

ne ha

s to 

pass



     

     

     

 `neg

ative

_prom

pt_em

beds`

 inst

ead. 

Ignor

ed wh

en no

t usi

ng gu

idanc

e (i.

e., i

gnore

d if 

`guid

ance_

scale

` is



     

     

     

 less

 than

 `1`)

.



     

     

  num

_imag

es_pe

r_pro

mpt (

`int`

, *op

tiona

l*, d

efaul

ts to

 1):



     

     

     

 The 

numbe

r of 

image

s to 

gener

ate p

er pr

ompt.



     

     

  eta

 (`fl

oat`,

 *opt

ional

*, de

fault

s to 

0.0):



     

     

     

 Corr

espon

ds to

 para

meter

 eta 

(η) i

n the

 DDIM

 pape

r: ht

tps:/

/arxi

v.org

/abs/

2010.

02502

. Onl

y app

lies 

to



     

     

     

 [`sc

hedul

ers.D

DIMSc

hedul

er`],

 will

 be i

gnore

d for

 othe

rs.



     

     

  gen

erato

r (`t

orch.

Gener

ator`

 or `

List[

torch

.Gene

rator

]`, *

optio

nal*)

:



     

     

     

 One 

or a 

list 

of [t

orch 

gener

ator(

s)](h

ttps:

//pyt

orch.

org/d

ocs/s

table

/gene

rated

/torc

h.Gen

erato

r.htm

l)



     

     

     

 to m

ake g

enera

tion 

deter

minis

tic.



     

     

  lat

ents 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

noisy

 late

nts, 

sampl

ed fr

om a 

Gauss

ian d

istri

butio

n, to

 be u

sed a

s inp

uts f

or im

age



     

     

     

 gene

ratio

n. Ca

n be 

used 

to tw

eak t

he sa

me ge

nerat

ion w

ith d

iffer

ent p

rompt

s. If

 not 

provi

ded, 

a lat

ents



     

     

     

 tens

or wi

ll ge

 gene

rated

 by s

ampli

ng us

ing t

he su

pplie

d ran

dom `

gener

ator`

.



     

     

  pro

mpt_e

mbeds

 (`to

rch.F

loatT

ensor

`, *o

ption

al*):



     

     

     

 Pre-

gener

ated 

text 

embed

dings

. Can

 be u

sed t

o eas

ily t

weak 

text 

input

s, *e

.g.* 

promp

t wei

ghtin

g. If

 not



     

     

     

 prov

ided,

 text

 embe

dding

s wil

l be 

gener

ated 

from 

`prom

pt` i

nput 

argum

ent.



     

     

  neg

ative

_prom

pt_em

beds 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

negat

ive t

ext e

mbedd

ings.

 Can 

be us

ed to

 easi

ly tw

eak t

ext i

nputs

, *e.

g.* p

rompt



     

     

     

 weig

hting

. If 

not p

rovid

ed, n

egati

ve_pr

ompt_

embed

s wil

l be 

gener

ated 

from 

`nega

tive_

promp

t` in

put



     

     

     

 argu

ment.



     

     

  out

put_t

ype (

`str`

, *op

tiona

l*, d

efaul

ts to

 `"pi

l"`):



     

     

     

 The 

outpu

t for

mat o

f the

 gene

rate 

image

. Cho

ose b

etwee

n



     

     

     

 [PIL

](htt

ps://

pillo

w.rea

dthed

ocs.i

o/en/

stabl

e/): 

`PIL.

Image

.Imag

e` or

 `np.

array

`.



     

     

  ret

urn_d

ict (

`bool

`, *o

ption

al*, 

defau

lts t

o `Tr

ue`):



     

     

     

 Whet

her o

r not

 to r

eturn

 a [`

~pipe

lines

.stab

le_di

ffusi

on.St

ableD

iffus

ionPi

pelin

eOutp

ut`] 

inste

ad of

 a



     

     

     

 plai

n tup

le.



     

     

  cal

lback

 (`Ca

llabl

e`, *

optio

nal*)

:



     

     

     

 A fu

nctio

n tha

t wil

l be 

calle

d eve

ry `c

allba

ck_st

eps` 

steps

 duri

ng in

feren

ce. T

he fu

nctio

n wil

l be



     

     

     

 call

ed wi

th th

e fol

lowin

g arg

ument

s: `c

allba

ck(st

ep: i

nt, t

imest

ep: i

nt, l

atent

s: to

rch.F

loatT

ensor

)`.



     

     

  cal

lback

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 1

):



     

     

     

 The 

frequ

ency 

at wh

ich t

he `c

allba

ck` f

uncti

on wi

ll be

 call

ed. I

f not

 spec

ified

, the

 call

back 

will 

be



     

     

     

 call

ed at

 ever

y ste

p.



     

     

  cro

ss_at

tenti

on_kw

args 

(`dic

t`, *

optio

nal*)

:



     

     

     

 A kw

args 

dicti

onary

 that

 if s

pecif

ied i

s pas

sed a

long 

to th

e `At

tenti

onPro

cesso

r` as

 defi

ned u

nder



     

     

     

 `sel

f.pro

cesso

r` in



     

     

     

 [dif

fuser

s.cro

ss_at

tenti

on](h

ttps:

//git

hub.c

om/hu

gging

face/

diffu

sers/

blob/

main/

src/d

iffus

ers/m

odels

/cros

s_att

entio

n.py)

.



     

     

  con

troln

et_co

nditi

oning

_scal

e (`f

loat`

 or `

List[

float

]`, *

optio

nal*,

 defa

ults 

to 1.

0):



     

     

     

 The 

outpu

ts of

 the 

contr

olnet

 are 

multi

plied

 by `

contr

olnet

_cond

ition

ing_s

cale`

 befo

re th

ey ar

e add

ed



     

     

     

 to t

he re

sidua

l in 

the o

rigin

al un

et. I

f mul

tiple

 Cont

rolNe

ts ar

e spe

cifie

d in 

init,

 you 

can s

et th

e



     

     

     

 corr

espon

ding 

scale

 as a

 list

.



     

     

  gue

ss_mo

de (`

bool`

, *op

tiona

l*, d

efaul

ts to

 `Fal

se`):



     

     

     

 In t

his m

ode, 

the C

ontro

lNet 

encod

er wi

ll tr

y bes

t to 

recog

nize 

the c

onten

t of 

the i

nput 

image

 even

 if



     

     

     

 you 

remov

e all

 prom

pts. 

The `

guida

nce_s

cale`

 betw

een 3

.0 an

d 5.0

 is r

ecomm

ended

.





     

   Ex

ample

s:





     

   Re

turns

:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] o

r `tu

ple`:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] i

f `re

turn_

dict`

 is T

rue, 

other

wise 

a `tu

ple.



     

     

  Whe

n ret

urnin

g a t

uple,

 the 

first

 elem

ent i

s a l

ist w

ith t

he ge

nerat

ed im

ages,

 and 

the s

econd

 elem

ent i

s a



     

     

  lis

t of 

`bool

`s de

notin

g whe

ther 

the c

orres

pondi

ng ge

nerat

ed im

age l

ikely

 repr

esent

s "no

t-saf

e-for

-work

"



     

     

  (ns

fw) c

onten

t, ac

cordi

ng to

 the 

`safe

ty_ch

ecker

`.



     

   ""

"



     

   # 

0. De

fault

 heig

ht an

d wid

th to

 unet



     

   # 

BEV: 

we ca

nnot 

use t

he si

ze of

 imag

e



     

   # 

heigh

t, wi

dth =

 self

._def

ault_

heigh

t_wid

th(he

ight,

 widt

h, No

ne)





     

   # 

1. Ch

eck i

nputs

. Rai

se er

ror i

f not

 corr

ect



     

   # 

we do

 not 

need 

this,

 only

 some

 type

 asse

rtion



     

   # 

self.

check

_inpu

ts(



     

   # 

    p

rompt

,



     

   # 

    i

mage,



     

   # 

    h

eight

,



     

   # 

    w

idth,



     

   # 

    c

allba

ck_st

eps,



     

   # 

    n

egati

ve_pr

ompt,



     

   # 

    p

rompt

_embe

ds,



     

   # 

    n

egati

ve_pr

ompt_

embed

s,



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

   # 

)





     

   # 

2. De

fine 

call 

param

eters



     

   # 

NOTE:

 we g

et ba

tch_s

ize f

irst 

from 

promp

t, th

en al

ign w

ith i

t.



     

   if

 prom

pt is

 not 

None 

and i

sinst

ance(

promp

t, st

r):



     

     

  bat

ch_si

ze = 

1



     

   el

if pr

ompt 

is no

t Non

e and

 isin

stanc

e(pro

mpt, 

list)

:



     

     

  bat

ch_si

ze = 

len(p

rompt

)



     

   el

se:



     

     

  bat

ch_si

ze = 

promp

t_emb

eds.s

hape[

0]





     

   de

vice 

= sel

f._ex

ecuti

on_de

vice



     

   # 

here 

`guid

ance_

scale

` is 

defin

ed an

alog 

to th

e gui

dance

 weig

ht `w

` of 

equat

ion (

2)



     

   # 

of th

e Ima

gen p

aper:

 http

s://a

rxiv.

org/p

df/22

05.11

487.p

df . 

`guid

ance_

scale

 = 1`



     

   # 

corre

spond

s to 

doing

 no c

lassi

fier 

free 

guida

nce.



     

   do

_clas

sifie

r_fre

e_gui

dance

 = gu

idanc

e_sca

le > 

1.0





     

   ##

# BEV

, che

ck ca

mera_

param

 ###



     

   if

 came

ra_pa

ram i

s Non

e:



     

     

  # u

se un

cond_

cam a

nd di

sable

 clas

sifie

r fre

e gui

dance



     

     

  N_c

am = 

6  # 

TODO:

 hard

-code

d



     

     

  cam

era_p

aram 

= sel

f.con

troln

et.un

cond_

cam_p

aram(

(batc

h_siz

e, N_

cam))



     

     

  do_

class

ifier

_free

_guid

ance 

= Fal

se



     

   ##

# don

e ###





     

   # 

if is

insta

nce(s

elf.c

ontro

lnet,

 Mult

iCont

rolNe

tMode

l) an

d isi

nstan

ce(co

ntrol

net_c

ondit

ionin

g_sca

le, f

loat)

:



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale =

 [con

troln

et_co

nditi

oning

_scal

e] * 

len(s

elf.c

ontro

lnet.

nets)





     

   # 

3. En

code 

input

 prom

pt



     

   # 

NOTE:

 here

 they

 use 

paddi

ng to

 77, 

is th

is ne

cessa

ry?



     

   pr

ompt_

embed

s = s

elf._

encod

e_pro

mpt(



     

     

  pro

mpt,



     

     

  dev

ice,



     

     

  num

_imag

es_pe

r_pro

mpt,



     

     

  do_

class

ifier

_free

_guid

ance,



     

     

  neg

ative

_prom

pt,



     

     

  pro

mpt_e

mbeds

=prom

pt_em

beds,



     

     

  neg

ative

_prom

pt_em

beds=

negat

ive_p

rompt

_embe

ds,



     

   ) 

 # (2

 * b,

 77 +

 1, 7

68)





     

   # 

4. Pr

epare

 imag

e



     

   # 

NOTE:

 if i

mage 

is no

t ten

sor, 

there

 will

 be s

evera

l pro

cess.



     

   as

sert 

not s

elf.c

ontro

l_ima

ge_pr

ocess

or.co

nfig.

do_no

rmali

ze, "

Your 

contr

olnet

 shou

ld no

t nor

maliz

e the

 cont

rol i

mage.

"



     

   im

age =

 self

.prep

are_i

mage(



     

     

  ima

ge=im

age,



     

     

  wid

th=wi

dth,



     

     

  hei

ght=h

eight

,



     

     

  bat

ch_si

ze=ba

tch_s

ize *

 num_

image

s_per

_prom

pt,



     

     

  num

_imag

es_pe

r_pro

mpt=n

um_im

ages_

per_p

rompt

,



     

     

  dev

ice=d

evice

,



     

     

  dty

pe=se

lf.co

ntrol

net.d

type,



     

     

  do_

class

ifier

_free

_guid

ance=

do_cl

assif

ier_f

ree_g

uidan

ce,



     

     

  gue

ss_mo

de=gu

ess_m

ode,



     

   ) 

 # (2

 * b,

 c_26

, 200

, 200

)



     

   if

 use_

zero_

map_a

s_unc

ondit

ional

 and 

do_cl

assif

ier_f

ree_g

uidan

ce:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  _im

ages[

0] = 

torch

.zero

s_lik

e(_im

ages[

0])



     

     

  ima

ge = 

torch

.cat(

_imag

es)





     

   # 

5. Pr

epare

 time

steps



     

   se

lf.sc

hedul

er.se

t_tim

estep

s(num

_infe

rence

_step

s, de

vice=

devic

e)



     

   ti

meste

ps = 

self.

sched

uler.

times

teps





     

   # 

6. Pr

epare

 late

nt va

riabl

es



     

   nu

m_cha

nnels

_late

nts =

 self

.unet

.conf

ig.in

_chan

nels



     

   la

tents

 = se

lf.pr

epare

_late

nts(



     

     

  bat

ch_si

ze * 

num_i

mages

_per_

promp

t,



     

     

  num

_chan

nels_

laten

ts,



     

     

  hei

ght,



     

     

  wid

th,



     

     

  pro

mpt_e

mbeds

.dtyp

e,



     

     

  dev

ice,



     

     

  gen

erato

r,



     

     

  lat

ents,

  # w

ill u

se if

 not 

None,

 othe

rwise

 will

 gene

rate



     

   ) 

 # (b

, c, 

h/8, 

w/8) 

-> (b

s, 4,

 28, 

50)





     

   # 

7. Pr

epare

 extr

a ste

p kwa

rgs.



     

   ex

tra_s

tep_k

wargs

 = se

lf.pr

epare

_extr

a_ste

p_kwa

rgs(g

enera

tor, 

eta)





     

   ##

#### 

BEV: 

here 

we re

const

ruct 

each 

input

 form

at ##

####



     

   as

sert 

camer

a_par

am.sh

ape[0

] == 

batch

_size

, \



     

     

  f"E

xcept

 {bat

ch_si

ze} c

amera

 para

ms, b

ut yo

u hav

e bs=

{len(

camer

a_par

am)}"



     

   N_

cam =

 came

ra_pa

ram.s

hape[

1]



     

   la

tents

 = to

rch.s

tack(

[late

nts] 

* N_c

am, d

im=1)

  # b

s, 6,

 4, 2

8, 50



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ca

mera_

param

 = ca

mera_

param

.to(s

elf.d

evice

)



     

   if

 do_c

lassi

fier_

free_

guida

nce a

nd no

t gue

ss_mo

de:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  kwa

rgs_w

ith_u

ncond

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_kw

args(



     

     

     

 came

ra_pa

ram=c

amera

_para

m,



     

     

     

 imag

e=_im

ages[

0],  

# 0 i

s for

 unco

nditi

onal



     

     

     

 max_

len=b

box_m

ax_le

ngth,



     

     

     

 **be

v_con

troln

et_kw

args,



     

     

  )



     

     

  kwa

rgs_w

ith_u

ncond

.pop(

"max_

len",

 None

)  # 

some 

do no

t tak

e thi

s.



     

     

  cam

era_p

aram 

= kwa

rgs_w

ith_u

ncond

.pop(

"came

ra_pa

ram")



     

     

  _im

ages[

0] = 

kwarg

s_wit

h_unc

ond.p

op("i

mage"

)



     

     

  ima

ge = 

torch

.cat(

_imag

es)



     

     

  bev

_cont

rolne

t_kwa

rgs =

 move

_to(k

wargs

_with

_unco

nd, s

elf.d

evice

)



     

   ##

#### 

BEV e

nd ##

####





     

   # 

8. De

noisi

ng lo

op



     

   nu

m_war

mup_s

teps 

= len

(time

steps

) - n

um_in

feren

ce_st

eps *

 self

.sche

duler

.orde

r



     

   wi

th se

lf.pr

ogres

s_bar

(tota

l=num

_infe

rence

_step

s) as

 prog

ress_

bar:



     

     

  for

 i, t

 in e

numer

ate(t

imest

eps):



     

     

     

 # ex

pand 

the l

atent

s if 

we ar

e doi

ng cl

assif

ier f

ree g

uidan

ce



     

     

     

 # bs

*2, 6

, 4, 

28, 5

0



     

     

     

 late

nt_mo

del_i

nput 

= (



     

     

     

     

torch

.cat(

[late

nts] 

* 2) 

if do

_clas

sifie

r_fre

e_gui

dance

 else

 late

nts



     

     

     

 )



     

     

     

 late

nt_mo

del_i

nput 

= sel

f.sch

edule

r.sca

le_mo

del_i

nput(



     

     

     

     

laten

t_mod

el_in

put, 

t



     

     

     

 )





     

     

     

 # co

ntrol

net(s

) inf

erenc

e



     

     

     

 cont

rolne

t_t =

 t.un

squee

ze(0)



     

     

     

 # gu

ess_m

ode &

 clas

sifie

r_fre

e_gui

dance

 -> o

nly g

uidan

ce us

e con

troln

et



     

     

     

 # no

t gue

ss_mo

de & 

class

ifier

_free

_guid

ance 

-> al

l use

 cont

rolne

t



     

     

     

 # gu

ess_m

ode -

> nor

mal i

nput,

 take

 effe

ct in

 cont

rolne

t



     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

er Co

ntrol

Net o

nly f

or th

e con

ditio

nal b

atch.



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ents



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds

.chun

k(2)[

1]



     

     

     

 else

:



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ent_m

odel_

input



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds



     

     

     

 cont

rolne

t_t =

 cont

rolne

t_t.r

epeat

(len(

contr

olnet

_late

nt_mo

del_i

nput)

)





     

     

     

 # fm

t: of

f



     

     

     

 down

_bloc

k_res

_samp

les, 

mid_b

lock_

res_s

ample

, \



     

     

     

 enco

der_h

idden

_stat

es_wi

th_ca

m = s

elf.c

ontro

lnet(



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput,



     

     

     

     

contr

olnet

_t,



     

     

     

     

camer

a_par

am,  

# for

 BEV



     

     

     

     

encod

er_hi

dden_

state

s=con

troln

et_pr

ompt_

embed

s,



     

     

     

     

contr

olnet

_cond

=imag

e,



     

     

     

     

condi

tioni

ng_sc

ale=c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

     

     

     

guess

_mode

=gues

s_mod

e,



     

     

     

     

retur

n_dic

t=Fal

se,



     

     

     

     

**bev

_cont

rolne

t_kwa

rgs, 

# for

 BEV



     

     

     

 )



     

     

     

 # fm

t: on





     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

ered 

Contr

olNet

 only

 for 

the c

ondit

ional

 batc

h.



     

     

     

     

# To 

apply

 the 

outpu

t of 

Contr

olNet

 to b

oth t

he un

condi

tiona

l and

 cond

ition

al ba

tches

,



     

     

     

     

# add

 0 to

 the 

uncon

ditio

nal b

atch 

to ke

ep it

 unch

anged

.



     

     

     

     

down_

block

_res_

sampl

es = 

[



     

     

     

     

    t

orch.

cat([

torch

.zero

s_lik

e(d),

 d])



     

     

     

     

    f

or d 

in do

wn_bl

ock_r

es_sa

mples



     

     

     

     

]



     

     

     

     

mid_b

lock_

res_s

ample

 = to

rch.c

at(



     

     

     

     

    [

torch

.zero

s_lik

e(mid

_bloc

k_res

_samp

le), 

mid_b

lock_

res_s

ample

]



     

     

     

     

)



     

     

     

     

# add

 unco

nd en

coder

_hidd

en_st

ates_

with_

cam h

ere



     

     

     

     

encod

er_hi

dden_

state

s_wit

h_cam

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_em

b(



     

     

     

     

    p

rompt

_embe

ds.ch

unk(2

)[0],

 N_ca

m,



     

     

     

     

    e

ncode

r_hid

den_s

tates

_with

_cam,



     

     

     

     

)





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # St

ratin

g fro

m her

e, we

 use 

4-dim

 data

.



     

     

     

 # en

coder

_hidd

en_st

ates_

with_

cam: 

(2b x

 N), 

78, 7

68



     

     

     

 # la

tent_

model

_inpu

t: 2b

, N, 

4, 28

, 50 

-> 2b

 x N,

 4, 2

8, 50



     

     

     

 late

nt_mo

del_i

nput 

= rea

rrang

e(



     

     

     

     

laten

t_mod

el_in

put, 

'b n 

... -

> (b 

n) ..

.')



     

     

     

 late

nts =

 rear

range

(late

nts, 

'b n 

... -

> (b 

n) ..

.')





     

     

     

 # pr

edict

 the 

noise

 resi

dual:

 2bxN

, 4, 

28, 5

0



     

     

     

 addi

tiona

l_par

am = 

{}



     

     

     

 nois

e_pre

d = s

elf.u

net(



     

     

     

     

laten

t_mod

el_in

put, 

 # ma

y wit

h unc

ondit

ional



     

     

     

     

t,



     

     

     

     

encod

er_hi

dden_

state

s=enc

oder_

hidde

n_sta

tes_w

ith_c

am,



     

     

     

     

**add

ition

al_pa

ram, 

 # if

 use 

origi

nal u

net, 

it ca

nnot 

take 

kwarg

s



     

     

     

     

cross

_atte

ntion

_kwar

gs=cr

oss_a

ttent

ion_k

wargs

,



     

     

     

     

down_

block

_addi

tiona

l_res

idual

s=dow

n_blo

ck_re

s_sam

ples,



     

     

     

     

mid_b

lock_

addit

ional

_resi

dual=

mid_b

lock_

res_s

ample

,



     

     

     

 ).sa

mple





     

     

     

 # pe

rform

 guid

ance



     

     

     

 if d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# for

 each

: bxN

, 4, 

28, 5

0



     

     

     

     

noise

_pred

_unco

nd, n

oise_

pred_

text 

= noi

se_pr

ed.ch

unk(2

)



     

     

     

     

noise

_pred

 = no

ise_p

red_u

ncond

 + gu

idanc

e_sca

le * 

(



     

     

     

     

    n

oise_

pred_

text 

- noi

se_pr

ed_un

cond



     

     

     

     

)





     

     

     

 # co

mpute

 the 

previ

ous n

oisy 

sampl

e x_t

 -> x

_t-1



     

     

     

 # NO

TE: i

s the

 sche

duler

 use 

rando

mness

, ple

ase h

andle

 the 

logic



     

     

     

 # fo

r gen

erato

r.



     

     

     

 late

nts =

 self

.sche

duler

.step

(



     

     

     

     

noise

_pred

, t, 

laten

ts, *

*extr

a_ste

p_kwa

rgs



     

     

     

 ).pr

ev_sa

mple





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # no

w we 

add d

imens

ion b

ack, 

use 5

-dim 

data.



     

     

     

 # NO

TE: o

nly `

laten

ts` i

s upd

ated 

throu

gh th

e loo

p



     

     

     

 late

nts =

 rear

range

(late

nts, 

'(b n

) ...

 -> b

 n ..

.', n

=N_ca

m)





     

     

     

 # ca

ll th

e cal

lback

, if 

provi

ded



     

     

     

 if i

 == l

en(ti

meste

ps) -

 1 or

 (



     

     

     

     

(i + 

1) > 

num_w

armup

_step

s and

 (i +

 1) %

 self

.sche

duler

.orde

r == 

0



     

     

     

 ):



     

     

     

     

progr

ess_b

ar.up

date(

)



     

     

     

     

if ca

llbac

k is 

not N

one a

nd i 

% cal

lback

_step

s == 

0:



     

     

     

     

    c

allba

ck(i,

 t, l

atent

s)





     

   ##

#### 

BEV: 

here 

rebui

ld th

e sha

pes b

ack. 

post-

proce

ss st

ill a

ssume



     

   # 

laten

ts, n

o nee

d for

 b, n

, 4, 

28, 5

0



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ##

### B

EV en

d





     

   # 

If we

 do s

equen

tial 

model

 offl

oadin

g, le

t's o

ffloa

d une

t and

 cont

rolne

t



     

   # 

manua

lly f

or ma

x mem

ory s

aving

s



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.une

t.to(

"cpu"

)



     

     

  sel

f.con

troln

et.to

("cpu

")



     

     

  tor

ch.cu

da.em

pty_c

ache(

)





     

   if

 outp

ut_ty

pe ==

 "lat

ent":



     

     

  ima

ge = 

laten

ts



     

     

  has

_nsfw

_conc

ept =

 None



     

   el

if ou

tput_

type 

== "p

il":



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

     

  # 1

0. Co

nvert

 to P

IL



     

     

  ima

ge = 

self.

numpy

_to_p

il_do

uble(

image

)



     

   el

se:



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

   # 

Offlo

ad la

st mo

del t

o CPU



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.fin

al_of

fload

_hook

.offl

oad()





     

   if

 not 

retur

n_dic

t:



     

     

  ret

urn (

image

, has

_nsfw

_conc

ept)





     

   re

turn 

BEVSt

ableD

iffus

ionPi

pelin

eOutp

ut(



     

     

  ima

ges=i

mage,

 nsfw

_cont

ent_d

etect

ed=ha

s_nsf

w_con

cept



     

   )



from 

datac

lasse

s imp

ort d

atacl

ass



from 

typin

g imp

ort A

ny, C

allab

le, D

ict, 

List,

 Opti

onal,

 Tupl

e, Un

ion



impor

t ins

pect





impor

t tor

ch



impor

t PIL



impor

t num

py as

 np



from 

einop

s imp

ort r

earra

nge





from 

diffu

sers 

impor

t Sta

bleDi

ffusi

onCon

trolN

etPip

eline



from 

diffu

sers.

utils

 impo

rt Ba

seOut

put



from 

diffu

sers.

image

_proc

essor

 impo

rt Va

eImag

eProc

essor



from 

diffu

sers.

model

s imp

ort A

utoen

coder

KL, U

Net2D

Condi

tionM

odel



from 

diffu

sers.

pipel

ines.

stabl

e_dif

fusio

n imp

ort S

table

Diffu

sionS

afety

Check

er



from 

diffu

sers.

sched

ulers

.sche

dulin

g_uti

ls im

port 

Karra

sDiff

usion

Sched

ulers



from 

trans

forme

rs im

port 

CLIPI

mageP

roces

sor, 

CLIPT

extMo

del, 

CLIPT

okeni

zer





from 

..mis

c.com

mon i

mport

 move

_to







@data

class



class

 BEVS

table

Diffu

sionP

ipeli

neOut

put(B

aseOu

tput)

:



    "

""



    O

utput

 clas

s for

 Stab

le Di

ffusi

on pi

pelin

es.





    A

rgs:



     

   im

ages 

(`Lis

t[PIL

.Imag

e.Ima

ge]` 

or `n

p.nda

rray`

)



     

     

  Lis

t of 

denoi

sed P

IL im

ages 

of le

ngth 

`batc

h_siz

e` or

 nump

y arr

ay of

 shap

e `(b

atch_

size,

 heig

ht, w

idth,



     

     

  num

_chan

nels)

`. PI

L ima

ges o

r num

py ar

ray p

resen

t the

 deno

ised 

image

s of 

the d

iffus

ion p

ipeli

ne.



     

   ns

fw_co

ntent

_dete

cted 

(`Lis

t[boo

l]`)



     

     

  Lis

t of 

flags

 deno

ting 

wheth

er th

e cor

respo

nding

 gene

rated

 imag

e lik

ely r

epres

ents 

"not-

safe-

for-w

ork"



     

     

  (ns

fw) c

onten

t, or

 `Non

e` if

 safe

ty ch

eckin

g cou

ld no

t be 

perfo

rmed.



    "

""





    i

mages

: Uni

on[Li

st[Li

st[PI

L.Ima

ge.Im

age]]

, np.

ndarr

ay]



    n

sfw_c

onten

t_det

ected

: Opt

ional

[List

[bool

]]







class

 Stab

leDif

fusio

nBEVC

ontro

lNetP

ipeli

ne(St

ableD

iffus

ionCo

ntrol

NetPi

pelin

e):



    d

ef __

init_

_(



     

   se

lf,



     

   va

e: Au

toenc

oderK

L,



     

   te

xt_en

coder

: CLI

PText

Model

,



     

   un

et: U

Net2D

Condi

tionM

odel,



     

   co

ntrol

net,



     

   sc

hedul

er: K

arras

Diffu

sionS

chedu

lers,



     

   to

keniz

er: C

LIPTo

keniz

er,



     

   sa

fety_

check

er: S

table

Diffu

sionS

afety

Check

er = 

None,



     

   fe

ature

_extr

actor

: CLI

PImag

eProc

essor

 = No

ne,



     

   re

quire

s_saf

ety_c

hecke

r: bo

ol = 

False

,



    )

:



     

   su

per()

.__in

it__(



     

     

  vae

,



     

     

  tex

t_enc

oder,



     

     

  tok

enize

r,



     

     

  une

t,



     

     

  con

troln

et,



     

     

  sch

edule

r,



     

     

  saf

ety_c

hecke

r,



     

     

  fea

ture_

extra

ctor,



     

     

  req

uires

_safe

ty_ch

ecker

,



     

   )



     

   as

sert 

safet

y_che

cker 

== No

ne, "

Pleas

e do 

not u

se sa

fety_

check

er."



     

   se

lf.co

ntrol

_imag

e_pro

cesso

r = V

aeIma

gePro

cesso

r(



     

     

  vae

_scal

e_fac

tor=s

elf.v

ae_sc

ale_f

actor

,



     

     

  do_

resiz

e=Fal

se,



     

     

  do_

conve

rt_rg

b=Fal

se,



     

     

  do_

norma

lize=

False

,



     

   )





    d

ef nu

mpy_t

o_pil

_doub

le(se

lf, i

mages

):



     

   ""

"



     

   Co

nvert

 a nu

mpy i

mage 

or a 

batch

 of i

mages

 to a

 PIL 

image

.



     

   We

 need

 to h

andle

 5-di

m inp

uts a

nd re

ture 

2-dim

 list

.



     

   ""

"



     

   im

gs_li

st = 

[]



     

   fo

r img

s in 

image

s:



     

     

  img

s_lis

t.app

end(s

elf.n

umpy_

to_pi

l(img

s))



     

   re

turn 

imgs_

list





    #

 Copi

ed fr

om di

ffuse

rs.pi

pelin

es.st

able_

diffu

sion.

pipel

ine_s

table

_diff

usion

.Stab

leDif

fusio

nPipe

line.

prepa

re_ex

tra_s

tep_k

wargs



    d

ef pr

epare

_extr

a_ste

p_kwa

rgs(s

elf, 

gener

ator,

 eta)

:



     

   # 

prepa

re ex

tra k

wargs

 for 

the s

chedu

ler s

tep, 

since

 not 

all s

chedu

lers 

have 

the s

ame s

ignat

ure



     

   # 

eta (

η) is

 only

 used

 with

 the 

DDIMS

chedu

ler, 

it wi

ll be

 igno

red f

or ot

her s

chedu

lers.



     

   # 

eta c

orres

ponds

 to η

 in D

DIM p

aper:

 http

s://a

rxiv.

org/a

bs/20

10.02

502



     

   # 

and s

hould

 be b

etwee

n [0,

 1]





     

   ac

cepts

_eta 

= "et

a" in

 set(

inspe

ct.si

gnatu

re(se

lf.sc

hedul

er.st

ep).p

arame

ters.

keys(

))



     

   ex

tra_s

tep_k

wargs

 = {}



     

   if

 acce

pts_e

ta:



     

     

  ext

ra_st

ep_kw

args[

"eta"

] = e

ta





     

   # 

check

 if t

he sc

hedul

er ac

cepts

 gene

rator



     

   ac

cepts

_gene

rator

 = "g

enera

tor" 

in se

t(ins

pect.

signa

ture(

self.

sched

uler.

step)

.para

meter

s.key

s())



     

   if

 acce

pts_g

enera

tor:



     

     

  rai

se Ru

ntime

Error

("If 

you f

ixed 

the l

ogic 

for g

enera

tor, 

pleas

e rem

ove t

his. 

Other

wise,

 plea

se us

e oth

er sa

mpler

.")



     

     

  ext

ra_st

ep_kw

args[

"gene

rator

"] = 

gener

ator



     

   re

turn 

extra

_step

_kwar

gs





    d

ef de

code_

laten

ts(se

lf, l

atent

s):



     

   # 

decod

e lat

ents 

with 

5-dim

s



     

   la

tents

 = 1 

/ sel

f.vae

.conf

ig.sc

aling

_fact

or * 

laten

ts





     

   bs

 = le

n(lat

ents)



     

   la

tents

 = re

arran

ge(la

tents

, 'b 

c ...

 -> (

b c) 

...')



     

   im

age =

 self

.vae.

decod

e(lat

ents)

.samp

le



     

   im

age =

 rear

range

(imag

e, '(

b c) 

... -

> b c

 ...'

, b=b

s)





     

   im

age =

 (ima

ge / 

2 + 0

.5).c

lamp(

0, 1)



     

   # 

we al

ways 

cast 

to fl

oat32

 as t

his d

oes n

ot ca

use s

ignif

icant

 over

head 

and i

s com

patib

le wi

th bf

loat1

6



     

   im

age =

 rear

range

(imag

e.cpu

(), '

... c

 h w 

-> ..

. h w

 c').

float

().nu

mpy()



     

   re

turn 

image





    @

torch

.no_g

rad()



    d

ef __

call_

_(



     

   se

lf,



     

   pr

ompt:

 Unio

n[str

, Lis

t[str

]],



     

   im

age: 

torch

.Floa

tTens

or,



     

   ca

mera_

param

: Uni

on[to

rch.T

ensor

, Non

e],



     

   he

ight:

 int,



     

   wi

dth: 

int,



     

   nu

m_inf

erenc

e_ste

ps: i

nt = 

50,



     

   gu

idanc

e_sca

le: f

loat 

= 7.5

,



     

   ne

gativ

e_pro

mpt: 

Optio

nal[U

nion[

str, 

List[

str]]

] = N

one,



     

   nu

m_ima

ges_p

er_pr

ompt:

 Opti

onal[

int] 

= 1,



     

   et

a: fl

oat =

 0.0,



     

   ge

nerat

or: O

ption

al[to

rch.G

enera

tor] 

= Non

e,



     

   la

tents

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   pr

ompt_

embed

s: Op

tiona

l[tor

ch.Fl

oatTe

nsor]

 = No

ne,



     

   ne

gativ

e_pro

mpt_e

mbeds

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   ou

tput_

type:

 Opti

onal[

str] 

= "pi

l",



     

   re

turn_

dict:

 bool

 = Tr

ue,



     

   ca

llbac

k: Op

tiona

l[Cal

lable

[[int

, int

, tor

ch.Fl

oatTe

nsor]

, Non

e]] =

 None

,



     

   ca

llbac

k_ste

ps: i

nt = 

1,



     

   cr

oss_a

ttent

ion_k

wargs

: Opt

ional

[Dict

[str,

 Any]

] = N

one,



     

   co

ntrol

net_c

ondit

ionin

g_sca

le: f

loat 

= 1,



     

   gu

ess_m

ode: 

bool 

= Fal

se,



     

   us

e_zer

o_map

_as_u

ncond

ition

al: b

ool =

 Fals

e,



     

   be

v_con

troln

et_kw

args 

= {},



     

   bb

ox_ma

x_len

gth =

 None

,



    )

:



     

   r"

""



     

   Fu

nctio

n inv

oked 

when 

calli

ng th

e pip

eline

 for 

gener

ation

.





     

   Ar

gs:



     

     

  pro

mpt (

`str`

 or `

List[

str]`

, *op

tiona

l*):



     

     

     

 The 

promp

t or 

promp

ts to

 guid

e the

 imag

e gen

erati

on. I

f not

 defi

ned, 

one h

as to

 pass

 `pro

mpt_e

mbeds

`.



     

     

     

 inst

ead.



     

     

  ima

ge (`

torch

.Floa

tTens

or`, 

`PIL.

Image

.Imag

e`, `

List[

torch

.Floa

tTens

or]`,

 `Lis

t[PIL

.Imag

e.Ima

ge]`,



     

     

     

     

`List

[List

[torc

h.Flo

atTen

sor]]

`, or

 `Lis

t[Lis

t[PIL

.Imag

e.Ima

ge]]`

):



     

     

     

 The 

Contr

olNet

 inpu

t con

ditio

n. Co

ntrol

Net u

ses t

his i

nput 

condi

tion 

to ge

nerat

e gui

dance

 to U

net. 

If



     

     

     

 the 

type 

is sp

ecifi

ed as

 `Tor

ch.Fl

oatTe

nsor`

, it 

is pa

ssed 

to Co

ntrol

Net a

s is.

 `PIL

.Imag

e.Ima

ge` c

an



     

     

     

 also

 be a

ccept

ed as

 an i

mage.

 The 

dimen

sions

 of t

he ou

tput 

image

 defa

ults 

to `i

mage`

's di

mensi

ons. 

If



     

     

     

 heig

ht an

d/or 

width

 are 

passe

d, `i

mage`

 is r

esize

d acc

ordin

g to 

them.

 If m

ultip

le Co

ntrol

Nets 

are



     

     

     

 spec

ified

 in i

nit, 

image

s mus

t be 

passe

d as 

a lis

t suc

h tha

t eac

h ele

ment 

of th

e lis

t can

 be c

orrec

tly



     

     

     

 batc

hed f

or in

put t

o a s

ingle

 cont

rolne

t.



     

     

  hei

ght (

`int`

, *op

tiona

l*, d

efaul

ts to

 self

.unet

.conf

ig.sa

mple_

size 

* sel

f.vae

_scal

e_fac

tor):



     

     

     

 The 

heigh

t in 

pixel

s of 

the g

enera

ted i

mage.



     

     

  wid

th (`

int`,

 *opt

ional

*, de

fault

s to 

self.

unet.

confi

g.sam

ple_s

ize *

 self

.vae_

scale

_fact

or):



     

     

     

 The 

width

 in p

ixels

 of t

he ge

nerat

ed im

age.



     

     

  num

_infe

rence

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 5

0):



     

     

     

 The 

numbe

r of 

denoi

sing 

steps

. Mor

e den

oisin

g ste

ps us

ually

 lead

 to a

 high

er qu

ality

 imag

e at 

the



     

     

     

 expe

nse o

f slo

wer i

nfere

nce.



     

     

  gui

dance

_scal

e (`f

loat`

, *op

tiona

l*, d

efaul

ts to

 7.5)

:



     

     

     

 Guid

ance 

scale

 as d

efine

d in 

[Clas

sifie

r-Fre

e Dif

fusio

n Gui

dance

](htt

ps://

arxiv

.org/

abs/2

207.1

2598)

.



     

     

     

 `gui

dance

_scal

e` is

 defi

ned a

s `w`

 of e

quati

on 2.

 of [

Image

n



     

     

     

 Pape

r](ht

tps:/

/arxi

v.org

/pdf/

2205.

11487

.pdf)

. Gui

dance

 scal

e is 

enabl

ed by

 sett

ing `

guida

nce_s

cale 

>



     

     

     

 1`. 

Highe

r gui

dance

 scal

e enc

ourag

es to

 gene

rate 

image

s tha

t are

 clos

ely l

inked

 to t

he te

xt `p

rompt

`,



     

     

     

 usua

lly a

t the

 expe

nse o

f low

er im

age q

ualit

y.



     

     

  neg

ative

_prom

pt (`

str` 

or `L

ist[s

tr]`,

 *opt

ional

*):



     

     

     

 The 

promp

t or 

promp

ts no

t to 

guide

 the 

image

 gene

ratio

n. If

 not 

defin

ed, o

ne ha

s to 

pass



     

     

     

 `neg

ative

_prom

pt_em

beds`

 inst

ead. 

Ignor

ed wh

en no

t usi

ng gu

idanc

e (i.

e., i

gnore

d if 

`guid

ance_

scale

` is



     

     

     

 less

 than

 `1`)

.



     

     

  num

_imag

es_pe

r_pro

mpt (

`int`

, *op

tiona

l*, d

efaul

ts to

 1):



     

     

     

 The 

numbe

r of 

image

s to 

gener

ate p

er pr

ompt.



     

     

  eta

 (`fl

oat`,

 *opt

ional

*, de

fault

s to 

0.0):



     

     

     

 Corr

espon

ds to

 para

meter

 eta 

(η) i

n the

 DDIM

 pape

r: ht

tps:/

/arxi

v.org

/abs/

2010.

02502

. Onl

y app

lies 

to



     

     

     

 [`sc

hedul

ers.D

DIMSc

hedul

er`],

 will

 be i

gnore

d for

 othe

rs.



     

     

  gen

erato

r (`t

orch.

Gener

ator`

 or `

List[

torch

.Gene

rator

]`, *

optio

nal*)

:



     

     

     

 One 

or a 

list 

of [t

orch 

gener

ator(

s)](h

ttps:

//pyt

orch.

org/d

ocs/s

table

/gene

rated

/torc

h.Gen

erato

r.htm

l)



     

     

     

 to m

ake g

enera

tion 

deter

minis

tic.



     

     

  lat

ents 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

noisy

 late

nts, 

sampl

ed fr

om a 

Gauss

ian d

istri

butio

n, to

 be u

sed a

s inp

uts f

or im

age



     

     

     

 gene

ratio

n. Ca

n be 

used 

to tw

eak t

he sa

me ge

nerat

ion w

ith d

iffer

ent p

rompt

s. If

 not 

provi

ded, 

a lat

ents



     

     

     

 tens

or wi

ll ge

 gene

rated

 by s

ampli

ng us

ing t

he su

pplie

d ran

dom `

gener

ator`

.



     

     

  pro

mpt_e

mbeds

 (`to

rch.F

loatT

ensor

`, *o

ption

al*):



     

     

     

 Pre-

gener

ated 

text 

embed

dings

. Can

 be u

sed t

o eas

ily t

weak 

text 

input

s, *e

.g.* 

promp

t wei

ghtin

g. If

 not



     

     

     

 prov

ided,

 text

 embe

dding

s wil

l be 

gener

ated 

from 

`prom

pt` i

nput 

argum

ent.



     

     

  neg

ative

_prom

pt_em

beds 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

negat

ive t

ext e

mbedd

ings.

 Can 

be us

ed to

 easi

ly tw

eak t

ext i

nputs

, *e.

g.* p

rompt



     

     

     

 weig

hting

. If 

not p

rovid

ed, n

egati

ve_pr

ompt_

embed

s wil

l be 

gener

ated 

from 

`nega

tive_

promp

t` in

put



     

     

     

 argu

ment.



     

     

  out

put_t

ype (

`str`

, *op

tiona

l*, d

efaul

ts to

 `"pi

l"`):



     

     

     

 The 

outpu

t for

mat o

f the

 gene

rate 

image

. Cho

ose b

etwee

n



     

     

     

 [PIL

](htt

ps://

pillo

w.rea

dthed

ocs.i

o/en/

stabl

e/): 

`PIL.

Image

.Imag

e` or

 `np.

array

`.



     

     

  ret

urn_d

ict (

`bool

`, *o

ption

al*, 

defau

lts t

o `Tr

ue`):



     

     

     

 Whet

her o

r not

 to r

eturn

 a [`

~pipe

lines

.stab

le_di

ffusi

on.St

ableD

iffus

ionPi

pelin

eOutp

ut`] 

inste

ad of

 a



     

     

     

 plai

n tup

le.



     

     

  cal

lback

 (`Ca

llabl

e`, *

optio

nal*)

:



     

     

     

 A fu

nctio

n tha

t wil

l be 

calle

d eve

ry `c

allba

ck_st

eps` 

steps

 duri

ng in

feren

ce. T

he fu

nctio

n wil

l be



     

     

     

 call

ed wi

th th

e fol

lowin

g arg

ument

s: `c

allba

ck(st

ep: i

nt, t

imest

ep: i

nt, l

atent

s: to

rch.F

loatT

ensor

)`.



     

     

  cal

lback

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 1

):



     

     

     

 The 

frequ

ency 

at wh

ich t

he `c

allba

ck` f

uncti

on wi

ll be

 call

ed. I

f not

 spec

ified

, the

 call

back 

will 

be



     

     

     

 call

ed at

 ever

y ste

p.



     

     

  cro

ss_at

tenti

on_kw

args 

(`dic

t`, *

optio

nal*)

:



     

     

     

 A kw

args 

dicti

onary

 that

 if s

pecif

ied i

s pas

sed a

long 

to th

e `At

tenti

onPro

cesso

r` as

 defi

ned u

nder



     

     

     

 `sel

f.pro

cesso

r` in



     

     

     

 [dif

fuser

s.cro

ss_at

tenti

on](h

ttps:

//git

hub.c

om/hu

gging

face/

diffu

sers/

blob/

main/

src/d

iffus

ers/m

odels

/cros

s_att

entio

n.py)

.



     

     

  con

troln

et_co

nditi

oning

_scal

e (`f

loat`

 or `

List[

float

]`, *

optio

nal*,

 defa

ults 

to 1.

0):



     

     

     

 The 

outpu

ts of

 the 

contr

olnet

 are 

multi

plied

 by `

contr

olnet

_cond

ition

ing_s

cale`

 befo

re th

ey ar

e add

ed



     

     

     

 to t

he re

sidua

l in 

the o

rigin

al un

et. I

f mul

tiple

 Cont

rolNe

ts ar

e spe

cifie

d in 

init,

 you 

can s

et th

e



     

     

     

 corr

espon

ding 

scale

 as a

 list

.



     

     

  gue

ss_mo

de (`

bool`

, *op

tiona

l*, d

efaul

ts to

 `Fal

se`):



     

     

     

 In t

his m

ode, 

the C

ontro

lNet 

encod

er wi

ll tr

y bes

t to 

recog

nize 

the c

onten

t of 

the i

nput 

image

 even

 if



     

     

     

 you 

remov

e all

 prom

pts. 

The `

guida

nce_s

cale`

 betw

een 3

.0 an

d 5.0

 is r

ecomm

ended

.





     

   Ex

ample

s:





     

   Re

turns

:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] o

r `tu

ple`:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] i

f `re

turn_

dict`

 is T

rue, 

other

wise 

a `tu

ple.



     

     

  Whe

n ret

urnin

g a t

uple,

 the 

first

 elem

ent i

s a l

ist w

ith t

he ge

nerat

ed im

ages,

 and 

the s

econd

 elem

ent i

s a



     

     

  lis

t of 

`bool

`s de

notin

g whe

ther 

the c

orres

pondi

ng ge

nerat

ed im

age l

ikely

 repr

esent

s "no

t-saf

e-for

-work

"



     

     

  (ns

fw) c

onten

t, ac

cordi

ng to

 the 

`safe

ty_ch

ecker

`.



     

   ""

"



     

   # 

0. De

fault

 heig

ht an

d wid

th to

 unet



     

   # 

BEV: 

we ca

nnot 

use t

he si

ze of

 imag

e



     

   # 

heigh

t, wi

dth =

 self

._def

ault_

heigh

t_wid

th(he

ight,

 widt

h, No

ne)





     

   # 

1. Ch

eck i

nputs

. Rai

se er

ror i

f not

 corr

ect



     

   # 

we do

 not 

need 

this,

 only

 some

 type

 asse

rtion



     

   # 

self.

check

_inpu

ts(



     

   # 

    p

rompt

,



     

   # 

    i

mage,



     

   # 

    h

eight

,



     

   # 

    w

idth,



     

   # 

    c

allba

ck_st

eps,



     

   # 

    n

egati

ve_pr

ompt,



     

   # 

    p

rompt

_embe

ds,



     

   # 

    n

egati

ve_pr

ompt_

embed

s,



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

   # 

)





     

   # 

2. De

fine 

call 

param

eters



     

   # 

NOTE:

 we g

et ba

tch_s

ize f

irst 

from 

promp

t, th

en al

ign w

ith i

t.



     

   if

 prom

pt is

 not 

None 

and i

sinst

ance(

promp

t, st

r):



     

     

  bat

ch_si

ze = 

1



     

   el

if pr

ompt 

is no

t Non

e and

 isin

stanc

e(pro

mpt, 

list)

:



     

     

  bat

ch_si

ze = 

len(p

rompt

)



     

   el

se:



     

     

  bat

ch_si

ze = 

promp

t_emb

eds.s

hape[

0]





     

   de

vice 

= sel

f._ex

ecuti

on_de

vice



     

   # 

here 

`guid

ance_

scale

` is 

defin

ed an

alog 

to th

e gui

dance

 weig

ht `w

` of 

equat

ion (

2)



     

   # 

of th

e Ima

gen p

aper:

 http

s://a

rxiv.

org/p

df/22

05.11

487.p

df . 

`guid

ance_

scale

 = 1`



     

   # 

corre

spond

s to 

doing

 no c

lassi

fier 

free 

guida

nce.



     

   do

_clas

sifie

r_fre

e_gui

dance

 = gu

idanc

e_sca

le > 

1.0





     

   ##

# BEV

, che

ck ca

mera_

param

 ###



     

   if

 came

ra_pa

ram i

s Non

e:



     

     

  # u

se un

cond_

cam a

nd di

sable

 clas

sifie

r fre

e gui

dance



     

     

  N_c

am = 

6  # 

TODO:

 hard

-code

d



     

     

  cam

era_p

aram 

= sel

f.con

troln

et.un

cond_

cam_p

aram(

(batc

h_siz

e, N_

cam))



     

     

  do_

class

ifier

_free

_guid

ance 

= Fal

se



     

   ##

# don

e ###





     

   # 

if is

insta

nce(s

elf.c

ontro

lnet,

 Mult

iCont

rolNe

tMode

l) an

d isi

nstan

ce(co

ntrol

net_c

ondit

ionin

g_sca

le, f

loat)

:



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale =

 [con

troln

et_co

nditi

oning

_scal

e] * 

len(s

elf.c

ontro

lnet.

nets)





     

   # 

3. En

code 

input

 prom

pt



     

   # 

NOTE:

 here

 they

 use 

paddi

ng to

 77, 

is th

is ne

cessa

ry?



     

   pr

ompt_

embed

s = s

elf._

encod

e_pro

mpt(



     

     

  pro

mpt,



     

     

  dev

ice,



     

     

  num

_imag

es_pe

r_pro

mpt,



     

     

  do_

class

ifier

_free

_guid

ance,



     

     

  neg

ative

_prom

pt,



     

     

  pro

mpt_e

mbeds

=prom

pt_em

beds,



     

     

  neg

ative

_prom

pt_em

beds=

negat

ive_p

rompt

_embe

ds,



     

   ) 

 # (2

 * b,

 77 +

 1, 7

68)





     

   # 

4. Pr

epare

 imag

e



     

   # 

NOTE:

 if i

mage 

is no

t ten

sor, 

there

 will

 be s

evera

l pro

cess.



     

   as

sert 

not s

elf.c

ontro

l_ima

ge_pr

ocess

or.co

nfig.

do_no

rmali

ze, "

Your 

contr

olnet

 shou

ld no

t nor

maliz

e the

 cont

rol i

mage.

"



     

   im

age =

 self

.prep

are_i

mage(



     

     

  ima

ge=im

age,



     

     

  wid

th=wi

dth,



     

     

  hei

ght=h

eight

,



     

     

  bat

ch_si

ze=ba

tch_s

ize *

 num_

image

s_per

_prom

pt,



     

     

  num

_imag

es_pe

r_pro

mpt=n

um_im

ages_

per_p

rompt

,



     

     

  dev

ice=d

evice

,



     

     

  dty

pe=se

lf.co

ntrol

net.d

type,



     

     

  do_

class

ifier

_free

_guid

ance=

do_cl

assif

ier_f

ree_g

uidan

ce,



     

     

  gue

ss_mo

de=gu

ess_m

ode,



     

   ) 

 # (2

 * b,

 c_26

, 200

, 200

)



     

   if

 use_

zero_

map_a

s_unc

ondit

ional

 and 

do_cl

assif

ier_f

ree_g

uidan

ce:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  _im

ages[

0] = 

torch

.zero

s_lik

e(_im

ages[

0])



     

     

  ima

ge = 

torch

.cat(

_imag

es)





     

   # 

5. Pr

epare

 time

steps



     

   se

lf.sc

hedul

er.se

t_tim

estep

s(num

_infe

rence

_step

s, de

vice=

devic

e)



     

   ti

meste

ps = 

self.

sched

uler.

times

teps





     

   # 

6. Pr

epare

 late

nt va

riabl

es



     

   nu

m_cha

nnels

_late

nts =

 self

.unet

.conf

ig.in

_chan

nels



     

   la

tents

 = se

lf.pr

epare

_late

nts(



     

     

  bat

ch_si

ze * 

num_i

mages

_per_

promp

t,



     

     

  num

_chan

nels_

laten

ts,



     

     

  hei

ght,



     

     

  wid

th,



     

     

  pro

mpt_e

mbeds

.dtyp

e,



     

     

  dev

ice,



     

     

  gen

erato

r,



     

     

  lat

ents,

  # w

ill u

se if

 not 

None,

 othe

rwise

 will

 gene

rate



     

   ) 

 # (b

, c, 

h/8, 

w/8) 

-> (b

s, 4,

 28, 

50)





     

   # 

7. Pr

epare

 extr

a ste

p kwa

rgs.



     

   ex

tra_s

tep_k

wargs

 = se

lf.pr

epare

_extr

a_ste

p_kwa

rgs(g

enera

tor, 

eta)





     

   ##

#### 

BEV: 

here 

we re

const

ruct 

each 

input

 form

at ##

####



     

   as

sert 

camer

a_par

am.sh

ape[0

] == 

batch

_size

, \



     

     

  f"E

xcept

 {bat

ch_si

ze} c

amera

 para

ms, b

ut yo

u hav

e bs=

{len(

camer

a_par

am)}"



     

   N_

cam =

 came

ra_pa

ram.s

hape[

1]



     

   la

tents

 = to

rch.s

tack(

[late

nts] 

* N_c

am, d

im=1)

  # b

s, 6,

 4, 2

8, 50



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ca

mera_

param

 = ca

mera_

param

.to(s

elf.d

evice

)



     

   if

 do_c

lassi

fier_

free_

guida

nce a

nd no

t gue

ss_mo

de:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  kwa

rgs_w

ith_u

ncond

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_kw

args(



     

     

     

 came

ra_pa

ram=c

amera

_para

m,



     

     

     

 imag

e=_im

ages[

0],  

# 0 i

s for

 unco

nditi

onal



     

     

     

 max_

len=b

box_m

ax_le

ngth,



     

     

     

 **be

v_con

troln

et_kw

args,



     

     

  )



     

     

  kwa

rgs_w

ith_u

ncond

.pop(

"max_

len",

 None

)  # 

some 

do no

t tak

e thi

s.



     

     

  cam

era_p

aram 

= kwa

rgs_w

ith_u

ncond

.pop(

"came

ra_pa

ram")



     

     

  _im

ages[

0] = 

kwarg

s_wit

h_unc

ond.p

op("i

mage"

)



     

     

  ima

ge = 

torch

.cat(

_imag

es)



     

     

  bev

_cont

rolne

t_kwa

rgs =

 move

_to(k

wargs

_with

_unco

nd, s

elf.d

evice

)



     

   ##

#### 

BEV e

nd ##

####





     

   # 

8. De

noisi

ng lo

op



     

   nu

m_war

mup_s

teps 

= len

(time

steps

) - n

um_in

feren

ce_st

eps *

 self

.sche

duler

.orde

r



     

   wi

th se

lf.pr

ogres

s_bar

(tota

l=num

_infe

rence

_step

s) as

 prog

ress_

bar:



     

     

  for

 i, t

 in e

numer

ate(t

imest

eps):



     

     

     

 # ex

pand 

the l

atent

s if 

we ar

e doi

ng cl

assif

ier f

ree g

uidan

ce



     

     

     

 # bs

*2, 6

, 4, 

28, 5

0



     

     

     

 late

nt_mo

del_i

nput 

= (



     

     

     

     

torch

.cat(

[late

nts] 

* 2) 

if do

_clas

sifie

r_fre

e_gui

dance

 else

 late

nts



     

     

     

 )



     

     

     

 late

nt_mo

del_i

nput 

= sel

f.sch

edule

r.sca

le_mo

del_i

nput(



     

     

     

     

laten

t_mod

el_in

put, 

t



     

     

     

 )





     

     

     

 # co

ntrol

net(s

) inf

erenc

e



     

     

     

 cont

rolne

t_t =

 t.un

squee

ze(0)



     

     

     

 # gu

ess_m

ode &

 clas

sifie

r_fre

e_gui

dance

 -> o

nly g

uidan

ce us

e con

troln

et



     

     

     

 # no

t gue

ss_mo

de & 

class

ifier

_free

_guid

ance 

-> al

l use

 cont

rolne

t



     

     

     

 # gu

ess_m

ode -

> nor

mal i

nput,

 take

 effe

ct in

 cont

rolne

t



     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

er Co

ntrol

Net o

nly f

or th

e con

ditio

nal b

atch.



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ents



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds

.chun

k(2)[

1]



     

     

     

 else

:



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ent_m

odel_

input



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds



     

     

     

 cont

rolne

t_t =

 cont

rolne

t_t.r

epeat

(len(

contr

olnet

_late

nt_mo

del_i

nput)

)





     

     

     

 # fm

t: of

f



     

     

     

 down

_bloc

k_res

_samp

les, 

mid_b

lock_

res_s

ample

, \



     

     

     

 enco

der_h

idden

_stat

es_wi

th_ca

m = s

elf.c

ontro

lnet(



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput,



     

     

     

     

contr

olnet

_t,



     

     

     

     

camer

a_par

am,  

# for

 BEV



     

     

     

     

encod

er_hi

dden_

state

s=con

troln

et_pr

ompt_

embed

s,



     

     

     

     

contr

olnet

_cond

=imag

e,



     

     

     

     

condi

tioni

ng_sc

ale=c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

     

     

     

guess

_mode

=gues

s_mod

e,



     

     

     

     

retur

n_dic

t=Fal

se,



     

     

     

     

**bev

_cont

rolne

t_kwa

rgs, 

# for

 BEV



     

     

     

 )



     

     

     

 # fm

t: on





     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

ered 

Contr

olNet

 only

 for 

the c

ondit

ional

 batc

h.



     

     

     

     

# To 

apply

 the 

outpu

t of 

Contr

olNet

 to b

oth t

he un

condi

tiona

l and

 cond

ition

al ba

tches

,



     

     

     

     

# add

 0 to

 the 

uncon

ditio

nal b

atch 

to ke

ep it

 unch

anged

.



     

     

     

     

down_

block

_res_

sampl

es = 

[



     

     

     

     

    t

orch.

cat([

torch

.zero

s_lik

e(d),

 d])



     

     

     

     

    f

or d 

in do

wn_bl

ock_r

es_sa

mples



     

     

     

     

]



     

     

     

     

mid_b

lock_

res_s

ample

 = to

rch.c

at(



     

     

     

     

    [

torch

.zero

s_lik

e(mid

_bloc

k_res

_samp

le), 

mid_b

lock_

res_s

ample

]



     

     

     

     

)



     

     

     

     

# add

 unco

nd en

coder

_hidd

en_st

ates_

with_

cam h

ere



     

     

     

     

encod

er_hi

dden_

state

s_wit

h_cam

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_em

b(



     

     

     

     

    p

rompt

_embe

ds.ch

unk(2

)[0],

 N_ca

m,



     

     

     

     

    e

ncode

r_hid

den_s

tates

_with

_cam,



     

     

     

     

)





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # St

ratin

g fro

m her

e, we

 use 

4-dim

 data

.



     

     

     

 # en

coder

_hidd

en_st

ates_

with_

cam: 

(2b x

 N), 

78, 7

68



     

     

     

 # la

tent_

model

_inpu

t: 2b

, N, 

4, 28

, 50 

-> 2b

 x N,

 4, 2

8, 50



     

     

     

 late

nt_mo

del_i

nput 

= rea

rrang

e(



     

     

     

     

laten

t_mod

el_in

put, 

'b n 

... -

> (b 

n) ..

.')



     

     

     

 late

nts =

 rear

range

(late

nts, 

'b n 

... -

> (b 

n) ..

.')





     

     

     

 # pr

edict

 the 

noise

 resi

dual:

 2bxN

, 4, 

28, 5

0



     

     

     

 addi

tiona

l_par

am = 

{}



     

     

     

 nois

e_pre

d = s

elf.u

net(



     

     

     

     

laten

t_mod

el_in

put, 

 # ma

y wit

h unc

ondit

ional



     

     

     

     

t,



     

     

     

     

encod

er_hi

dden_

state

s=enc

oder_

hidde

n_sta

tes_w

ith_c

am,



     

     

     

     

**add

ition

al_pa

ram, 

 # if

 use 

origi

nal u

net, 

it ca

nnot 

take 

kwarg

s



     

     

     

     

cross

_atte

ntion

_kwar

gs=cr

oss_a

ttent

ion_k

wargs

,



     

     

     

     

down_

block

_addi

tiona

l_res

idual

s=dow

n_blo

ck_re

s_sam

ples,



     

     

     

     

mid_b

lock_

addit

ional

_resi

dual=

mid_b

lock_

res_s

ample

,



     

     

     

 ).sa

mple





     

     

     

 # pe

rform

 guid

ance



     

     

     

 if d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# for

 each

: bxN

, 4, 

28, 5

0



     

     

     

     

noise

_pred

_unco

nd, n

oise_

pred_

text 

= noi

se_pr

ed.ch

unk(2

)



     

     

     

     

noise

_pred

 = no

ise_p

red_u

ncond

 + gu

idanc

e_sca

le * 

(



     

     

     

     

    n

oise_

pred_

text 

- noi

se_pr

ed_un

cond



     

     

     

     

)





     

     

     

 # co

mpute

 the 

previ

ous n

oisy 

sampl

e x_t

 -> x

_t-1



     

     

     

 # NO

TE: i

s the

 sche

duler

 use 

rando

mness

, ple

ase h

andle

 the 

logic



     

     

     

 # fo

r gen

erato

r.



     

     

     

 late

nts =

 self

.sche

duler

.step

(



     

     

     

     

noise

_pred

, t, 

laten

ts, *

*extr

a_ste

p_kwa

rgs



     

     

     

 ).pr

ev_sa

mple





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # no

w we 

add d

imens

ion b

ack, 

use 5

-dim 

data.



     

     

     

 # NO

TE: o

nly `

laten

ts` i

s upd

ated 

throu

gh th

e loo

p



     

     

     

 late

nts =

 rear

range

(late

nts, 

'(b n

) ...

 -> b

 n ..

.', n

=N_ca

m)





     

     

     

 # ca

ll th

e cal

lback

, if 

provi

ded



     

     

     

 if i

 == l

en(ti

meste

ps) -

 1 or

 (



     

     

     

     

(i + 

1) > 

num_w

armup

_step

s and

 (i +

 1) %

 self

.sche

duler

.orde

r == 

0



     

     

     

 ):



     

     

     

     

progr

ess_b

ar.up

date(

)



     

     

     

     

if ca

llbac

k is 

not N

one a

nd i 

% cal

lback

_step

s == 

0:



     

     

     

     

    c

allba

ck(i,

 t, l

atent

s)





     

   ##

#### 

BEV: 

here 

rebui

ld th

e sha

pes b

ack. 

post-

proce

ss st

ill a

ssume



     

   # 

laten

ts, n

o nee

d for

 b, n

, 4, 

28, 5

0



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ##

### B

EV en

d





     

   # 

If we

 do s

equen

tial 

model

 offl

oadin

g, le

t's o

ffloa

d une

t and

 cont

rolne

t



     

   # 

manua

lly f

or ma

x mem

ory s

aving

s



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.une

t.to(

"cpu"

)



     

     

  sel

f.con

troln

et.to

("cpu

")



     

     

  tor

ch.cu

da.em

pty_c

ache(

)





     

   if

 outp

ut_ty

pe ==

 "lat

ent":



     

     

  ima

ge = 

laten

ts



     

     

  has

_nsfw

_conc

ept =

 None



     

   el

if ou

tput_

type 

== "p

il":



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

     

  # 1

0. Co

nvert

 to P

IL



     

     

  ima

ge = 

self.

numpy

_to_p

il_do

uble(

image

)



     

   el

se:



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

   # 

Offlo

ad la

st mo

del t

o CPU



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.fin

al_of

fload

_hook

.offl

oad()





     

   if

 not 

retur

n_dic

t:



     

     

  ret

urn (

image

, has

_nsfw

_conc

ept)





     

   re

turn 

BEVSt

ableD

iffus

ionPi

pelin

eOutp

ut(



     

     

  ima

ges=i

mage,

 nsfw

_cont

ent_d

etect

ed=ha

s_nsf

w_con

cept



     

   )



from 

datac

lasse

s imp

ort d

atacl

ass



from 

typin

g imp

ort A

ny, C

allab

le, D

ict, 

List,

 Opti

onal,

 Tupl

e, Un

ion



impor

t ins

pect





impor

t tor

ch



impor

t PIL



impor

t num

py as

 np



from 

einop

s imp

ort r

earra

nge





from 

diffu

sers 

impor

t Sta

bleDi

ffusi

onCon

trolN

etPip

eline



from 

diffu

sers.

utils

 impo

rt Ba

seOut

put



from 

diffu

sers.

image

_proc

essor

 impo

rt Va

eImag

eProc

essor



from 

diffu

sers.

model

s imp

ort A

utoen

coder

KL, U

Net2D

Condi

tionM

odel



from 

diffu

sers.

pipel

ines.

stabl

e_dif

fusio

n imp

ort S

table

Diffu

sionS

afety

Check

er



from 

diffu

sers.

sched

ulers

.sche

dulin

g_uti

ls im

port 

Karra

sDiff

usion

Sched

ulers



from 

trans

forme

rs im

port 

CLIPI

mageP

roces

sor, 

CLIPT

extMo

del, 

CLIPT

okeni

zer





from 

..mis

c.com

mon i

mport

 move

_to







@data

class



class

 BEVS

table

Diffu

sionP

ipeli

neOut

put(B

aseOu

tput)

:



    "

""



    O

utput

 clas

s for

 Stab

le Di

ffusi

on pi

pelin

es.





    A

rgs:



     

   im

ages 

(`Lis

t[PIL

.Imag

e.Ima

ge]` 

or `n

p.nda

rray`

)



     

     

  Lis

t of 

denoi

sed P

IL im

ages 

of le

ngth 

`batc

h_siz

e` or

 nump

y arr

ay of

 shap

e `(b

atch_

size,

 heig

ht, w

idth,



     

     

  num

_chan

nels)

`. PI

L ima

ges o

r num

py ar

ray p

resen

t the

 deno

ised 

image

s of 

the d

iffus

ion p

ipeli

ne.



     

   ns

fw_co

ntent

_dete

cted 

(`Lis

t[boo

l]`)



     

     

  Lis

t of 

flags

 deno

ting 

wheth

er th

e cor

respo

nding

 gene

rated

 imag

e lik

ely r

epres

ents 

"not-

safe-

for-w

ork"



     

     

  (ns

fw) c

onten

t, or

 `Non

e` if

 safe

ty ch

eckin

g cou

ld no

t be 

perfo

rmed.



    "

""





    i

mages

: Uni

on[Li

st[Li

st[PI

L.Ima

ge.Im

age]]

, np.

ndarr

ay]



    n

sfw_c

onten

t_det

ected

: Opt

ional

[List

[bool

]]







class

 Stab

leDif

fusio

nBEVC

ontro

lNetP

ipeli

ne(St

ableD

iffus

ionCo

ntrol

NetPi

pelin

e):



    d

ef __

init_

_(



     

   se

lf,



     

   va

e: Au

toenc

oderK

L,



     

   te

xt_en

coder

: CLI

PText

Model

,



     

   un

et: U

Net2D

Condi

tionM

odel,



     

   co

ntrol

net,



     

   sc

hedul

er: K

arras

Diffu

sionS

chedu

lers,



     

   to

keniz

er: C

LIPTo

keniz

er,



     

   sa

fety_

check

er: S

table

Diffu

sionS

afety

Check

er = 

None,



     

   fe

ature

_extr

actor

: CLI

PImag

eProc

essor

 = No

ne,



     

   re

quire

s_saf

ety_c

hecke

r: bo

ol = 

False

,



    )

:



     

   su

per()

.__in

it__(



     

     

  vae

,



     

     

  tex

t_enc

oder,



     

     

  tok

enize

r,



     

     

  une

t,



     

     

  con

troln

et,



     

     

  sch

edule

r,



     

     

  saf

ety_c

hecke

r,



     

     

  fea

ture_

extra

ctor,



     

     

  req

uires

_safe

ty_ch

ecker

,



     

   )



     

   as

sert 

safet

y_che

cker 

== No

ne, "

Pleas

e do 

not u

se sa

fety_

check

er."



     

   se

lf.co

ntrol

_imag

e_pro

cesso

r = V

aeIma

gePro

cesso

r(



     

     

  vae

_scal

e_fac

tor=s

elf.v

ae_sc

ale_f

actor

,



     

     

  do_

resiz

e=Fal

se,



     

     

  do_

conve

rt_rg

b=Fal

se,



     

     

  do_

norma

lize=

False

,



     

   )





    d

ef nu

mpy_t

o_pil

_doub

le(se

lf, i

mages

):



     

   ""

"



     

   Co

nvert

 a nu

mpy i

mage 

or a 

batch

 of i

mages

 to a

 PIL 

image

.



     

   We

 need

 to h

andle

 5-di

m inp

uts a

nd re

ture 

2-dim

 list

.



     

   ""

"



     

   im

gs_li

st = 

[]



     

   fo

r img

s in 

image

s:



     

     

  img

s_lis

t.app

end(s

elf.n

umpy_

to_pi

l(img

s))



     

   re

turn 

imgs_

list





    #

 Copi

ed fr

om di

ffuse

rs.pi

pelin

es.st

able_

diffu

sion.

pipel

ine_s

table

_diff

usion

.Stab

leDif

fusio

nPipe

line.

prepa

re_ex

tra_s

tep_k

wargs



    d

ef pr

epare

_extr

a_ste

p_kwa

rgs(s

elf, 

gener

ator,

 eta)

:



     

   # 

prepa

re ex

tra k

wargs

 for 

the s

chedu

ler s

tep, 

since

 not 

all s

chedu

lers 

have 

the s

ame s

ignat

ure



     

   # 

eta (

η) is

 only

 used

 with

 the 

DDIMS

chedu

ler, 

it wi

ll be

 igno

red f

or ot

her s

chedu

lers.



     

   # 

eta c

orres

ponds

 to η

 in D

DIM p

aper:

 http

s://a

rxiv.

org/a

bs/20

10.02

502



     

   # 

and s

hould

 be b

etwee

n [0,

 1]





     

   ac

cepts

_eta 

= "et

a" in

 set(

inspe

ct.si

gnatu

re(se

lf.sc

hedul

er.st

ep).p

arame

ters.

keys(

))



     

   ex

tra_s

tep_k

wargs

 = {}



     

   if

 acce

pts_e

ta:



     

     

  ext

ra_st

ep_kw

args[

"eta"

] = e

ta





     

   # 

check

 if t

he sc

hedul

er ac

cepts

 gene

rator



     

   ac

cepts

_gene

rator

 = "g

enera

tor" 

in se

t(ins

pect.

signa

ture(

self.

sched

uler.

step)

.para

meter

s.key

s())



     

   if

 acce

pts_g

enera

tor:



     

     

  rai

se Ru

ntime

Error

("If 

you f

ixed 

the l

ogic 

for g

enera

tor, 

pleas

e rem

ove t

his. 

Other

wise,

 plea

se us

e oth

er sa

mpler

.")



     

     

  ext

ra_st

ep_kw

args[

"gene

rator

"] = 

gener

ator



     

   re

turn 

extra

_step

_kwar

gs





    d

ef de

code_

laten

ts(se

lf, l

atent

s):



     

   # 

decod

e lat

ents 

with 

5-dim

s



     

   la

tents

 = 1 

/ sel

f.vae

.conf

ig.sc

aling

_fact

or * 

laten

ts





     

   bs

 = le

n(lat

ents)



     

   la

tents

 = re

arran

ge(la

tents

, 'b 

c ...

 -> (

b c) 

...')



     

   im

age =

 self

.vae.

decod

e(lat

ents)

.samp

le



     

   im

age =

 rear

range

(imag

e, '(

b c) 

... -

> b c

 ...'

, b=b

s)





     

   im

age =

 (ima

ge / 

2 + 0

.5).c

lamp(

0, 1)



     

   # 

we al

ways 

cast 

to fl

oat32

 as t

his d

oes n

ot ca

use s

ignif

icant

 over

head 

and i

s com

patib

le wi

th bf

loat1

6



     

   im

age =

 rear

range

(imag

e.cpu

(), '

... c

 h w 

-> ..

. h w

 c').

float

().nu

mpy()



     

   re

turn 

image





    @

torch

.no_g

rad()



    d

ef __

call_

_(



     

   se

lf,



     

   pr

ompt:

 Unio

n[str

, Lis

t[str

]],



     

   im

age: 

torch

.Floa

tTens

or,



     

   ca

mera_

param

: Uni

on[to

rch.T

ensor

, Non

e],



     

   he

ight:

 int,



     

   wi

dth: 

int,



     

   nu

m_inf

erenc

e_ste

ps: i

nt = 

50,



     

   gu

idanc

e_sca

le: f

loat 

= 7.5

,



     

   ne

gativ

e_pro

mpt: 

Optio

nal[U

nion[

str, 

List[

str]]

] = N

one,



     

   nu

m_ima

ges_p

er_pr

ompt:

 Opti

onal[

int] 

= 1,



     

   et

a: fl

oat =

 0.0,



     

   ge

nerat

or: O

ption

al[to

rch.G

enera

tor] 

= Non

e,



     

   la

tents

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   pr

ompt_

embed

s: Op

tiona

l[tor

ch.Fl

oatTe

nsor]

 = No

ne,



     

   ne

gativ

e_pro

mpt_e

mbeds

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   ou

tput_

type:

 Opti

onal[

str] 

= "pi

l",



     

   re

turn_

dict:

 bool

 = Tr

ue,



     

   ca

llbac

k: Op

tiona

l[Cal

lable

[[int

, int

, tor

ch.Fl

oatTe

nsor]

, Non

e]] =

 None

,



     

   ca

llbac

k_ste

ps: i

nt = 

1,



     

   cr

oss_a

ttent

ion_k

wargs

: Opt

ional

[Dict

[str,

 Any]

] = N

one,



     

   co

ntrol

net_c

ondit

ionin

g_sca

le: f

loat 

= 1,



     

   gu

ess_m

ode: 

bool 

= Fal

se,



     

   us

e_zer

o_map

_as_u

ncond

ition

al: b

ool =

 Fals

e,



     

   be

v_con

troln

et_kw

args 

= {},



     

   bb

ox_ma

x_len

gth =

 None

,



    )

:



     

   r"

""



     

   Fu

nctio

n inv

oked 

when 

calli

ng th

e pip

eline

 for 

gener

ation

.





     

   Ar

gs:



     

     

  pro

mpt (

`str`

 or `

List[

str]`

, *op

tiona

l*):



     

     

     

 The 

promp

t or 

promp

ts to

 guid

e the

 imag

e gen

erati

on. I

f not

 defi

ned, 

one h

as to

 pass

 `pro

mpt_e

mbeds

`.



     

     

     

 inst

ead.



     

     

  ima

ge (`

torch

.Floa

tTens

or`, 

`PIL.

Image

.Imag

e`, `

List[

torch

.Floa

tTens

or]`,

 `Lis

t[PIL

.Imag

e.Ima

ge]`,



     

     

     

     

`List

[List

[torc

h.Flo

atTen

sor]]

`, or

 `Lis

t[Lis

t[PIL

.Imag

e.Ima

ge]]`

):



     

     

     

 The 

Contr

olNet

 inpu

t con

ditio

n. Co

ntrol

Net u

ses t

his i

nput 

condi

tion 

to ge

nerat

e gui

dance

 to U

net. 

If



     

     

     

 the 

type 

is sp

ecifi

ed as

 `Tor

ch.Fl

oatTe

nsor`

, it 

is pa

ssed 

to Co

ntrol

Net a

s is.

 `PIL

.Imag

e.Ima

ge` c

an



     

     

     

 also

 be a

ccept

ed as

 an i

mage.

 The 

dimen

sions

 of t

he ou

tput 

image

 defa

ults 

to `i

mage`

's di

mensi

ons. 

If



     

     

     

 heig

ht an

d/or 

width

 are 

passe

d, `i

mage`

 is r

esize

d acc

ordin

g to 

them.

 If m

ultip

le Co

ntrol

Nets 

are



     

     

     

 spec

ified

 in i

nit, 

image

s mus

t be 

passe

d as 

a lis

t suc

h tha

t eac

h ele

ment 

of th

e lis

t can

 be c

orrec

tly



     

     

     

 batc

hed f

or in

put t

o a s

ingle

 cont

rolne

t.



     

     

  hei

ght (

`int`

, *op

tiona

l*, d

efaul

ts to

 self

.unet

.conf

ig.sa

mple_

size 

* sel

f.vae

_scal

e_fac

tor):



     

     

     

 The 

heigh

t in 

pixel

s of 

the g

enera

ted i

mage.



     

     

  wid

th (`

int`,

 *opt

ional

*, de

fault

s to 

self.

unet.

confi

g.sam

ple_s

ize *

 self

.vae_

scale

_fact

or):



     

     

     

 The 

width

 in p

ixels

 of t

he ge

nerat

ed im

age.



     

     

  num

_infe

rence

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 5

0):



     

     

     

 The 

numbe

r of 

denoi

sing 

steps

. Mor

e den

oisin

g ste

ps us

ually

 lead

 to a

 high

er qu

ality

 imag

e at 

the



     

     

     

 expe

nse o

f slo

wer i

nfere

nce.



     

     

  gui

dance

_scal

e (`f

loat`

, *op

tiona

l*, d

efaul

ts to

 7.5)

:



     

     

     

 Guid

ance 

scale

 as d

efine

d in 

[Clas

sifie

r-Fre

e Dif

fusio

n Gui

dance

](htt

ps://

arxiv

.org/

abs/2

207.1

2598)

.



     

     

     

 `gui

dance

_scal

e` is

 defi

ned a

s `w`

 of e

quati

on 2.

 of [

Image

n



     

     

     

 Pape

r](ht

tps:/

/arxi

v.org

/pdf/

2205.

11487

.pdf)

. Gui

dance

 scal

e is 

enabl

ed by

 sett

ing `

guida

nce_s

cale 

>



     

     

     

 1`. 

Highe

r gui

dance

 scal

e enc

ourag

es to

 gene

rate 

image

s tha

t are

 clos

ely l

inked

 to t

he te

xt `p

rompt

`,



     

     

     

 usua

lly a

t the

 expe

nse o

f low

er im

age q

ualit

y.



     

     

  neg

ative

_prom

pt (`

str` 

or `L

ist[s

tr]`,

 *opt

ional

*):



     

     

     

 The 

promp

t or 

promp

ts no

t to 

guide

 the 

image

 gene

ratio

n. If

 not 

defin

ed, o

ne ha

s to 

pass



     

     

     

 `neg

ative

_prom

pt_em

beds`

 inst

ead. 

Ignor

ed wh

en no

t usi

ng gu

idanc

e (i.

e., i

gnore

d if 

`guid

ance_

scale

` is



     

     

     

 less

 than

 `1`)

.



     

     

  num

_imag

es_pe

r_pro

mpt (

`int`

, *op

tiona

l*, d

efaul

ts to

 1):



     

     

     

 The 

numbe

r of 

image

s to 

gener

ate p

er pr

ompt.



     

     

  eta

 (`fl

oat`,

 *opt

ional

*, de

fault

s to 

0.0):



     

     

     

 Corr

espon

ds to

 para

meter

 eta 

(η) i

n the

 DDIM

 pape

r: ht

tps:/

/arxi

v.org

/abs/

2010.

02502

. Onl

y app

lies 

to



     

     

     

 [`sc

hedul

ers.D

DIMSc

hedul

er`],

 will

 be i

gnore

d for

 othe

rs.



     

     

  gen

erato

r (`t

orch.

Gener

ator`

 or `

List[

torch

.Gene

rator

]`, *

optio

nal*)

:



     

     

     

 One 

or a 

list 

of [t

orch 

gener

ator(

s)](h

ttps:

//pyt

orch.

org/d

ocs/s

table

/gene

rated

/torc

h.Gen

erato

r.htm

l)



     

     

     

 to m

ake g

enera

tion 

deter

minis

tic.



     

     

  lat

ents 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

noisy

 late

nts, 

sampl

ed fr

om a 

Gauss

ian d

istri

butio

n, to

 be u

sed a

s inp

uts f

or im

age



     

     

     

 gene

ratio

n. Ca

n be 

used 

to tw

eak t

he sa

me ge

nerat

ion w

ith d

iffer

ent p

rompt

s. If

 not 

provi

ded, 

a lat

ents



     

     

     

 tens

or wi

ll ge

 gene

rated

 by s

ampli

ng us

ing t

he su

pplie

d ran

dom `

gener

ator`

.



     

     

  pro

mpt_e

mbeds

 (`to

rch.F

loatT

ensor

`, *o

ption

al*):



     

     

     

 Pre-

gener

ated 

text 

embed

dings

. Can

 be u

sed t

o eas

ily t

weak 

text 

input

s, *e

.g.* 

promp

t wei

ghtin

g. If

 not



     

     

     

 prov

ided,

 text

 embe

dding

s wil

l be 

gener

ated 

from 

`prom

pt` i

nput 

argum

ent.



     

     

  neg

ative

_prom

pt_em

beds 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

negat

ive t

ext e

mbedd

ings.

 Can 

be us

ed to

 easi

ly tw

eak t

ext i

nputs

, *e.

g.* p

rompt



     

     

     

 weig

hting

. If 

not p

rovid

ed, n

egati

ve_pr

ompt_

embed

s wil

l be 

gener

ated 

from 

`nega

tive_

promp

t` in

put



     

     

     

 argu

ment.



     

     

  out

put_t

ype (

`str`

, *op

tiona

l*, d

efaul

ts to

 `"pi

l"`):



     

     

     

 The 

outpu

t for

mat o

f the

 gene

rate 

image

. Cho

ose b

etwee

n



     

     

     

 [PIL

](htt

ps://

pillo

w.rea

dthed

ocs.i

o/en/

stabl

e/): 

`PIL.

Image

.Imag

e` or

 `np.

array

`.



     

     

  ret

urn_d

ict (

`bool

`, *o

ption

al*, 

defau

lts t

o `Tr

ue`):



     

     

     

 Whet

her o

r not

 to r

eturn

 a [`

~pipe

lines

.stab

le_di

ffusi

on.St

ableD

iffus

ionPi

pelin

eOutp

ut`] 

inste

ad of

 a



     

     

     

 plai

n tup

le.



     

     

  cal

lback

 (`Ca

llabl

e`, *

optio

nal*)

:



     

     

     

 A fu

nctio

n tha

t wil

l be 

calle

d eve

ry `c

allba

ck_st

eps` 

steps

 duri

ng in

feren

ce. T

he fu

nctio

n wil

l be



     

     

     

 call

ed wi

th th

e fol

lowin

g arg

ument

s: `c

allba

ck(st

ep: i

nt, t

imest

ep: i

nt, l

atent

s: to

rch.F

loatT

ensor

)`.



     

     

  cal

lback

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 1

):



     

     

     

 The 

frequ

ency 

at wh

ich t

he `c

allba

ck` f

uncti

on wi

ll be

 call

ed. I

f not

 spec

ified

, the

 call

back 

will 

be



     

     

     

 call

ed at

 ever

y ste

p.



     

     

  cro

ss_at

tenti

on_kw

args 

(`dic

t`, *

optio

nal*)

:



     

     

     

 A kw

args 

dicti

onary

 that

 if s

pecif

ied i

s pas

sed a

long 

to th

e `At

tenti

onPro

cesso

r` as

 defi

ned u

nder



     

     

     

 `sel

f.pro

cesso

r` in



     

     

     

 [dif

fuser

s.cro

ss_at

tenti

on](h

ttps:

//git

hub.c

om/hu

gging

face/

diffu

sers/

blob/

main/

src/d

iffus

ers/m

odels

/cros

s_att

entio

n.py)

.



     

     

  con

troln

et_co

nditi

oning

_scal

e (`f

loat`

 or `

List[

float

]`, *

optio

nal*,

 defa

ults 

to 1.

0):



     

     

     

 The 

outpu

ts of

 the 

contr

olnet

 are 

multi

plied

 by `

contr

olnet

_cond

ition

ing_s

cale`

 befo

re th

ey ar

e add

ed



     

     

     

 to t

he re

sidua

l in 

the o

rigin

al un

et. I

f mul

tiple

 Cont

rolNe

ts ar

e spe

cifie

d in 

init,

 you 

can s

et th

e



     

     

     

 corr

espon

ding 

scale

 as a

 list

.



     

     

  gue

ss_mo

de (`

bool`

, *op

tiona

l*, d

efaul

ts to

 `Fal

se`):



     

     

     

 In t

his m

ode, 

the C

ontro

lNet 

encod

er wi

ll tr

y bes

t to 

recog

nize 

the c

onten

t of 

the i

nput 

image

 even

 if



     

     

     

 you 

remov

e all

 prom

pts. 

The `

guida

nce_s

cale`

 betw

een 3

.0 an

d 5.0

 is r

ecomm

ended

.





     

   Ex

ample

s:





     

   Re

turns

:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] o

r `tu

ple`:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] i

f `re

turn_

dict`

 is T

rue, 

other

wise 

a `tu

ple.



     

     

  Whe

n ret

urnin

g a t

uple,

 the 

first

 elem

ent i

s a l

ist w

ith t

he ge

nerat

ed im

ages,

 and 

the s

econd

 elem

ent i

s a



     

     

  lis

t of 

`bool

`s de

notin

g whe

ther 

the c

orres

pondi

ng ge

nerat

ed im

age l

ikely

 repr

esent

s "no

t-saf

e-for

-work

"



     

     

  (ns

fw) c

onten

t, ac

cordi

ng to

 the 

`safe

ty_ch

ecker

`.



     

   ""

"



     

   # 

0. De

fault

 heig

ht an

d wid

th to

 unet



     

   # 

BEV: 

we ca

nnot 

use t

he si

ze of

 imag

e



     

   # 

heigh

t, wi

dth =

 self

._def

ault_

heigh

t_wid

th(he

ight,

 widt

h, No

ne)





     

   # 

1. Ch

eck i

nputs

. Rai

se er

ror i

f not

 corr

ect



     

   # 

we do

 not 

need 

this,

 only

 some

 type

 asse

rtion



     

   # 

self.

check

_inpu

ts(



     

   # 

    p

rompt

,



     

   # 

    i

mage,



     

   # 

    h

eight

,



     

   # 

    w

idth,



     

   # 

    c

allba

ck_st

eps,



     

   # 

    n

egati

ve_pr

ompt,



     

   # 

    p

rompt

_embe

ds,



     

   # 

    n

egati

ve_pr

ompt_

embed

s,



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

   # 

)





     

   # 

2. De

fine 

call 

param

eters



     

   # 

NOTE:

 we g

et ba

tch_s

ize f

irst 

from 

promp

t, th

en al

ign w

ith i

t.



     

   if

 prom

pt is

 not 

None 

and i

sinst

ance(

promp

t, st

r):



     

     

  bat

ch_si

ze = 

1



     

   el

if pr

ompt 

is no

t Non

e and

 isin

stanc

e(pro

mpt, 

list)

:



     

     

  bat

ch_si

ze = 

len(p

rompt

)



     

   el

se:



     

     

  bat

ch_si

ze = 

promp

t_emb

eds.s

hape[

0]





     

   de

vice 

= sel

f._ex

ecuti

on_de

vice



     

   # 

here 

`guid

ance_

scale

` is 

defin

ed an

alog 

to th

e gui

dance

 weig

ht `w

` of 

equat

ion (

2)



     

   # 

of th

e Ima

gen p

aper:

 http

s://a

rxiv.

org/p

df/22

05.11

487.p

df . 

`guid

ance_

scale

 = 1`



     

   # 

corre

spond

s to 

doing

 no c

lassi

fier 

free 

guida

nce.



     

   do

_clas

sifie

r_fre

e_gui

dance

 = gu

idanc

e_sca

le > 

1.0





     

   ##

# BEV

, che

ck ca

mera_

param

 ###



     

   if

 came

ra_pa

ram i

s Non

e:



     

     

  # u

se un

cond_

cam a

nd di

sable

 clas

sifie

r fre

e gui

dance



     

     

  N_c

am = 

6  # 

TODO:

 hard

-code

d



     

     

  cam

era_p

aram 

= sel

f.con

troln

et.un

cond_

cam_p

aram(

(batc

h_siz

e, N_

cam))



     

     

  do_

class

ifier

_free

_guid

ance 

= Fal

se



     

   ##

# don

e ###





     

   # 

if is

insta

nce(s

elf.c

ontro

lnet,

 Mult

iCont

rolNe

tMode

l) an

d isi

nstan

ce(co

ntrol

net_c

ondit

ionin

g_sca

le, f

loat)

:



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale =

 [con

troln

et_co

nditi

oning

_scal

e] * 

len(s

elf.c

ontro

lnet.

nets)





     

   # 

3. En

code 

input

 prom

pt



     

   # 

NOTE:

 here

 they

 use 

paddi

ng to

 77, 

is th

is ne

cessa

ry?



     

   pr

ompt_

embed

s = s

elf._

encod

e_pro

mpt(



     

     

  pro

mpt,



     

     

  dev

ice,



     

     

  num

_imag

es_pe

r_pro

mpt,



     

     

  do_

class

ifier

_free

_guid

ance,



     

     

  neg

ative

_prom

pt,



     

     

  pro

mpt_e

mbeds

=prom

pt_em

beds,



     

     

  neg

ative

_prom

pt_em

beds=

negat

ive_p

rompt

_embe

ds,



     

   ) 

 # (2

 * b,

 77 +

 1, 7

68)





     

   # 

4. Pr

epare

 imag

e



     

   # 

NOTE:

 if i

mage 

is no

t ten

sor, 

there

 will

 be s

evera

l pro

cess.



     

   as

sert 

not s

elf.c

ontro

l_ima

ge_pr

ocess

or.co

nfig.

do_no

rmali

ze, "

Your 

contr

olnet

 shou

ld no

t nor

maliz

e the

 cont

rol i

mage.

"



     

   im

age =

 self

.prep

are_i

mage(



     

     

  ima

ge=im

age,



     

     

  wid

th=wi

dth,



     

     

  hei

ght=h

eight

,



     

     

  bat

ch_si

ze=ba

tch_s

ize *

 num_

image

s_per

_prom

pt,



     

     

  num

_imag

es_pe

r_pro

mpt=n

um_im

ages_

per_p

rompt

,



     

     

  dev

ice=d

evice

,



     

     

  dty

pe=se

lf.co

ntrol

net.d

type,



     

     

  do_

class

ifier

_free

_guid

ance=

do_cl

assif

ier_f

ree_g

uidan

ce,



     

     

  gue

ss_mo

de=gu

ess_m

ode,



     

   ) 

 # (2

 * b,

 c_26

, 200

, 200

)



     

   if

 use_

zero_

map_a

s_unc

ondit

ional

 and 

do_cl

assif

ier_f

ree_g

uidan

ce:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  _im

ages[

0] = 

torch

.zero

s_lik

e(_im

ages[

0])



     

     

  ima

ge = 

torch

.cat(

_imag

es)





     

   # 

5. Pr

epare

 time

steps



     

   se

lf.sc

hedul

er.se

t_tim

estep

s(num

_infe

rence

_step

s, de

vice=

devic

e)



     

   ti

meste

ps = 

self.

sched

uler.

times

teps





     

   # 

6. Pr

epare

 late

nt va

riabl

es



     

   nu

m_cha

nnels

_late

nts =

 self

.unet

.conf

ig.in

_chan

nels



     

   la

tents

 = se

lf.pr

epare

_late

nts(



     

     

  bat

ch_si

ze * 

num_i

mages

_per_

promp

t,



     

     

  num

_chan

nels_

laten

ts,



     

     

  hei

ght,



     

     

  wid

th,



     

     

  pro

mpt_e

mbeds

.dtyp

e,



     

     

  dev

ice,



     

     

  gen

erato

r,



     

     

  lat

ents,

  # w

ill u

se if

 not 

None,

 othe

rwise

 will

 gene

rate



     

   ) 

 # (b

, c, 

h/8, 

w/8) 

-> (b

s, 4,

 28, 

50)





     

   # 

7. Pr

epare

 extr

a ste

p kwa

rgs.



     

   ex

tra_s

tep_k

wargs

 = se

lf.pr

epare

_extr

a_ste

p_kwa

rgs(g

enera

tor, 

eta)





     

   ##

#### 

BEV: 

here 

we re

const

ruct 

each 

input

 form

at ##

####



     

   as

sert 

camer

a_par

am.sh

ape[0

] == 

batch

_size

, \



     

     

  f"E

xcept

 {bat

ch_si

ze} c

amera

 para

ms, b

ut yo

u hav

e bs=

{len(

camer

a_par

am)}"



     

   N_

cam =

 came

ra_pa

ram.s

hape[

1]



     

   la

tents

 = to

rch.s

tack(

[late

nts] 

* N_c

am, d

im=1)

  # b

s, 6,

 4, 2

8, 50



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ca

mera_

param

 = ca

mera_

param

.to(s

elf.d

evice

)



     

   if

 do_c

lassi

fier_

free_

guida

nce a

nd no

t gue

ss_mo

de:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  kwa

rgs_w

ith_u

ncond

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_kw

args(



     

     

     

 came

ra_pa

ram=c

amera

_para

m,



     

     

     

 imag

e=_im

ages[

0],  

# 0 i

s for

 unco

nditi

onal



     

     

     

 max_

len=b

box_m

ax_le

ngth,



     

     

     

 **be

v_con

troln

et_kw

args,



     

     

  )



     

     

  kwa

rgs_w

ith_u

ncond

.pop(

"max_

len",

 None

)  # 

some 

do no

t tak

e thi

s.



     

     

  cam

era_p

aram 

= kwa

rgs_w

ith_u

ncond

.pop(

"came

ra_pa

ram")



     

     

  _im

ages[

0] = 

kwarg

s_wit

h_unc

ond.p

op("i

mage"

)



     

     

  ima

ge = 

torch

.cat(

_imag

es)



     

     

  bev

_cont

rolne

t_kwa

rgs =

 move

_to(k

wargs

_with

_unco

nd, s

elf.d

evice

)



     

   ##

#### 

BEV e

nd ##

####





     

   # 

8. De

noisi

ng lo

op



     

   nu

m_war

mup_s

teps 

= len

(time

steps

) - n

um_in

feren

ce_st

eps *

 self

.sche

duler

.orde

r



     

   wi

th se

lf.pr

ogres

s_bar

(tota

l=num

_infe

rence

_step

s) as

 prog

ress_

bar:



     

     

  for

 i, t

 in e

numer

ate(t

imest

eps):



     

     

     

 # ex

pand 

the l

atent

s if 

we ar

e doi

ng cl

assif

ier f

ree g

uidan

ce



     

     

     

 # bs

*2, 6

, 4, 

28, 5

0



     

     

     

 late

nt_mo

del_i

nput 

= (



     

     

     

     

torch

.cat(

[late

nts] 

* 2) 

if do

_clas

sifie

r_fre

e_gui

dance

 else

 late

nts



     

     

     

 )



     

     

     

 late

nt_mo

del_i

nput 

= sel

f.sch

edule

r.sca

le_mo

del_i

nput(



     

     

     

     

laten

t_mod

el_in

put, 

t



     

     

     

 )





     

     

     

 # co

ntrol

net(s

) inf

erenc

e



     

     

     

 cont

rolne

t_t =

 t.un

squee

ze(0)



     

     

     

 # gu

ess_m

ode &

 clas

sifie

r_fre

e_gui

dance

 -> o

nly g

uidan

ce us

e con

troln

et



     

     

     

 # no

t gue

ss_mo

de & 

class

ifier

_free

_guid

ance 

-> al

l use

 cont

rolne

t



     

     

     

 # gu

ess_m

ode -

> nor

mal i

nput,

 take

 effe

ct in

 cont

rolne

t



     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

er Co

ntrol

Net o

nly f

or th

e con

ditio

nal b

atch.



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ents



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds

.chun

k(2)[

1]



     

     

     

 else

:



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ent_m

odel_

input



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds



     

     

     

 cont

rolne

t_t =

 cont

rolne

t_t.r

epeat

(len(

contr

olnet

_late

nt_mo

del_i

nput)

)





     

     

     

 # fm

t: of

f



     

     

     

 down

_bloc

k_res

_samp

les, 

mid_b

lock_

res_s

ample

, \



     

     

     

 enco

der_h

idden

_stat

es_wi

th_ca

m = s

elf.c

ontro

lnet(



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput,



     

     

     

     

contr

olnet

_t,



     

     

     

     

camer

a_par

am,  

# for

 BEV



     

     

     

     

encod

er_hi

dden_

state

s=con

troln

et_pr

ompt_

embed

s,



     

     

     

     

contr

olnet

_cond

=imag

e,



     

     

     

     

condi

tioni

ng_sc

ale=c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

     

     

     

guess

_mode

=gues

s_mod

e,



     

     

     

     

retur

n_dic

t=Fal

se,



     

     

     

     

**bev

_cont

rolne

t_kwa

rgs, 

# for

 BEV



     

     

     

 )



     

     

     

 # fm

t: on





     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

ered 

Contr

olNet

 only

 for 

the c

ondit

ional

 batc

h.



     

     

     

     

# To 

apply

 the 

outpu

t of 

Contr

olNet

 to b

oth t

he un

condi

tiona

l and

 cond

ition

al ba

tches

,



     

     

     

     

# add

 0 to

 the 

uncon

ditio

nal b

atch 

to ke

ep it

 unch

anged

.



     

     

     

     

down_

block

_res_

sampl

es = 

[



     

     

     

     

    t

orch.

cat([

torch

.zero

s_lik

e(d),

 d])



     

     

     

     

    f

or d 

in do

wn_bl

ock_r

es_sa

mples



     

     

     

     

]



     

     

     

     

mid_b

lock_

res_s

ample

 = to

rch.c

at(



     

     

     

     

    [

torch

.zero

s_lik

e(mid

_bloc

k_res

_samp

le), 

mid_b

lock_

res_s

ample

]



     

     

     

     

)



     

     

     

     

# add

 unco

nd en

coder

_hidd

en_st

ates_

with_

cam h

ere



     

     

     

     

encod

er_hi

dden_

state

s_wit

h_cam

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_em

b(



     

     

     

     

    p

rompt

_embe

ds.ch

unk(2

)[0],

 N_ca

m,



     

     

     

     

    e

ncode

r_hid

den_s

tates

_with

_cam,



     

     

     

     

)





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # St

ratin

g fro

m her

e, we

 use 

4-dim

 data

.



     

     

     

 # en

coder

_hidd

en_st

ates_

with_

cam: 

(2b x

 N), 

78, 7

68



     

     

     

 # la

tent_

model

_inpu

t: 2b

, N, 

4, 28

, 50 

-> 2b

 x N,

 4, 2

8, 50



     

     

     

 late

nt_mo

del_i

nput 

= rea

rrang

e(



     

     

     

     

laten

t_mod

el_in

put, 

'b n 

... -

> (b 

n) ..

.')



     

     

     

 late

nts =

 rear

range

(late

nts, 

'b n 

... -

> (b 

n) ..

.')





     

     

     

 # pr

edict

 the 

noise

 resi

dual:

 2bxN

, 4, 

28, 5

0



     

     

     

 addi

tiona

l_par

am = 

{}



     

     

     

 nois

e_pre

d = s

elf.u

net(



     

     

     

     

laten

t_mod

el_in

put, 

 # ma

y wit

h unc

ondit

ional



     

     

     

     

t,



     

     

     

     

encod

er_hi

dden_

state

s=enc

oder_

hidde

n_sta

tes_w

ith_c

am,



     

     

     

     

**add

ition

al_pa

ram, 

 # if

 use 

origi

nal u

net, 

it ca

nnot 

take 

kwarg

s



     

     

     

     

cross

_atte

ntion

_kwar

gs=cr

oss_a

ttent

ion_k

wargs

,



     

     

     

     

down_

block

_addi

tiona

l_res

idual

s=dow

n_blo

ck_re

s_sam

ples,



     

     

     

     

mid_b

lock_

addit

ional

_resi

dual=

mid_b

lock_

res_s

ample

,



     

     

     

 ).sa

mple





     

     

     

 # pe

rform

 guid

ance



     

     

     

 if d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# for

 each

: bxN

, 4, 

28, 5

0



     

     

     

     

noise

_pred

_unco

nd, n

oise_

pred_

text 

= noi

se_pr

ed.ch

unk(2

)



     

     

     

     

noise

_pred

 = no

ise_p

red_u

ncond

 + gu

idanc

e_sca

le * 

(



     

     

     

     

    n

oise_

pred_

text 

- noi

se_pr

ed_un

cond



     

     

     

     

)





     

     

     

 # co

mpute

 the 

previ

ous n

oisy 

sampl

e x_t

 -> x

_t-1



     

     

     

 # NO

TE: i

s the

 sche

duler

 use 

rando

mness

, ple

ase h

andle

 the 

logic



     

     

     

 # fo

r gen

erato

r.



     

     

     

 late

nts =

 self

.sche

duler

.step

(



     

     

     

     

noise

_pred

, t, 

laten

ts, *

*extr

a_ste

p_kwa

rgs



     

     

     

 ).pr

ev_sa

mple





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # no

w we 

add d

imens

ion b

ack, 

use 5

-dim 

data.



     

     

     

 # NO

TE: o

nly `

laten

ts` i

s upd

ated 

throu

gh th

e loo

p



     

     

     

 late

nts =

 rear

range

(late

nts, 

'(b n

) ...

 -> b

 n ..

.', n

=N_ca

m)





     

     

     

 # ca

ll th

e cal

lback

, if 

provi

ded



     

     

     

 if i

 == l

en(ti

meste

ps) -

 1 or

 (



     

     

     

     

(i + 

1) > 

num_w

armup

_step

s and

 (i +

 1) %

 self

.sche

duler

.orde

r == 

0



     

     

     

 ):



     

     

     

     

progr

ess_b

ar.up

date(

)



     

     

     

     

if ca

llbac

k is 

not N

one a

nd i 

% cal

lback

_step

s == 

0:



     

     

     

     

    c

allba

ck(i,

 t, l

atent

s)





     

   ##

#### 

BEV: 

here 

rebui

ld th

e sha

pes b

ack. 

post-

proce

ss st

ill a

ssume



     

   # 

laten

ts, n

o nee

d for

 b, n

, 4, 

28, 5

0



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ##

### B

EV en

d





     

   # 

If we

 do s

equen

tial 

model

 offl

oadin

g, le

t's o

ffloa

d une

t and

 cont

rolne

t



     

   # 

manua

lly f

or ma

x mem

ory s

aving

s



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.une

t.to(

"cpu"

)



     

     

  sel

f.con

troln

et.to

("cpu

")



     

     

  tor

ch.cu

da.em

pty_c

ache(

)





     

   if

 outp

ut_ty

pe ==

 "lat

ent":



     

     

  ima

ge = 

laten

ts



     

     

  has

_nsfw

_conc

ept =

 None



     

   el

if ou

tput_

type 

== "p

il":



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

     

  # 1

0. Co

nvert

 to P

IL



     

     

  ima

ge = 

self.

numpy

_to_p

il_do

uble(

image

)



     

   el

se:



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

   # 

Offlo

ad la

st mo

del t

o CPU



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.fin

al_of

fload

_hook

.offl

oad()





     

   if

 not 

retur

n_dic

t:



     

     

  ret

urn (

image

, has

_nsfw

_conc

ept)





     

   re

turn 

BEVSt

ableD

iffus

ionPi

pelin

eOutp

ut(



     

     

  ima

ges=i

mage,

 nsfw

_cont

ent_d

etect

ed=ha

s_nsf

w_con

cept



     

   )



from 

datac

lasse

s imp

ort d

atacl

ass



from 

typin

g imp

ort A

ny, C

allab

le, D

ict, 

List,

 Opti

onal,

 Tupl

e, Un

ion



impor

t ins

pect





impor

t tor

ch



impor

t PIL



impor

t num

py as

 np



from 

einop

s imp

ort r

earra

nge





from 

diffu

sers 

impor

t Sta

bleDi

ffusi

onCon

trolN

etPip

eline



from 

diffu

sers.

utils

 impo

rt Ba

seOut

put



from 

diffu

sers.

image

_proc

essor

 impo

rt Va

eImag

eProc

essor



from 

diffu

sers.

model

s imp

ort A

utoen

coder

KL, U

Net2D

Condi

tionM

odel



from 

diffu

sers.

pipel

ines.

stabl

e_dif

fusio

n imp

ort S

table

Diffu

sionS

afety

Check

er



from 

diffu

sers.

sched

ulers

.sche

dulin

g_uti

ls im

port 

Karra

sDiff

usion

Sched

ulers



from 

trans

forme

rs im

port 

CLIPI

mageP

roces

sor, 

CLIPT

extMo

del, 

CLIPT

okeni

zer





from 

..mis

c.com

mon i

mport

 move

_to







@data

class



class

 BEVS

table

Diffu

sionP

ipeli

neOut

put(B

aseOu

tput)

:



    "

""



    O

utput

 clas

s for

 Stab

le Di

ffusi

on pi

pelin

es.





    A

rgs:



     

   im

ages 

(`Lis

t[PIL

.Imag

e.Ima

ge]` 

or `n

p.nda

rray`

)



     

     

  Lis

t of 

denoi

sed P

IL im

ages 

of le

ngth 

`batc

h_siz

e` or

 nump

y arr

ay of

 shap

e `(b

atch_

size,

 heig

ht, w

idth,



     

     

  num

_chan

nels)

`. PI

L ima

ges o

r num

py ar

ray p

resen

t the

 deno

ised 

image

s of 

the d

iffus

ion p

ipeli

ne.



     

   ns

fw_co

ntent

_dete

cted 

(`Lis

t[boo

l]`)



     

     

  Lis

t of 

flags

 deno

ting 

wheth

er th

e cor

respo

nding

 gene

rated

 imag

e lik

ely r

epres

ents 

"not-

safe-

for-w

ork"



     

     

  (ns

fw) c

onten

t, or

 `Non

e` if

 safe

ty ch

eckin

g cou

ld no

t be 

perfo

rmed.



    "

""





    i

mages

: Uni

on[Li

st[Li

st[PI

L.Ima

ge.Im

age]]

, np.

ndarr

ay]



    n

sfw_c

onten

t_det

ected

: Opt

ional

[List

[bool

]]







class

 Stab

leDif

fusio

nBEVC

ontro

lNetP

ipeli

ne(St

ableD

iffus

ionCo

ntrol

NetPi

pelin

e):



    d

ef __

init_

_(



     

   se

lf,



     

   va

e: Au

toenc

oderK

L,



     

   te

xt_en

coder

: CLI

PText

Model

,



     

   un

et: U

Net2D

Condi

tionM

odel,



     

   co

ntrol

net,



     

   sc

hedul

er: K

arras

Diffu

sionS

chedu

lers,



     

   to

keniz

er: C

LIPTo

keniz

er,



     

   sa

fety_

check

er: S

table

Diffu

sionS

afety

Check

er = 

None,



     

   fe

ature

_extr

actor

: CLI

PImag

eProc

essor

 = No

ne,



     

   re

quire

s_saf

ety_c

hecke

r: bo

ol = 

False

,



    )

:



     

   su

per()

.__in

it__(



     

     

  vae

,



     

     

  tex

t_enc

oder,



     

     

  tok

enize

r,



     

     

  une

t,



     

     

  con

troln

et,



     

     

  sch

edule

r,



     

     

  saf

ety_c

hecke

r,



     

     

  fea

ture_

extra

ctor,



     

     

  req

uires

_safe

ty_ch

ecker

,



     

   )



     

   as

sert 

safet

y_che

cker 

== No

ne, "

Pleas

e do 

not u

se sa

fety_

check

er."



     

   se

lf.co

ntrol

_imag

e_pro

cesso

r = V

aeIma

gePro

cesso

r(



     

     

  vae

_scal

e_fac

tor=s

elf.v

ae_sc

ale_f

actor

,



     

     

  do_

resiz

e=Fal

se,



     

     

  do_

conve

rt_rg

b=Fal

se,



     

     

  do_

norma

lize=

False

,



     

   )





    d

ef nu

mpy_t

o_pil

_doub

le(se

lf, i

mages

):



     

   ""

"



     

   Co

nvert

 a nu

mpy i

mage 

or a 

batch

 of i

mages

 to a

 PIL 

image

.



     

   We

 need

 to h

andle

 5-di

m inp

uts a

nd re

ture 

2-dim

 list

.



     

   ""

"



     

   im

gs_li

st = 

[]



     

   fo

r img

s in 

image

s:



     

     

  img

s_lis

t.app

end(s

elf.n

umpy_

to_pi

l(img

s))



     

   re

turn 

imgs_

list





    #

 Copi

ed fr

om di

ffuse

rs.pi

pelin

es.st

able_

diffu

sion.

pipel

ine_s

table

_diff

usion

.Stab

leDif

fusio

nPipe

line.

prepa

re_ex

tra_s

tep_k

wargs



    d

ef pr

epare

_extr

a_ste

p_kwa

rgs(s

elf, 

gener

ator,

 eta)

:



     

   # 

prepa

re ex

tra k

wargs

 for 

the s

chedu

ler s

tep, 

since

 not 

all s

chedu

lers 

have 

the s

ame s

ignat

ure



     

   # 

eta (

η) is

 only

 used

 with

 the 

DDIMS

chedu

ler, 

it wi

ll be

 igno

red f

or ot

her s

chedu

lers.



     

   # 

eta c

orres

ponds

 to η

 in D

DIM p

aper:

 http

s://a

rxiv.

org/a

bs/20

10.02

502



     

   # 

and s

hould

 be b

etwee

n [0,

 1]





     

   ac

cepts

_eta 

= "et

a" in

 set(

inspe

ct.si

gnatu

re(se

lf.sc

hedul

er.st

ep).p

arame

ters.

keys(

))



     

   ex

tra_s

tep_k

wargs

 = {}



     

   if

 acce

pts_e

ta:



     

     

  ext

ra_st

ep_kw

args[

"eta"

] = e

ta





     

   # 

check

 if t

he sc

hedul

er ac

cepts

 gene

rator



     

   ac

cepts

_gene

rator

 = "g

enera

tor" 

in se

t(ins

pect.

signa

ture(

self.

sched

uler.

step)

.para

meter

s.key

s())



     

   if

 acce

pts_g

enera

tor:



     

     

  rai

se Ru

ntime

Error

("If 

you f

ixed 

the l

ogic 

for g

enera

tor, 

pleas

e rem

ove t

his. 

Other

wise,

 plea

se us

e oth

er sa

mpler

.")



     

     

  ext

ra_st

ep_kw

args[

"gene

rator

"] = 

gener

ator



     

   re

turn 

extra

_step

_kwar

gs





    d

ef de

code_

laten

ts(se

lf, l

atent

s):



     

   # 

decod

e lat

ents 

with 

5-dim

s



     

   la

tents

 = 1 

/ sel

f.vae

.conf

ig.sc

aling

_fact

or * 

laten

ts





     

   bs

 = le

n(lat

ents)



     

   la

tents

 = re

arran

ge(la

tents

, 'b 

c ...

 -> (

b c) 

...')



     

   im

age =

 self

.vae.

decod

e(lat

ents)

.samp

le



     

   im

age =

 rear

range

(imag

e, '(

b c) 

... -

> b c

 ...'

, b=b

s)





     

   im

age =

 (ima

ge / 

2 + 0

.5).c

lamp(

0, 1)



     

   # 

we al

ways 

cast 

to fl

oat32

 as t

his d

oes n

ot ca

use s

ignif

icant

 over

head 

and i

s com

patib

le wi

th bf

loat1

6



     

   im

age =

 rear

range

(imag

e.cpu

(), '

... c

 h w 

-> ..

. h w

 c').

float

().nu

mpy()



     

   re

turn 

image





    @

torch

.no_g

rad()



    d

ef __

call_

_(



     

   se

lf,



     

   pr

ompt:

 Unio

n[str

, Lis

t[str

]],



     

   im

age: 

torch

.Floa

tTens

or,



     

   ca

mera_

param

: Uni

on[to

rch.T

ensor

, Non

e],



     

   he

ight:

 int,



     

   wi

dth: 

int,



     

   nu

m_inf

erenc

e_ste

ps: i

nt = 

50,



     

   gu

idanc

e_sca

le: f

loat 

= 7.5

,



     

   ne

gativ

e_pro

mpt: 

Optio

nal[U

nion[

str, 

List[

str]]

] = N

one,



     

   nu

m_ima

ges_p

er_pr

ompt:

 Opti

onal[

int] 

= 1,



     

   et

a: fl

oat =

 0.0,



     

   ge

nerat

or: O

ption

al[to

rch.G

enera

tor] 

= Non

e,



     

   la

tents

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   pr

ompt_

embed

s: Op

tiona

l[tor

ch.Fl

oatTe

nsor]

 = No

ne,



     

   ne

gativ

e_pro

mpt_e

mbeds

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   ou

tput_

type:

 Opti

onal[

str] 

= "pi

l",



     

   re

turn_

dict:

 bool

 = Tr

ue,



     

   ca

llbac

k: Op

tiona

l[Cal

lable

[[int

, int

, tor

ch.Fl

oatTe

nsor]

, Non

e]] =

 None

,



     

   ca

llbac

k_ste

ps: i

nt = 

1,



     

   cr

oss_a

ttent

ion_k

wargs

: Opt

ional

[Dict

[str,

 Any]

] = N

one,



     

   co

ntrol

net_c

ondit

ionin

g_sca

le: f

loat 

= 1,



     

   gu

ess_m

ode: 

bool 

= Fal

se,



     

   us

e_zer

o_map

_as_u

ncond

ition

al: b

ool =

 Fals

e,



     

   be

v_con

troln

et_kw

args 

= {},



     

   bb

ox_ma

x_len

gth =

 None

,



    )

:



     

   r"

""



     

   Fu

nctio

n inv

oked 

when 

calli

ng th

e pip

eline

 for 

gener

ation

.





     

   Ar

gs:



     

     

  pro

mpt (

`str`

 or `

List[

str]`

, *op

tiona

l*):



     

     

     

 The 

promp

t or 

promp

ts to

 guid

e the

 imag

e gen

erati

on. I

f not

 defi

ned, 

one h

as to

 pass

 `pro

mpt_e

mbeds

`.



     

     

     

 inst

ead.



     

     

  ima

ge (`

torch

.Floa

tTens

or`, 

`PIL.

Image

.Imag

e`, `

List[

torch

.Floa

tTens

or]`,

 `Lis

t[PIL

.Imag

e.Ima

ge]`,



     

     

     

     

`List

[List

[torc

h.Flo

atTen

sor]]

`, or

 `Lis

t[Lis

t[PIL

.Imag

e.Ima

ge]]`

):



     

     

     

 The 

Contr

olNet

 inpu

t con

ditio

n. Co

ntrol

Net u

ses t

his i

nput 

condi

tion 

to ge

nerat

e gui

dance

 to U

net. 

If



     

     

     

 the 

type 

is sp

ecifi

ed as

 `Tor

ch.Fl

oatTe

nsor`

, it 

is pa

ssed 

to Co

ntrol

Net a

s is.

 `PIL

.Imag

e.Ima

ge` c

an



     

     

     

 also

 be a

ccept

ed as

 an i

mage.

 The 

dimen

sions

 of t

he ou

tput 

image

 defa

ults 

to `i

mage`

's di

mensi

ons. 

If



     

     

     

 heig

ht an

d/or 

width

 are 

passe

d, `i

mage`

 is r

esize

d acc

ordin

g to 

them.

 If m

ultip

le Co

ntrol

Nets 

are



     

     

     

 spec

ified

 in i

nit, 

image

s mus

t be 

passe

d as 

a lis

t suc

h tha

t eac

h ele

ment 

of th

e lis

t can

 be c

orrec

tly



     

     

     

 batc

hed f

or in

put t

o a s

ingle

 cont

rolne

t.



     

     

  hei

ght (

`int`

, *op

tiona

l*, d

efaul

ts to

 self

.unet

.conf

ig.sa

mple_

size 

* sel

f.vae

_scal

e_fac

tor):



     

     

     

 The 

heigh

t in 

pixel

s of 

the g

enera

ted i

mage.



     

     

  wid

th (`

int`,

 *opt

ional

*, de

fault

s to 

self.

unet.

confi

g.sam

ple_s

ize *

 self

.vae_

scale

_fact

or):



     

     

     

 The 

width

 in p

ixels

 of t

he ge

nerat

ed im

age.



     

     

  num

_infe

rence

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 5

0):



     

     

     

 The 

numbe

r of 

denoi

sing 

steps

. Mor

e den

oisin

g ste

ps us

ually

 lead

 to a

 high

er qu

ality

 imag

e at 

the



     

     

     

 expe

nse o

f slo

wer i

nfere

nce.



     

     

  gui

dance

_scal

e (`f

loat`

, *op

tiona

l*, d

efaul

ts to

 7.5)

:



     

     

     

 Guid

ance 

scale

 as d

efine

d in 

[Clas

sifie

r-Fre

e Dif

fusio

n Gui

dance

](htt

ps://

arxiv

.org/

abs/2

207.1

2598)

.



     

     

     

 `gui

dance

_scal

e` is

 defi

ned a

s `w`

 of e

quati

on 2.

 of [

Image

n



     

     

     

 Pape

r](ht

tps:/

/arxi

v.org

/pdf/

2205.

11487

.pdf)

. Gui

dance

 scal

e is 

enabl

ed by

 sett

ing `

guida

nce_s

cale 

>



     

     

     

 1`. 

Highe

r gui

dance

 scal

e enc

ourag

es to

 gene

rate 

image

s tha

t are

 clos

ely l

inked

 to t

he te

xt `p

rompt

`,



     

     

     

 usua

lly a

t the

 expe

nse o

f low

er im

age q

ualit

y.



     

     

  neg

ative

_prom

pt (`

str` 

or `L

ist[s

tr]`,

 *opt

ional

*):



     

     

     

 The 

promp

t or 

promp

ts no

t to 

guide

 the 

image

 gene

ratio

n. If

 not 

defin

ed, o

ne ha

s to 

pass



     

     

     

 `neg

ative

_prom

pt_em

beds`

 inst

ead. 

Ignor

ed wh

en no

t usi

ng gu

idanc

e (i.

e., i

gnore

d if 

`guid

ance_

scale

` is



     

     

     

 less

 than

 `1`)

.



     

     

  num

_imag

es_pe

r_pro

mpt (

`int`

, *op

tiona

l*, d

efaul

ts to

 1):



     

     

     

 The 

numbe

r of 

image

s to 

gener

ate p

er pr

ompt.



     

     

  eta

 (`fl

oat`,

 *opt

ional

*, de

fault

s to 

0.0):



     

     

     

 Corr

espon

ds to

 para

meter

 eta 

(η) i

n the

 DDIM

 pape

r: ht

tps:/

/arxi

v.org

/abs/

2010.

02502

. Onl

y app

lies 

to



     

     

     

 [`sc

hedul

ers.D

DIMSc

hedul

er`],

 will

 be i

gnore

d for

 othe

rs.



     

     

  gen

erato

r (`t

orch.

Gener

ator`

 or `

List[

torch

.Gene

rator

]`, *

optio

nal*)

:



     

     

     

 One 

or a 

list 

of [t

orch 

gener

ator(

s)](h

ttps:

//pyt

orch.

org/d

ocs/s

table

/gene

rated

/torc

h.Gen

erato

r.htm

l)



     

     

     

 to m

ake g

enera

tion 

deter

minis

tic.



     

     

  lat

ents 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

noisy

 late

nts, 

sampl

ed fr

om a 

Gauss

ian d

istri

butio

n, to

 be u

sed a

s inp

uts f

or im

age



     

     

     

 gene

ratio

n. Ca

n be 

used 

to tw

eak t

he sa

me ge

nerat

ion w

ith d

iffer

ent p

rompt

s. If

 not 

provi

ded, 

a lat

ents



     

     

     

 tens

or wi

ll ge

 gene

rated

 by s

ampli

ng us

ing t

he su

pplie

d ran

dom `

gener

ator`

.



     

     

  pro

mpt_e

mbeds

 (`to

rch.F

loatT

ensor

`, *o

ption

al*):



     

     

     

 Pre-

gener

ated 

text 

embed

dings

. Can

 be u

sed t

o eas

ily t

weak 

text 

input

s, *e

.g.* 

promp

t wei

ghtin

g. If

 not



     

     

     

 prov

ided,

 text

 embe

dding

s wil

l be 

gener

ated 

from 

`prom

pt` i

nput 

argum

ent.



     

     

  neg

ative

_prom

pt_em

beds 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

negat

ive t

ext e

mbedd

ings.

 Can 

be us

ed to

 easi

ly tw

eak t

ext i

nputs

, *e.

g.* p

rompt



     

     

     

 weig

hting

. If 

not p

rovid

ed, n

egati

ve_pr

ompt_

embed

s wil

l be 

gener

ated 

from 

`nega

tive_

promp

t` in

put



     

     

     

 argu

ment.



     

     

  out

put_t

ype (

`str`

, *op

tiona

l*, d

efaul

ts to

 `"pi

l"`):



     

     

     

 The 

outpu

t for

mat o

f the

 gene

rate 

image

. Cho

ose b

etwee

n



     

     

     

 [PIL

](htt

ps://

pillo

w.rea

dthed

ocs.i

o/en/

stabl

e/): 

`PIL.

Image

.Imag

e` or

 `np.

array

`.



     

     

  ret

urn_d

ict (

`bool

`, *o

ption

al*, 

defau

lts t

o `Tr

ue`):



     

     

     

 Whet

her o

r not

 to r

eturn

 a [`

~pipe

lines

.stab

le_di

ffusi

on.St

ableD

iffus

ionPi

pelin

eOutp

ut`] 

inste

ad of

 a



     

     

     

 plai

n tup

le.



     

     

  cal

lback

 (`Ca

llabl

e`, *

optio

nal*)

:



     

     

     

 A fu

nctio

n tha

t wil

l be 

calle

d eve

ry `c

allba

ck_st

eps` 

steps

 duri

ng in

feren

ce. T

he fu

nctio

n wil

l be



     

     

     

 call

ed wi

th th

e fol

lowin

g arg

ument

s: `c

allba

ck(st

ep: i

nt, t

imest

ep: i

nt, l

atent

s: to

rch.F

loatT

ensor

)`.



     

     

  cal

lback

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 1

):



     

     

     

 The 

frequ

ency 

at wh

ich t

he `c

allba

ck` f

uncti

on wi

ll be

 call

ed. I

f not

 spec

ified

, the

 call

back 

will 

be



     

     

     

 call

ed at

 ever

y ste

p.



     

     

  cro

ss_at

tenti

on_kw

args 

(`dic

t`, *

optio

nal*)

:



     

     

     

 A kw

args 

dicti

onary

 that

 if s

pecif

ied i

s pas

sed a

long 

to th

e `At

tenti

onPro

cesso

r` as

 defi

ned u

nder



     

     

     

 `sel

f.pro

cesso

r` in



     

     

     

 [dif

fuser

s.cro

ss_at

tenti

on](h

ttps:

//git

hub.c

om/hu

gging

face/

diffu

sers/

blob/

main/

src/d

iffus

ers/m

odels

/cros

s_att

entio

n.py)

.



     

     

  con

troln

et_co

nditi

oning

_scal

e (`f

loat`

 or `

List[

float

]`, *

optio

nal*,

 defa

ults 

to 1.

0):



     

     

     

 The 

outpu

ts of

 the 

contr

olnet

 are 

multi

plied

 by `

contr

olnet

_cond

ition

ing_s

cale`

 befo

re th

ey ar

e add

ed



     

     

     

 to t

he re

sidua

l in 

the o

rigin

al un

et. I

f mul

tiple

 Cont

rolNe

ts ar

e spe

cifie

d in 

init,

 you 

can s

et th

e



     

     

     

 corr

espon

ding 

scale

 as a

 list

.



     

     

  gue

ss_mo

de (`

bool`

, *op

tiona

l*, d

efaul

ts to

 `Fal

se`):



     

     

     

 In t

his m

ode, 

the C

ontro

lNet 

encod

er wi

ll tr

y bes

t to 

recog

nize 

the c

onten

t of 

the i

nput 

image

 even

 if



     

     

     

 you 

remov

e all

 prom

pts. 

The `

guida

nce_s

cale`

 betw

een 3

.0 an

d 5.0

 is r

ecomm

ended

.





     

   Ex

ample

s:





     

   Re

turns

:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] o

r `tu

ple`:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] i

f `re

turn_

dict`

 is T

rue, 

other

wise 

a `tu

ple.



     

     

  Whe

n ret

urnin

g a t

uple,

 the 

first

 elem

ent i

s a l

ist w

ith t

he ge

nerat

ed im

ages,

 and 

the s

econd

 elem

ent i

s a



     

     

  lis

t of 

`bool

`s de

notin

g whe

ther 

the c

orres

pondi

ng ge

nerat

ed im

age l

ikely

 repr

esent

s "no

t-saf

e-for

-work

"



     

     

  (ns

fw) c

onten

t, ac

cordi

ng to

 the 

`safe

ty_ch

ecker

`.



     

   ""

"



     

   # 

0. De

fault

 heig

ht an

d wid

th to

 unet



     

   # 

BEV: 

we ca

nnot 

use t

he si

ze of

 imag

e



     

   # 

heigh

t, wi

dth =

 self

._def

ault_

heigh

t_wid

th(he

ight,

 widt

h, No

ne)





     

   # 

1. Ch

eck i

nputs

. Rai

se er

ror i

f not

 corr

ect



     

   # 

we do

 not 

need 

this,

 only

 some

 type

 asse

rtion



     

   # 

self.

check

_inpu

ts(



     

   # 

    p

rompt

,



     

   # 

    i

mage,



     

   # 

    h

eight

,



     

   # 

    w

idth,



     

   # 

    c

allba

ck_st

eps,



     

   # 

    n

egati

ve_pr

ompt,



     

   # 

    p

rompt

_embe

ds,



     

   # 

    n

egati

ve_pr

ompt_

embed

s,



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

   # 

)





     

   # 

2. De

fine 

call 

param

eters



     

   # 

NOTE:

 we g

et ba

tch_s

ize f

irst 

from 

promp

t, th

en al

ign w

ith i

t.



     

   if

 prom

pt is

 not 

None 

and i

sinst

ance(

promp

t, st

r):



     

     

  bat

ch_si

ze = 

1



     

   el

if pr

ompt 

is no

t Non

e and

 isin

stanc

e(pro

mpt, 

list)

:



     

     

  bat

ch_si

ze = 

len(p

rompt

)



     

   el

se:



     

     

  bat

ch_si

ze = 

promp

t_emb

eds.s

hape[

0]





     

   de

vice 

= sel

f._ex

ecuti

on_de

vice



     

   # 

here 

`guid

ance_

scale

` is 

defin

ed an

alog 

to th

e gui

dance

 weig

ht `w

` of 

equat

ion (

2)



     

   # 

of th

e Ima

gen p

aper:

 http

s://a

rxiv.

org/p

df/22

05.11

487.p

df . 

`guid

ance_

scale

 = 1`



     

   # 

corre

spond

s to 

doing

 no c

lassi

fier 

free 

guida

nce.



     

   do

_clas

sifie

r_fre

e_gui

dance

 = gu

idanc

e_sca

le > 

1.0





     

   ##

# BEV

, che

ck ca

mera_

param

 ###



     

   if

 came

ra_pa

ram i

s Non

e:



     

     

  # u

se un

cond_

cam a

nd di

sable

 clas

sifie

r fre

e gui

dance



     

     

  N_c

am = 

6  # 

TODO:

 hard

-code

d



     

     

  cam

era_p

aram 

= sel

f.con

troln

et.un

cond_

cam_p

aram(

(batc

h_siz

e, N_

cam))



     

     

  do_

class

ifier

_free

_guid

ance 

= Fal

se



     

   ##

# don

e ###





     

   # 

if is

insta

nce(s

elf.c

ontro

lnet,

 Mult

iCont

rolNe

tMode

l) an

d isi

nstan

ce(co

ntrol

net_c

ondit

ionin

g_sca

le, f

loat)

:



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale =

 [con

troln

et_co

nditi

oning

_scal

e] * 

len(s

elf.c

ontro

lnet.

nets)





     

   # 

3. En

code 

input

 prom

pt



     

   # 

NOTE:

 here

 they

 use 

paddi

ng to

 77, 

is th

is ne

cessa

ry?



     

   pr

ompt_

embed

s = s

elf._

encod

e_pro

mpt(



     

     

  pro

mpt,



     

     

  dev

ice,



     

     

  num

_imag

es_pe

r_pro

mpt,



     

     

  do_

class

ifier

_free

_guid

ance,



     

     

  neg

ative

_prom

pt,



     

     

  pro

mpt_e

mbeds

=prom

pt_em

beds,



     

     

  neg

ative

_prom

pt_em

beds=

negat

ive_p

rompt

_embe

ds,



     

   ) 

 # (2

 * b,

 77 +

 1, 7

68)





     

   # 

4. Pr

epare

 imag

e



     

   # 

NOTE:

 if i

mage 

is no

t ten

sor, 

there

 will

 be s

evera

l pro

cess.



     

   as

sert 

not s

elf.c

ontro

l_ima

ge_pr

ocess

or.co

nfig.

do_no

rmali

ze, "

Your 

contr

olnet

 shou

ld no

t nor

maliz

e the

 cont

rol i

mage.

"



     

   im

age =

 self

.prep

are_i

mage(



     

     

  ima

ge=im

age,



     

     

  wid

th=wi

dth,



     

     

  hei

ght=h

eight

,



     

     

  bat

ch_si

ze=ba

tch_s

ize *

 num_

image

s_per

_prom

pt,



     

     

  num

_imag

es_pe

r_pro

mpt=n

um_im

ages_

per_p

rompt

,



     

     

  dev

ice=d

evice

,



     

     

  dty

pe=se

lf.co

ntrol

net.d

type,



     

     

  do_

class

ifier

_free

_guid

ance=

do_cl

assif

ier_f

ree_g

uidan

ce,



     

     

  gue

ss_mo

de=gu

ess_m

ode,



     

   ) 

 # (2

 * b,

 c_26

, 200

, 200

)



     

   if

 use_

zero_

map_a

s_unc

ondit

ional

 and 

do_cl

assif

ier_f

ree_g

uidan

ce:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  _im

ages[

0] = 

torch

.zero

s_lik

e(_im

ages[

0])



     

     

  ima

ge = 

torch

.cat(

_imag

es)





     

   # 

5. Pr

epare

 time

steps



     

   se

lf.sc

hedul

er.se

t_tim

estep

s(num

_infe

rence

_step

s, de

vice=

devic

e)



     

   ti

meste

ps = 

self.

sched

uler.

times

teps





     

   # 

6. Pr

epare

 late

nt va

riabl

es



     

   nu

m_cha

nnels

_late

nts =

 self

.unet

.conf

ig.in

_chan

nels



     

   la

tents

 = se

lf.pr

epare

_late

nts(



     

     

  bat

ch_si

ze * 

num_i

mages

_per_

promp

t,



     

     

  num

_chan

nels_

laten

ts,



     

     

  hei

ght,



     

     

  wid

th,



     

     

  pro

mpt_e

mbeds

.dtyp

e,



     

     

  dev

ice,



     

     

  gen

erato

r,



     

     

  lat

ents,

  # w

ill u

se if

 not 

None,

 othe

rwise

 will

 gene

rate



     

   ) 

 # (b

, c, 

h/8, 

w/8) 

-> (b

s, 4,

 28, 

50)





     

   # 

7. Pr

epare

 extr

a ste

p kwa

rgs.



     

   ex

tra_s

tep_k

wargs

 = se

lf.pr

epare

_extr

a_ste

p_kwa

rgs(g

enera

tor, 

eta)





     

   ##

#### 

BEV: 

here 

we re

const

ruct 

each 

input

 form

at ##

####



     

   as

sert 

camer

a_par

am.sh

ape[0

] == 

batch

_size

, \



     

     

  f"E

xcept

 {bat

ch_si

ze} c

amera

 para

ms, b

ut yo

u hav

e bs=

{len(

camer

a_par

am)}"



     

   N_

cam =

 came

ra_pa

ram.s

hape[

1]



     

   la

tents

 = to

rch.s

tack(

[late

nts] 

* N_c

am, d

im=1)

  # b

s, 6,

 4, 2

8, 50



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ca

mera_

param

 = ca

mera_

param

.to(s

elf.d

evice

)



     

   if

 do_c

lassi

fier_

free_

guida

nce a

nd no

t gue

ss_mo

de:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  kwa

rgs_w

ith_u

ncond

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_kw

args(



     

     

     

 came

ra_pa

ram=c

amera

_para

m,



     

     

     

 imag

e=_im

ages[

0],  

# 0 i

s for

 unco

nditi

onal



     

     

     

 max_

len=b

box_m

ax_le

ngth,



     

     

     

 **be

v_con

troln

et_kw

args,



     

     

  )



     

     

  kwa

rgs_w

ith_u

ncond

.pop(

"max_

len",

 None

)  # 

some 

do no

t tak

e thi

s.



     

     

  cam

era_p

aram 

= kwa

rgs_w

ith_u

ncond

.pop(

"came

ra_pa

ram")



     

     

  _im

ages[

0] = 

kwarg

s_wit

h_unc

ond.p

op("i

mage"

)



     

     

  ima

ge = 

torch

.cat(

_imag

es)



     

     

  bev

_cont

rolne

t_kwa

rgs =

 move

_to(k

wargs

_with

_unco

nd, s

elf.d

evice

)



     

   ##

#### 

BEV e

nd ##

####





     

   # 

8. De

noisi

ng lo

op



     

   nu

m_war

mup_s

teps 

= len

(time

steps

) - n

um_in

feren

ce_st

eps *

 self

.sche

duler

.orde

r



     

   wi

th se

lf.pr

ogres

s_bar

(tota

l=num

_infe

rence

_step

s) as

 prog

ress_

bar:



     

     

  for

 i, t

 in e

numer

ate(t

imest

eps):



     

     

     

 # ex

pand 

the l

atent

s if 

we ar

e doi

ng cl

assif

ier f

ree g

uidan

ce



     

     

     

 # bs

*2, 6

, 4, 

28, 5

0



     

     

     

 late

nt_mo

del_i

nput 

= (



     

     

     

     

torch

.cat(

[late

nts] 

* 2) 

if do

_clas

sifie

r_fre

e_gui

dance

 else

 late

nts



     

     

     

 )



     

     

     

 late

nt_mo

del_i

nput 

= sel

f.sch

edule

r.sca

le_mo

del_i

nput(



     

     

     

     

laten

t_mod

el_in

put, 

t



     

     

     

 )





     

     

     

 # co

ntrol

net(s

) inf

erenc

e



     

     

     

 cont

rolne

t_t =

 t.un

squee

ze(0)



     

     

     

 # gu

ess_m

ode &

 clas

sifie

r_fre

e_gui

dance

 -> o

nly g

uidan

ce us

e con

troln

et



     

     

     

 # no

t gue

ss_mo

de & 

class

ifier

_free

_guid

ance 

-> al

l use

 cont

rolne

t



     

     

     

 # gu

ess_m

ode -

> nor

mal i

nput,

 take

 effe

ct in

 cont

rolne

t



     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

er Co

ntrol

Net o

nly f

or th

e con

ditio

nal b

atch.



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ents



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds

.chun

k(2)[

1]



     

     

     

 else

:



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ent_m

odel_

input



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds



     

     

     

 cont

rolne

t_t =

 cont

rolne

t_t.r

epeat

(len(

contr

olnet

_late

nt_mo

del_i

nput)

)





     

     

     

 # fm

t: of

f



     

     

     

 down

_bloc

k_res

_samp

les, 

mid_b

lock_

res_s

ample

, \



     

     

     

 enco

der_h

idden

_stat

es_wi

th_ca

m = s

elf.c

ontro

lnet(



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput,



     

     

     

     

contr

olnet

_t,



     

     

     

     

camer

a_par

am,  

# for

 BEV



     

     

     

     

encod

er_hi

dden_

state

s=con

troln

et_pr

ompt_

embed

s,



     

     

     

     

contr

olnet

_cond

=imag

e,



     

     

     

     

condi

tioni

ng_sc

ale=c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

     

     

     

guess

_mode

=gues

s_mod

e,



     

     

     

     

retur

n_dic

t=Fal

se,



     

     

     

     

**bev

_cont

rolne

t_kwa

rgs, 

# for

 BEV



     

     

     

 )



     

     

     

 # fm

t: on





     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

ered 

Contr

olNet

 only

 for 

the c

ondit

ional

 batc

h.



     

     

     

     

# To 

apply

 the 

outpu

t of 

Contr

olNet

 to b

oth t

he un

condi

tiona

l and

 cond

ition

al ba

tches

,



     

     

     

     

# add

 0 to

 the 

uncon

ditio

nal b

atch 

to ke

ep it

 unch

anged

.



     

     

     

     

down_

block

_res_

sampl

es = 

[



     

     

     

     

    t

orch.

cat([

torch

.zero

s_lik

e(d),

 d])



     

     

     

     

    f

or d 

in do

wn_bl

ock_r

es_sa

mples



     

     

     

     

]



     

     

     

     

mid_b

lock_

res_s

ample

 = to

rch.c

at(



     

     

     

     

    [

torch

.zero

s_lik

e(mid

_bloc

k_res

_samp

le), 

mid_b

lock_

res_s

ample

]



     

     

     

     

)



     

     

     

     

# add

 unco

nd en

coder

_hidd

en_st

ates_

with_

cam h

ere



     

     

     

     

encod

er_hi

dden_

state

s_wit

h_cam

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_em

b(



     

     

     

     

    p

rompt

_embe

ds.ch

unk(2

)[0],

 N_ca

m,



     

     

     

     

    e

ncode

r_hid

den_s

tates

_with

_cam,



     

     

     

     

)





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # St

ratin

g fro

m her

e, we

 use 

4-dim

 data

.



     

     

     

 # en

coder

_hidd

en_st

ates_

with_

cam: 

(2b x

 N), 

78, 7

68



     

     

     

 # la

tent_

model

_inpu

t: 2b

, N, 

4, 28

, 50 

-> 2b

 x N,

 4, 2

8, 50



     

     

     

 late

nt_mo

del_i

nput 

= rea

rrang

e(



     

     

     

     

laten

t_mod

el_in

put, 

'b n 

... -

> (b 

n) ..

.')



     

     

     

 late

nts =

 rear

range

(late

nts, 

'b n 

... -

> (b 

n) ..

.')





     

     

     

 # pr

edict

 the 

noise

 resi

dual:

 2bxN

, 4, 

28, 5

0



     

     

     

 addi

tiona

l_par

am = 

{}



     

     

     

 nois

e_pre

d = s

elf.u

net(



     

     

     

     

laten

t_mod

el_in

put, 

 # ma

y wit

h unc

ondit

ional



     

     

     

     

t,



     

     

     

     

encod

er_hi

dden_

state

s=enc

oder_

hidde

n_sta

tes_w

ith_c

am,



     

     

     

     

**add

ition

al_pa

ram, 

 # if

 use 

origi

nal u

net, 

it ca

nnot 

take 

kwarg

s



     

     

     

     

cross

_atte

ntion

_kwar

gs=cr

oss_a

ttent

ion_k

wargs

,



     

     

     

     

down_

block

_addi

tiona

l_res

idual

s=dow

n_blo

ck_re

s_sam

ples,



     

     

     

     

mid_b

lock_

addit

ional

_resi

dual=

mid_b

lock_

res_s

ample

,



     

     

     

 ).sa

mple





     

     

     

 # pe

rform

 guid

ance



     

     

     

 if d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# for

 each

: bxN

, 4, 

28, 5

0



     

     

     

     

noise

_pred

_unco

nd, n

oise_

pred_

text 

= noi

se_pr

ed.ch

unk(2

)



     

     

     

     

noise

_pred

 = no

ise_p

red_u

ncond

 + gu

idanc

e_sca

le * 

(



     

     

     

     

    n

oise_

pred_

text 

- noi

se_pr

ed_un

cond



     

     

     

     

)





     

     

     

 # co

mpute

 the 

previ

ous n

oisy 

sampl

e x_t

 -> x

_t-1



     

     

     

 # NO

TE: i

s the

 sche

duler

 use 

rando

mness

, ple

ase h

andle

 the 

logic



     

     

     

 # fo

r gen

erato

r.



     

     

     

 late

nts =

 self

.sche

duler

.step

(



     

     

     

     

noise

_pred

, t, 

laten

ts, *

*extr

a_ste

p_kwa

rgs



     

     

     

 ).pr

ev_sa

mple





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # no

w we 

add d

imens

ion b

ack, 

use 5

-dim 

data.



     

     

     

 # NO

TE: o

nly `

laten

ts` i

s upd

ated 

throu

gh th

e loo

p



     

     

     

 late

nts =

 rear

range

(late

nts, 

'(b n

) ...

 -> b

 n ..

.', n

=N_ca

m)





     

     

     

 # ca

ll th

e cal

lback

, if 

provi

ded



     

     

     

 if i

 == l

en(ti

meste

ps) -

 1 or

 (



     

     

     

     

(i + 

1) > 

num_w

armup

_step

s and

 (i +

 1) %

 self

.sche

duler

.orde

r == 

0



     

     

     

 ):



     

     

     

     

progr

ess_b

ar.up

date(

)



     

     

     

     

if ca

llbac

k is 

not N

one a

nd i 

% cal

lback

_step

s == 

0:



     

     

     

     

    c

allba

ck(i,

 t, l

atent

s)





     

   ##

#### 

BEV: 

here 

rebui

ld th

e sha

pes b

ack. 

post-

proce

ss st

ill a

ssume



     

   # 

laten

ts, n

o nee

d for

 b, n

, 4, 

28, 5

0



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ##

### B

EV en

d





     

   # 

If we

 do s

equen

tial 

model

 offl

oadin

g, le

t's o

ffloa

d une

t and

 cont

rolne

t



     

   # 

manua

lly f

or ma

x mem

ory s

aving

s



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.une

t.to(

"cpu"

)



     

     

  sel

f.con

troln

et.to

("cpu

")



     

     

  tor

ch.cu

da.em

pty_c

ache(

)





     

   if

 outp

ut_ty

pe ==

 "lat

ent":



     

     

  ima

ge = 

laten

ts



     

     

  has

_nsfw

_conc

ept =

 None



     

   el

if ou

tput_

type 

== "p

il":



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

     

  # 1

0. Co

nvert

 to P

IL



     

     

  ima

ge = 

self.

numpy

_to_p

il_do

uble(

image

)



     

   el

se:



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

   # 

Offlo

ad la

st mo

del t

o CPU



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.fin

al_of

fload

_hook

.offl

oad()





     

   if

 not 

retur

n_dic

t:



     

     

  ret

urn (

image

, has

_nsfw

_conc

ept)





     

   re

turn 

BEVSt

ableD

iffus

ionPi

pelin

eOutp

ut(



     

     

  ima

ges=i

mage,

 nsfw

_cont

ent_d

etect

ed=ha

s_nsf

w_con

cept



     

   )



from 

datac

lasse

s imp

ort d

atacl

ass



from 

typin

g imp

ort A

ny, C

allab

le, D

ict, 

List,

 Opti

onal,

 Tupl

e, Un

ion



impor

t ins

pect





impor

t tor

ch



impor

t PIL



impor

t num

py as

 np



from 

einop

s imp

ort r

earra

nge





from 

diffu

sers 

impor

t Sta

bleDi

ffusi

onCon

trolN

etPip

eline



from 

diffu

sers.

utils

 impo

rt Ba

seOut

put



from 

diffu

sers.

image

_proc

essor

 impo

rt Va

eImag

eProc

essor



from 

diffu

sers.

model

s imp

ort A

utoen

coder

KL, U

Net2D

Condi

tionM

odel



from 

diffu

sers.

pipel

ines.

stabl

e_dif

fusio

n imp

ort S

table

Diffu

sionS

afety

Check

er



from 

diffu

sers.

sched

ulers

.sche

dulin

g_uti

ls im

port 

Karra

sDiff

usion

Sched

ulers



from 

trans

forme

rs im

port 

CLIPI

mageP

roces

sor, 

CLIPT

extMo

del, 

CLIPT

okeni

zer





from 

..mis

c.com

mon i

mport

 move

_to







@data

class



class

 BEVS

table

Diffu

sionP

ipeli

neOut

put(B

aseOu

tput)

:



    "

""



    O

utput

 clas

s for

 Stab

le Di

ffusi

on pi

pelin

es.





    A

rgs:



     

   im

ages 

(`Lis

t[PIL

.Imag

e.Ima

ge]` 

or `n

p.nda

rray`

)



     

     

  Lis

t of 

denoi

sed P

IL im

ages 

of le

ngth 

`batc

h_siz

e` or

 nump

y arr

ay of

 shap

e `(b

atch_

size,

 heig

ht, w

idth,



     

     

  num

_chan

nels)

`. PI

L ima

ges o

r num

py ar

ray p

resen

t the

 deno

ised 

image

s of 

the d

iffus

ion p

ipeli

ne.



     

   ns

fw_co

ntent

_dete

cted 

(`Lis

t[boo

l]`)



     

     

  Lis

t of 

flags

 deno

ting 

wheth

er th

e cor

respo

nding

 gene

rated

 imag

e lik

ely r

epres

ents 

"not-

safe-

for-w

ork"



     

     

  (ns

fw) c

onten

t, or

 `Non

e` if

 safe

ty ch

eckin

g cou

ld no

t be 

perfo

rmed.



    "

""





    i

mages

: Uni

on[Li

st[Li

st[PI

L.Ima

ge.Im

age]]

, np.

ndarr

ay]



    n

sfw_c

onten

t_det

ected

: Opt

ional

[List

[bool

]]







class

 Stab

leDif

fusio

nBEVC

ontro

lNetP

ipeli

ne(St

ableD

iffus

ionCo

ntrol

NetPi

pelin

e):



    d

ef __

init_

_(



     

   se

lf,



     

   va

e: Au

toenc

oderK

L,



     

   te

xt_en

coder

: CLI

PText

Model

,



     

   un

et: U

Net2D

Condi

tionM

odel,



     

   co

ntrol

net,



     

   sc

hedul

er: K

arras

Diffu

sionS

chedu

lers,



     

   to

keniz

er: C

LIPTo

keniz

er,



     

   sa

fety_

check

er: S

table

Diffu

sionS

afety

Check

er = 

None,



     

   fe

ature

_extr

actor

: CLI

PImag

eProc

essor

 = No

ne,



     

   re

quire

s_saf

ety_c

hecke

r: bo

ol = 

False

,



    )

:



     

   su

per()

.__in

it__(



     

     

  vae

,



     

     

  tex

t_enc

oder,



     

     

  tok

enize

r,



     

     

  une

t,



     

     

  con

troln

et,



     

     

  sch

edule

r,



     

     

  saf

ety_c

hecke

r,



     

     

  fea

ture_

extra

ctor,



     

     

  req

uires

_safe

ty_ch

ecker

,



     

   )



     

   as

sert 

safet

y_che

cker 

== No

ne, "

Pleas

e do 

not u

se sa

fety_

check

er."



     

   se

lf.co

ntrol

_imag

e_pro

cesso

r = V

aeIma

gePro

cesso

r(



     

     

  vae

_scal

e_fac

tor=s

elf.v

ae_sc

ale_f

actor

,



     

     

  do_

resiz

e=Fal

se,



     

     

  do_

conve

rt_rg

b=Fal

se,



     

     

  do_

norma

lize=

False

,



     

   )





    d

ef nu

mpy_t

o_pil

_doub

le(se

lf, i

mages

):



     

   ""

"



     

   Co

nvert

 a nu

mpy i

mage 

or a 

batch

 of i

mages

 to a

 PIL 

image

.



     

   We

 need

 to h

andle

 5-di

m inp

uts a

nd re

ture 

2-dim

 list

.



     

   ""

"



     

   im

gs_li

st = 

[]



     

   fo

r img

s in 

image

s:



     

     

  img

s_lis

t.app

end(s

elf.n

umpy_

to_pi

l(img

s))



     

   re

turn 

imgs_

list





    #

 Copi

ed fr

om di

ffuse

rs.pi

pelin

es.st

able_

diffu

sion.

pipel

ine_s

table

_diff

usion

.Stab

leDif

fusio

nPipe

line.

prepa

re_ex

tra_s

tep_k

wargs



    d

ef pr

epare

_extr

a_ste

p_kwa

rgs(s

elf, 

gener

ator,

 eta)

:



     

   # 

prepa

re ex

tra k

wargs

 for 

the s

chedu

ler s

tep, 

since

 not 

all s

chedu

lers 

have 

the s

ame s

ignat

ure



     

   # 

eta (

η) is

 only

 used

 with

 the 

DDIMS

chedu

ler, 

it wi

ll be

 igno

red f

or ot

her s

chedu

lers.



     

   # 

eta c

orres

ponds

 to η

 in D

DIM p

aper:

 http

s://a

rxiv.

org/a

bs/20

10.02

502



     

   # 

and s

hould

 be b

etwee

n [0,

 1]





     

   ac

cepts

_eta 

= "et

a" in

 set(

inspe

ct.si

gnatu

re(se

lf.sc

hedul

er.st

ep).p

arame

ters.

keys(

))



     

   ex

tra_s

tep_k

wargs

 = {}



     

   if

 acce

pts_e

ta:



     

     

  ext

ra_st

ep_kw

args[

"eta"

] = e

ta





     

   # 

check

 if t

he sc

hedul

er ac

cepts

 gene

rator



     

   ac

cepts

_gene

rator

 = "g

enera

tor" 

in se

t(ins

pect.

signa

ture(

self.

sched

uler.

step)

.para

meter

s.key

s())



     

   if

 acce

pts_g

enera

tor:



     

     

  rai

se Ru

ntime

Error

("If 

you f

ixed 

the l

ogic 

for g

enera

tor, 

pleas

e rem

ove t

his. 

Other

wise,

 plea

se us

e oth

er sa

mpler

.")



     

     

  ext

ra_st

ep_kw

args[

"gene

rator

"] = 

gener

ator



     

   re

turn 

extra

_step

_kwar

gs





    d

ef de

code_

laten

ts(se

lf, l

atent

s):



     

   # 

decod

e lat

ents 

with 

5-dim

s



     

   la

tents

 = 1 

/ sel

f.vae

.conf

ig.sc

aling

_fact

or * 

laten

ts





     

   bs

 = le

n(lat

ents)



     

   la

tents

 = re

arran

ge(la

tents

, 'b 

c ...

 -> (

b c) 

...')



     

   im

age =

 self

.vae.

decod

e(lat

ents)

.samp

le



     

   im

age =

 rear

range

(imag

e, '(

b c) 

... -

> b c

 ...'

, b=b

s)





     

   im

age =

 (ima

ge / 

2 + 0

.5).c

lamp(

0, 1)



     

   # 

we al

ways 

cast 

to fl

oat32

 as t

his d

oes n

ot ca

use s

ignif

icant

 over

head 

and i

s com

patib

le wi

th bf

loat1

6



     

   im

age =

 rear

range

(imag

e.cpu

(), '

... c

 h w 

-> ..

. h w

 c').

float

().nu

mpy()



     

   re

turn 

image





    @

torch

.no_g

rad()



    d

ef __

call_

_(



     

   se

lf,



     

   pr

ompt:

 Unio

n[str

, Lis

t[str

]],



     

   im

age: 

torch

.Floa

tTens

or,



     

   ca

mera_

param

: Uni

on[to

rch.T

ensor

, Non

e],



     

   he

ight:

 int,



     

   wi

dth: 

int,



     

   nu

m_inf

erenc

e_ste

ps: i

nt = 

50,



     

   gu

idanc

e_sca

le: f

loat 

= 7.5

,



     

   ne

gativ

e_pro

mpt: 

Optio

nal[U

nion[

str, 

List[

str]]

] = N

one,



     

   nu

m_ima

ges_p

er_pr

ompt:

 Opti

onal[

int] 

= 1,



     

   et

a: fl

oat =

 0.0,



     

   ge

nerat

or: O

ption

al[to

rch.G

enera

tor] 

= Non

e,



     

   la

tents

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   pr

ompt_

embed

s: Op

tiona

l[tor

ch.Fl

oatTe

nsor]

 = No

ne,



     

   ne

gativ

e_pro

mpt_e

mbeds

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   ou

tput_

type:

 Opti

onal[

str] 

= "pi

l",



     

   re

turn_

dict:

 bool

 = Tr

ue,



     

   ca

llbac

k: Op

tiona

l[Cal

lable

[[int

, int

, tor

ch.Fl

oatTe

nsor]

, Non

e]] =

 None

,



     

   ca

llbac

k_ste

ps: i

nt = 

1,



     

   cr

oss_a

ttent

ion_k

wargs

: Opt

ional

[Dict

[str,

 Any]

] = N

one,



     

   co

ntrol

net_c

ondit

ionin

g_sca

le: f

loat 

= 1,



     

   gu

ess_m

ode: 

bool 

= Fal

se,



     

   us

e_zer

o_map

_as_u

ncond

ition

al: b

ool =

 Fals

e,



     

   be

v_con

troln

et_kw

args 

= {},



     

   bb

ox_ma

x_len

gth =

 None

,



    )

:



     

   r"

""



     

   Fu

nctio

n inv

oked 

when 

calli

ng th

e pip

eline

 for 

gener

ation

.





     

   Ar

gs:



     

     

  pro

mpt (

`str`

 or `

List[

str]`

, *op

tiona

l*):



     

     

     

 The 

promp

t or 

promp

ts to

 guid

e the

 imag

e gen

erati

on. I

f not

 defi

ned, 

one h

as to

 pass

 `pro

mpt_e

mbeds

`.



     

     

     

 inst

ead.



     

     

  ima

ge (`

torch

.Floa

tTens

or`, 

`PIL.

Image

.Imag

e`, `

List[

torch

.Floa

tTens

or]`,

 `Lis

t[PIL

.Imag

e.Ima

ge]`,



     

     

     

     

`List

[List

[torc

h.Flo

atTen

sor]]

`, or

 `Lis

t[Lis

t[PIL

.Imag

e.Ima

ge]]`

):



     

     

     

 The 

Contr

olNet

 inpu

t con

ditio

n. Co

ntrol

Net u

ses t

his i

nput 

condi

tion 

to ge

nerat

e gui

dance

 to U

net. 

If



     

     

     

 the 

type 

is sp

ecifi

ed as

 `Tor

ch.Fl

oatTe

nsor`

, it 

is pa

ssed 

to Co

ntrol

Net a

s is.

 `PIL

.Imag

e.Ima

ge` c

an



     

     

     

 also

 be a

ccept

ed as

 an i

mage.

 The 

dimen

sions

 of t

he ou

tput 

image

 defa

ults 

to `i

mage`

's di

mensi

ons. 

If



     

     

     

 heig

ht an

d/or 

width

 are 

passe

d, `i

mage`

 is r

esize

d acc

ordin

g to 

them.

 If m

ultip

le Co

ntrol

Nets 

are



     

     

     

 spec

ified

 in i

nit, 

image

s mus

t be 

passe

d as 

a lis

t suc

h tha

t eac

h ele

ment 

of th

e lis

t can

 be c

orrec

tly



     

     

     

 batc

hed f

or in

put t

o a s

ingle

 cont

rolne

t.



     

     

  hei

ght (

`int`

, *op

tiona

l*, d

efaul

ts to

 self

.unet

.conf

ig.sa

mple_

size 

* sel

f.vae

_scal

e_fac

tor):



     

     

     

 The 

heigh

t in 

pixel

s of 

the g

enera

ted i

mage.



     

     

  wid

th (`

int`,

 *opt

ional

*, de

fault

s to 

self.

unet.

confi

g.sam

ple_s

ize *

 self

.vae_

scale

_fact

or):



     

     

     

 The 

width

 in p

ixels

 of t

he ge

nerat

ed im

age.



     

     

  num

_infe

rence

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 5

0):



     

     

     

 The 

numbe

r of 

denoi

sing 

steps

. Mor

e den

oisin

g ste

ps us

ually

 lead

 to a

 high

er qu

ality

 imag

e at 

the



     

     

     

 expe

nse o

f slo

wer i

nfere

nce.



     

     

  gui

dance

_scal

e (`f

loat`

, *op

tiona

l*, d

efaul

ts to

 7.5)

:



     

     

     

 Guid

ance 

scale

 as d

efine

d in 

[Clas

sifie

r-Fre

e Dif

fusio

n Gui

dance

](htt

ps://

arxiv

.org/

abs/2

207.1

2598)

.



     

     

     

 `gui

dance

_scal

e` is

 defi

ned a

s `w`

 of e

quati

on 2.

 of [

Image

n



     

     

     

 Pape

r](ht

tps:/

/arxi

v.org

/pdf/

2205.

11487

.pdf)

. Gui

dance

 scal

e is 

enabl

ed by

 sett

ing `

guida

nce_s

cale 

>



     

     

     

 1`. 

Highe

r gui

dance

 scal

e enc

ourag

es to

 gene

rate 

image

s tha

t are

 clos

ely l

inked

 to t

he te

xt `p

rompt

`,



     

     

     

 usua

lly a

t the

 expe

nse o

f low

er im

age q

ualit

y.



     

     

  neg

ative

_prom

pt (`

str` 

or `L

ist[s

tr]`,

 *opt

ional

*):



     

     

     

 The 

promp

t or 

promp

ts no

t to 

guide

 the 

image

 gene

ratio

n. If

 not 

defin

ed, o

ne ha

s to 

pass



     

     

     

 `neg

ative

_prom

pt_em

beds`

 inst

ead. 

Ignor

ed wh

en no

t usi

ng gu

idanc

e (i.

e., i

gnore

d if 

`guid

ance_

scale

` is



     

     

     

 less

 than

 `1`)

.



     

     

  num

_imag

es_pe

r_pro

mpt (

`int`

, *op

tiona

l*, d

efaul

ts to

 1):



     

     

     

 The 

numbe

r of 

image

s to 

gener

ate p

er pr

ompt.



     

     

  eta

 (`fl

oat`,

 *opt

ional

*, de

fault

s to 

0.0):



     

     

     

 Corr

espon

ds to

 para

meter

 eta 

(η) i

n the

 DDIM

 pape

r: ht

tps:/

/arxi

v.org

/abs/

2010.

02502

. Onl

y app

lies 

to



     

     

     

 [`sc

hedul

ers.D

DIMSc

hedul

er`],

 will

 be i

gnore

d for

 othe

rs.



     

     

  gen

erato

r (`t

orch.

Gener

ator`

 or `

List[

torch

.Gene

rator

]`, *

optio

nal*)

:



     

     

     

 One 

or a 

list 

of [t

orch 

gener

ator(

s)](h

ttps:

//pyt

orch.

org/d

ocs/s

table

/gene

rated

/torc

h.Gen

erato

r.htm

l)



     

     

     

 to m

ake g

enera

tion 

deter

minis

tic.



     

     

  lat

ents 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

noisy

 late

nts, 

sampl

ed fr

om a 

Gauss

ian d

istri

butio

n, to

 be u

sed a

s inp

uts f

or im

age



     

     

     

 gene

ratio

n. Ca

n be 

used 

to tw

eak t

he sa

me ge

nerat

ion w

ith d

iffer

ent p

rompt

s. If

 not 

provi

ded, 

a lat

ents



     

     

     

 tens

or wi

ll ge

 gene

rated

 by s

ampli

ng us

ing t

he su

pplie

d ran

dom `

gener

ator`

.



     

     

  pro

mpt_e

mbeds

 (`to

rch.F

loatT

ensor

`, *o

ption

al*):



     

     

     

 Pre-

gener

ated 

text 

embed

dings

. Can

 be u

sed t

o eas

ily t

weak 

text 

input

s, *e

.g.* 

promp

t wei

ghtin

g. If

 not



     

     

     

 prov

ided,

 text

 embe

dding

s wil

l be 

gener

ated 

from 

`prom

pt` i

nput 

argum

ent.



     

     

  neg

ative

_prom

pt_em

beds 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

negat

ive t

ext e

mbedd

ings.

 Can 

be us

ed to

 easi

ly tw

eak t

ext i

nputs

, *e.

g.* p

rompt



     

     

     

 weig

hting

. If 

not p

rovid

ed, n

egati

ve_pr

ompt_

embed

s wil

l be 

gener

ated 

from 

`nega

tive_

promp

t` in

put



     

     

     

 argu

ment.



     

     

  out

put_t

ype (

`str`

, *op

tiona

l*, d

efaul

ts to

 `"pi

l"`):



     

     

     

 The 

outpu

t for

mat o

f the

 gene

rate 

image

. Cho

ose b

etwee

n



     

     

     

 [PIL

](htt

ps://

pillo

w.rea

dthed

ocs.i

o/en/

stabl

e/): 

`PIL.

Image

.Imag

e` or

 `np.

array

`.



     

     

  ret

urn_d

ict (

`bool

`, *o

ption

al*, 

defau

lts t

o `Tr

ue`):



     

     

     

 Whet

her o

r not

 to r

eturn

 a [`

~pipe

lines

.stab

le_di

ffusi

on.St

ableD

iffus

ionPi

pelin

eOutp

ut`] 

inste

ad of

 a



     

     

     

 plai

n tup

le.



     

     

  cal

lback

 (`Ca

llabl

e`, *

optio

nal*)

:



     

     

     

 A fu

nctio

n tha

t wil

l be 

calle

d eve

ry `c

allba

ck_st

eps` 

steps

 duri

ng in

feren

ce. T

he fu

nctio

n wil

l be



     

     

     

 call

ed wi

th th

e fol

lowin

g arg

ument

s: `c

allba

ck(st

ep: i

nt, t

imest

ep: i

nt, l

atent

s: to

rch.F

loatT

ensor

)`.



     

     

  cal

lback

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 1

):



     

     

     

 The 

frequ

ency 

at wh

ich t

he `c

allba

ck` f

uncti

on wi

ll be

 call

ed. I

f not

 spec

ified

, the

 call

back 

will 

be



     

     

     

 call

ed at

 ever

y ste

p.



     

     

  cro

ss_at

tenti

on_kw

args 

(`dic

t`, *

optio

nal*)

:



     

     

     

 A kw

args 

dicti

onary

 that

 if s

pecif

ied i

s pas

sed a

long 

to th

e `At

tenti

onPro

cesso

r` as

 defi

ned u

nder



     

     

     

 `sel

f.pro

cesso

r` in



     

     

     

 [dif

fuser

s.cro

ss_at

tenti

on](h

ttps:

//git

hub.c

om/hu

gging

face/

diffu

sers/

blob/

main/

src/d

iffus

ers/m

odels

/cros

s_att

entio

n.py)

.



     

     

  con

troln

et_co

nditi

oning

_scal

e (`f

loat`

 or `

List[

float

]`, *

optio

nal*,

 defa

ults 

to 1.

0):



     

     

     

 The 

outpu

ts of

 the 

contr

olnet

 are 

multi

plied

 by `

contr

olnet

_cond

ition

ing_s

cale`

 befo

re th

ey ar

e add

ed



     

     

     

 to t

he re

sidua

l in 

the o

rigin

al un

et. I

f mul

tiple

 Cont

rolNe

ts ar

e spe

cifie

d in 

init,

 you 

can s

et th

e



     

     

     

 corr

espon

ding 

scale

 as a

 list

.



     

     

  gue

ss_mo

de (`

bool`

, *op

tiona

l*, d

efaul

ts to

 `Fal

se`):



     

     

     

 In t

his m

ode, 

the C

ontro

lNet 

encod

er wi

ll tr

y bes

t to 

recog

nize 

the c

onten

t of 

the i

nput 

image

 even

 if



     

     

     

 you 

remov

e all

 prom

pts. 

The `

guida

nce_s

cale`

 betw

een 3

.0 an

d 5.0

 is r

ecomm

ended

.





     

   Ex

ample

s:





     

   Re

turns

:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] o

r `tu

ple`:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] i

f `re

turn_

dict`

 is T

rue, 

other

wise 

a `tu

ple.



     

     

  Whe

n ret

urnin

g a t

uple,

 the 

first

 elem

ent i

s a l

ist w

ith t

he ge

nerat

ed im

ages,

 and 

the s

econd

 elem

ent i

s a



     

     

  lis

t of 

`bool

`s de

notin

g whe

ther 

the c

orres

pondi

ng ge

nerat

ed im

age l

ikely

 repr

esent

s "no

t-saf

e-for

-work

"



     

     

  (ns

fw) c

onten

t, ac

cordi

ng to

 the 

`safe

ty_ch

ecker

`.



     

   ""

"



     

   # 

0. De

fault

 heig

ht an

d wid

th to

 unet



     

   # 

BEV: 

we ca

nnot 

use t

he si

ze of

 imag

e



     

   # 

heigh

t, wi

dth =

 self

._def

ault_

heigh

t_wid

th(he

ight,

 widt

h, No

ne)





     

   # 

1. Ch

eck i

nputs

. Rai

se er

ror i

f not

 corr

ect



     

   # 

we do

 not 

need 

this,

 only

 some

 type

 asse

rtion



     

   # 

self.

check

_inpu

ts(



     

   # 

    p

rompt

,



     

   # 

    i

mage,



     

   # 

    h

eight

,



     

   # 

    w

idth,



     

   # 

    c

allba

ck_st

eps,



     

   # 

    n

egati

ve_pr

ompt,



     

   # 

    p

rompt

_embe

ds,



     

   # 

    n

egati

ve_pr

ompt_

embed

s,



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

   # 

)





     

   # 

2. De

fine 

call 

param

eters



     

   # 

NOTE:

 we g

et ba

tch_s

ize f

irst 

from 

promp

t, th

en al

ign w

ith i

t.



     

   if

 prom

pt is

 not 

None 

and i

sinst

ance(

promp

t, st

r):



     

     

  bat

ch_si

ze = 

1



     

   el

if pr

ompt 

is no

t Non

e and

 isin

stanc

e(pro

mpt, 

list)

:



     

     

  bat

ch_si

ze = 

len(p

rompt

)



     

   el

se:



     

     

  bat

ch_si

ze = 

promp

t_emb

eds.s

hape[

0]





     

   de

vice 

= sel

f._ex

ecuti

on_de

vice



     

   # 

here 

`guid

ance_

scale

` is 

defin

ed an

alog 

to th

e gui

dance

 weig

ht `w

` of 

equat

ion (

2)



     

   # 

of th

e Ima

gen p

aper:

 http

s://a

rxiv.

org/p

df/22

05.11

487.p

df . 

`guid

ance_

scale

 = 1`



     

   # 

corre

spond

s to 

doing

 no c

lassi

fier 

free 

guida

nce.



     

   do

_clas

sifie

r_fre

e_gui

dance

 = gu

idanc

e_sca

le > 

1.0





     

   ##

# BEV

, che

ck ca

mera_

param

 ###



     

   if

 came

ra_pa

ram i

s Non

e:



     

     

  # u

se un

cond_

cam a

nd di

sable

 clas

sifie

r fre

e gui

dance



     

     

  N_c

am = 

6  # 

TODO:

 hard

-code

d



     

     

  cam

era_p

aram 

= sel

f.con

troln

et.un

cond_

cam_p

aram(

(batc

h_siz

e, N_

cam))



     

     

  do_

class

ifier

_free

_guid

ance 

= Fal

se



     

   ##

# don

e ###





     

   # 

if is

insta

nce(s

elf.c

ontro

lnet,

 Mult

iCont

rolNe

tMode

l) an

d isi

nstan

ce(co

ntrol

net_c

ondit

ionin

g_sca

le, f

loat)

:



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale =

 [con

troln

et_co

nditi

oning

_scal

e] * 

len(s

elf.c

ontro

lnet.

nets)





     

   # 

3. En

code 

input

 prom

pt



     

   # 

NOTE:

 here

 they

 use 

paddi

ng to

 77, 

is th

is ne

cessa

ry?



     

   pr

ompt_

embed

s = s

elf._

encod

e_pro

mpt(



     

     

  pro

mpt,



     

     

  dev

ice,



     

     

  num

_imag

es_pe

r_pro

mpt,



     

     

  do_

class

ifier

_free

_guid

ance,



     

     

  neg

ative

_prom

pt,



     

     

  pro

mpt_e

mbeds

=prom

pt_em

beds,



     

     

  neg

ative

_prom

pt_em

beds=

negat

ive_p

rompt

_embe

ds,



     

   ) 

 # (2

 * b,

 77 +

 1, 7

68)





     

   # 

4. Pr

epare

 imag

e



     

   # 

NOTE:

 if i

mage 

is no

t ten

sor, 

there

 will

 be s

evera

l pro

cess.



     

   as

sert 

not s

elf.c

ontro

l_ima

ge_pr

ocess

or.co

nfig.

do_no

rmali

ze, "

Your 

contr

olnet

 shou

ld no

t nor

maliz

e the

 cont

rol i

mage.

"



     

   im

age =

 self

.prep

are_i

mage(



     

     

  ima

ge=im

age,



     

     

  wid

th=wi

dth,



     

     

  hei

ght=h

eight

,



     

     

  bat

ch_si

ze=ba

tch_s

ize *

 num_

image

s_per

_prom

pt,



     

     

  num

_imag

es_pe

r_pro

mpt=n

um_im

ages_

per_p

rompt

,



     

     

  dev

ice=d

evice

,



     

     

  dty

pe=se

lf.co

ntrol

net.d

type,



     

     

  do_

class

ifier

_free

_guid

ance=

do_cl

assif

ier_f

ree_g

uidan

ce,



     

     

  gue

ss_mo

de=gu

ess_m

ode,



     

   ) 

 # (2

 * b,

 c_26

, 200

, 200

)



     

   if

 use_

zero_

map_a

s_unc

ondit

ional

 and 

do_cl

assif

ier_f

ree_g

uidan

ce:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  _im

ages[

0] = 

torch

.zero

s_lik

e(_im

ages[

0])



     

     

  ima

ge = 

torch

.cat(

_imag

es)





     

   # 

5. Pr

epare

 time

steps



     

   se

lf.sc

hedul

er.se

t_tim

estep

s(num

_infe

rence

_step

s, de

vice=

devic

e)



     

   ti

meste

ps = 

self.

sched

uler.

times

teps





     

   # 

6. Pr

epare

 late

nt va

riabl

es



     

   nu

m_cha

nnels

_late

nts =

 self

.unet

.conf

ig.in

_chan

nels



     

   la

tents

 = se

lf.pr

epare

_late

nts(



     

     

  bat

ch_si

ze * 

num_i

mages

_per_

promp

t,



     

     

  num

_chan

nels_

laten

ts,



     

     

  hei

ght,



     

     

  wid

th,



     

     

  pro

mpt_e

mbeds

.dtyp

e,



     

     

  dev

ice,



     

     

  gen

erato

r,



     

     

  lat

ents,

  # w

ill u

se if

 not 

None,

 othe

rwise

 will

 gene

rate



     

   ) 

 # (b

, c, 

h/8, 

w/8) 

-> (b

s, 4,

 28, 

50)





     

   # 

7. Pr

epare

 extr

a ste

p kwa

rgs.



     

   ex

tra_s

tep_k

wargs

 = se

lf.pr

epare

_extr

a_ste

p_kwa

rgs(g

enera

tor, 

eta)





     

   ##

#### 

BEV: 

here 

we re

const

ruct 

each 

input

 form

at ##

####



     

   as

sert 

camer

a_par

am.sh

ape[0

] == 

batch

_size

, \



     

     

  f"E

xcept

 {bat

ch_si

ze} c

amera

 para

ms, b

ut yo

u hav

e bs=

{len(

camer

a_par

am)}"



     

   N_

cam =

 came

ra_pa

ram.s

hape[

1]



     

   la

tents

 = to

rch.s

tack(

[late

nts] 

* N_c

am, d

im=1)

  # b

s, 6,

 4, 2

8, 50



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ca

mera_

param

 = ca

mera_

param

.to(s

elf.d

evice

)



     

   if

 do_c

lassi

fier_

free_

guida

nce a

nd no

t gue

ss_mo

de:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  kwa

rgs_w

ith_u

ncond

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_kw

args(



     

     

     

 came

ra_pa

ram=c

amera

_para

m,



     

     

     

 imag

e=_im

ages[

0],  

# 0 i

s for

 unco

nditi

onal



     

     

     

 max_

len=b

box_m

ax_le

ngth,



     

     

     

 **be

v_con

troln

et_kw

args,



     

     

  )



     

     

  kwa

rgs_w

ith_u

ncond

.pop(

"max_

len",

 None

)  # 

some 

do no

t tak

e thi

s.



     

     

  cam

era_p

aram 

= kwa

rgs_w

ith_u

ncond

.pop(

"came

ra_pa

ram")



     

     

  _im

ages[

0] = 

kwarg

s_wit

h_unc

ond.p

op("i

mage"

)



     

     

  ima

ge = 

torch

.cat(

_imag

es)



     

     

  bev

_cont

rolne

t_kwa

rgs =

 move

_to(k

wargs

_with

_unco

nd, s

elf.d

evice

)



     

   ##

#### 

BEV e

nd ##

####





     

   # 

8. De

noisi

ng lo

op



     

   nu

m_war

mup_s

teps 

= len

(time

steps

) - n

um_in

feren

ce_st

eps *

 self

.sche

duler

.orde

r



     

   wi

th se

lf.pr

ogres

s_bar

(tota

l=num

_infe

rence

_step

s) as

 prog

ress_

bar:



     

     

  for

 i, t

 in e

numer

ate(t

imest

eps):



     

     

     

 # ex

pand 

the l

atent

s if 

we ar

e doi

ng cl

assif

ier f

ree g

uidan

ce



     

     

     

 # bs

*2, 6

, 4, 

28, 5

0



     

     

     

 late

nt_mo

del_i

nput 

= (



     

     

     

     

torch

.cat(

[late

nts] 

* 2) 

if do

_clas

sifie

r_fre

e_gui

dance

 else

 late

nts



     

     

     

 )



     

     

     

 late

nt_mo

del_i

nput 

= sel

f.sch

edule

r.sca

le_mo

del_i

nput(



     

     

     

     

laten

t_mod

el_in

put, 

t



     

     

     

 )





     

     

     

 # co

ntrol

net(s

) inf

erenc

e



     

     

     

 cont

rolne

t_t =

 t.un

squee

ze(0)



     

     

     

 # gu

ess_m

ode &

 clas

sifie

r_fre

e_gui

dance

 -> o

nly g

uidan

ce us

e con

troln

et



     

     

     

 # no

t gue

ss_mo

de & 

class

ifier

_free

_guid

ance 

-> al

l use

 cont

rolne

t



     

     

     

 # gu

ess_m

ode -

> nor

mal i

nput,

 take

 effe

ct in

 cont

rolne

t



     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

er Co

ntrol

Net o

nly f

or th

e con

ditio

nal b

atch.



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ents



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds

.chun

k(2)[

1]



     

     

     

 else

:



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ent_m

odel_

input



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds



     

     

     

 cont

rolne

t_t =

 cont

rolne

t_t.r

epeat

(len(

contr

olnet

_late

nt_mo

del_i

nput)

)





     

     

     

 # fm

t: of

f



     

     

     

 down

_bloc

k_res

_samp

les, 

mid_b

lock_

res_s

ample

, \



     

     

     

 enco

der_h

idden

_stat

es_wi

th_ca

m = s

elf.c

ontro

lnet(



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput,



     

     

     

     

contr

olnet

_t,



     

     

     

     

camer

a_par

am,  

# for

 BEV



     

     

     

     

encod

er_hi

dden_

state

s=con

troln

et_pr

ompt_

embed

s,



     

     

     

     

contr

olnet

_cond

=imag

e,



     

     

     

     

condi

tioni

ng_sc

ale=c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

     

     

     

guess

_mode

=gues

s_mod

e,



     

     

     

     

retur

n_dic

t=Fal

se,



     

     

     

     

**bev

_cont

rolne

t_kwa

rgs, 

# for

 BEV



     

     

     

 )



     

     

     

 # fm

t: on





     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

ered 

Contr

olNet

 only

 for 

the c

ondit

ional

 batc

h.



     

     

     

     

# To 

apply

 the 

outpu

t of 

Contr

olNet

 to b

oth t

he un

condi

tiona

l and

 cond

ition

al ba

tches

,



     

     

     

     

# add

 0 to

 the 

uncon

ditio

nal b

atch 

to ke

ep it

 unch

anged

.



     

     

     

     

down_

block

_res_

sampl

es = 

[



     

     

     

     

    t

orch.

cat([

torch

.zero

s_lik

e(d),

 d])



     

     

     

     

    f

or d 

in do

wn_bl

ock_r

es_sa

mples



     

     

     

     

]



     

     

     

     

mid_b

lock_

res_s

ample

 = to

rch.c

at(



     

     

     

     

    [

torch

.zero

s_lik

e(mid

_bloc

k_res

_samp

le), 

mid_b

lock_

res_s

ample

]



     

     

     

     

)



     

     

     

     

# add

 unco

nd en

coder

_hidd

en_st

ates_

with_

cam h

ere



     

     

     

     

encod

er_hi

dden_

state

s_wit

h_cam

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_em

b(



     

     

     

     

    p

rompt

_embe

ds.ch

unk(2

)[0],

 N_ca

m,



     

     

     

     

    e

ncode

r_hid

den_s

tates

_with

_cam,



     

     

     

     

)





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # St

ratin

g fro

m her

e, we

 use 

4-dim

 data

.



     

     

     

 # en

coder

_hidd

en_st

ates_

with_

cam: 

(2b x

 N), 

78, 7

68



     

     

     

 # la

tent_

model

_inpu

t: 2b

, N, 

4, 28

, 50 

-> 2b

 x N,

 4, 2

8, 50



     

     

     

 late

nt_mo

del_i

nput 

= rea

rrang

e(



     

     

     

     

laten

t_mod

el_in

put, 

'b n 

... -

> (b 

n) ..

.')



     

     

     

 late

nts =

 rear

range

(late

nts, 

'b n 

... -

> (b 

n) ..

.')





     

     

     

 # pr

edict

 the 

noise

 resi

dual:

 2bxN

, 4, 

28, 5

0



     

     

     

 addi

tiona

l_par

am = 

{}



     

     

     

 nois

e_pre

d = s

elf.u

net(



     

     

     

     

laten

t_mod

el_in

put, 

 # ma

y wit

h unc

ondit

ional



     

     

     

     

t,



     

     

     

     

encod

er_hi

dden_

state

s=enc

oder_

hidde

n_sta

tes_w

ith_c

am,



     

     

     

     

**add

ition

al_pa

ram, 

 # if

 use 

origi

nal u

net, 

it ca

nnot 

take 

kwarg

s



     

     

     

     

cross

_atte

ntion

_kwar

gs=cr

oss_a

ttent

ion_k

wargs

,



     

     

     

     

down_

block

_addi

tiona

l_res

idual

s=dow

n_blo

ck_re

s_sam

ples,



     

     

     

     

mid_b

lock_

addit

ional

_resi

dual=

mid_b

lock_

res_s

ample

,



     

     

     

 ).sa

mple





     

     

     

 # pe

rform

 guid

ance



     

     

     

 if d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# for

 each

: bxN

, 4, 

28, 5

0



     

     

     

     

noise

_pred

_unco

nd, n

oise_

pred_

text 

= noi

se_pr

ed.ch

unk(2

)



     

     

     

     

noise

_pred

 = no

ise_p

red_u

ncond

 + gu

idanc

e_sca

le * 

(



     

     

     

     

    n

oise_

pred_

text 

- noi

se_pr

ed_un

cond



     

     

     

     

)





     

     

     

 # co

mpute

 the 

previ

ous n

oisy 

sampl

e x_t

 -> x

_t-1



     

     

     

 # NO

TE: i

s the

 sche

duler

 use 

rando

mness

, ple

ase h

andle

 the 

logic



     

     

     

 # fo

r gen

erato

r.



     

     

     

 late

nts =

 self

.sche

duler

.step

(



     

     

     

     

noise

_pred

, t, 

laten

ts, *

*extr

a_ste

p_kwa

rgs



     

     

     

 ).pr

ev_sa

mple





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # no

w we 

add d

imens

ion b

ack, 

use 5

-dim 

data.



     

     

     

 # NO

TE: o

nly `

laten

ts` i

s upd

ated 

throu

gh th

e loo

p



     

     

     

 late

nts =

 rear

range

(late

nts, 

'(b n

) ...

 -> b

 n ..

.', n

=N_ca

m)





     

     

     

 # ca

ll th

e cal

lback

, if 

provi

ded



     

     

     

 if i

 == l

en(ti

meste

ps) -

 1 or

 (



     

     

     

     

(i + 

1) > 

num_w

armup

_step

s and

 (i +

 1) %

 self

.sche

duler

.orde

r == 

0



     

     

     

 ):



     

     

     

     

progr

ess_b

ar.up

date(

)



     

     

     

     

if ca

llbac

k is 

not N

one a

nd i 

% cal

lback

_step

s == 

0:



     

     

     

     

    c

allba

ck(i,

 t, l

atent

s)





     

   ##

#### 

BEV: 

here 

rebui

ld th

e sha

pes b

ack. 

post-

proce

ss st

ill a

ssume



     

   # 

laten

ts, n

o nee

d for

 b, n

, 4, 

28, 5

0



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ##

### B

EV en

d





     

   # 

If we

 do s

equen

tial 

model

 offl

oadin

g, le

t's o

ffloa

d une

t and

 cont

rolne

t



     

   # 

manua

lly f

or ma

x mem

ory s

aving

s



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.une

t.to(

"cpu"

)



     

     

  sel

f.con

troln

et.to

("cpu

")



     

     

  tor

ch.cu

da.em

pty_c

ache(

)





     

   if

 outp

ut_ty

pe ==

 "lat

ent":



     

     

  ima

ge = 

laten

ts



     

     

  has

_nsfw

_conc

ept =

 None



     

   el

if ou

tput_

type 

== "p

il":



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

     

  # 1

0. Co

nvert

 to P

IL



     

     

  ima

ge = 

self.

numpy

_to_p

il_do

uble(

image

)



     

   el

se:



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

   # 

Offlo

ad la

st mo

del t

o CPU



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.fin

al_of

fload

_hook

.offl

oad()





     

   if

 not 

retur

n_dic

t:



     

     

  ret

urn (

image

, has

_nsfw

_conc

ept)





     

   re

turn 

BEVSt

ableD

iffus

ionPi

pelin

eOutp

ut(



     

     

  ima

ges=i

mage,

 nsfw

_cont

ent_d

etect

ed=ha

s_nsf

w_con

cept



     

   )



from 

datac

lasse

s imp

ort d

atacl

ass



from 

typin

g imp

ort A

ny, C

allab

le, D

ict, 

List,

 Opti

onal,

 Tupl

e, Un

ion



impor

t ins

pect





impor

t tor

ch



impor

t PIL



impor

t num

py as

 np



from 

einop

s imp

ort r

earra

nge





from 

diffu

sers 

impor

t Sta

bleDi

ffusi

onCon

trolN

etPip

eline



from 

diffu

sers.

utils

 impo

rt Ba

seOut

put



from 

diffu

sers.

image

_proc

essor

 impo

rt Va

eImag

eProc

essor



from 

diffu

sers.

model

s imp

ort A

utoen

coder

KL, U

Net2D

Condi

tionM

odel



from 

diffu

sers.

pipel

ines.

stabl

e_dif

fusio

n imp

ort S

table

Diffu

sionS

afety

Check

er



from 

diffu

sers.

sched

ulers

.sche

dulin

g_uti

ls im

port 

Karra

sDiff

usion

Sched

ulers



from 

trans

forme

rs im

port 

CLIPI

mageP

roces

sor, 

CLIPT

extMo

del, 

CLIPT

okeni

zer





from 

..mis

c.com

mon i

mport

 move

_to







@data

class



class

 BEVS

table

Diffu

sionP

ipeli

neOut

put(B

aseOu

tput)

:



    "

""



    O

utput

 clas

s for

 Stab

le Di

ffusi

on pi

pelin

es.





    A

rgs:



     

   im

ages 

(`Lis

t[PIL

.Imag

e.Ima

ge]` 

or `n

p.nda

rray`

)



     

     

  Lis

t of 

denoi

sed P

IL im

ages 

of le

ngth 

`batc

h_siz

e` or

 nump

y arr

ay of

 shap

e `(b

atch_

size,

 heig

ht, w

idth,



     

     

  num

_chan

nels)

`. PI

L ima

ges o

r num

py ar

ray p

resen

t the

 deno

ised 

image

s of 

the d

iffus

ion p

ipeli

ne.



     

   ns

fw_co

ntent

_dete

cted 

(`Lis

t[boo

l]`)



     

     

  Lis

t of 

flags

 deno

ting 

wheth

er th

e cor

respo

nding

 gene

rated

 imag

e lik

ely r

epres

ents 

"not-

safe-

for-w

ork"



     

     

  (ns

fw) c

onten

t, or

 `Non

e` if

 safe

ty ch

eckin

g cou

ld no

t be 

perfo

rmed.



    "

""





    i

mages

: Uni

on[Li

st[Li

st[PI

L.Ima

ge.Im

age]]

, np.

ndarr

ay]



    n

sfw_c

onten

t_det

ected

: Opt

ional

[List

[bool

]]







class

 Stab

leDif

fusio

nBEVC

ontro

lNetP

ipeli

ne(St

ableD

iffus

ionCo

ntrol

NetPi

pelin

e):



    d

ef __

init_

_(



     

   se

lf,



     

   va

e: Au

toenc

oderK

L,



     

   te

xt_en

coder

: CLI

PText

Model

,



     

   un

et: U

Net2D

Condi

tionM

odel,



     

   co

ntrol

net,



     

   sc

hedul

er: K

arras

Diffu

sionS

chedu

lers,



     

   to

keniz

er: C

LIPTo

keniz

er,



     

   sa

fety_

check

er: S

table

Diffu

sionS

afety

Check

er = 

None,



     

   fe

ature

_extr

actor

: CLI

PImag

eProc

essor

 = No

ne,



     

   re

quire

s_saf

ety_c

hecke

r: bo

ol = 

False

,



    )

:



     

   su

per()

.__in

it__(



     

     

  vae

,



     

     

  tex

t_enc

oder,



     

     

  tok

enize

r,



     

     

  une

t,



     

     

  con

troln

et,



     

     

  sch

edule

r,



     

     

  saf

ety_c

hecke

r,



     

     

  fea

ture_

extra

ctor,



     

     

  req

uires

_safe

ty_ch

ecker

,



     

   )



     

   as

sert 

safet

y_che

cker 

== No

ne, "

Pleas

e do 

not u

se sa

fety_

check

er."



     

   se

lf.co

ntrol

_imag

e_pro

cesso

r = V

aeIma

gePro

cesso

r(



     

     

  vae

_scal

e_fac

tor=s

elf.v

ae_sc

ale_f

actor

,



     

     

  do_

resiz

e=Fal

se,



     

     

  do_

conve

rt_rg

b=Fal

se,



     

     

  do_

norma

lize=

False

,



     

   )





    d

ef nu

mpy_t

o_pil

_doub

le(se

lf, i

mages

):



     

   ""

"



     

   Co

nvert

 a nu

mpy i

mage 

or a 

batch

 of i

mages

 to a

 PIL 

image

.



     

   We

 need

 to h

andle

 5-di

m inp

uts a

nd re

ture 

2-dim

 list

.



     

   ""

"



     

   im

gs_li

st = 

[]



     

   fo

r img

s in 

image

s:



     

     

  img

s_lis

t.app

end(s

elf.n

umpy_

to_pi

l(img

s))



     

   re

turn 

imgs_

list





    #

 Copi

ed fr

om di

ffuse

rs.pi

pelin

es.st

able_

diffu

sion.

pipel

ine_s

table

_diff

usion

.Stab

leDif

fusio

nPipe

line.

prepa

re_ex

tra_s

tep_k

wargs



    d

ef pr

epare

_extr

a_ste

p_kwa

rgs(s

elf, 

gener

ator,

 eta)

:



     

   # 

prepa

re ex

tra k

wargs

 for 

the s

chedu

ler s

tep, 

since

 not 

all s

chedu

lers 

have 

the s

ame s

ignat

ure



     

   # 

eta (

η) is

 only

 used

 with

 the 

DDIMS

chedu

ler, 

it wi

ll be

 igno

red f

or ot

her s

chedu

lers.



     

   # 

eta c

orres

ponds

 to η

 in D

DIM p

aper:

 http

s://a

rxiv.

org/a

bs/20

10.02

502



     

   # 

and s

hould

 be b

etwee

n [0,

 1]





     

   ac

cepts

_eta 

= "et

a" in

 set(

inspe

ct.si

gnatu

re(se

lf.sc

hedul

er.st

ep).p

arame

ters.

keys(

))



     

   ex

tra_s

tep_k

wargs

 = {}



     

   if

 acce

pts_e

ta:



     

     

  ext

ra_st

ep_kw

args[

"eta"

] = e

ta





     

   # 

check

 if t

he sc

hedul

er ac

cepts

 gene

rator



     

   ac

cepts

_gene

rator

 = "g

enera

tor" 

in se

t(ins

pect.

signa

ture(

self.

sched

uler.

step)

.para

meter

s.key

s())



     

   if

 acce

pts_g

enera

tor:



     

     

  rai

se Ru

ntime

Error

("If 

you f

ixed 

the l

ogic 

for g

enera

tor, 

pleas

e rem

ove t

his. 

Other

wise,

 plea

se us

e oth

er sa

mpler

.")



     

     

  ext

ra_st

ep_kw

args[

"gene

rator

"] = 

gener

ator



     

   re

turn 

extra

_step

_kwar

gs





    d

ef de

code_

laten

ts(se

lf, l

atent

s):



     

   # 

decod

e lat

ents 

with 

5-dim

s



     

   la

tents

 = 1 

/ sel

f.vae

.conf

ig.sc

aling

_fact

or * 

laten

ts





     

   bs

 = le

n(lat

ents)



     

   la

tents

 = re

arran

ge(la

tents

, 'b 

c ...

 -> (

b c) 

...')



     

   im

age =

 self

.vae.

decod

e(lat

ents)

.samp

le



     

   im

age =

 rear

range

(imag

e, '(

b c) 

... -

> b c

 ...'

, b=b

s)





     

   im

age =

 (ima

ge / 

2 + 0

.5).c

lamp(

0, 1)



     

   # 

we al

ways 

cast 

to fl

oat32

 as t

his d

oes n

ot ca

use s

ignif

icant

 over

head 

and i

s com

patib

le wi

th bf

loat1

6



     

   im

age =

 rear

range

(imag

e.cpu

(), '

... c

 h w 

-> ..

. h w

 c').

float

().nu

mpy()



     

   re

turn 

image





    @

torch

.no_g

rad()



    d

ef __

call_

_(



     

   se

lf,



     

   pr

ompt:

 Unio

n[str

, Lis

t[str

]],



     

   im

age: 

torch

.Floa

tTens

or,



     

   ca

mera_

param

: Uni

on[to

rch.T

ensor

, Non

e],



     

   he

ight:

 int,



     

   wi

dth: 

int,



     

   nu

m_inf

erenc

e_ste

ps: i

nt = 

50,



     

   gu

idanc

e_sca

le: f

loat 

= 7.5

,



     

   ne

gativ

e_pro

mpt: 

Optio

nal[U

nion[

str, 

List[

str]]

] = N

one,



     

   nu

m_ima

ges_p

er_pr

ompt:

 Opti

onal[

int] 

= 1,



     

   et

a: fl

oat =

 0.0,



     

   ge

nerat

or: O

ption

al[to

rch.G

enera

tor] 

= Non

e,



     

   la

tents

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   pr

ompt_

embed

s: Op

tiona

l[tor

ch.Fl

oatTe

nsor]

 = No

ne,



     

   ne

gativ

e_pro

mpt_e

mbeds

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   ou

tput_

type:

 Opti

onal[

str] 

= "pi

l",



     

   re

turn_

dict:

 bool

 = Tr

ue,



     

   ca

llbac

k: Op

tiona

l[Cal

lable

[[int

, int

, tor

ch.Fl

oatTe

nsor]

, Non

e]] =

 None

,



     

   ca

llbac

k_ste

ps: i

nt = 

1,



     

   cr

oss_a

ttent

ion_k

wargs

: Opt

ional

[Dict

[str,

 Any]

] = N

one,



     

   co

ntrol

net_c

ondit

ionin

g_sca

le: f

loat 

= 1,



     

   gu

ess_m

ode: 

bool 

= Fal

se,



     

   us

e_zer

o_map

_as_u

ncond

ition

al: b

ool =

 Fals

e,



     

   be

v_con

troln

et_kw

args 

= {},



     

   bb

ox_ma

x_len

gth =

 None

,



    )

:



     

   r"

""



     

   Fu

nctio

n inv

oked 

when 

calli

ng th

e pip

eline

 for 

gener

ation

.





     

   Ar

gs:



     

     

  pro

mpt (

`str`

 or `

List[

str]`

, *op

tiona

l*):



     

     

     

 The 

promp

t or 

promp

ts to

 guid

e the

 imag

e gen

erati

on. I

f not

 defi

ned, 

one h

as to

 pass

 `pro

mpt_e

mbeds

`.



     

     

     

 inst

ead.



     

     

  ima

ge (`

torch

.Floa

tTens

or`, 

`PIL.

Image

.Imag

e`, `

List[

torch

.Floa

tTens

or]`,

 `Lis

t[PIL

.Imag

e.Ima

ge]`,



     

     

     

     

`List

[List

[torc

h.Flo

atTen

sor]]

`, or

 `Lis

t[Lis

t[PIL

.Imag

e.Ima

ge]]`

):



     

     

     

 The 

Contr

olNet

 inpu

t con

ditio

n. Co

ntrol

Net u

ses t

his i

nput 

condi

tion 

to ge

nerat

e gui

dance

 to U

net. 

If



     

     

     

 the 

type 

is sp

ecifi

ed as

 `Tor

ch.Fl

oatTe

nsor`

, it 

is pa

ssed 

to Co

ntrol

Net a

s is.

 `PIL

.Imag

e.Ima

ge` c

an



     

     

     

 also

 be a

ccept

ed as

 an i

mage.

 The 

dimen

sions

 of t

he ou

tput 

image

 defa

ults 

to `i

mage`

's di

mensi

ons. 

If



     

     

     

 heig

ht an

d/or 

width

 are 

passe

d, `i

mage`

 is r

esize

d acc

ordin

g to 

them.

 If m

ultip

le Co

ntrol

Nets 

are



     

     

     

 spec

ified

 in i

nit, 

image

s mus

t be 

passe

d as 

a lis

t suc

h tha

t eac

h ele

ment 

of th

e lis

t can

 be c

orrec

tly



     

     

     

 batc

hed f

or in

put t

o a s

ingle

 cont

rolne

t.



     

     

  hei

ght (

`int`

, *op

tiona

l*, d

efaul

ts to

 self

.unet

.conf

ig.sa

mple_

size 

* sel

f.vae

_scal

e_fac

tor):



     

     

     

 The 

heigh

t in 

pixel

s of 

the g

enera

ted i

mage.



     

     

  wid

th (`

int`,

 *opt

ional

*, de

fault

s to 

self.

unet.

confi

g.sam

ple_s

ize *

 self

.vae_

scale

_fact

or):



     

     

     

 The 

width

 in p

ixels

 of t

he ge

nerat

ed im

age.



     

     

  num

_infe

rence

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 5

0):



     

     

     

 The 

numbe

r of 

denoi

sing 

steps

. Mor

e den

oisin

g ste

ps us

ually

 lead

 to a

 high

er qu

ality

 imag

e at 

the



     

     

     

 expe

nse o

f slo

wer i

nfere

nce.



     

     

  gui

dance

_scal

e (`f

loat`

, *op

tiona

l*, d

efaul

ts to

 7.5)

:



     

     

     

 Guid

ance 

scale

 as d

efine

d in 

[Clas

sifie

r-Fre

e Dif

fusio

n Gui

dance

](htt

ps://

arxiv

.org/

abs/2

207.1

2598)

.



     

     

     

 `gui

dance

_scal

e` is

 defi

ned a

s `w`

 of e

quati

on 2.

 of [

Image

n



     

     

     

 Pape

r](ht

tps:/

/arxi

v.org

/pdf/

2205.

11487

.pdf)

. Gui

dance

 scal

e is 

enabl

ed by

 sett

ing `

guida

nce_s

cale 

>



     

     

     

 1`. 

Highe

r gui

dance

 scal

e enc

ourag

es to

 gene

rate 

image

s tha

t are

 clos

ely l

inked

 to t

he te

xt `p

rompt

`,



     

     

     

 usua

lly a

t the

 expe

nse o

f low

er im

age q

ualit

y.



     

     

  neg

ative

_prom

pt (`

str` 

or `L

ist[s

tr]`,

 *opt

ional

*):



     

     

     

 The 

promp

t or 

promp

ts no

t to 

guide

 the 

image

 gene

ratio

n. If

 not 

defin

ed, o

ne ha

s to 

pass



     

     

     

 `neg

ative

_prom

pt_em

beds`

 inst

ead. 

Ignor

ed wh

en no

t usi

ng gu

idanc

e (i.

e., i

gnore

d if 

`guid

ance_

scale

` is



     

     

     

 less

 than

 `1`)

.



     

     

  num

_imag

es_pe

r_pro

mpt (

`int`

, *op

tiona

l*, d

efaul

ts to

 1):



     

     

     

 The 

numbe

r of 

image

s to 

gener

ate p

er pr

ompt.



     

     

  eta

 (`fl

oat`,

 *opt

ional

*, de

fault

s to 

0.0):



     

     

     

 Corr

espon

ds to

 para

meter

 eta 

(η) i

n the

 DDIM

 pape

r: ht

tps:/

/arxi

v.org

/abs/

2010.

02502

. Onl

y app

lies 

to



     

     

     

 [`sc

hedul

ers.D

DIMSc

hedul

er`],

 will

 be i

gnore

d for

 othe

rs.



     

     

  gen

erato

r (`t

orch.

Gener

ator`

 or `

List[

torch

.Gene

rator

]`, *

optio

nal*)

:



     

     

     

 One 

or a 

list 

of [t

orch 

gener

ator(

s)](h

ttps:

//pyt

orch.

org/d

ocs/s

table

/gene

rated

/torc

h.Gen

erato

r.htm

l)



     

     

     

 to m

ake g

enera

tion 

deter

minis

tic.



     

     

  lat

ents 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

noisy

 late

nts, 

sampl

ed fr

om a 

Gauss

ian d

istri

butio

n, to

 be u

sed a

s inp

uts f

or im

age



     

     

     

 gene

ratio

n. Ca

n be 

used 

to tw

eak t

he sa

me ge

nerat

ion w

ith d

iffer

ent p

rompt

s. If

 not 

provi

ded, 

a lat

ents



     

     

     

 tens

or wi

ll ge

 gene

rated

 by s

ampli

ng us

ing t

he su

pplie

d ran

dom `

gener

ator`

.



     

     

  pro

mpt_e

mbeds

 (`to

rch.F

loatT

ensor

`, *o

ption

al*):



     

     

     

 Pre-

gener

ated 

text 

embed

dings

. Can

 be u

sed t

o eas

ily t

weak 

text 

input

s, *e

.g.* 

promp

t wei

ghtin

g. If

 not



     

     

     

 prov

ided,

 text

 embe

dding

s wil

l be 

gener

ated 

from 

`prom

pt` i

nput 

argum

ent.



     

     

  neg

ative

_prom

pt_em

beds 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

negat

ive t

ext e

mbedd

ings.

 Can 

be us

ed to

 easi

ly tw

eak t

ext i

nputs

, *e.

g.* p

rompt



     

     

     

 weig

hting

. If 

not p

rovid

ed, n

egati

ve_pr

ompt_

embed

s wil

l be 

gener

ated 

from 

`nega

tive_

promp

t` in

put



     

     

     

 argu

ment.



     

     

  out

put_t

ype (

`str`

, *op

tiona

l*, d

efaul

ts to

 `"pi

l"`):



     

     

     

 The 

outpu

t for

mat o

f the

 gene

rate 

image

. Cho

ose b

etwee

n



     

     

     

 [PIL

](htt

ps://

pillo

w.rea

dthed

ocs.i

o/en/

stabl

e/): 

`PIL.

Image

.Imag

e` or

 `np.

array

`.



     

     

  ret

urn_d

ict (

`bool

`, *o

ption

al*, 

defau

lts t

o `Tr

ue`):



     

     

     

 Whet

her o

r not

 to r

eturn

 a [`

~pipe

lines

.stab

le_di

ffusi

on.St

ableD

iffus

ionPi

pelin

eOutp

ut`] 

inste

ad of

 a



     

     

     

 plai

n tup

le.



     

     

  cal

lback

 (`Ca

llabl

e`, *

optio

nal*)

:



     

     

     

 A fu

nctio

n tha

t wil

l be 

calle

d eve

ry `c

allba

ck_st

eps` 

steps

 duri

ng in

feren

ce. T

he fu

nctio

n wil

l be



     

     

     

 call

ed wi

th th

e fol

lowin

g arg

ument

s: `c

allba

ck(st

ep: i

nt, t

imest

ep: i

nt, l

atent

s: to

rch.F

loatT

ensor

)`.



     

     

  cal

lback

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 1

):



     

     

     

 The 

frequ

ency 

at wh

ich t

he `c

allba

ck` f

uncti

on wi

ll be

 call

ed. I

f not

 spec

ified

, the

 call

back 

will 

be



     

     

     

 call

ed at

 ever

y ste

p.



     

     

  cro

ss_at

tenti

on_kw

args 

(`dic

t`, *

optio

nal*)

:



     

     

     

 A kw

args 

dicti

onary

 that

 if s

pecif

ied i

s pas

sed a

long 

to th

e `At

tenti

onPro

cesso

r` as

 defi

ned u

nder



     

     

     

 `sel

f.pro

cesso

r` in



     

     

     

 [dif

fuser

s.cro

ss_at

tenti

on](h

ttps:

//git

hub.c

om/hu

gging

face/

diffu

sers/

blob/

main/

src/d

iffus

ers/m

odels

/cros

s_att

entio

n.py)

.



     

     

  con

troln

et_co

nditi

oning

_scal

e (`f

loat`

 or `

List[

float

]`, *

optio

nal*,

 defa

ults 

to 1.

0):



     

     

     

 The 

outpu

ts of

 the 

contr

olnet

 are 

multi

plied

 by `

contr

olnet

_cond

ition

ing_s

cale`

 befo

re th

ey ar

e add

ed



     

     

     

 to t

he re

sidua

l in 

the o

rigin

al un

et. I

f mul

tiple

 Cont

rolNe

ts ar

e spe

cifie

d in 

init,

 you 

can s

et th

e



     

     

     

 corr

espon

ding 

scale

 as a

 list

.



     

     

  gue

ss_mo

de (`

bool`

, *op

tiona

l*, d

efaul

ts to

 `Fal

se`):



     

     

     

 In t

his m

ode, 

the C

ontro

lNet 

encod

er wi

ll tr

y bes

t to 

recog

nize 

the c

onten

t of 

the i

nput 

image

 even

 if



     

     

     

 you 

remov

e all

 prom

pts. 

The `

guida

nce_s

cale`

 betw

een 3

.0 an

d 5.0

 is r

ecomm

ended

.





     

   Ex

ample

s:





     

   Re

turns

:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] o

r `tu

ple`:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] i

f `re

turn_

dict`

 is T

rue, 

other

wise 

a `tu

ple.



     

     

  Whe

n ret

urnin

g a t

uple,

 the 

first

 elem

ent i

s a l

ist w

ith t

he ge

nerat

ed im

ages,

 and 

the s

econd

 elem

ent i

s a



     

     

  lis

t of 

`bool

`s de

notin

g whe

ther 

the c

orres

pondi

ng ge

nerat

ed im

age l

ikely

 repr

esent

s "no

t-saf

e-for

-work

"



     

     

  (ns

fw) c

onten

t, ac

cordi

ng to

 the 

`safe

ty_ch

ecker

`.



     

   ""

"



     

   # 

0. De

fault

 heig

ht an

d wid

th to

 unet



     

   # 

BEV: 

we ca

nnot 

use t

he si

ze of

 imag

e



     

   # 

heigh

t, wi

dth =

 self

._def

ault_

heigh

t_wid

th(he

ight,

 widt

h, No

ne)





     

   # 

1. Ch

eck i

nputs

. Rai

se er

ror i

f not

 corr

ect



     

   # 

we do

 not 

need 

this,

 only

 some

 type

 asse

rtion



     

   # 

self.

check

_inpu

ts(



     

   # 

    p

rompt

,



     

   # 

    i

mage,



     

   # 

    h

eight

,



     

   # 

    w

idth,



     

   # 

    c

allba

ck_st

eps,



     

   # 

    n

egati

ve_pr

ompt,



     

   # 

    p

rompt

_embe

ds,



     

   # 

    n

egati

ve_pr

ompt_

embed

s,



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

   # 

)





     

   # 

2. De

fine 

call 

param

eters



     

   # 

NOTE:

 we g

et ba

tch_s

ize f

irst 

from 

promp

t, th

en al

ign w

ith i

t.



     

   if

 prom

pt is

 not 

None 

and i

sinst

ance(

promp

t, st

r):



     

     

  bat

ch_si

ze = 

1



     

   el

if pr

ompt 

is no

t Non

e and

 isin

stanc

e(pro

mpt, 

list)

:



     

     

  bat

ch_si

ze = 

len(p

rompt

)



     

   el

se:



     

     

  bat

ch_si

ze = 

promp

t_emb

eds.s

hape[

0]





     

   de

vice 

= sel

f._ex

ecuti

on_de

vice



     

   # 

here 

`guid

ance_

scale

` is 

defin

ed an

alog 

to th

e gui

dance

 weig

ht `w

` of 

equat

ion (

2)



     

   # 

of th

e Ima

gen p

aper:

 http

s://a

rxiv.

org/p

df/22

05.11

487.p

df . 

`guid

ance_

scale

 = 1`



     

   # 

corre

spond

s to 

doing

 no c

lassi

fier 

free 

guida

nce.



     

   do

_clas

sifie

r_fre

e_gui

dance

 = gu

idanc

e_sca

le > 

1.0





     

   ##

# BEV

, che

ck ca

mera_

param

 ###



     

   if

 came

ra_pa

ram i

s Non

e:



     

     

  # u

se un

cond_

cam a

nd di

sable

 clas

sifie

r fre

e gui

dance



     

     

  N_c

am = 

6  # 

TODO:

 hard

-code

d



     

     

  cam

era_p

aram 

= sel

f.con

troln

et.un

cond_

cam_p

aram(

(batc

h_siz

e, N_

cam))



     

     

  do_

class

ifier

_free

_guid

ance 

= Fal

se



     

   ##

# don

e ###





     

   # 

if is

insta

nce(s

elf.c

ontro

lnet,

 Mult

iCont

rolNe

tMode

l) an

d isi

nstan

ce(co

ntrol

net_c

ondit

ionin

g_sca

le, f

loat)

:



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale =

 [con

troln

et_co

nditi

oning

_scal

e] * 

len(s

elf.c

ontro

lnet.

nets)





     

   # 

3. En

code 

input

 prom

pt



     

   # 

NOTE:

 here

 they

 use 

paddi

ng to

 77, 

is th

is ne

cessa

ry?



     

   pr

ompt_

embed

s = s

elf._

encod

e_pro

mpt(



     

     

  pro

mpt,



     

     

  dev

ice,



     

     

  num

_imag

es_pe

r_pro

mpt,



     

     

  do_

class

ifier

_free

_guid

ance,



     

     

  neg

ative

_prom

pt,



     

     

  pro

mpt_e

mbeds

=prom

pt_em

beds,



     

     

  neg

ative

_prom

pt_em

beds=

negat

ive_p

rompt

_embe

ds,



     

   ) 

 # (2

 * b,

 77 +

 1, 7

68)





     

   # 

4. Pr

epare

 imag

e



     

   # 

NOTE:

 if i

mage 

is no

t ten

sor, 

there

 will

 be s

evera

l pro

cess.



     

   as

sert 

not s

elf.c

ontro

l_ima

ge_pr

ocess

or.co

nfig.

do_no

rmali

ze, "

Your 

contr

olnet

 shou

ld no

t nor

maliz

e the

 cont

rol i

mage.

"



     

   im

age =

 self

.prep

are_i

mage(



     

     

  ima

ge=im

age,



     

     

  wid

th=wi

dth,



     

     

  hei

ght=h

eight

,



     

     

  bat

ch_si

ze=ba

tch_s

ize *

 num_

image

s_per

_prom

pt,



     

     

  num

_imag

es_pe

r_pro

mpt=n

um_im

ages_

per_p

rompt

,



     

     

  dev

ice=d

evice

,



     

     

  dty

pe=se

lf.co

ntrol

net.d

type,



     

     

  do_

class

ifier

_free

_guid

ance=

do_cl

assif

ier_f

ree_g

uidan

ce,



     

     

  gue

ss_mo

de=gu

ess_m

ode,



     

   ) 

 # (2

 * b,

 c_26

, 200

, 200

)



     

   if

 use_

zero_

map_a

s_unc

ondit

ional

 and 

do_cl

assif

ier_f

ree_g

uidan

ce:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  _im

ages[

0] = 

torch

.zero

s_lik

e(_im

ages[

0])



     

     

  ima

ge = 

torch

.cat(

_imag

es)





     

   # 

5. Pr

epare

 time

steps



     

   se

lf.sc

hedul

er.se

t_tim

estep

s(num

_infe

rence

_step

s, de

vice=

devic

e)



     

   ti

meste

ps = 

self.

sched

uler.

times

teps





     

   # 

6. Pr

epare

 late

nt va

riabl

es



     

   nu

m_cha

nnels

_late

nts =

 self

.unet

.conf

ig.in

_chan

nels



     

   la

tents

 = se

lf.pr

epare

_late

nts(



     

     

  bat

ch_si

ze * 

num_i

mages

_per_

promp

t,



     

     

  num

_chan

nels_

laten

ts,



     

     

  hei

ght,



     

     

  wid

th,



     

     

  pro

mpt_e

mbeds

.dtyp

e,



     

     

  dev

ice,



     

     

  gen

erato

r,



     

     

  lat

ents,

  # w

ill u

se if

 not 

None,

 othe

rwise

 will

 gene

rate



     

   ) 

 # (b

, c, 

h/8, 

w/8) 

-> (b

s, 4,

 28, 

50)





     

   # 

7. Pr

epare

 extr

a ste

p kwa

rgs.



     

   ex

tra_s

tep_k

wargs

 = se

lf.pr

epare

_extr

a_ste

p_kwa

rgs(g

enera

tor, 

eta)





     

   ##

#### 

BEV: 

here 

we re

const

ruct 

each 

input

 form

at ##

####



     

   as

sert 

camer

a_par

am.sh

ape[0

] == 

batch

_size

, \



     

     

  f"E

xcept

 {bat

ch_si

ze} c

amera

 para

ms, b

ut yo

u hav

e bs=

{len(

camer

a_par

am)}"



     

   N_

cam =

 came

ra_pa

ram.s

hape[

1]



     

   la

tents

 = to

rch.s

tack(

[late

nts] 

* N_c

am, d

im=1)

  # b

s, 6,

 4, 2

8, 50



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ca

mera_

param

 = ca

mera_

param

.to(s

elf.d

evice

)



     

   if

 do_c

lassi

fier_

free_

guida

nce a

nd no

t gue

ss_mo

de:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  kwa

rgs_w

ith_u

ncond

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_kw

args(



     

     

     

 came

ra_pa

ram=c

amera

_para

m,



     

     

     

 imag

e=_im

ages[

0],  

# 0 i

s for

 unco

nditi

onal



     

     

     

 max_

len=b

box_m

ax_le

ngth,



     

     

     

 **be

v_con

troln

et_kw

args,



     

     

  )



     

     

  kwa

rgs_w

ith_u

ncond

.pop(

"max_

len",

 None

)  # 

some 

do no

t tak

e thi

s.



     

     

  cam

era_p

aram 

= kwa

rgs_w

ith_u

ncond

.pop(

"came

ra_pa

ram")



     

     

  _im

ages[

0] = 

kwarg

s_wit

h_unc

ond.p

op("i

mage"

)



     

     

  ima

ge = 

torch

.cat(

_imag

es)



     

     

  bev

_cont

rolne

t_kwa

rgs =

 move

_to(k

wargs

_with

_unco

nd, s

elf.d

evice

)



     

   ##

#### 

BEV e

nd ##

####





     

   # 

8. De

noisi

ng lo

op



     

   nu

m_war

mup_s

teps 

= len

(time

steps

) - n

um_in

feren

ce_st

eps *

 self

.sche

duler

.orde

r



     

   wi

th se

lf.pr

ogres

s_bar

(tota

l=num

_infe

rence

_step

s) as

 prog

ress_

bar:



     

     

  for

 i, t

 in e

numer

ate(t

imest

eps):



     

     

     

 # ex

pand 

the l

atent

s if 

we ar

e doi

ng cl

assif

ier f

ree g

uidan

ce



     

     

     

 # bs

*2, 6

, 4, 

28, 5

0



     

     

     

 late

nt_mo

del_i

nput 

= (



     

     

     

     

torch

.cat(

[late

nts] 

* 2) 

if do

_clas

sifie

r_fre

e_gui

dance

 else

 late

nts



     

     

     

 )



     

     

     

 late

nt_mo

del_i

nput 

= sel

f.sch

edule

r.sca

le_mo

del_i

nput(



     

     

     

     

laten

t_mod

el_in

put, 

t



     

     

     

 )





     

     

     

 # co

ntrol

net(s

) inf

erenc

e



     

     

     

 cont

rolne

t_t =

 t.un

squee

ze(0)



     

     

     

 # gu

ess_m

ode &

 clas

sifie

r_fre

e_gui

dance

 -> o

nly g

uidan

ce us

e con

troln

et



     

     

     

 # no

t gue

ss_mo

de & 

class

ifier

_free

_guid

ance 

-> al

l use

 cont

rolne

t



     

     

     

 # gu

ess_m

ode -

> nor

mal i

nput,

 take

 effe

ct in

 cont

rolne

t



     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

er Co

ntrol

Net o

nly f

or th

e con

ditio

nal b

atch.



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ents



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds

.chun

k(2)[

1]



     

     

     

 else

:



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ent_m

odel_

input



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds



     

     

     

 cont

rolne

t_t =

 cont

rolne

t_t.r

epeat

(len(

contr

olnet

_late

nt_mo

del_i

nput)

)





     

     

     

 # fm

t: of

f



     

     

     

 down

_bloc

k_res

_samp

les, 

mid_b

lock_

res_s

ample

, \



     

     

     

 enco

der_h

idden

_stat

es_wi

th_ca

m = s

elf.c

ontro

lnet(



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput,



     

     

     

     

contr

olnet

_t,



     

     

     

     

camer

a_par

am,  

# for

 BEV



     

     

     

     

encod

er_hi

dden_

state

s=con

troln

et_pr

ompt_

embed

s,



     

     

     

     

contr

olnet

_cond

=imag

e,



     

     

     

     

condi

tioni

ng_sc

ale=c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

     

     

     

guess

_mode

=gues

s_mod

e,



     

     

     

     

retur

n_dic

t=Fal

se,



     

     

     

     

**bev

_cont

rolne

t_kwa

rgs, 

# for

 BEV



     

     

     

 )



     

     

     

 # fm

t: on





     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

ered 

Contr

olNet

 only

 for 

the c

ondit

ional

 batc

h.



     

     

     

     

# To 

apply

 the 

outpu

t of 

Contr

olNet

 to b

oth t

he un

condi

tiona

l and

 cond

ition

al ba

tches

,



     

     

     

     

# add

 0 to

 the 

uncon

ditio

nal b

atch 

to ke

ep it

 unch

anged

.



     

     

     

     

down_

block

_res_

sampl

es = 

[



     

     

     

     

    t

orch.

cat([

torch

.zero

s_lik

e(d),

 d])



     

     

     

     

    f

or d 

in do

wn_bl

ock_r

es_sa

mples



     

     

     

     

]



     

     

     

     

mid_b

lock_

res_s

ample

 = to

rch.c

at(



     

     

     

     

    [

torch

.zero

s_lik

e(mid

_bloc

k_res

_samp

le), 

mid_b

lock_

res_s

ample

]



     

     

     

     

)



     

     

     

     

# add

 unco

nd en

coder

_hidd

en_st

ates_

with_

cam h

ere



     

     

     

     

encod

er_hi

dden_

state

s_wit

h_cam

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_em

b(



     

     

     

     

    p

rompt

_embe

ds.ch

unk(2

)[0],

 N_ca

m,



     

     

     

     

    e

ncode

r_hid

den_s

tates

_with

_cam,



     

     

     

     

)





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # St

ratin

g fro

m her

e, we

 use 

4-dim

 data

.



     

     

     

 # en

coder

_hidd

en_st

ates_

with_

cam: 

(2b x

 N), 

78, 7

68



     

     

     

 # la

tent_

model

_inpu

t: 2b

, N, 

4, 28

, 50 

-> 2b

 x N,

 4, 2

8, 50



     

     

     

 late

nt_mo

del_i

nput 

= rea

rrang

e(



     

     

     

     

laten

t_mod

el_in

put, 

'b n 

... -

> (b 

n) ..

.')



     

     

     

 late

nts =

 rear

range

(late

nts, 

'b n 

... -

> (b 

n) ..

.')





     

     

     

 # pr

edict

 the 

noise

 resi

dual:

 2bxN

, 4, 

28, 5

0



     

     

     

 addi

tiona

l_par

am = 

{}



     

     

     

 nois

e_pre

d = s

elf.u

net(



     

     

     

     

laten

t_mod

el_in

put, 

 # ma

y wit

h unc

ondit

ional



     

     

     

     

t,



     

     

     

     

encod

er_hi

dden_

state

s=enc

oder_

hidde

n_sta

tes_w

ith_c

am,



     

     

     

     

**add

ition

al_pa

ram, 

 # if

 use 

origi

nal u

net, 

it ca

nnot 

take 

kwarg

s



     

     

     

     

cross

_atte

ntion

_kwar

gs=cr

oss_a

ttent

ion_k

wargs

,



     

     

     

     

down_

block

_addi

tiona

l_res

idual

s=dow

n_blo

ck_re

s_sam

ples,



     

     

     

     

mid_b

lock_

addit

ional

_resi

dual=

mid_b

lock_

res_s

ample

,



     

     

     

 ).sa

mple





     

     

     

 # pe

rform

 guid

ance



     

     

     

 if d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# for

 each

: bxN

, 4, 

28, 5

0



     

     

     

     

noise

_pred

_unco

nd, n

oise_

pred_

text 

= noi

se_pr

ed.ch

unk(2

)



     

     

     

     

noise

_pred

 = no

ise_p

red_u

ncond

 + gu

idanc

e_sca

le * 

(



     

     

     

     

    n

oise_

pred_

text 

- noi

se_pr

ed_un

cond



     

     

     

     

)





     

     

     

 # co

mpute

 the 

previ

ous n

oisy 

sampl

e x_t

 -> x

_t-1



     

     

     

 # NO

TE: i

s the

 sche

duler

 use 

rando

mness

, ple

ase h

andle

 the 

logic



     

     

     

 # fo

r gen

erato

r.



     

     

     

 late

nts =

 self

.sche

duler

.step

(



     

     

     

     

noise

_pred

, t, 

laten

ts, *

*extr

a_ste

p_kwa

rgs



     

     

     

 ).pr

ev_sa

mple





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # no

w we 

add d

imens

ion b

ack, 

use 5

-dim 

data.



     

     

     

 # NO

TE: o

nly `

laten

ts` i

s upd

ated 

throu

gh th

e loo

p



     

     

     

 late

nts =

 rear

range

(late

nts, 

'(b n

) ...

 -> b

 n ..

.', n

=N_ca

m)





     

     

     

 # ca

ll th

e cal

lback

, if 

provi

ded



     

     

     

 if i

 == l

en(ti

meste

ps) -

 1 or

 (



     

     

     

     

(i + 

1) > 

num_w

armup

_step

s and

 (i +

 1) %

 self

.sche

duler

.orde

r == 

0



     

     

     

 ):



     

     

     

     

progr

ess_b

ar.up

date(

)



     

     

     

     

if ca

llbac

k is 

not N

one a

nd i 

% cal

lback

_step

s == 

0:



     

     

     

     

    c

allba

ck(i,

 t, l

atent

s)





     

   ##

#### 

BEV: 

here 

rebui

ld th

e sha

pes b

ack. 

post-

proce

ss st

ill a

ssume



     

   # 

laten

ts, n

o nee

d for

 b, n

, 4, 

28, 5

0



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ##

### B

EV en

d





     

   # 

If we

 do s

equen

tial 

model

 offl

oadin

g, le

t's o

ffloa

d une

t and

 cont

rolne

t



     

   # 

manua

lly f

or ma

x mem

ory s

aving

s



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.une

t.to(

"cpu"

)



     

     

  sel

f.con

troln

et.to

("cpu

")



     

     

  tor

ch.cu

da.em

pty_c

ache(

)





     

   if

 outp

ut_ty

pe ==

 "lat

ent":



     

     

  ima

ge = 

laten

ts



     

     

  has

_nsfw

_conc

ept =

 None



     

   el

if ou

tput_

type 

== "p

il":



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

     

  # 1

0. Co

nvert

 to P

IL



     

     

  ima

ge = 

self.

numpy

_to_p

il_do

uble(

image

)



     

   el

se:



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

   # 

Offlo

ad la

st mo

del t

o CPU



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.fin

al_of

fload

_hook

.offl

oad()





     

   if

 not 

retur

n_dic

t:



     

     

  ret

urn (

image

, has

_nsfw

_conc

ept)





     

   re

turn 

BEVSt

ableD

iffus

ionPi

pelin

eOutp

ut(



     

     

  ima

ges=i

mage,

 nsfw

_cont

ent_d

etect

ed=ha

s_nsf

w_con

cept



     

   )



from 

datac

lasse

s imp

ort d

atacl

ass



from 

typin

g imp

ort A

ny, C

allab

le, D

ict, 

List,

 Opti

onal,

 Tupl

e, Un

ion



impor

t ins

pect





impor

t tor

ch



impor

t PIL



impor

t num

py as

 np



from 

einop

s imp

ort r

earra

nge





from 

diffu

sers 

impor

t Sta

bleDi

ffusi

onCon

trolN

etPip

eline



from 

diffu

sers.

utils

 impo

rt Ba

seOut

put



from 

diffu

sers.

image

_proc

essor

 impo

rt Va

eImag

eProc

essor



from 

diffu

sers.

model

s imp

ort A

utoen

coder

KL, U

Net2D

Condi

tionM

odel



from 

diffu

sers.

pipel

ines.

stabl

e_dif

fusio

n imp

ort S

table

Diffu

sionS

afety

Check

er



from 

diffu

sers.

sched

ulers

.sche

dulin

g_uti

ls im

port 

Karra

sDiff

usion

Sched

ulers



from 

trans

forme

rs im

port 

CLIPI

mageP

roces

sor, 

CLIPT

extMo

del, 

CLIPT

okeni

zer





from 

..mis

c.com

mon i

mport

 move

_to







@data

class



class

 BEVS

table

Diffu

sionP

ipeli

neOut

put(B

aseOu

tput)

:



    "

""



    O

utput

 clas

s for

 Stab

le Di

ffusi

on pi

pelin

es.





    A

rgs:



     

   im

ages 

(`Lis

t[PIL

.Imag

e.Ima

ge]` 

or `n

p.nda

rray`

)



     

     

  Lis

t of 

denoi

sed P

IL im

ages 

of le

ngth 

`batc

h_siz

e` or

 nump

y arr

ay of

 shap

e `(b

atch_

size,

 heig

ht, w

idth,



     

     

  num

_chan

nels)

`. PI

L ima

ges o

r num

py ar

ray p

resen

t the

 deno

ised 

image

s of 

the d

iffus

ion p

ipeli

ne.



     

   ns

fw_co

ntent

_dete

cted 

(`Lis

t[boo

l]`)



     

     

  Lis

t of 

flags

 deno

ting 

wheth

er th

e cor

respo

nding

 gene

rated

 imag

e lik

ely r

epres

ents 

"not-

safe-

for-w

ork"



     

     

  (ns

fw) c

onten

t, or

 `Non

e` if

 safe

ty ch

eckin

g cou

ld no

t be 

perfo

rmed.



    "

""





    i

mages

: Uni

on[Li

st[Li

st[PI

L.Ima

ge.Im

age]]

, np.

ndarr

ay]



    n

sfw_c

onten

t_det

ected

: Opt

ional

[List

[bool

]]







class

 Stab

leDif

fusio

nBEVC

ontro

lNetP

ipeli

ne(St

ableD

iffus

ionCo

ntrol

NetPi

pelin

e):



    d

ef __

init_

_(



     

   se

lf,



     

   va

e: Au

toenc

oderK

L,



     

   te

xt_en

coder

: CLI

PText

Model

,



     

   un

et: U

Net2D

Condi

tionM

odel,



     

   co

ntrol

net,



     

   sc

hedul

er: K

arras

Diffu

sionS

chedu

lers,



     

   to

keniz

er: C

LIPTo

keniz

er,



     

   sa

fety_

check

er: S

table

Diffu

sionS

afety

Check

er = 

None,



     

   fe

ature

_extr

actor

: CLI

PImag

eProc

essor

 = No

ne,



     

   re

quire

s_saf

ety_c

hecke

r: bo

ol = 

False

,



    )

:



     

   su

per()

.__in

it__(



     

     

  vae

,



     

     

  tex

t_enc

oder,



     

     

  tok

enize

r,



     

     

  une

t,



     

     

  con

troln

et,



     

     

  sch

edule

r,



     

     

  saf

ety_c

hecke

r,



     

     

  fea

ture_

extra

ctor,



     

     

  req

uires

_safe

ty_ch

ecker

,



     

   )



     

   as

sert 

safet

y_che

cker 

== No

ne, "

Pleas

e do 

not u

se sa

fety_

check

er."



     

   se

lf.co

ntrol

_imag

e_pro

cesso

r = V

aeIma

gePro

cesso

r(



     

     

  vae

_scal

e_fac

tor=s

elf.v

ae_sc

ale_f

actor

,



     

     

  do_

resiz

e=Fal

se,



     

     

  do_

conve

rt_rg

b=Fal

se,



     

     

  do_

norma

lize=

False

,



     

   )





    d

ef nu

mpy_t

o_pil

_doub

le(se

lf, i

mages

):



     

   ""

"



     

   Co

nvert

 a nu

mpy i

mage 

or a 

batch

 of i

mages

 to a

 PIL 

image

.



     

   We

 need

 to h

andle

 5-di

m inp

uts a

nd re

ture 

2-dim

 list

.



     

   ""

"



     

   im

gs_li

st = 

[]



     

   fo

r img

s in 

image

s:



     

     

  img

s_lis

t.app

end(s

elf.n

umpy_

to_pi

l(img

s))



     

   re

turn 

imgs_

list





    #

 Copi

ed fr

om di

ffuse

rs.pi

pelin

es.st

able_

diffu

sion.

pipel

ine_s

table

_diff

usion

.Stab

leDif

fusio

nPipe

line.

prepa

re_ex

tra_s

tep_k

wargs



    d

ef pr

epare

_extr

a_ste

p_kwa

rgs(s

elf, 

gener

ator,

 eta)

:



     

   # 

prepa

re ex

tra k

wargs

 for 

the s

chedu

ler s

tep, 

since

 not 

all s

chedu

lers 

have 

the s

ame s

ignat

ure



     

   # 

eta (

η) is

 only

 used

 with

 the 

DDIMS

chedu

ler, 

it wi

ll be

 igno

red f

or ot

her s

chedu

lers.



     

   # 

eta c

orres

ponds

 to η

 in D

DIM p

aper:

 http

s://a

rxiv.

org/a

bs/20

10.02

502



     

   # 

and s

hould

 be b

etwee

n [0,

 1]





     

   ac

cepts

_eta 

= "et

a" in

 set(

inspe

ct.si

gnatu

re(se

lf.sc

hedul

er.st

ep).p

arame

ters.

keys(

))



     

   ex

tra_s

tep_k

wargs

 = {}



     

   if

 acce

pts_e

ta:



     

     

  ext

ra_st

ep_kw

args[

"eta"

] = e

ta





     

   # 

check

 if t

he sc

hedul

er ac

cepts

 gene

rator



     

   ac

cepts

_gene

rator

 = "g

enera

tor" 

in se

t(ins

pect.

signa

ture(

self.

sched

uler.

step)

.para

meter

s.key

s())



     

   if

 acce

pts_g

enera

tor:



     

     

  rai

se Ru

ntime

Error

("If 

you f

ixed 

the l

ogic 

for g

enera

tor, 

pleas

e rem

ove t

his. 

Other

wise,

 plea

se us

e oth

er sa

mpler

.")



     

     

  ext

ra_st

ep_kw

args[

"gene

rator

"] = 

gener

ator



     

   re

turn 

extra

_step

_kwar

gs





    d

ef de

code_

laten

ts(se

lf, l

atent

s):



     

   # 

decod

e lat

ents 

with 

5-dim

s



     

   la

tents

 = 1 

/ sel

f.vae

.conf

ig.sc

aling

_fact

or * 

laten

ts





     

   bs

 = le

n(lat

ents)



     

   la

tents

 = re

arran

ge(la

tents

, 'b 

c ...

 -> (

b c) 

...')



     

   im

age =

 self

.vae.

decod

e(lat

ents)

.samp

le



     

   im

age =

 rear

range

(imag

e, '(

b c) 

... -

> b c

 ...'

, b=b

s)





     

   im

age =

 (ima

ge / 

2 + 0

.5).c

lamp(

0, 1)



     

   # 

we al

ways 

cast 

to fl

oat32

 as t

his d

oes n

ot ca

use s

ignif

icant

 over

head 

and i

s com

patib

le wi

th bf

loat1

6



     

   im

age =

 rear

range

(imag

e.cpu

(), '

... c

 h w 

-> ..

. h w

 c').

float

().nu

mpy()



     

   re

turn 

image





    @

torch

.no_g

rad()



    d

ef __

call_

_(



     

   se

lf,



     

   pr

ompt:

 Unio

n[str

, Lis

t[str

]],



     

   im

age: 

torch

.Floa

tTens

or,



     

   ca

mera_

param

: Uni

on[to

rch.T

ensor

, Non

e],



     

   he

ight:

 int,



     

   wi

dth: 

int,



     

   nu

m_inf

erenc

e_ste

ps: i

nt = 

50,



     

   gu

idanc

e_sca

le: f

loat 

= 7.5

,



     

   ne

gativ

e_pro

mpt: 

Optio

nal[U

nion[

str, 

List[

str]]

] = N

one,



     

   nu

m_ima

ges_p

er_pr

ompt:

 Opti

onal[

int] 

= 1,



     

   et

a: fl

oat =

 0.0,



     

   ge

nerat

or: O

ption

al[to

rch.G

enera

tor] 

= Non

e,



     

   la

tents

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   pr

ompt_

embed

s: Op

tiona

l[tor

ch.Fl

oatTe

nsor]

 = No

ne,



     

   ne

gativ

e_pro

mpt_e

mbeds

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   ou

tput_

type:

 Opti

onal[

str] 

= "pi

l",



     

   re

turn_

dict:

 bool

 = Tr

ue,



     

   ca

llbac

k: Op

tiona

l[Cal

lable

[[int

, int

, tor

ch.Fl

oatTe

nsor]

, Non

e]] =

 None

,



     

   ca

llbac

k_ste

ps: i

nt = 

1,



     

   cr

oss_a

ttent

ion_k

wargs

: Opt

ional

[Dict

[str,

 Any]

] = N

one,



     

   co

ntrol

net_c

ondit

ionin

g_sca

le: f

loat 

= 1,



     

   gu

ess_m

ode: 

bool 

= Fal

se,



     

   us

e_zer

o_map

_as_u

ncond

ition

al: b

ool =

 Fals

e,



     

   be

v_con

troln

et_kw

args 

= {},



     

   bb

ox_ma

x_len

gth =

 None

,



    )

:



     

   r"

""



     

   Fu

nctio

n inv

oked 

when 

calli

ng th

e pip

eline

 for 

gener

ation

.





     

   Ar

gs:



     

     

  pro

mpt (

`str`

 or `

List[

str]`

, *op

tiona

l*):



     

     

     

 The 

promp

t or 

promp

ts to

 guid

e the

 imag

e gen

erati

on. I

f not

 defi

ned, 

one h

as to

 pass

 `pro

mpt_e

mbeds

`.



     

     

     

 inst

ead.



     

     

  ima

ge (`

torch

.Floa

tTens

or`, 

`PIL.

Image

.Imag

e`, `

List[

torch

.Floa

tTens

or]`,

 `Lis

t[PIL

.Imag

e.Ima

ge]`,



     

     

     

     

`List

[List

[torc

h.Flo

atTen

sor]]

`, or

 `Lis

t[Lis

t[PIL

.Imag

e.Ima

ge]]`

):



     

     

     

 The 

Contr

olNet

 inpu

t con

ditio

n. Co

ntrol

Net u

ses t

his i

nput 

condi

tion 

to ge

nerat

e gui

dance

 to U

net. 

If



     

     

     

 the 

type 

is sp

ecifi

ed as

 `Tor

ch.Fl

oatTe

nsor`

, it 

is pa

ssed 

to Co

ntrol

Net a

s is.

 `PIL

.Imag

e.Ima

ge` c

an



     

     

     

 also

 be a

ccept

ed as

 an i

mage.

 The 

dimen

sions

 of t

he ou

tput 

image

 defa

ults 

to `i

mage`

's di

mensi

ons. 

If



     

     

     

 heig

ht an

d/or 

width

 are 

passe

d, `i

mage`

 is r

esize

d acc

ordin

g to 

them.

 If m

ultip

le Co

ntrol

Nets 

are



     

     

     

 spec

ified

 in i

nit, 

image

s mus

t be 

passe

d as 

a lis

t suc

h tha

t eac

h ele

ment 

of th

e lis

t can

 be c

orrec

tly



     

     

     

 batc

hed f

or in

put t

o a s

ingle

 cont

rolne

t.



     

     

  hei

ght (

`int`

, *op

tiona

l*, d

efaul

ts to

 self

.unet

.conf

ig.sa

mple_

size 

* sel

f.vae

_scal

e_fac

tor):



     

     

     

 The 

heigh

t in 

pixel

s of 

the g

enera

ted i

mage.



     

     

  wid

th (`

int`,

 *opt

ional

*, de

fault

s to 

self.

unet.

confi

g.sam

ple_s

ize *

 self

.vae_

scale

_fact

or):



     

     

     

 The 

width

 in p

ixels

 of t

he ge

nerat

ed im

age.



     

     

  num

_infe

rence

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 5

0):



     

     

     

 The 

numbe

r of 

denoi

sing 

steps

. Mor

e den

oisin

g ste

ps us

ually

 lead

 to a

 high

er qu

ality

 imag

e at 

the



     

     

     

 expe

nse o

f slo

wer i

nfere

nce.



     

     

  gui

dance

_scal

e (`f

loat`

, *op

tiona

l*, d

efaul

ts to

 7.5)

:



     

     

     

 Guid

ance 

scale

 as d

efine

d in 

[Clas

sifie

r-Fre

e Dif

fusio

n Gui

dance

](htt

ps://

arxiv

.org/

abs/2

207.1

2598)

.



     

     

     

 `gui

dance

_scal

e` is

 defi

ned a

s `w`

 of e

quati

on 2.

 of [

Image

n



     

     

     

 Pape

r](ht

tps:/

/arxi

v.org

/pdf/

2205.

11487

.pdf)

. Gui

dance

 scal

e is 

enabl

ed by

 sett

ing `

guida

nce_s

cale 

>



     

     

     

 1`. 

Highe

r gui

dance

 scal

e enc

ourag

es to

 gene

rate 

image

s tha

t are

 clos

ely l

inked

 to t

he te

xt `p

rompt

`,



     

     

     

 usua

lly a

t the

 expe

nse o

f low

er im

age q

ualit

y.



     

     

  neg

ative

_prom

pt (`

str` 

or `L

ist[s

tr]`,

 *opt

ional

*):



     

     

     

 The 

promp

t or 

promp

ts no

t to 

guide

 the 

image

 gene

ratio

n. If

 not 

defin

ed, o

ne ha

s to 

pass



     

     

     

 `neg

ative

_prom

pt_em

beds`

 inst

ead. 

Ignor

ed wh

en no

t usi

ng gu

idanc

e (i.

e., i

gnore

d if 

`guid

ance_

scale

` is



     

     

     

 less

 than

 `1`)

.



     

     

  num

_imag

es_pe

r_pro

mpt (

`int`

, *op

tiona

l*, d

efaul

ts to

 1):



     

     

     

 The 

numbe

r of 

image

s to 

gener

ate p

er pr

ompt.



     

     

  eta

 (`fl

oat`,

 *opt

ional

*, de

fault

s to 

0.0):



     

     

     

 Corr

espon

ds to

 para

meter

 eta 

(η) i

n the

 DDIM

 pape

r: ht

tps:/

/arxi

v.org

/abs/

2010.

02502

. Onl

y app

lies 

to



     

     

     

 [`sc

hedul

ers.D

DIMSc

hedul

er`],

 will

 be i

gnore

d for

 othe

rs.



     

     

  gen

erato

r (`t

orch.

Gener

ator`

 or `

List[

torch

.Gene

rator

]`, *

optio

nal*)

:



     

     

     

 One 

or a 

list 

of [t

orch 

gener

ator(

s)](h

ttps:

//pyt

orch.

org/d

ocs/s

table

/gene

rated

/torc

h.Gen

erato

r.htm

l)



     

     

     

 to m

ake g

enera

tion 

deter

minis

tic.



     

     

  lat

ents 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

noisy

 late

nts, 

sampl

ed fr

om a 

Gauss

ian d

istri

butio

n, to

 be u

sed a

s inp

uts f

or im

age



     

     

     

 gene

ratio

n. Ca

n be 

used 

to tw

eak t

he sa

me ge

nerat

ion w

ith d

iffer

ent p

rompt

s. If

 not 

provi

ded, 

a lat

ents



     

     

     

 tens

or wi

ll ge

 gene

rated

 by s

ampli

ng us

ing t

he su

pplie

d ran

dom `

gener

ator`

.



     

     

  pro

mpt_e

mbeds

 (`to

rch.F

loatT

ensor

`, *o

ption

al*):



     

     

     

 Pre-

gener

ated 

text 

embed

dings

. Can

 be u

sed t

o eas

ily t

weak 

text 

input

s, *e

.g.* 

promp

t wei

ghtin

g. If

 not



     

     

     

 prov

ided,

 text

 embe

dding

s wil

l be 

gener

ated 

from 

`prom

pt` i

nput 

argum

ent.



     

     

  neg

ative

_prom

pt_em

beds 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

negat

ive t

ext e

mbedd

ings.

 Can 

be us

ed to

 easi

ly tw

eak t

ext i

nputs

, *e.

g.* p

rompt



     

     

     

 weig

hting

. If 

not p

rovid

ed, n

egati

ve_pr

ompt_

embed

s wil

l be 

gener

ated 

from 

`nega

tive_

promp

t` in

put



     

     

     

 argu

ment.



     

     

  out

put_t

ype (

`str`

, *op

tiona

l*, d

efaul

ts to

 `"pi

l"`):



     

     

     

 The 

outpu

t for

mat o

f the

 gene

rate 

image

. Cho

ose b

etwee

n



     

     

     

 [PIL

](htt

ps://

pillo

w.rea

dthed

ocs.i

o/en/

stabl

e/): 

`PIL.

Image

.Imag

e` or

 `np.

array

`.



     

     

  ret

urn_d

ict (

`bool

`, *o

ption

al*, 

defau

lts t

o `Tr

ue`):



     

     

     

 Whet

her o

r not

 to r

eturn

 a [`

~pipe

lines

.stab

le_di

ffusi

on.St

ableD

iffus

ionPi

pelin

eOutp

ut`] 

inste

ad of

 a



     

     

     

 plai

n tup

le.



     

     

  cal

lback

 (`Ca

llabl

e`, *

optio

nal*)

:



     

     

     

 A fu

nctio

n tha

t wil

l be 

calle

d eve

ry `c

allba

ck_st

eps` 

steps

 duri

ng in

feren

ce. T

he fu

nctio

n wil

l be



     

     

     

 call

ed wi

th th

e fol

lowin

g arg

ument

s: `c

allba

ck(st

ep: i

nt, t

imest

ep: i

nt, l

atent

s: to

rch.F

loatT

ensor

)`.



     

     

  cal

lback

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 1

):



     

     

     

 The 

frequ

ency 

at wh

ich t

he `c

allba

ck` f

uncti

on wi

ll be

 call

ed. I

f not

 spec

ified

, the

 call

back 

will 

be



     

     

     

 call

ed at

 ever

y ste

p.



     

     

  cro

ss_at

tenti

on_kw

args 

(`dic

t`, *

optio

nal*)

:



     

     

     

 A kw

args 

dicti

onary

 that

 if s

pecif

ied i

s pas

sed a

long 

to th

e `At

tenti

onPro

cesso

r` as

 defi

ned u

nder



     

     

     

 `sel

f.pro

cesso

r` in



     

     

     

 [dif

fuser

s.cro

ss_at

tenti

on](h

ttps:

//git

hub.c

om/hu

gging

face/

diffu

sers/

blob/

main/

src/d

iffus

ers/m

odels

/cros

s_att

entio

n.py)

.



     

     

  con

troln

et_co

nditi

oning

_scal

e (`f

loat`

 or `

List[

float

]`, *

optio

nal*,

 defa

ults 

to 1.

0):



     

     

     

 The 

outpu

ts of

 the 

contr

olnet

 are 

multi

plied

 by `

contr

olnet

_cond

ition

ing_s

cale`

 befo

re th

ey ar

e add

ed



     

     

     

 to t

he re

sidua

l in 

the o

rigin

al un

et. I

f mul

tiple

 Cont

rolNe

ts ar

e spe

cifie

d in 

init,

 you 

can s

et th

e



     

     

     

 corr

espon

ding 

scale

 as a

 list

.



     

     

  gue

ss_mo

de (`

bool`

, *op

tiona

l*, d

efaul

ts to

 `Fal

se`):



     

     

     

 In t

his m

ode, 

the C

ontro

lNet 

encod

er wi

ll tr

y bes

t to 

recog

nize 

the c

onten

t of 

the i

nput 

image

 even

 if



     

     

     

 you 

remov

e all

 prom

pts. 

The `

guida

nce_s

cale`

 betw

een 3

.0 an

d 5.0

 is r

ecomm

ended

.





     

   Ex

ample

s:





     

   Re

turns

:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] o

r `tu

ple`:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] i

f `re

turn_

dict`

 is T

rue, 

other

wise 

a `tu

ple.



     

     

  Whe

n ret

urnin

g a t

uple,

 the 

first

 elem

ent i

s a l

ist w

ith t

he ge

nerat

ed im

ages,

 and 

the s

econd

 elem

ent i

s a



     

     

  lis

t of 

`bool

`s de

notin

g whe

ther 

the c

orres

pondi

ng ge

nerat

ed im

age l

ikely

 repr

esent

s "no

t-saf

e-for

-work

"



     

     

  (ns

fw) c

onten

t, ac

cordi

ng to

 the 

`safe

ty_ch

ecker

`.



     

   ""

"



     

   # 

0. De

fault

 heig

ht an

d wid

th to

 unet



     

   # 

BEV: 

we ca

nnot 

use t

he si

ze of

 imag

e



     

   # 

heigh

t, wi

dth =

 self

._def

ault_

heigh

t_wid

th(he

ight,

 widt

h, No

ne)





     

   # 

1. Ch

eck i

nputs

. Rai

se er

ror i

f not

 corr

ect



     

   # 

we do

 not 

need 

this,

 only

 some

 type

 asse

rtion



     

   # 

self.

check

_inpu

ts(



     

   # 

    p

rompt

,



     

   # 

    i

mage,



     

   # 

    h

eight

,



     

   # 

    w

idth,



     

   # 

    c

allba

ck_st

eps,



     

   # 

    n

egati

ve_pr

ompt,



     

   # 

    p

rompt

_embe

ds,



     

   # 

    n

egati

ve_pr

ompt_

embed

s,



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

   # 

)





     

   # 

2. De

fine 

call 

param

eters



     

   # 

NOTE:

 we g

et ba

tch_s

ize f

irst 

from 

promp

t, th

en al

ign w

ith i

t.



     

   if

 prom

pt is

 not 

None 

and i

sinst

ance(

promp

t, st

r):



     

     

  bat

ch_si

ze = 

1



     

   el

if pr

ompt 

is no

t Non

e and

 isin

stanc

e(pro

mpt, 

list)

:



     

     

  bat

ch_si

ze = 

len(p

rompt

)



     

   el

se:



     

     

  bat

ch_si

ze = 

promp

t_emb

eds.s

hape[

0]





     

   de

vice 

= sel

f._ex

ecuti

on_de

vice



     

   # 

here 

`guid

ance_

scale

` is 

defin

ed an

alog 

to th

e gui

dance

 weig

ht `w

` of 

equat

ion (

2)



     

   # 

of th

e Ima

gen p

aper:

 http

s://a

rxiv.

org/p

df/22

05.11

487.p

df . 

`guid

ance_

scale

 = 1`



     

   # 

corre

spond

s to 

doing

 no c

lassi

fier 

free 

guida

nce.



     

   do

_clas

sifie

r_fre

e_gui

dance

 = gu

idanc

e_sca

le > 

1.0





     

   ##

# BEV

, che

ck ca

mera_

param

 ###



     

   if

 came

ra_pa

ram i

s Non

e:



     

     

  # u

se un

cond_

cam a

nd di

sable

 clas

sifie

r fre

e gui

dance



     

     

  N_c

am = 

6  # 

TODO:

 hard

-code

d



     

     

  cam

era_p

aram 

= sel

f.con

troln

et.un

cond_

cam_p

aram(

(batc

h_siz

e, N_

cam))



     

     

  do_

class

ifier

_free

_guid

ance 

= Fal

se



     

   ##

# don

e ###





     

   # 

if is

insta

nce(s

elf.c

ontro

lnet,

 Mult

iCont

rolNe

tMode

l) an

d isi

nstan

ce(co

ntrol

net_c

ondit

ionin

g_sca

le, f

loat)

:



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale =

 [con

troln

et_co

nditi

oning

_scal

e] * 

len(s

elf.c

ontro

lnet.

nets)





     

   # 

3. En

code 

input

 prom

pt



     

   # 

NOTE:

 here

 they

 use 

paddi

ng to

 77, 

is th

is ne

cessa

ry?



     

   pr

ompt_

embed

s = s

elf._

encod

e_pro

mpt(



     

     

  pro

mpt,



     

     

  dev

ice,



     

     

  num

_imag

es_pe

r_pro

mpt,



     

     

  do_

class

ifier

_free

_guid

ance,



     

     

  neg

ative

_prom

pt,



     

     

  pro

mpt_e

mbeds

=prom

pt_em

beds,



     

     

  neg

ative

_prom

pt_em

beds=

negat

ive_p

rompt

_embe

ds,



     

   ) 

 # (2

 * b,

 77 +

 1, 7

68)





     

   # 

4. Pr

epare

 imag

e



     

   # 

NOTE:

 if i

mage 

is no

t ten

sor, 

there

 will

 be s

evera

l pro

cess.



     

   as

sert 

not s

elf.c

ontro

l_ima

ge_pr

ocess

or.co

nfig.

do_no

rmali

ze, "

Your 

contr

olnet

 shou

ld no

t nor

maliz

e the

 cont

rol i

mage.

"



     

   im

age =

 self

.prep

are_i

mage(



     

     

  ima

ge=im

age,



     

     

  wid

th=wi

dth,



     

     

  hei

ght=h

eight

,



     

     

  bat

ch_si

ze=ba

tch_s

ize *

 num_

image

s_per

_prom

pt,



     

     

  num

_imag

es_pe

r_pro

mpt=n

um_im

ages_

per_p

rompt

,



     

     

  dev

ice=d

evice

,



     

     

  dty

pe=se

lf.co

ntrol

net.d

type,



     

     

  do_

class

ifier

_free

_guid

ance=

do_cl

assif

ier_f

ree_g

uidan

ce,



     

     

  gue

ss_mo

de=gu

ess_m

ode,



     

   ) 

 # (2

 * b,

 c_26

, 200

, 200

)



     

   if

 use_

zero_

map_a

s_unc

ondit

ional

 and 

do_cl

assif

ier_f

ree_g

uidan

ce:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  _im

ages[

0] = 

torch

.zero

s_lik

e(_im

ages[

0])



     

     

  ima

ge = 

torch

.cat(

_imag

es)





     

   # 

5. Pr

epare

 time

steps



     

   se

lf.sc

hedul

er.se

t_tim

estep

s(num

_infe

rence

_step

s, de

vice=

devic

e)



     

   ti

meste

ps = 

self.

sched

uler.

times

teps





     

   # 

6. Pr

epare

 late

nt va

riabl

es



     

   nu

m_cha

nnels

_late

nts =

 self

.unet

.conf

ig.in

_chan

nels



     

   la

tents

 = se

lf.pr

epare

_late

nts(



     

     

  bat

ch_si

ze * 

num_i

mages

_per_

promp

t,



     

     

  num

_chan

nels_

laten

ts,



     

     

  hei

ght,



     

     

  wid

th,



     

     

  pro

mpt_e

mbeds

.dtyp

e,



     

     

  dev

ice,



     

     

  gen

erato

r,



     

     

  lat

ents,

  # w

ill u

se if

 not 

None,

 othe

rwise

 will

 gene

rate



     

   ) 

 # (b

, c, 

h/8, 

w/8) 

-> (b

s, 4,

 28, 

50)





     

   # 

7. Pr

epare

 extr

a ste

p kwa

rgs.



     

   ex

tra_s

tep_k

wargs

 = se

lf.pr

epare

_extr

a_ste

p_kwa

rgs(g

enera

tor, 

eta)





     

   ##

#### 

BEV: 

here 

we re

const

ruct 

each 

input

 form

at ##

####



     

   as

sert 

camer

a_par

am.sh

ape[0

] == 

batch

_size

, \



     

     

  f"E

xcept

 {bat

ch_si

ze} c

amera

 para

ms, b

ut yo

u hav

e bs=

{len(

camer

a_par

am)}"



     

   N_

cam =

 came

ra_pa

ram.s

hape[

1]



     

   la

tents

 = to

rch.s

tack(

[late

nts] 

* N_c

am, d

im=1)

  # b

s, 6,

 4, 2

8, 50



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ca

mera_

param

 = ca

mera_

param

.to(s

elf.d

evice

)



     

   if

 do_c

lassi

fier_

free_

guida

nce a

nd no

t gue

ss_mo

de:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  kwa

rgs_w

ith_u

ncond

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_kw

args(



     

     

     

 came

ra_pa

ram=c

amera

_para

m,



     

     

     

 imag

e=_im

ages[

0],  

# 0 i

s for

 unco

nditi

onal



     

     

     

 max_

len=b

box_m

ax_le

ngth,



     

     

     

 **be

v_con

troln

et_kw

args,



     

     

  )



     

     

  kwa

rgs_w

ith_u

ncond

.pop(

"max_

len",

 None

)  # 

some 

do no

t tak

e thi

s.



     

     

  cam

era_p

aram 

= kwa

rgs_w

ith_u

ncond

.pop(

"came

ra_pa

ram")



     

     

  _im

ages[

0] = 

kwarg

s_wit

h_unc

ond.p

op("i

mage"

)



     

     

  ima

ge = 

torch

.cat(

_imag

es)



     

     

  bev

_cont

rolne

t_kwa

rgs =

 move

_to(k

wargs

_with

_unco

nd, s

elf.d

evice

)



     

   ##

#### 

BEV e

nd ##

####





     

   # 

8. De

noisi

ng lo

op



     

   nu

m_war

mup_s

teps 

= len

(time

steps

) - n

um_in

feren

ce_st

eps *

 self

.sche

duler

.orde

r



     

   wi

th se

lf.pr

ogres

s_bar

(tota

l=num

_infe

rence

_step

s) as

 prog

ress_

bar:



     

     

  for

 i, t

 in e

numer

ate(t

imest

eps):



     

     

     

 # ex

pand 

the l

atent

s if 

we ar

e doi

ng cl

assif

ier f

ree g

uidan

ce



     

     

     

 # bs

*2, 6

, 4, 

28, 5

0



     

     

     

 late

nt_mo

del_i

nput 

= (



     

     

     

     

torch

.cat(

[late

nts] 

* 2) 

if do

_clas

sifie

r_fre

e_gui

dance

 else

 late

nts



     

     

     

 )



     

     

     

 late

nt_mo

del_i

nput 

= sel

f.sch

edule

r.sca

le_mo

del_i

nput(



     

     

     

     

laten

t_mod

el_in

put, 

t



     

     

     

 )





     

     

     

 # co

ntrol

net(s

) inf

erenc

e



     

     

     

 cont

rolne

t_t =

 t.un

squee

ze(0)



     

     

     

 # gu

ess_m

ode &

 clas

sifie

r_fre

e_gui

dance

 -> o

nly g

uidan

ce us

e con

troln

et



     

     

     

 # no

t gue

ss_mo

de & 

class

ifier

_free

_guid

ance 

-> al

l use

 cont

rolne

t



     

     

     

 # gu

ess_m

ode -

> nor

mal i

nput,

 take

 effe

ct in

 cont

rolne

t



     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

er Co

ntrol

Net o

nly f

or th

e con

ditio

nal b

atch.



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ents



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds

.chun

k(2)[

1]



     

     

     

 else

:



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ent_m

odel_

input



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds



     

     

     

 cont

rolne

t_t =

 cont

rolne

t_t.r

epeat

(len(

contr

olnet

_late

nt_mo

del_i

nput)

)





     

     

     

 # fm

t: of

f



     

     

     

 down

_bloc

k_res

_samp

les, 

mid_b

lock_

res_s

ample

, \



     

     

     

 enco

der_h

idden

_stat

es_wi

th_ca

m = s

elf.c

ontro

lnet(



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput,



     

     

     

     

contr

olnet

_t,



     

     

     

     

camer

a_par

am,  

# for

 BEV



     

     

     

     

encod

er_hi

dden_

state

s=con

troln

et_pr

ompt_

embed

s,



     

     

     

     

contr

olnet

_cond

=imag

e,



     

     

     

     

condi

tioni

ng_sc

ale=c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

     

     

     

guess

_mode

=gues

s_mod

e,



     

     

     

     

retur

n_dic

t=Fal

se,



     

     

     

     

**bev

_cont

rolne

t_kwa

rgs, 

# for

 BEV



     

     

     

 )



     

     

     

 # fm

t: on





     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

ered 

Contr

olNet

 only

 for 

the c

ondit

ional

 batc

h.



     

     

     

     

# To 

apply

 the 

outpu

t of 

Contr

olNet

 to b

oth t

he un

condi

tiona

l and

 cond

ition

al ba

tches

,



     

     

     

     

# add

 0 to

 the 

uncon

ditio

nal b

atch 

to ke

ep it

 unch

anged

.



     

     

     

     

down_

block

_res_

sampl

es = 

[



     

     

     

     

    t

orch.

cat([

torch

.zero

s_lik

e(d),

 d])



     

     

     

     

    f

or d 

in do

wn_bl

ock_r

es_sa

mples



     

     

     

     

]



     

     

     

     

mid_b

lock_

res_s

ample

 = to

rch.c

at(



     

     

     

     

    [

torch

.zero

s_lik

e(mid

_bloc

k_res

_samp

le), 

mid_b

lock_

res_s

ample

]



     

     

     

     

)



     

     

     

     

# add

 unco

nd en

coder

_hidd

en_st

ates_

with_

cam h

ere



     

     

     

     

encod

er_hi

dden_

state

s_wit

h_cam

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_em

b(



     

     

     

     

    p

rompt

_embe

ds.ch

unk(2

)[0],

 N_ca

m,



     

     

     

     

    e

ncode

r_hid

den_s

tates

_with

_cam,



     

     

     

     

)





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # St

ratin

g fro

m her

e, we

 use 

4-dim

 data

.



     

     

     

 # en

coder

_hidd

en_st

ates_

with_

cam: 

(2b x

 N), 

78, 7

68



     

     

     

 # la

tent_

model

_inpu

t: 2b

, N, 

4, 28

, 50 

-> 2b

 x N,

 4, 2

8, 50



     

     

     

 late

nt_mo

del_i

nput 

= rea

rrang

e(



     

     

     

     

laten

t_mod

el_in

put, 

'b n 

... -

> (b 

n) ..

.')



     

     

     

 late

nts =

 rear

range

(late

nts, 

'b n 

... -

> (b 

n) ..

.')





     

     

     

 # pr

edict

 the 

noise

 resi

dual:

 2bxN

, 4, 

28, 5

0



     

     

     

 addi

tiona

l_par

am = 

{}



     

     

     

 nois

e_pre

d = s

elf.u

net(



     

     

     

     

laten

t_mod

el_in

put, 

 # ma

y wit

h unc

ondit

ional



     

     

     

     

t,



     

     

     

     

encod

er_hi

dden_

state

s=enc

oder_

hidde

n_sta

tes_w

ith_c

am,



     

     

     

     

**add

ition

al_pa

ram, 

 # if

 use 

origi

nal u

net, 

it ca

nnot 

take 

kwarg

s



     

     

     

     

cross

_atte

ntion

_kwar

gs=cr

oss_a

ttent

ion_k

wargs

,



     

     

     

     

down_

block

_addi

tiona

l_res

idual

s=dow

n_blo

ck_re

s_sam

ples,



     

     

     

     

mid_b

lock_

addit

ional

_resi

dual=

mid_b

lock_

res_s

ample

,



     

     

     

 ).sa

mple





     

     

     

 # pe

rform

 guid

ance



     

     

     

 if d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# for

 each

: bxN

, 4, 

28, 5

0



     

     

     

     

noise

_pred

_unco

nd, n

oise_

pred_

text 

= noi

se_pr

ed.ch

unk(2

)



     

     

     

     

noise

_pred

 = no

ise_p

red_u

ncond

 + gu

idanc

e_sca

le * 

(



     

     

     

     

    n

oise_

pred_

text 

- noi

se_pr

ed_un

cond



     

     

     

     

)





     

     

     

 # co

mpute

 the 

previ

ous n

oisy 

sampl

e x_t

 -> x

_t-1



     

     

     

 # NO

TE: i

s the

 sche

duler

 use 

rando

mness

, ple

ase h

andle

 the 

logic



     

     

     

 # fo

r gen

erato

r.



     

     

     

 late

nts =

 self

.sche

duler

.step

(



     

     

     

     

noise

_pred

, t, 

laten

ts, *

*extr

a_ste

p_kwa

rgs



     

     

     

 ).pr

ev_sa

mple





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # no

w we 

add d

imens

ion b

ack, 

use 5

-dim 

data.



     

     

     

 # NO

TE: o

nly `

laten

ts` i

s upd

ated 

throu

gh th

e loo

p



     

     

     

 late

nts =

 rear

range

(late

nts, 

'(b n

) ...

 -> b

 n ..

.', n

=N_ca

m)





     

     

     

 # ca

ll th

e cal

lback

, if 

provi

ded



     

     

     

 if i

 == l

en(ti

meste

ps) -

 1 or

 (



     

     

     

     

(i + 

1) > 

num_w

armup

_step

s and

 (i +

 1) %

 self

.sche

duler

.orde

r == 

0



     

     

     

 ):



     

     

     

     

progr

ess_b

ar.up

date(

)



     

     

     

     

if ca

llbac

k is 

not N

one a

nd i 

% cal

lback

_step

s == 

0:



     

     

     

     

    c

allba

ck(i,

 t, l

atent

s)





     

   ##

#### 

BEV: 

here 

rebui

ld th

e sha

pes b

ack. 

post-

proce

ss st

ill a

ssume



     

   # 

laten

ts, n

o nee

d for

 b, n

, 4, 

28, 5

0



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ##

### B

EV en

d





     

   # 

If we

 do s

equen

tial 

model

 offl

oadin

g, le

t's o

ffloa

d une

t and

 cont

rolne

t



     

   # 

manua

lly f

or ma

x mem

ory s

aving

s



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.une

t.to(

"cpu"

)



     

     

  sel

f.con

troln

et.to

("cpu

")



     

     

  tor

ch.cu

da.em

pty_c

ache(

)





     

   if

 outp

ut_ty

pe ==

 "lat

ent":



     

     

  ima

ge = 

laten

ts



     

     

  has

_nsfw

_conc

ept =

 None



     

   el

if ou

tput_

type 

== "p

il":



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

     

  # 1

0. Co

nvert

 to P

IL



     

     

  ima

ge = 

self.

numpy

_to_p

il_do

uble(

image

)



     

   el

se:



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

   # 

Offlo

ad la

st mo

del t

o CPU



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.fin

al_of

fload

_hook

.offl

oad()





     

   if

 not 

retur

n_dic

t:



     

     

  ret

urn (

image

, has

_nsfw

_conc

ept)





     

   re

turn 

BEVSt

ableD

iffus

ionPi

pelin

eOutp

ut(



     

     

  ima

ges=i

mage,

 nsfw

_cont

ent_d

etect

ed=ha

s_nsf

w_con

cept



     

   )



from 

datac

lasse

s imp

ort d

atacl

ass



from 

typin

g imp

ort A

ny, C

allab

le, D

ict, 

List,

 Opti

onal,

 Tupl

e, Un

ion



impor

t ins

pect





impor

t tor

ch



impor

t PIL



impor

t num

py as

 np



from 

einop

s imp

ort r

earra

nge





from 

diffu

sers 

impor

t Sta

bleDi

ffusi

onCon

trolN

etPip

eline



from 

diffu

sers.

utils

 impo

rt Ba

seOut

put



from 

diffu

sers.

image

_proc

essor

 impo

rt Va

eImag

eProc

essor



from 

diffu

sers.

model

s imp

ort A

utoen

coder

KL, U

Net2D

Condi

tionM

odel



from 

diffu

sers.

pipel

ines.

stabl

e_dif

fusio

n imp

ort S

table

Diffu

sionS

afety

Check

er



from 

diffu

sers.

sched

ulers

.sche

dulin

g_uti

ls im

port 

Karra

sDiff

usion

Sched

ulers



from 

trans

forme

rs im

port 

CLIPI

mageP

roces

sor, 

CLIPT

extMo

del, 

CLIPT

okeni

zer





from 

..mis

c.com

mon i

mport

 move

_to







@data

class



class

 BEVS

table

Diffu

sionP

ipeli

neOut

put(B

aseOu

tput)

:



    "

""



    O

utput

 clas

s for

 Stab

le Di

ffusi

on pi

pelin

es.





    A

rgs:



     

   im

ages 

(`Lis

t[PIL

.Imag

e.Ima

ge]` 

or `n

p.nda

rray`

)



     

     

  Lis

t of 

denoi

sed P

IL im

ages 

of le

ngth 

`batc

h_siz

e` or

 nump

y arr

ay of

 shap

e `(b

atch_

size,

 heig

ht, w

idth,



     

     

  num

_chan

nels)

`. PI

L ima

ges o

r num

py ar

ray p

resen

t the

 deno

ised 

image

s of 

the d

iffus

ion p

ipeli

ne.



     

   ns

fw_co

ntent

_dete

cted 

(`Lis

t[boo

l]`)



     

     

  Lis

t of 

flags

 deno

ting 

wheth

er th

e cor

respo

nding

 gene

rated

 imag

e lik

ely r

epres

ents 

"not-

safe-

for-w

ork"



     

     

  (ns

fw) c

onten

t, or

 `Non

e` if

 safe

ty ch

eckin

g cou

ld no

t be 

perfo

rmed.



    "

""





    i

mages

: Uni

on[Li

st[Li

st[PI

L.Ima

ge.Im

age]]

, np.

ndarr

ay]



    n

sfw_c

onten

t_det

ected

: Opt

ional

[List

[bool

]]







class

 Stab

leDif

fusio

nBEVC

ontro

lNetP

ipeli

ne(St

ableD

iffus

ionCo

ntrol

NetPi

pelin

e):



    d

ef __

init_

_(



     

   se

lf,



     

   va

e: Au

toenc

oderK

L,



     

   te

xt_en

coder

: CLI

PText

Model

,



     

   un

et: U

Net2D

Condi

tionM

odel,



     

   co

ntrol

net,



     

   sc

hedul

er: K

arras

Diffu

sionS

chedu

lers,



     

   to

keniz

er: C

LIPTo

keniz

er,



     

   sa

fety_

check

er: S

table

Diffu

sionS

afety

Check

er = 

None,



     

   fe

ature

_extr

actor

: CLI

PImag

eProc

essor

 = No

ne,



     

   re

quire

s_saf

ety_c

hecke

r: bo

ol = 

False

,



    )

:



     

   su

per()

.__in

it__(



     

     

  vae

,



     

     

  tex

t_enc

oder,



     

     

  tok

enize

r,



     

     

  une

t,



     

     

  con

troln

et,



     

     

  sch

edule

r,



     

     

  saf

ety_c

hecke

r,



     

     

  fea

ture_

extra

ctor,



     

     

  req

uires

_safe

ty_ch

ecker

,



     

   )



     

   as

sert 

safet

y_che

cker 

== No

ne, "

Pleas

e do 

not u

se sa

fety_

check

er."



     

   se

lf.co

ntrol

_imag

e_pro

cesso

r = V

aeIma

gePro

cesso

r(



     

     

  vae

_scal

e_fac

tor=s

elf.v

ae_sc

ale_f

actor

,



     

     

  do_

resiz

e=Fal

se,



     

     

  do_

conve

rt_rg

b=Fal

se,



     

     

  do_

norma

lize=

False

,



     

   )





    d

ef nu

mpy_t

o_pil

_doub

le(se

lf, i

mages

):



     

   ""

"



     

   Co

nvert

 a nu

mpy i

mage 

or a 

batch

 of i

mages

 to a

 PIL 

image

.



     

   We

 need

 to h

andle

 5-di

m inp

uts a

nd re

ture 

2-dim

 list

.



     

   ""

"



     

   im

gs_li

st = 

[]



     

   fo

r img

s in 

image

s:



     

     

  img

s_lis

t.app

end(s

elf.n

umpy_

to_pi

l(img

s))



     

   re

turn 

imgs_

list





    #

 Copi

ed fr

om di

ffuse

rs.pi

pelin

es.st

able_

diffu

sion.

pipel

ine_s

table

_diff

usion

.Stab

leDif

fusio

nPipe

line.

prepa

re_ex

tra_s

tep_k

wargs



    d

ef pr

epare

_extr

a_ste

p_kwa

rgs(s

elf, 

gener

ator,

 eta)

:



     

   # 

prepa

re ex

tra k

wargs

 for 

the s

chedu

ler s

tep, 

since

 not 

all s

chedu

lers 

have 

the s

ame s

ignat

ure



     

   # 

eta (

η) is

 only

 used

 with

 the 

DDIMS

chedu

ler, 

it wi

ll be

 igno

red f

or ot

her s

chedu

lers.



     

   # 

eta c

orres

ponds

 to η

 in D

DIM p

aper:

 http

s://a

rxiv.

org/a

bs/20

10.02

502



     

   # 

and s

hould

 be b

etwee

n [0,

 1]





     

   ac

cepts

_eta 

= "et

a" in

 set(

inspe

ct.si

gnatu

re(se

lf.sc

hedul

er.st

ep).p

arame

ters.

keys(

))



     

   ex

tra_s

tep_k

wargs

 = {}



     

   if

 acce

pts_e

ta:



     

     

  ext

ra_st

ep_kw

args[

"eta"

] = e

ta





     

   # 

check

 if t

he sc

hedul

er ac

cepts

 gene

rator



     

   ac

cepts

_gene

rator

 = "g

enera

tor" 

in se

t(ins

pect.

signa

ture(

self.

sched

uler.

step)

.para

meter

s.key

s())



     

   if

 acce

pts_g

enera

tor:



     

     

  rai

se Ru

ntime

Error

("If 

you f

ixed 

the l

ogic 

for g

enera

tor, 

pleas

e rem

ove t

his. 

Other

wise,

 plea

se us

e oth

er sa

mpler

.")



     

     

  ext

ra_st

ep_kw

args[

"gene

rator

"] = 

gener

ator



     

   re

turn 

extra

_step

_kwar

gs





    d

ef de

code_

laten

ts(se

lf, l

atent

s):



     

   # 

decod

e lat

ents 

with 

5-dim

s



     

   la

tents

 = 1 

/ sel

f.vae

.conf

ig.sc

aling

_fact

or * 

laten

ts





     

   bs

 = le

n(lat

ents)



     

   la

tents

 = re

arran

ge(la

tents

, 'b 

c ...

 -> (

b c) 

...')



     

   im

age =

 self

.vae.

decod

e(lat

ents)

.samp

le



     

   im

age =

 rear

range

(imag

e, '(

b c) 

... -

> b c

 ...'

, b=b

s)





     

   im

age =

 (ima

ge / 

2 + 0

.5).c

lamp(

0, 1)



     

   # 

we al

ways 

cast 

to fl

oat32

 as t

his d

oes n

ot ca

use s

ignif

icant

 over

head 

and i

s com

patib

le wi

th bf

loat1

6



     

   im

age =

 rear

range

(imag

e.cpu

(), '

... c

 h w 

-> ..

. h w

 c').

float

().nu

mpy()



     

   re

turn 

image





    @

torch

.no_g

rad()



    d

ef __

call_

_(



     

   se

lf,



     

   pr

ompt:

 Unio

n[str

, Lis

t[str

]],



     

   im

age: 

torch

.Floa

tTens

or,



     

   ca

mera_

param

: Uni

on[to

rch.T

ensor

, Non

e],



     

   he

ight:

 int,



     

   wi

dth: 

int,



     

   nu

m_inf

erenc

e_ste

ps: i

nt = 

50,



     

   gu

idanc

e_sca

le: f

loat 

= 7.5

,



     

   ne

gativ

e_pro

mpt: 

Optio

nal[U

nion[

str, 

List[

str]]

] = N

one,



     

   nu

m_ima

ges_p

er_pr

ompt:

 Opti

onal[

int] 

= 1,



     

   et

a: fl

oat =

 0.0,



     

   ge

nerat

or: O

ption

al[to

rch.G

enera

tor] 

= Non

e,



     

   la

tents

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   pr

ompt_

embed

s: Op

tiona

l[tor

ch.Fl

oatTe

nsor]

 = No

ne,



     

   ne

gativ

e_pro

mpt_e

mbeds

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   ou

tput_

type:

 Opti

onal[

str] 

= "pi

l",



     

   re

turn_

dict:

 bool

 = Tr

ue,



     

   ca

llbac

k: Op

tiona

l[Cal

lable

[[int

, int

, tor

ch.Fl

oatTe

nsor]

, Non

e]] =

 None

,



     

   ca

llbac

k_ste

ps: i

nt = 

1,



     

   cr

oss_a

ttent

ion_k

wargs

: Opt

ional

[Dict

[str,

 Any]

] = N

one,



     

   co

ntrol

net_c

ondit

ionin

g_sca

le: f

loat 

= 1,



     

   gu

ess_m

ode: 

bool 

= Fal

se,



     

   us

e_zer

o_map

_as_u

ncond

ition

al: b

ool =

 Fals

e,



     

   be

v_con

troln

et_kw

args 

= {},



     

   bb

ox_ma

x_len

gth =

 None

,



    )

:



     

   r"

""



     

   Fu

nctio

n inv

oked 

when 

calli

ng th

e pip

eline

 for 

gener

ation

.





     

   Ar

gs:



     

     

  pro

mpt (

`str`

 or `

List[

str]`

, *op

tiona

l*):



     

     

     

 The 

promp

t or 

promp

ts to

 guid

e the

 imag

e gen

erati

on. I

f not

 defi

ned, 

one h

as to

 pass

 `pro

mpt_e

mbeds

`.



     

     

     

 inst

ead.



     

     

  ima

ge (`

torch

.Floa

tTens

or`, 

`PIL.

Image

.Imag

e`, `

List[

torch

.Floa

tTens

or]`,

 `Lis

t[PIL

.Imag

e.Ima

ge]`,



     

     

     

     

`List

[List

[torc

h.Flo

atTen

sor]]

`, or

 `Lis

t[Lis

t[PIL

.Imag

e.Ima

ge]]`

):



     

     

     

 The 

Contr

olNet

 inpu

t con

ditio

n. Co

ntrol

Net u

ses t

his i

nput 

condi

tion 

to ge

nerat

e gui

dance

 to U

net. 

If



     

     

     

 the 

type 

is sp

ecifi

ed as

 `Tor

ch.Fl

oatTe

nsor`

, it 

is pa

ssed 

to Co

ntrol

Net a

s is.

 `PIL

.Imag

e.Ima

ge` c

an



     

     

     

 also

 be a

ccept

ed as

 an i

mage.

 The 

dimen

sions

 of t

he ou

tput 

image

 defa

ults 

to `i

mage`

's di

mensi

ons. 

If



     

     

     

 heig

ht an

d/or 

width

 are 

passe

d, `i

mage`

 is r

esize

d acc

ordin

g to 

them.

 If m

ultip

le Co

ntrol

Nets 

are



     

     

     

 spec

ified

 in i

nit, 

image

s mus

t be 

passe

d as 

a lis

t suc

h tha

t eac

h ele

ment 

of th

e lis

t can

 be c

orrec

tly



     

     

     

 batc

hed f

or in

put t

o a s

ingle

 cont

rolne

t.



     

     

  hei

ght (

`int`

, *op

tiona

l*, d

efaul

ts to

 self

.unet

.conf

ig.sa

mple_

size 

* sel

f.vae

_scal

e_fac

tor):



     

     

     

 The 

heigh

t in 

pixel

s of 

the g

enera

ted i

mage.



     

     

  wid

th (`

int`,

 *opt

ional

*, de

fault

s to 

self.

unet.

confi

g.sam

ple_s

ize *

 self

.vae_

scale

_fact

or):



     

     

     

 The 

width

 in p

ixels

 of t

he ge

nerat

ed im

age.



     

     

  num

_infe

rence

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 5

0):



     

     

     

 The 

numbe

r of 

denoi

sing 

steps

. Mor

e den

oisin

g ste

ps us

ually

 lead

 to a

 high

er qu

ality

 imag

e at 

the



     

     

     

 expe

nse o

f slo

wer i

nfere

nce.



     

     

  gui

dance

_scal

e (`f

loat`

, *op

tiona

l*, d

efaul

ts to

 7.5)

:



     

     

     

 Guid

ance 

scale

 as d

efine

d in 

[Clas

sifie

r-Fre

e Dif

fusio

n Gui

dance

](htt

ps://

arxiv

.org/

abs/2

207.1

2598)

.



     

     

     

 `gui

dance

_scal

e` is

 defi

ned a

s `w`

 of e

quati

on 2.

 of [

Image

n



     

     

     

 Pape

r](ht

tps:/

/arxi

v.org

/pdf/

2205.

11487

.pdf)

. Gui

dance

 scal

e is 

enabl

ed by

 sett

ing `

guida

nce_s

cale 

>



     

     

     

 1`. 

Highe

r gui

dance

 scal

e enc

ourag

es to

 gene

rate 

image

s tha

t are

 clos

ely l

inked

 to t

he te

xt `p

rompt

`,



     

     

     

 usua

lly a

t the

 expe

nse o

f low

er im

age q

ualit

y.



     

     

  neg

ative

_prom

pt (`

str` 

or `L

ist[s

tr]`,

 *opt

ional

*):



     

     

     

 The 

promp

t or 

promp

ts no

t to 

guide

 the 

image

 gene

ratio

n. If

 not 

defin

ed, o

ne ha

s to 

pass



     

     

     

 `neg

ative

_prom

pt_em

beds`

 inst

ead. 

Ignor

ed wh

en no

t usi

ng gu

idanc

e (i.

e., i

gnore

d if 

`guid

ance_

scale

` is



     

     

     

 less

 than

 `1`)

.



     

     

  num

_imag

es_pe

r_pro

mpt (

`int`

, *op

tiona

l*, d

efaul

ts to

 1):



     

     

     

 The 

numbe

r of 

image

s to 

gener

ate p

er pr

ompt.



     

     

  eta

 (`fl

oat`,

 *opt

ional

*, de

fault

s to 

0.0):



     

     

     

 Corr

espon

ds to

 para

meter

 eta 

(η) i

n the

 DDIM

 pape

r: ht

tps:/

/arxi

v.org

/abs/

2010.

02502

. Onl

y app

lies 

to



     

     

     

 [`sc

hedul

ers.D

DIMSc

hedul

er`],

 will

 be i

gnore

d for

 othe

rs.



     

     

  gen

erato

r (`t

orch.

Gener

ator`

 or `

List[

torch

.Gene

rator

]`, *

optio

nal*)

:



     

     

     

 One 

or a 

list 

of [t

orch 

gener

ator(

s)](h

ttps:

//pyt

orch.

org/d

ocs/s

table

/gene

rated

/torc

h.Gen

erato

r.htm

l)



     

     

     

 to m

ake g

enera

tion 

deter

minis

tic.



     

     

  lat

ents 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

noisy

 late

nts, 

sampl

ed fr

om a 

Gauss

ian d

istri

butio

n, to

 be u

sed a

s inp

uts f

or im

age



     

     

     

 gene

ratio

n. Ca

n be 

used 

to tw

eak t

he sa

me ge

nerat

ion w

ith d

iffer

ent p

rompt

s. If

 not 

provi

ded, 

a lat

ents



     

     

     

 tens

or wi

ll ge

 gene

rated

 by s

ampli

ng us

ing t

he su

pplie

d ran

dom `

gener

ator`

.



     

     

  pro

mpt_e

mbeds

 (`to

rch.F

loatT

ensor

`, *o

ption

al*):



     

     

     

 Pre-

gener

ated 

text 

embed

dings

. Can

 be u

sed t

o eas

ily t

weak 

text 

input

s, *e

.g.* 

promp

t wei

ghtin

g. If

 not



     

     

     

 prov

ided,

 text

 embe

dding

s wil

l be 

gener

ated 

from 

`prom

pt` i

nput 

argum

ent.



     

     

  neg

ative

_prom

pt_em

beds 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

negat

ive t

ext e

mbedd

ings.

 Can 

be us

ed to

 easi

ly tw

eak t

ext i

nputs

, *e.

g.* p

rompt



     

     

     

 weig

hting

. If 

not p

rovid

ed, n

egati

ve_pr

ompt_

embed

s wil

l be 

gener

ated 

from 

`nega

tive_

promp

t` in

put



     

     

     

 argu

ment.



     

     

  out

put_t

ype (

`str`

, *op

tiona

l*, d

efaul

ts to

 `"pi

l"`):



     

     

     

 The 

outpu

t for

mat o

f the

 gene

rate 

image

. Cho

ose b

etwee

n



     

     

     

 [PIL

](htt

ps://

pillo

w.rea

dthed

ocs.i

o/en/

stabl

e/): 

`PIL.

Image

.Imag

e` or

 `np.

array

`.



     

     

  ret

urn_d

ict (

`bool

`, *o

ption

al*, 

defau

lts t

o `Tr

ue`):



     

     

     

 Whet

her o

r not

 to r

eturn

 a [`

~pipe

lines

.stab

le_di

ffusi

on.St

ableD

iffus

ionPi

pelin

eOutp

ut`] 

inste

ad of

 a



     

     

     

 plai

n tup

le.



     

     

  cal

lback

 (`Ca

llabl

e`, *

optio

nal*)

:



     

     

     

 A fu

nctio

n tha

t wil

l be 

calle

d eve

ry `c

allba

ck_st

eps` 

steps

 duri

ng in

feren

ce. T

he fu

nctio

n wil

l be



     

     

     

 call

ed wi

th th

e fol

lowin

g arg

ument

s: `c

allba

ck(st

ep: i

nt, t

imest

ep: i

nt, l

atent

s: to

rch.F

loatT

ensor

)`.



     

     

  cal

lback

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 1

):



     

     

     

 The 

frequ

ency 

at wh

ich t

he `c

allba

ck` f

uncti

on wi

ll be

 call

ed. I

f not

 spec

ified

, the

 call

back 

will 

be



     

     

     

 call

ed at

 ever

y ste

p.



     

     

  cro

ss_at

tenti

on_kw

args 

(`dic

t`, *

optio

nal*)

:



     

     

     

 A kw

args 

dicti

onary

 that

 if s

pecif

ied i

s pas

sed a

long 

to th

e `At

tenti

onPro

cesso

r` as

 defi

ned u

nder



     

     

     

 `sel

f.pro

cesso

r` in



     

     

     

 [dif

fuser

s.cro

ss_at

tenti

on](h

ttps:

//git

hub.c

om/hu

gging

face/

diffu

sers/

blob/

main/

src/d

iffus

ers/m

odels

/cros

s_att

entio

n.py)

.



     

     

  con

troln

et_co

nditi

oning

_scal

e (`f

loat`

 or `

List[

float

]`, *

optio

nal*,

 defa

ults 

to 1.

0):



     

     

     

 The 

outpu

ts of

 the 

contr

olnet

 are 

multi

plied

 by `

contr

olnet

_cond

ition

ing_s

cale`

 befo

re th

ey ar

e add

ed



     

     

     

 to t

he re

sidua

l in 

the o

rigin

al un

et. I

f mul

tiple

 Cont

rolNe

ts ar

e spe

cifie

d in 

init,

 you 

can s

et th

e



     

     

     

 corr

espon

ding 

scale

 as a

 list

.



     

     

  gue

ss_mo

de (`

bool`

, *op

tiona

l*, d

efaul

ts to

 `Fal

se`):



     

     

     

 In t

his m

ode, 

the C

ontro

lNet 

encod

er wi

ll tr

y bes

t to 

recog

nize 

the c

onten

t of 

the i

nput 

image

 even

 if



     

     

     

 you 

remov

e all

 prom

pts. 

The `

guida

nce_s

cale`

 betw

een 3

.0 an

d 5.0

 is r

ecomm

ended

.





     

   Ex

ample

s:





     

   Re

turns

:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] o

r `tu

ple`:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] i

f `re

turn_

dict`

 is T

rue, 

other

wise 

a `tu

ple.



     

     

  Whe

n ret

urnin

g a t

uple,

 the 

first

 elem

ent i

s a l

ist w

ith t

he ge

nerat

ed im

ages,

 and 

the s

econd

 elem

ent i

s a



     

     

  lis

t of 

`bool

`s de

notin

g whe

ther 

the c

orres

pondi

ng ge

nerat

ed im

age l

ikely

 repr

esent

s "no

t-saf

e-for

-work

"



     

     

  (ns

fw) c

onten

t, ac

cordi

ng to

 the 

`safe

ty_ch

ecker

`.



     

   ""

"



     

   # 

0. De

fault

 heig

ht an

d wid

th to

 unet



     

   # 

BEV: 

we ca

nnot 

use t

he si

ze of

 imag

e



     

   # 

heigh

t, wi

dth =

 self

._def

ault_

heigh

t_wid

th(he

ight,

 widt

h, No

ne)





     

   # 

1. Ch

eck i

nputs

. Rai

se er

ror i

f not

 corr

ect



     

   # 

we do

 not 

need 

this,

 only

 some

 type

 asse

rtion



     

   # 

self.

check

_inpu

ts(



     

   # 

    p

rompt

,



     

   # 

    i

mage,



     

   # 

    h

eight

,



     

   # 

    w

idth,



     

   # 

    c

allba

ck_st

eps,



     

   # 

    n

egati

ve_pr

ompt,



     

   # 

    p

rompt

_embe

ds,



     

   # 

    n

egati

ve_pr

ompt_

embed

s,



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

   # 

)





     

   # 

2. De

fine 

call 

param

eters



     

   # 

NOTE:

 we g

et ba

tch_s

ize f

irst 

from 

promp

t, th

en al

ign w

ith i

t.



     

   if

 prom

pt is

 not 

None 

and i

sinst

ance(

promp

t, st

r):



     

     

  bat

ch_si

ze = 

1



     

   el

if pr

ompt 

is no

t Non

e and

 isin

stanc

e(pro

mpt, 

list)

:



     

     

  bat

ch_si

ze = 

len(p

rompt

)



     

   el

se:



     

     

  bat

ch_si

ze = 

promp

t_emb

eds.s

hape[

0]





     

   de

vice 

= sel

f._ex

ecuti

on_de

vice



     

   # 

here 

`guid

ance_

scale

` is 

defin

ed an

alog 

to th

e gui

dance

 weig

ht `w

` of 

equat

ion (

2)



     

   # 

of th

e Ima

gen p

aper:

 http

s://a

rxiv.

org/p

df/22

05.11

487.p

df . 

`guid

ance_

scale

 = 1`



     

   # 

corre

spond

s to 

doing

 no c

lassi

fier 

free 

guida

nce.



     

   do

_clas

sifie

r_fre

e_gui

dance

 = gu

idanc

e_sca

le > 

1.0





     

   ##

# BEV

, che

ck ca

mera_

param

 ###



     

   if

 came

ra_pa

ram i

s Non

e:



     

     

  # u

se un

cond_

cam a

nd di

sable

 clas

sifie

r fre

e gui

dance



     

     

  N_c

am = 

6  # 

TODO:

 hard

-code

d



     

     

  cam

era_p

aram 

= sel

f.con

troln

et.un

cond_

cam_p

aram(

(batc

h_siz

e, N_

cam))



     

     

  do_

class

ifier

_free

_guid

ance 

= Fal

se



     

   ##

# don

e ###





     

   # 

if is

insta

nce(s

elf.c

ontro

lnet,

 Mult

iCont

rolNe

tMode

l) an

d isi

nstan

ce(co

ntrol

net_c

ondit

ionin

g_sca

le, f

loat)

:



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale =

 [con

troln

et_co

nditi

oning

_scal

e] * 

len(s

elf.c

ontro

lnet.

nets)





     

   # 

3. En

code 

input

 prom

pt



     

   # 

NOTE:

 here

 they

 use 

paddi

ng to

 77, 

is th

is ne

cessa

ry?



     

   pr

ompt_

embed

s = s

elf._

encod

e_pro

mpt(



     

     

  pro

mpt,



     

     

  dev

ice,



     

     

  num

_imag

es_pe

r_pro

mpt,



     

     

  do_

class

ifier

_free

_guid

ance,



     

     

  neg

ative

_prom

pt,



     

     

  pro

mpt_e

mbeds

=prom

pt_em

beds,



     

     

  neg

ative

_prom

pt_em

beds=

negat

ive_p

rompt

_embe

ds,



     

   ) 

 # (2

 * b,

 77 +

 1, 7

68)





     

   # 

4. Pr

epare

 imag

e



     

   # 

NOTE:

 if i

mage 

is no

t ten

sor, 

there

 will

 be s

evera

l pro

cess.



     

   as

sert 

not s

elf.c

ontro

l_ima

ge_pr

ocess

or.co

nfig.

do_no

rmali

ze, "

Your 

contr

olnet

 shou

ld no

t nor

maliz

e the

 cont

rol i

mage.

"



     

   im

age =

 self

.prep

are_i

mage(



     

     

  ima

ge=im

age,



     

     

  wid

th=wi

dth,



     

     

  hei

ght=h

eight

,



     

     

  bat

ch_si

ze=ba

tch_s

ize *

 num_

image

s_per

_prom

pt,



     

     

  num

_imag

es_pe

r_pro

mpt=n

um_im

ages_

per_p

rompt

,



     

     

  dev

ice=d

evice

,



     

     

  dty

pe=se

lf.co

ntrol

net.d

type,



     

     

  do_

class

ifier

_free

_guid

ance=

do_cl

assif

ier_f

ree_g

uidan

ce,



     

     

  gue

ss_mo

de=gu

ess_m

ode,



     

   ) 

 # (2

 * b,

 c_26

, 200

, 200

)



     

   if

 use_

zero_

map_a

s_unc

ondit

ional

 and 

do_cl

assif

ier_f

ree_g

uidan

ce:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  _im

ages[

0] = 

torch

.zero

s_lik

e(_im

ages[

0])



     

     

  ima

ge = 

torch

.cat(

_imag

es)





     

   # 

5. Pr

epare

 time

steps



     

   se

lf.sc

hedul

er.se

t_tim

estep

s(num

_infe

rence

_step

s, de

vice=

devic

e)



     

   ti

meste

ps = 

self.

sched

uler.

times

teps





     

   # 

6. Pr

epare

 late

nt va

riabl

es



     

   nu

m_cha

nnels

_late

nts =

 self

.unet

.conf

ig.in

_chan

nels



     

   la

tents

 = se

lf.pr

epare

_late

nts(



     

     

  bat

ch_si

ze * 

num_i

mages

_per_

promp

t,



     

     

  num

_chan

nels_

laten

ts,



     

     

  hei

ght,



     

     

  wid

th,



     

     

  pro

mpt_e

mbeds

.dtyp

e,



     

     

  dev

ice,



     

     

  gen

erato

r,



     

     

  lat

ents,

  # w

ill u

se if

 not 

None,

 othe

rwise

 will

 gene

rate



     

   ) 

 # (b

, c, 

h/8, 

w/8) 

-> (b

s, 4,

 28, 

50)





     

   # 

7. Pr

epare

 extr

a ste

p kwa

rgs.



     

   ex

tra_s

tep_k

wargs

 = se

lf.pr

epare

_extr

a_ste

p_kwa

rgs(g

enera

tor, 

eta)





     

   ##

#### 

BEV: 

here 

we re

const

ruct 

each 

input

 form

at ##

####



     

   as

sert 

camer

a_par

am.sh

ape[0

] == 

batch

_size

, \



     

     

  f"E

xcept

 {bat

ch_si

ze} c

amera

 para

ms, b

ut yo

u hav

e bs=

{len(

camer

a_par

am)}"



     

   N_

cam =

 came

ra_pa

ram.s

hape[

1]



     

   la

tents

 = to

rch.s

tack(

[late

nts] 

* N_c

am, d

im=1)

  # b

s, 6,

 4, 2

8, 50



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ca

mera_

param

 = ca

mera_

param

.to(s

elf.d

evice

)



     

   if

 do_c

lassi

fier_

free_

guida

nce a

nd no

t gue

ss_mo

de:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  kwa

rgs_w

ith_u

ncond

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_kw

args(



     

     

     

 came

ra_pa

ram=c

amera

_para

m,



     

     

     

 imag

e=_im

ages[

0],  

# 0 i

s for

 unco

nditi

onal



     

     

     

 max_

len=b

box_m

ax_le

ngth,



     

     

     

 **be

v_con

troln

et_kw

args,



     

     

  )



     

     

  kwa

rgs_w

ith_u

ncond

.pop(

"max_

len",

 None

)  # 

some 

do no

t tak

e thi

s.



     

     

  cam

era_p

aram 

= kwa

rgs_w

ith_u

ncond

.pop(

"came

ra_pa

ram")



     

     

  _im

ages[

0] = 

kwarg

s_wit

h_unc

ond.p

op("i

mage"

)



     

     

  ima

ge = 

torch

.cat(

_imag

es)



     

     

  bev

_cont

rolne

t_kwa

rgs =

 move

_to(k

wargs

_with

_unco

nd, s

elf.d

evice

)



     

   ##

#### 

BEV e

nd ##

####





     

   # 

8. De

noisi

ng lo

op



     

   nu

m_war

mup_s

teps 

= len

(time

steps

) - n

um_in

feren

ce_st

eps *

 self

.sche

duler

.orde

r



     

   wi

th se

lf.pr

ogres

s_bar

(tota

l=num

_infe

rence

_step

s) as

 prog

ress_

bar:



     

     

  for

 i, t

 in e

numer

ate(t

imest

eps):



     

     

     

 # ex

pand 

the l

atent

s if 

we ar

e doi

ng cl

assif

ier f

ree g

uidan

ce



     

     

     

 # bs

*2, 6

, 4, 

28, 5

0



     

     

     

 late

nt_mo

del_i

nput 

= (



     

     

     

     

torch

.cat(

[late

nts] 

* 2) 

if do

_clas

sifie

r_fre

e_gui

dance

 else

 late

nts



     

     

     

 )



     

     

     

 late

nt_mo

del_i

nput 

= sel

f.sch

edule

r.sca

le_mo

del_i

nput(



     

     

     

     

laten

t_mod

el_in

put, 

t



     

     

     

 )





     

     

     

 # co

ntrol

net(s

) inf

erenc

e



     

     

     

 cont

rolne

t_t =

 t.un

squee

ze(0)



     

     

     

 # gu

ess_m

ode &

 clas

sifie

r_fre

e_gui

dance

 -> o

nly g

uidan

ce us

e con

troln

et



     

     

     

 # no

t gue

ss_mo

de & 

class

ifier

_free

_guid

ance 

-> al

l use

 cont

rolne

t



     

     

     

 # gu

ess_m

ode -

> nor

mal i

nput,

 take

 effe

ct in

 cont

rolne

t



     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

er Co

ntrol

Net o

nly f

or th

e con

ditio

nal b

atch.



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ents



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds

.chun

k(2)[

1]



     

     

     

 else

:



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ent_m

odel_

input



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds



     

     

     

 cont

rolne

t_t =

 cont

rolne

t_t.r

epeat

(len(

contr

olnet

_late

nt_mo

del_i

nput)

)





     

     

     

 # fm

t: of

f



     

     

     

 down

_bloc

k_res

_samp

les, 

mid_b

lock_

res_s

ample

, \



     

     

     

 enco

der_h

idden

_stat

es_wi

th_ca

m = s

elf.c

ontro

lnet(



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput,



     

     

     

     

contr

olnet

_t,



     

     

     

     

camer

a_par

am,  

# for

 BEV



     

     

     

     

encod

er_hi

dden_

state

s=con

troln

et_pr

ompt_

embed

s,



     

     

     

     

contr

olnet

_cond

=imag

e,



     

     

     

     

condi

tioni

ng_sc

ale=c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

     

     

     

guess

_mode

=gues

s_mod

e,



     

     

     

     

retur

n_dic

t=Fal

se,



     

     

     

     

**bev

_cont

rolne

t_kwa

rgs, 

# for

 BEV



     

     

     

 )



     

     

     

 # fm

t: on





     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

ered 

Contr

olNet

 only

 for 

the c

ondit

ional

 batc

h.



     

     

     

     

# To 

apply

 the 

outpu

t of 

Contr

olNet

 to b

oth t

he un

condi

tiona

l and

 cond

ition

al ba

tches

,



     

     

     

     

# add

 0 to

 the 

uncon

ditio

nal b

atch 

to ke

ep it

 unch

anged

.



     

     

     

     

down_

block

_res_

sampl

es = 

[



     

     

     

     

    t

orch.

cat([

torch

.zero

s_lik

e(d),

 d])



     

     

     

     

    f

or d 

in do

wn_bl

ock_r

es_sa

mples



     

     

     

     

]



     

     

     

     

mid_b

lock_

res_s

ample

 = to

rch.c

at(



     

     

     

     

    [

torch

.zero

s_lik

e(mid

_bloc

k_res

_samp

le), 

mid_b

lock_

res_s

ample

]



     

     

     

     

)



     

     

     

     

# add

 unco

nd en

coder

_hidd

en_st

ates_

with_

cam h

ere



     

     

     

     

encod

er_hi

dden_

state

s_wit

h_cam

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_em

b(



     

     

     

     

    p

rompt

_embe

ds.ch

unk(2

)[0],

 N_ca

m,



     

     

     

     

    e

ncode

r_hid

den_s

tates

_with

_cam,



     

     

     

     

)





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # St

ratin

g fro

m her

e, we

 use 

4-dim

 data

.



     

     

     

 # en

coder

_hidd

en_st

ates_

with_

cam: 

(2b x

 N), 

78, 7

68



     

     

     

 # la

tent_

model

_inpu

t: 2b

, N, 

4, 28

, 50 

-> 2b

 x N,

 4, 2

8, 50



     

     

     

 late

nt_mo

del_i

nput 

= rea

rrang

e(



     

     

     

     

laten

t_mod

el_in

put, 

'b n 

... -

> (b 

n) ..

.')



     

     

     

 late

nts =

 rear

range

(late

nts, 

'b n 

... -

> (b 

n) ..

.')





     

     

     

 # pr

edict

 the 

noise

 resi

dual:

 2bxN

, 4, 

28, 5

0



     

     

     

 addi

tiona

l_par

am = 

{}



     

     

     

 nois

e_pre

d = s

elf.u

net(



     

     

     

     

laten

t_mod

el_in

put, 

 # ma

y wit

h unc

ondit

ional



     

     

     

     

t,



     

     

     

     

encod

er_hi

dden_

state

s=enc

oder_

hidde

n_sta

tes_w

ith_c

am,



     

     

     

     

**add

ition

al_pa

ram, 

 # if

 use 

origi

nal u

net, 

it ca

nnot 

take 

kwarg

s



     

     

     

     

cross

_atte

ntion

_kwar

gs=cr

oss_a

ttent

ion_k

wargs

,



     

     

     

     

down_

block

_addi

tiona

l_res

idual

s=dow

n_blo

ck_re

s_sam

ples,



     

     

     

     

mid_b

lock_

addit

ional

_resi

dual=

mid_b

lock_

res_s

ample

,



     

     

     

 ).sa

mple





     

     

     

 # pe

rform

 guid

ance



     

     

     

 if d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# for

 each

: bxN

, 4, 

28, 5

0



     

     

     

     

noise

_pred

_unco

nd, n

oise_

pred_

text 

= noi

se_pr

ed.ch

unk(2

)



     

     

     

     

noise

_pred

 = no

ise_p

red_u

ncond

 + gu

idanc

e_sca

le * 

(



     

     

     

     

    n

oise_

pred_

text 

- noi

se_pr

ed_un

cond



     

     

     

     

)





     

     

     

 # co

mpute

 the 

previ

ous n

oisy 

sampl

e x_t

 -> x

_t-1



     

     

     

 # NO

TE: i

s the

 sche

duler

 use 

rando

mness

, ple

ase h

andle

 the 

logic



     

     

     

 # fo

r gen

erato

r.



     

     

     

 late

nts =

 self

.sche

duler

.step

(



     

     

     

     

noise

_pred

, t, 

laten

ts, *

*extr

a_ste

p_kwa

rgs



     

     

     

 ).pr

ev_sa

mple





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # no

w we 

add d

imens

ion b

ack, 

use 5

-dim 

data.



     

     

     

 # NO

TE: o

nly `

laten

ts` i

s upd

ated 

throu

gh th

e loo

p



     

     

     

 late

nts =

 rear

range

(late

nts, 

'(b n

) ...

 -> b

 n ..

.', n

=N_ca

m)





     

     

     

 # ca

ll th

e cal

lback

, if 

provi

ded



     

     

     

 if i

 == l

en(ti

meste

ps) -

 1 or

 (



     

     

     

     

(i + 

1) > 

num_w

armup

_step

s and

 (i +

 1) %

 self

.sche

duler

.orde

r == 

0



     

     

     

 ):



     

     

     

     

progr

ess_b

ar.up

date(

)



     

     

     

     

if ca

llbac

k is 

not N

one a

nd i 

% cal

lback

_step

s == 

0:



     

     

     

     

    c

allba

ck(i,

 t, l

atent

s)





     

   ##

#### 

BEV: 

here 

rebui

ld th

e sha

pes b

ack. 

post-

proce

ss st

ill a

ssume



     

   # 

laten

ts, n

o nee

d for

 b, n

, 4, 

28, 5

0



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ##

### B

EV en

d





     

   # 

If we

 do s

equen

tial 

model

 offl

oadin

g, le

t's o

ffloa

d une

t and

 cont

rolne

t



     

   # 

manua

lly f

or ma

x mem

ory s

aving

s



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.une

t.to(

"cpu"

)



     

     

  sel

f.con

troln

et.to

("cpu

")



     

     

  tor

ch.cu

da.em

pty_c

ache(

)





     

   if

 outp

ut_ty

pe ==

 "lat

ent":



     

     

  ima

ge = 

laten

ts



     

     

  has

_nsfw

_conc

ept =

 None



     

   el

if ou

tput_

type 

== "p

il":



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

     

  # 1

0. Co

nvert

 to P

IL



     

     

  ima

ge = 

self.

numpy

_to_p

il_do

uble(

image

)



     

   el

se:



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

   # 

Offlo

ad la

st mo

del t

o CPU



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.fin

al_of

fload

_hook

.offl

oad()





     

   if

 not 

retur

n_dic

t:



     

     

  ret

urn (

image

, has

_nsfw

_conc

ept)





     

   re

turn 

BEVSt

ableD

iffus

ionPi

pelin

eOutp

ut(



     

     

  ima

ges=i

mage,

 nsfw

_cont

ent_d

etect

ed=ha

s_nsf

w_con

cept



     

   )



from 

datac

lasse

s imp

ort d

atacl

ass



from 

typin

g imp

ort A

ny, C

allab

le, D

ict, 

List,

 Opti

onal,

 Tupl

e, Un

ion



impor

t ins

pect





impor

t tor

ch



impor

t PIL



impor

t num

py as

 np



from 

einop

s imp

ort r

earra

nge





from 

diffu

sers 

impor

t Sta

bleDi

ffusi

onCon

trolN

etPip

eline



from 

diffu

sers.

utils

 impo

rt Ba

seOut

put



from 

diffu

sers.

image

_proc

essor

 impo

rt Va

eImag

eProc

essor



from 

diffu

sers.

model

s imp

ort A

utoen

coder

KL, U

Net2D

Condi

tionM

odel



from 

diffu

sers.

pipel

ines.

stabl

e_dif

fusio

n imp

ort S

table

Diffu

sionS

afety

Check

er



from 

diffu

sers.

sched

ulers

.sche

dulin

g_uti

ls im

port 

Karra

sDiff

usion

Sched

ulers



from 

trans

forme

rs im

port 

CLIPI

mageP

roces

sor, 

CLIPT

extMo

del, 

CLIPT

okeni

zer





from 

..mis

c.com

mon i

mport

 move

_to







@data

class



class

 BEVS

table

Diffu

sionP

ipeli

neOut

put(B

aseOu

tput)

:



    "

""



    O

utput

 clas

s for

 Stab

le Di

ffusi

on pi

pelin

es.





    A

rgs:



     

   im

ages 

(`Lis

t[PIL

.Imag

e.Ima

ge]` 

or `n

p.nda

rray`

)



     

     

  Lis

t of 

denoi

sed P

IL im

ages 

of le

ngth 

`batc

h_siz

e` or

 nump

y arr

ay of

 shap

e `(b

atch_

size,

 heig

ht, w

idth,



     

     

  num

_chan

nels)

`. PI

L ima

ges o

r num

py ar

ray p

resen

t the

 deno

ised 

image

s of 

the d

iffus

ion p

ipeli

ne.



     

   ns

fw_co

ntent

_dete

cted 

(`Lis

t[boo

l]`)



     

     

  Lis

t of 

flags

 deno

ting 

wheth

er th

e cor

respo

nding

 gene

rated

 imag

e lik

ely r

epres

ents 

"not-

safe-

for-w

ork"



     

     

  (ns

fw) c

onten

t, or

 `Non

e` if

 safe

ty ch

eckin

g cou

ld no

t be 

perfo

rmed.



    "

""





    i

mages

: Uni

on[Li

st[Li

st[PI

L.Ima

ge.Im

age]]

, np.

ndarr

ay]



    n

sfw_c

onten

t_det

ected

: Opt

ional

[List

[bool

]]







class

 Stab

leDif

fusio

nBEVC

ontro

lNetP

ipeli

ne(St

ableD

iffus

ionCo

ntrol

NetPi

pelin

e):



    d

ef __

init_

_(



     

   se

lf,



     

   va

e: Au

toenc

oderK

L,



     

   te

xt_en

coder

: CLI

PText

Model

,



     

   un

et: U

Net2D

Condi

tionM

odel,



     

   co

ntrol

net,



     

   sc

hedul

er: K

arras

Diffu

sionS

chedu

lers,



     

   to

keniz

er: C

LIPTo

keniz

er,



     

   sa

fety_

check

er: S

table

Diffu

sionS

afety

Check

er = 

None,



     

   fe

ature

_extr

actor

: CLI

PImag

eProc

essor

 = No

ne,



     

   re

quire

s_saf

ety_c

hecke

r: bo

ol = 

False

,



    )

:



     

   su

per()

.__in

it__(



     

     

  vae

,



     

     

  tex

t_enc

oder,



     

     

  tok

enize

r,



     

     

  une

t,



     

     

  con

troln

et,



     

     

  sch

edule

r,



     

     

  saf

ety_c

hecke

r,



     

     

  fea

ture_

extra

ctor,



     

     

  req

uires

_safe

ty_ch

ecker

,



     

   )



     

   as

sert 

safet

y_che

cker 

== No

ne, "

Pleas

e do 

not u

se sa

fety_

check

er."



     

   se

lf.co

ntrol

_imag

e_pro

cesso

r = V

aeIma

gePro

cesso

r(



     

     

  vae

_scal

e_fac

tor=s

elf.v

ae_sc

ale_f

actor

,



     

     

  do_

resiz

e=Fal

se,



     

     

  do_

conve

rt_rg

b=Fal

se,



     

     

  do_

norma

lize=

False

,



     

   )





    d

ef nu

mpy_t

o_pil

_doub

le(se

lf, i

mages

):



     

   ""

"



     

   Co

nvert

 a nu

mpy i

mage 

or a 

batch

 of i

mages

 to a

 PIL 

image

.



     

   We

 need

 to h

andle

 5-di

m inp

uts a

nd re

ture 

2-dim

 list

.



     

   ""

"



     

   im

gs_li

st = 

[]



     

   fo

r img

s in 

image

s:



     

     

  img

s_lis

t.app

end(s

elf.n

umpy_

to_pi

l(img

s))



     

   re

turn 

imgs_

list





    #

 Copi

ed fr

om di

ffuse

rs.pi

pelin

es.st

able_

diffu

sion.

pipel

ine_s

table

_diff

usion

.Stab

leDif

fusio

nPipe

line.

prepa

re_ex

tra_s

tep_k

wargs



    d

ef pr

epare

_extr

a_ste

p_kwa

rgs(s

elf, 

gener

ator,

 eta)

:



     

   # 

prepa

re ex

tra k

wargs

 for 

the s

chedu

ler s

tep, 

since

 not 

all s

chedu

lers 

have 

the s

ame s

ignat

ure



     

   # 

eta (

η) is

 only

 used

 with

 the 

DDIMS

chedu

ler, 

it wi

ll be

 igno

red f

or ot

her s

chedu

lers.



     

   # 

eta c

orres

ponds

 to η

 in D

DIM p

aper:

 http

s://a

rxiv.

org/a

bs/20

10.02

502



     

   # 

and s

hould

 be b

etwee

n [0,

 1]





     

   ac

cepts

_eta 

= "et

a" in

 set(

inspe

ct.si

gnatu

re(se

lf.sc

hedul

er.st

ep).p

arame

ters.

keys(

))



     

   ex

tra_s

tep_k

wargs

 = {}



     

   if

 acce

pts_e

ta:



     

     

  ext

ra_st

ep_kw

args[

"eta"

] = e

ta





     

   # 

check

 if t

he sc

hedul

er ac

cepts

 gene

rator



     

   ac

cepts

_gene

rator

 = "g

enera

tor" 

in se

t(ins

pect.

signa

ture(

self.

sched

uler.

step)

.para

meter

s.key

s())



     

   if

 acce

pts_g

enera

tor:



     

     

  rai

se Ru

ntime

Error

("If 

you f

ixed 

the l

ogic 

for g

enera

tor, 

pleas

e rem

ove t

his. 

Other

wise,

 plea

se us

e oth

er sa

mpler

.")



     

     

  ext

ra_st

ep_kw

args[

"gene

rator

"] = 

gener

ator



     

   re

turn 

extra

_step

_kwar

gs





    d

ef de

code_

laten

ts(se

lf, l

atent

s):



     

   # 

decod

e lat

ents 

with 

5-dim

s



     

   la

tents

 = 1 

/ sel

f.vae

.conf

ig.sc

aling

_fact

or * 

laten

ts





     

   bs

 = le

n(lat

ents)



     

   la

tents

 = re

arran

ge(la

tents

, 'b 

c ...

 -> (

b c) 

...')



     

   im

age =

 self

.vae.

decod

e(lat

ents)

.samp

le



     

   im

age =

 rear

range

(imag

e, '(

b c) 

... -

> b c

 ...'

, b=b

s)





     

   im

age =

 (ima

ge / 

2 + 0

.5).c

lamp(

0, 1)



     

   # 

we al

ways 

cast 

to fl

oat32

 as t

his d

oes n

ot ca

use s

ignif

icant

 over

head 

and i

s com

patib

le wi

th bf

loat1

6



     

   im

age =

 rear

range

(imag

e.cpu

(), '

... c

 h w 

-> ..

. h w

 c').

float

().nu

mpy()



     

   re

turn 

image





    @

torch

.no_g

rad()



    d

ef __

call_

_(



     

   se

lf,



     

   pr

ompt:

 Unio

n[str

, Lis

t[str

]],



     

   im

age: 

torch

.Floa

tTens

or,



     

   ca

mera_

param

: Uni

on[to

rch.T

ensor

, Non

e],



     

   he

ight:

 int,



     

   wi

dth: 

int,



     

   nu

m_inf

erenc

e_ste

ps: i

nt = 

50,



     

   gu

idanc

e_sca

le: f

loat 

= 7.5

,



     

   ne

gativ

e_pro

mpt: 

Optio

nal[U

nion[

str, 

List[

str]]

] = N

one,



     

   nu

m_ima

ges_p

er_pr

ompt:

 Opti

onal[

int] 

= 1,



     

   et

a: fl

oat =

 0.0,



     

   ge

nerat

or: O

ption

al[to

rch.G

enera

tor] 

= Non

e,



     

   la

tents

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   pr

ompt_

embed

s: Op

tiona

l[tor

ch.Fl

oatTe

nsor]

 = No

ne,



     

   ne

gativ

e_pro

mpt_e

mbeds

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   ou

tput_

type:

 Opti

onal[

str] 

= "pi

l",



     

   re

turn_

dict:

 bool

 = Tr

ue,



     

   ca

llbac

k: Op

tiona

l[Cal

lable

[[int

, int

, tor

ch.Fl

oatTe

nsor]

, Non

e]] =

 None

,



     

   ca

llbac

k_ste

ps: i

nt = 

1,



     

   cr

oss_a

ttent

ion_k

wargs

: Opt

ional

[Dict

[str,

 Any]

] = N

one,



     

   co

ntrol

net_c

ondit

ionin

g_sca

le: f

loat 

= 1,



     

   gu

ess_m

ode: 

bool 

= Fal

se,



     

   us

e_zer

o_map

_as_u

ncond

ition

al: b

ool =

 Fals

e,



     

   be

v_con

troln

et_kw

args 

= {},



     

   bb

ox_ma

x_len

gth =

 None

,



    )

:



     

   r"

""



     

   Fu

nctio

n inv

oked 

when 

calli

ng th

e pip

eline

 for 

gener

ation

.





     

   Ar

gs:



     

     

  pro

mpt (

`str`

 or `

List[

str]`

, *op

tiona

l*):



     

     

     

 The 

promp

t or 

promp

ts to

 guid

e the

 imag

e gen

erati

on. I

f not

 defi

ned, 

one h

as to

 pass

 `pro

mpt_e

mbeds

`.



     

     

     

 inst

ead.



     

     

  ima

ge (`

torch

.Floa

tTens

or`, 

`PIL.

Image

.Imag

e`, `

List[

torch

.Floa

tTens

or]`,

 `Lis

t[PIL

.Imag

e.Ima

ge]`,



     

     

     

     

`List

[List

[torc

h.Flo

atTen

sor]]

`, or

 `Lis

t[Lis

t[PIL

.Imag

e.Ima

ge]]`

):



     

     

     

 The 

Contr

olNet

 inpu

t con

ditio

n. Co

ntrol

Net u

ses t

his i

nput 

condi

tion 

to ge

nerat

e gui

dance

 to U

net. 

If



     

     

     

 the 

type 

is sp

ecifi

ed as

 `Tor

ch.Fl

oatTe

nsor`

, it 

is pa

ssed 

to Co

ntrol

Net a

s is.

 `PIL

.Imag

e.Ima

ge` c

an



     

     

     

 also

 be a

ccept

ed as

 an i

mage.

 The 

dimen

sions

 of t

he ou

tput 

image

 defa

ults 

to `i

mage`

's di

mensi

ons. 

If



     

     

     

 heig

ht an

d/or 

width

 are 

passe

d, `i

mage`

 is r

esize

d acc

ordin

g to 

them.

 If m

ultip

le Co

ntrol

Nets 

are



     

     

     

 spec

ified

 in i

nit, 

image

s mus

t be 

passe

d as 

a lis

t suc

h tha

t eac

h ele

ment 

of th

e lis

t can

 be c

orrec

tly



     

     

     

 batc

hed f

or in

put t

o a s

ingle

 cont

rolne

t.



     

     

  hei

ght (

`int`

, *op

tiona

l*, d

efaul

ts to

 self

.unet

.conf

ig.sa

mple_

size 

* sel

f.vae

_scal

e_fac

tor):



     

     

     

 The 

heigh

t in 

pixel

s of 

the g

enera

ted i

mage.



     

     

  wid

th (`

int`,

 *opt

ional

*, de

fault

s to 

self.

unet.

confi

g.sam

ple_s

ize *

 self

.vae_

scale

_fact

or):



     

     

     

 The 

width

 in p

ixels

 of t

he ge

nerat

ed im

age.



     

     

  num

_infe

rence

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 5

0):



     

     

     

 The 

numbe

r of 

denoi

sing 

steps

. Mor

e den

oisin

g ste

ps us

ually

 lead

 to a

 high

er qu

ality

 imag

e at 

the



     

     

     

 expe

nse o

f slo

wer i

nfere

nce.



     

     

  gui

dance

_scal

e (`f

loat`

, *op

tiona

l*, d

efaul

ts to

 7.5)

:



     

     

     

 Guid

ance 

scale

 as d

efine

d in 

[Clas

sifie

r-Fre

e Dif

fusio

n Gui

dance

](htt

ps://

arxiv

.org/

abs/2

207.1

2598)

.



     

     

     

 `gui

dance

_scal

e` is

 defi

ned a

s `w`

 of e

quati

on 2.

 of [

Image

n



     

     

     

 Pape

r](ht

tps:/

/arxi

v.org

/pdf/

2205.

11487

.pdf)

. Gui

dance

 scal

e is 

enabl

ed by

 sett

ing `

guida

nce_s

cale 

>



     

     

     

 1`. 

Highe

r gui

dance

 scal

e enc

ourag

es to

 gene

rate 

image

s tha

t are

 clos

ely l

inked

 to t

he te

xt `p

rompt

`,



     

     

     

 usua

lly a

t the

 expe

nse o

f low

er im

age q

ualit

y.



     

     

  neg

ative

_prom

pt (`

str` 

or `L

ist[s

tr]`,

 *opt

ional

*):



     

     

     

 The 

promp

t or 

promp

ts no

t to 

guide

 the 

image

 gene

ratio

n. If

 not 

defin

ed, o

ne ha

s to 

pass



     

     

     

 `neg

ative

_prom

pt_em

beds`

 inst

ead. 

Ignor

ed wh

en no

t usi

ng gu

idanc

e (i.

e., i

gnore

d if 

`guid

ance_

scale

` is



     

     

     

 less

 than

 `1`)

.



     

     

  num

_imag

es_pe

r_pro

mpt (

`int`

, *op

tiona

l*, d

efaul

ts to

 1):



     

     

     

 The 

numbe

r of 

image

s to 

gener

ate p

er pr

ompt.



     

     

  eta

 (`fl

oat`,

 *opt

ional

*, de

fault

s to 

0.0):



     

     

     

 Corr

espon

ds to

 para

meter

 eta 

(η) i

n the

 DDIM

 pape

r: ht

tps:/

/arxi

v.org

/abs/

2010.

02502

. Onl

y app

lies 

to



     

     

     

 [`sc

hedul

ers.D

DIMSc

hedul

er`],

 will

 be i

gnore

d for

 othe

rs.



     

     

  gen

erato

r (`t

orch.

Gener

ator`

 or `

List[

torch

.Gene

rator

]`, *

optio

nal*)

:



     

     

     

 One 

or a 

list 

of [t

orch 

gener

ator(

s)](h

ttps:

//pyt

orch.

org/d

ocs/s

table

/gene

rated

/torc

h.Gen

erato

r.htm

l)



     

     

     

 to m

ake g

enera

tion 

deter

minis

tic.



     

     

  lat

ents 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

noisy

 late

nts, 

sampl

ed fr

om a 

Gauss

ian d

istri

butio

n, to

 be u

sed a

s inp

uts f

or im

age



     

     

     

 gene

ratio

n. Ca

n be 

used 

to tw

eak t

he sa

me ge

nerat

ion w

ith d

iffer

ent p

rompt

s. If

 not 

provi

ded, 

a lat

ents



     

     

     

 tens

or wi

ll ge

 gene

rated

 by s

ampli

ng us

ing t

he su

pplie

d ran

dom `

gener

ator`

.



     

     

  pro

mpt_e

mbeds

 (`to

rch.F

loatT

ensor

`, *o

ption

al*):



     

     

     

 Pre-

gener

ated 

text 

embed

dings

. Can

 be u

sed t

o eas

ily t

weak 

text 

input

s, *e

.g.* 

promp

t wei

ghtin

g. If

 not



     

     

     

 prov

ided,

 text

 embe

dding

s wil

l be 

gener

ated 

from 

`prom

pt` i

nput 

argum

ent.



     

     

  neg

ative

_prom

pt_em

beds 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

negat

ive t

ext e

mbedd

ings.

 Can 

be us

ed to

 easi

ly tw

eak t

ext i

nputs

, *e.

g.* p

rompt



     

     

     

 weig

hting

. If 

not p

rovid

ed, n

egati

ve_pr

ompt_

embed

s wil

l be 

gener

ated 

from 

`nega

tive_

promp

t` in

put



     

     

     

 argu

ment.



     

     

  out

put_t

ype (

`str`

, *op

tiona

l*, d

efaul

ts to

 `"pi

l"`):



     

     

     

 The 

outpu

t for

mat o

f the

 gene

rate 

image

. Cho

ose b

etwee

n



     

     

     

 [PIL

](htt

ps://

pillo

w.rea

dthed

ocs.i

o/en/

stabl

e/): 

`PIL.

Image

.Imag

e` or

 `np.

array

`.



     

     

  ret

urn_d

ict (

`bool

`, *o

ption

al*, 

defau

lts t

o `Tr

ue`):



     

     

     

 Whet

her o

r not

 to r

eturn

 a [`

~pipe

lines

.stab

le_di

ffusi

on.St

ableD

iffus

ionPi

pelin

eOutp

ut`] 

inste

ad of

 a



     

     

     

 plai

n tup

le.



     

     

  cal

lback

 (`Ca

llabl

e`, *

optio

nal*)

:



     

     

     

 A fu

nctio

n tha

t wil

l be 

calle

d eve

ry `c

allba

ck_st

eps` 

steps

 duri

ng in

feren

ce. T

he fu

nctio

n wil

l be



     

     

     

 call

ed wi

th th

e fol

lowin

g arg

ument

s: `c

allba

ck(st

ep: i

nt, t

imest

ep: i

nt, l

atent

s: to

rch.F

loatT

ensor

)`.



     

     

  cal

lback

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 1

):



     

     

     

 The 

frequ

ency 

at wh

ich t

he `c

allba

ck` f

uncti

on wi

ll be

 call

ed. I

f not

 spec

ified

, the

 call

back 

will 

be



     

     

     

 call

ed at

 ever

y ste

p.



     

     

  cro

ss_at

tenti

on_kw

args 

(`dic

t`, *

optio

nal*)

:



     

     

     

 A kw

args 

dicti

onary

 that

 if s

pecif

ied i

s pas

sed a

long 

to th

e `At

tenti

onPro

cesso

r` as

 defi

ned u

nder



     

     

     

 `sel

f.pro

cesso

r` in



     

     

     

 [dif

fuser

s.cro

ss_at

tenti

on](h

ttps:

//git

hub.c

om/hu

gging

face/

diffu

sers/

blob/

main/

src/d

iffus

ers/m

odels

/cros

s_att

entio

n.py)

.



     

     

  con

troln

et_co

nditi

oning

_scal

e (`f

loat`

 or `

List[

float

]`, *

optio

nal*,

 defa

ults 

to 1.

0):



     

     

     

 The 

outpu

ts of

 the 

contr

olnet

 are 

multi

plied

 by `

contr

olnet

_cond

ition

ing_s

cale`

 befo

re th

ey ar

e add

ed



     

     

     

 to t

he re

sidua

l in 

the o

rigin

al un

et. I

f mul

tiple

 Cont

rolNe

ts ar

e spe

cifie

d in 

init,

 you 

can s

et th

e



     

     

     

 corr

espon

ding 

scale

 as a

 list

.



     

     

  gue

ss_mo

de (`

bool`

, *op

tiona

l*, d

efaul

ts to

 `Fal

se`):



     

     

     

 In t

his m

ode, 

the C

ontro

lNet 

encod

er wi

ll tr

y bes

t to 

recog

nize 

the c

onten

t of 

the i

nput 

image

 even

 if



     

     

     

 you 

remov

e all

 prom

pts. 

The `

guida

nce_s

cale`

 betw

een 3

.0 an

d 5.0

 is r

ecomm

ended

.





     

   Ex

ample

s:





     

   Re

turns

:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] o

r `tu

ple`:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] i

f `re

turn_

dict`

 is T

rue, 

other

wise 

a `tu

ple.



     

     

  Whe

n ret

urnin

g a t

uple,

 the 

first

 elem

ent i

s a l

ist w

ith t

he ge

nerat

ed im

ages,

 and 

the s

econd

 elem

ent i

s a



     

     

  lis

t of 

`bool

`s de

notin

g whe

ther 

the c

orres

pondi

ng ge

nerat

ed im

age l

ikely

 repr

esent

s "no

t-saf

e-for

-work

"



     

     

  (ns

fw) c

onten

t, ac

cordi

ng to

 the 

`safe

ty_ch

ecker

`.



     

   ""

"



     

   # 

0. De

fault

 heig

ht an

d wid

th to

 unet



     

   # 

BEV: 

we ca

nnot 

use t

he si

ze of

 imag

e



     

   # 

heigh

t, wi

dth =

 self

._def

ault_

heigh

t_wid

th(he

ight,

 widt

h, No

ne)





     

   # 

1. Ch

eck i

nputs

. Rai

se er

ror i

f not

 corr

ect



     

   # 

we do

 not 

need 

this,

 only

 some

 type

 asse

rtion



     

   # 

self.

check

_inpu

ts(



     

   # 

    p

rompt

,



     

   # 

    i

mage,



     

   # 

    h

eight

,



     

   # 

    w

idth,



     

   # 

    c

allba

ck_st

eps,



     

   # 

    n

egati

ve_pr

ompt,



     

   # 

    p

rompt

_embe

ds,



     

   # 

    n

egati

ve_pr

ompt_

embed

s,



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

   # 

)





     

   # 

2. De

fine 

call 

param

eters



     

   # 

NOTE:

 we g

et ba

tch_s

ize f

irst 

from 

promp

t, th

en al

ign w

ith i

t.



     

   if

 prom

pt is

 not 

None 

and i

sinst

ance(

promp

t, st

r):



     

     

  bat

ch_si

ze = 

1



     

   el

if pr

ompt 

is no

t Non

e and

 isin

stanc

e(pro

mpt, 

list)

:



     

     

  bat

ch_si

ze = 

len(p

rompt

)



     

   el

se:



     

     

  bat

ch_si

ze = 

promp

t_emb

eds.s

hape[

0]





     

   de

vice 

= sel

f._ex

ecuti

on_de

vice



     

   # 

here 

`guid

ance_

scale

` is 

defin

ed an

alog 

to th

e gui

dance

 weig

ht `w

` of 

equat

ion (

2)



     

   # 

of th

e Ima

gen p

aper:

 http

s://a

rxiv.

org/p

df/22

05.11

487.p

df . 

`guid

ance_

scale

 = 1`



     

   # 

corre

spond

s to 

doing

 no c

lassi

fier 

free 

guida

nce.



     

   do

_clas

sifie

r_fre

e_gui

dance

 = gu

idanc

e_sca

le > 

1.0





     

   ##

# BEV

, che

ck ca

mera_

param

 ###



     

   if

 came

ra_pa

ram i

s Non

e:



     

     

  # u

se un

cond_

cam a

nd di

sable

 clas

sifie

r fre

e gui

dance



     

     

  N_c

am = 

6  # 

TODO:

 hard

-code

d



     

     

  cam

era_p

aram 

= sel

f.con

troln

et.un

cond_

cam_p

aram(

(batc

h_siz

e, N_

cam))



     

     

  do_

class

ifier

_free

_guid

ance 

= Fal

se



     

   ##

# don

e ###





     

   # 

if is

insta

nce(s

elf.c

ontro

lnet,

 Mult

iCont

rolNe

tMode

l) an

d isi

nstan

ce(co

ntrol

net_c

ondit

ionin

g_sca

le, f

loat)

:



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale =

 [con

troln

et_co

nditi

oning

_scal

e] * 

len(s

elf.c

ontro

lnet.

nets)





     

   # 

3. En

code 

input

 prom

pt



     

   # 

NOTE:

 here

 they

 use 

paddi

ng to

 77, 

is th

is ne

cessa

ry?



     

   pr

ompt_

embed

s = s

elf._

encod

e_pro

mpt(



     

     

  pro

mpt,



     

     

  dev

ice,



     

     

  num

_imag

es_pe

r_pro

mpt,



     

     

  do_

class

ifier

_free

_guid

ance,



     

     

  neg

ative

_prom

pt,



     

     

  pro

mpt_e

mbeds

=prom

pt_em

beds,



     

     

  neg

ative

_prom

pt_em

beds=

negat

ive_p

rompt

_embe

ds,



     

   ) 

 # (2

 * b,

 77 +

 1, 7

68)





     

   # 

4. Pr

epare

 imag

e



     

   # 

NOTE:

 if i

mage 

is no

t ten

sor, 

there

 will

 be s

evera

l pro

cess.



     

   as

sert 

not s

elf.c

ontro

l_ima

ge_pr

ocess

or.co

nfig.

do_no

rmali

ze, "

Your 

contr

olnet

 shou

ld no

t nor

maliz

e the

 cont

rol i

mage.

"



     

   im

age =

 self

.prep

are_i

mage(



     

     

  ima

ge=im

age,



     

     

  wid

th=wi

dth,



     

     

  hei

ght=h

eight

,



     

     

  bat

ch_si

ze=ba

tch_s

ize *

 num_

image

s_per

_prom

pt,



     

     

  num

_imag

es_pe

r_pro

mpt=n

um_im

ages_

per_p

rompt

,



     

     

  dev

ice=d

evice

,



     

     

  dty

pe=se

lf.co

ntrol

net.d

type,



     

     

  do_

class

ifier

_free

_guid

ance=

do_cl

assif

ier_f

ree_g

uidan

ce,



     

     

  gue

ss_mo

de=gu

ess_m

ode,



     

   ) 

 # (2

 * b,

 c_26

, 200

, 200

)



     

   if

 use_

zero_

map_a

s_unc

ondit

ional

 and 

do_cl

assif

ier_f

ree_g

uidan

ce:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  _im

ages[

0] = 

torch

.zero

s_lik

e(_im

ages[

0])



     

     

  ima

ge = 

torch

.cat(

_imag

es)





     

   # 

5. Pr

epare

 time

steps



     

   se

lf.sc

hedul

er.se

t_tim

estep

s(num

_infe

rence

_step

s, de

vice=

devic

e)



     

   ti

meste

ps = 

self.

sched

uler.

times

teps





     

   # 

6. Pr

epare

 late

nt va

riabl

es



     

   nu

m_cha

nnels

_late

nts =

 self

.unet

.conf

ig.in

_chan

nels



     

   la

tents

 = se

lf.pr

epare

_late

nts(



     

     

  bat

ch_si

ze * 

num_i

mages

_per_

promp

t,



     

     

  num

_chan

nels_

laten

ts,



     

     

  hei

ght,



     

     

  wid

th,



     

     

  pro

mpt_e

mbeds

.dtyp

e,



     

     

  dev

ice,



     

     

  gen

erato

r,



     

     

  lat

ents,

  # w

ill u

se if

 not 

None,

 othe

rwise

 will

 gene

rate



     

   ) 

 # (b

, c, 

h/8, 

w/8) 

-> (b

s, 4,

 28, 

50)





     

   # 

7. Pr

epare

 extr

a ste

p kwa

rgs.



     

   ex

tra_s

tep_k

wargs

 = se

lf.pr

epare

_extr

a_ste

p_kwa

rgs(g

enera

tor, 

eta)





     

   ##

#### 

BEV: 

here 

we re

const

ruct 

each 

input

 form

at ##

####



     

   as

sert 

camer

a_par

am.sh

ape[0

] == 

batch

_size

, \



     

     

  f"E

xcept

 {bat

ch_si

ze} c

amera

 para

ms, b

ut yo

u hav

e bs=

{len(

camer

a_par

am)}"



     

   N_

cam =

 came

ra_pa

ram.s

hape[

1]



     

   la

tents

 = to

rch.s

tack(

[late

nts] 

* N_c

am, d

im=1)

  # b

s, 6,

 4, 2

8, 50



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ca

mera_

param

 = ca

mera_

param

.to(s

elf.d

evice

)



     

   if

 do_c

lassi

fier_

free_

guida

nce a

nd no

t gue

ss_mo

de:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  kwa

rgs_w

ith_u

ncond

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_kw

args(



     

     

     

 came

ra_pa

ram=c

amera

_para

m,



     

     

     

 imag

e=_im

ages[

0],  

# 0 i

s for

 unco

nditi

onal



     

     

     

 max_

len=b

box_m

ax_le

ngth,



     

     

     

 **be

v_con

troln

et_kw

args,



     

     

  )



     

     

  kwa

rgs_w

ith_u

ncond

.pop(

"max_

len",

 None

)  # 

some 

do no

t tak

e thi

s.



     

     

  cam

era_p

aram 

= kwa

rgs_w

ith_u

ncond

.pop(

"came

ra_pa

ram")



     

     

  _im

ages[

0] = 

kwarg

s_wit

h_unc

ond.p

op("i

mage"

)



     

     

  ima

ge = 

torch

.cat(

_imag

es)



     

     

  bev

_cont

rolne

t_kwa

rgs =

 move

_to(k

wargs

_with

_unco

nd, s

elf.d

evice

)



     

   ##

#### 

BEV e

nd ##

####





     

   # 

8. De

noisi

ng lo

op



     

   nu

m_war

mup_s

teps 

= len

(time

steps

) - n

um_in

feren

ce_st

eps *

 self

.sche

duler

.orde

r



     

   wi

th se

lf.pr

ogres

s_bar

(tota

l=num

_infe

rence

_step

s) as

 prog

ress_

bar:



     

     

  for

 i, t

 in e

numer

ate(t

imest

eps):



     

     

     

 # ex

pand 

the l

atent

s if 

we ar

e doi

ng cl

assif

ier f

ree g

uidan

ce



     

     

     

 # bs

*2, 6

, 4, 

28, 5

0



     

     

     

 late

nt_mo

del_i

nput 

= (



     

     

     

     

torch

.cat(

[late

nts] 

* 2) 

if do

_clas

sifie

r_fre

e_gui

dance

 else

 late

nts



     

     

     

 )



     

     

     

 late

nt_mo

del_i

nput 

= sel

f.sch

edule

r.sca

le_mo

del_i

nput(



     

     

     

     

laten

t_mod

el_in

put, 

t



     

     

     

 )





     

     

     

 # co

ntrol

net(s

) inf

erenc

e



     

     

     

 cont

rolne

t_t =

 t.un

squee

ze(0)



     

     

     

 # gu

ess_m

ode &

 clas

sifie

r_fre

e_gui

dance

 -> o

nly g

uidan

ce us

e con

troln

et



     

     

     

 # no

t gue

ss_mo

de & 

class

ifier

_free

_guid

ance 

-> al

l use

 cont

rolne

t



     

     

     

 # gu

ess_m

ode -

> nor

mal i

nput,

 take

 effe

ct in

 cont

rolne

t



     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

er Co

ntrol

Net o

nly f

or th

e con

ditio

nal b

atch.



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ents



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds

.chun

k(2)[

1]



     

     

     

 else

:



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ent_m

odel_

input



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds



     

     

     

 cont

rolne

t_t =

 cont

rolne

t_t.r

epeat

(len(

contr

olnet

_late

nt_mo

del_i

nput)

)





     

     

     

 # fm

t: of

f



     

     

     

 down

_bloc

k_res

_samp

les, 

mid_b

lock_

res_s

ample

, \



     

     

     

 enco

der_h

idden

_stat

es_wi

th_ca

m = s

elf.c

ontro

lnet(



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput,



     

     

     

     

contr

olnet

_t,



     

     

     

     

camer

a_par

am,  

# for

 BEV



     

     

     

     

encod

er_hi

dden_

state

s=con

troln

et_pr

ompt_

embed

s,



     

     

     

     

contr

olnet

_cond

=imag

e,



     

     

     

     

condi

tioni

ng_sc

ale=c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

     

     

     

guess

_mode

=gues

s_mod

e,



     

     

     

     

retur

n_dic

t=Fal

se,



     

     

     

     

**bev

_cont

rolne

t_kwa

rgs, 

# for

 BEV



     

     

     

 )



     

     

     

 # fm

t: on





     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

ered 

Contr

olNet

 only

 for 

the c

ondit

ional

 batc

h.



     

     

     

     

# To 

apply

 the 

outpu

t of 

Contr

olNet

 to b

oth t

he un

condi

tiona

l and

 cond

ition

al ba

tches

,



     

     

     

     

# add

 0 to

 the 

uncon

ditio

nal b

atch 

to ke

ep it

 unch

anged

.



     

     

     

     

down_

block

_res_

sampl

es = 

[



     

     

     

     

    t

orch.

cat([

torch

.zero

s_lik

e(d),

 d])



     

     

     

     

    f

or d 

in do

wn_bl

ock_r

es_sa

mples



     

     

     

     

]



     

     

     

     

mid_b

lock_

res_s

ample

 = to

rch.c

at(



     

     

     

     

    [

torch

.zero

s_lik

e(mid

_bloc

k_res

_samp

le), 

mid_b

lock_

res_s

ample

]



     

     

     

     

)



     

     

     

     

# add

 unco

nd en

coder

_hidd

en_st

ates_

with_

cam h

ere



     

     

     

     

encod

er_hi

dden_

state

s_wit

h_cam

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_em

b(



     

     

     

     

    p

rompt

_embe

ds.ch

unk(2

)[0],

 N_ca

m,



     

     

     

     

    e

ncode

r_hid

den_s

tates

_with

_cam,



     

     

     

     

)





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # St

ratin

g fro

m her

e, we

 use 

4-dim

 data

.



     

     

     

 # en

coder

_hidd

en_st

ates_

with_

cam: 

(2b x

 N), 

78, 7

68



     

     

     

 # la

tent_

model

_inpu

t: 2b

, N, 

4, 28

, 50 

-> 2b

 x N,

 4, 2

8, 50



     

     

     

 late

nt_mo

del_i

nput 

= rea

rrang

e(



     

     

     

     

laten

t_mod

el_in

put, 

'b n 

... -

> (b 

n) ..

.')



     

     

     

 late

nts =

 rear

range

(late

nts, 

'b n 

... -

> (b 

n) ..

.')





     

     

     

 # pr

edict

 the 

noise

 resi

dual:

 2bxN

, 4, 

28, 5

0



     

     

     

 addi

tiona

l_par

am = 

{}



     

     

     

 nois

e_pre

d = s

elf.u

net(



     

     

     

     

laten

t_mod

el_in

put, 

 # ma

y wit

h unc

ondit

ional



     

     

     

     

t,



     

     

     

     

encod

er_hi

dden_

state

s=enc

oder_

hidde

n_sta

tes_w

ith_c

am,



     

     

     

     

**add

ition

al_pa

ram, 

 # if

 use 

origi

nal u

net, 

it ca

nnot 

take 

kwarg

s



     

     

     

     

cross

_atte

ntion

_kwar

gs=cr

oss_a

ttent

ion_k

wargs

,



     

     

     

     

down_

block

_addi

tiona

l_res

idual

s=dow

n_blo

ck_re

s_sam

ples,



     

     

     

     

mid_b

lock_

addit

ional

_resi

dual=

mid_b

lock_

res_s

ample

,



     

     

     

 ).sa

mple





     

     

     

 # pe

rform

 guid

ance



     

     

     

 if d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# for

 each

: bxN

, 4, 

28, 5

0



     

     

     

     

noise

_pred

_unco

nd, n

oise_

pred_

text 

= noi

se_pr

ed.ch

unk(2

)



     

     

     

     

noise

_pred

 = no

ise_p

red_u

ncond

 + gu

idanc

e_sca

le * 

(



     

     

     

     

    n

oise_

pred_

text 

- noi

se_pr

ed_un

cond



     

     

     

     

)





     

     

     

 # co

mpute

 the 

previ

ous n

oisy 

sampl

e x_t

 -> x

_t-1



     

     

     

 # NO

TE: i

s the

 sche

duler

 use 

rando

mness

, ple

ase h

andle

 the 

logic



     

     

     

 # fo

r gen

erato

r.



     

     

     

 late

nts =

 self

.sche

duler

.step

(



     

     

     

     

noise

_pred

, t, 

laten

ts, *

*extr

a_ste

p_kwa

rgs



     

     

     

 ).pr

ev_sa

mple





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # no

w we 

add d

imens

ion b

ack, 

use 5

-dim 

data.



     

     

     

 # NO

TE: o

nly `

laten

ts` i

s upd

ated 

throu

gh th

e loo

p



     

     

     

 late

nts =

 rear

range

(late

nts, 

'(b n

) ...

 -> b

 n ..

.', n

=N_ca

m)





     

     

     

 # ca

ll th

e cal

lback

, if 

provi

ded



     

     

     

 if i

 == l

en(ti

meste

ps) -

 1 or

 (



     

     

     

     

(i + 

1) > 

num_w

armup

_step

s and

 (i +

 1) %

 self

.sche

duler

.orde

r == 

0



     

     

     

 ):



     

     

     

     

progr

ess_b

ar.up

date(

)



     

     

     

     

if ca

llbac

k is 

not N

one a

nd i 

% cal

lback

_step

s == 

0:



     

     

     

     

    c

allba

ck(i,

 t, l

atent

s)





     

   ##

#### 

BEV: 

here 

rebui

ld th

e sha

pes b

ack. 

post-

proce

ss st

ill a

ssume



     

   # 

laten

ts, n

o nee

d for

 b, n

, 4, 

28, 5

0



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ##

### B

EV en

d





     

   # 

If we

 do s

equen

tial 

model

 offl

oadin

g, le

t's o

ffloa

d une

t and

 cont

rolne

t



     

   # 

manua

lly f

or ma

x mem

ory s

aving

s



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.une

t.to(

"cpu"

)



     

     

  sel

f.con

troln

et.to

("cpu

")



     

     

  tor

ch.cu

da.em

pty_c

ache(

)





     

   if

 outp

ut_ty

pe ==

 "lat

ent":



     

     

  ima

ge = 

laten

ts



     

     

  has

_nsfw

_conc

ept =

 None



     

   el

if ou

tput_

type 

== "p

il":



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

     

  # 1

0. Co

nvert

 to P

IL



     

     

  ima

ge = 

self.

numpy

_to_p

il_do

uble(

image

)



     

   el

se:



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

   # 

Offlo

ad la

st mo

del t

o CPU



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.fin

al_of

fload

_hook

.offl

oad()





     

   if

 not 

retur

n_dic

t:



     

     

  ret

urn (

image

, has

_nsfw

_conc

ept)





     

   re

turn 

BEVSt

ableD

iffus

ionPi

pelin

eOutp

ut(



     

     

  ima

ges=i

mage,

 nsfw

_cont

ent_d

etect

ed=ha

s_nsf

w_con

cept



     

   )



from 

datac

lasse

s imp

ort d

atacl

ass



from 

typin

g imp

ort A

ny, C

allab

le, D

ict, 

List,

 Opti

onal,

 Tupl

e, Un

ion



impor

t ins

pect





impor

t tor

ch



impor

t PIL



impor

t num

py as

 np



from 

einop

s imp

ort r

earra

nge





from 

diffu

sers 

impor

t Sta

bleDi

ffusi

onCon

trolN

etPip

eline



from 

diffu

sers.

utils

 impo

rt Ba

seOut

put



from 

diffu

sers.

image

_proc

essor

 impo

rt Va

eImag

eProc

essor



from 

diffu

sers.

model

s imp

ort A

utoen

coder

KL, U

Net2D

Condi

tionM

odel



from 

diffu

sers.

pipel

ines.

stabl

e_dif

fusio

n imp

ort S

table

Diffu

sionS

afety

Check

er



from 

diffu

sers.

sched

ulers

.sche

dulin

g_uti

ls im

port 

Karra

sDiff

usion

Sched

ulers



from 

trans

forme

rs im

port 

CLIPI

mageP

roces

sor, 

CLIPT

extMo

del, 

CLIPT

okeni

zer





from 

..mis

c.com

mon i

mport

 move

_to







@data

class



class

 BEVS

table

Diffu

sionP

ipeli

neOut

put(B

aseOu

tput)

:



    "

""



    O

utput

 clas

s for

 Stab

le Di

ffusi

on pi

pelin

es.





    A

rgs:



     

   im

ages 

(`Lis

t[PIL

.Imag

e.Ima

ge]` 

or `n

p.nda

rray`

)



     

     

  Lis

t of 

denoi

sed P

IL im

ages 

of le

ngth 

`batc

h_siz

e` or

 nump

y arr

ay of

 shap

e `(b

atch_

size,

 heig

ht, w

idth,



     

     

  num

_chan

nels)

`. PI

L ima

ges o

r num

py ar

ray p

resen

t the

 deno

ised 

image

s of 

the d

iffus

ion p

ipeli

ne.



     

   ns

fw_co

ntent

_dete

cted 

(`Lis

t[boo

l]`)



     

     

  Lis

t of 

flags

 deno

ting 

wheth

er th

e cor

respo

nding

 gene

rated

 imag

e lik

ely r

epres

ents 

"not-

safe-

for-w

ork"



     

     

  (ns

fw) c

onten

t, or

 `Non

e` if

 safe

ty ch

eckin

g cou

ld no

t be 

perfo

rmed.



    "

""





    i

mages

: Uni

on[Li

st[Li

st[PI

L.Ima

ge.Im

age]]

, np.

ndarr

ay]



    n

sfw_c

onten

t_det

ected

: Opt

ional

[List

[bool

]]







class

 Stab

leDif

fusio

nBEVC

ontro

lNetP

ipeli

ne(St

ableD

iffus

ionCo

ntrol

NetPi

pelin

e):



    d

ef __

init_

_(



     

   se

lf,



     

   va

e: Au

toenc

oderK

L,



     

   te

xt_en

coder

: CLI

PText

Model

,



     

   un

et: U

Net2D

Condi

tionM

odel,



     

   co

ntrol

net,



     

   sc

hedul

er: K

arras

Diffu

sionS

chedu

lers,



     

   to

keniz

er: C

LIPTo

keniz

er,



     

   sa

fety_

check

er: S

table

Diffu

sionS

afety

Check

er = 

None,



     

   fe

ature

_extr

actor

: CLI

PImag

eProc

essor

 = No

ne,



     

   re

quire

s_saf

ety_c

hecke

r: bo

ol = 

False

,



    )

:



     

   su

per()

.__in

it__(



     

     

  vae

,



     

     

  tex

t_enc

oder,



     

     

  tok

enize

r,



     

     

  une

t,



     

     

  con

troln

et,



     

     

  sch

edule

r,



     

     

  saf

ety_c

hecke

r,



     

     

  fea

ture_

extra

ctor,



     

     

  req

uires

_safe

ty_ch

ecker

,



     

   )



     

   as

sert 

safet

y_che

cker 

== No

ne, "

Pleas

e do 

not u

se sa

fety_

check

er."



     

   se

lf.co

ntrol

_imag

e_pro

cesso

r = V

aeIma

gePro

cesso

r(



     

     

  vae

_scal

e_fac

tor=s

elf.v

ae_sc

ale_f

actor

,



     

     

  do_

resiz

e=Fal

se,



     

     

  do_

conve

rt_rg

b=Fal

se,



     

     

  do_

norma

lize=

False

,



     

   )





    d

ef nu

mpy_t

o_pil

_doub

le(se

lf, i

mages

):



     

   ""

"



     

   Co

nvert

 a nu

mpy i

mage 

or a 

batch

 of i

mages

 to a

 PIL 

image

.



     

   We

 need

 to h

andle

 5-di

m inp

uts a

nd re

ture 

2-dim

 list

.



     

   ""

"



     

   im

gs_li

st = 

[]



     

   fo

r img

s in 

image

s:



     

     

  img

s_lis

t.app

end(s

elf.n

umpy_

to_pi

l(img

s))



     

   re

turn 

imgs_

list





    #

 Copi

ed fr

om di

ffuse

rs.pi

pelin

es.st

able_

diffu

sion.

pipel

ine_s

table

_diff

usion

.Stab

leDif

fusio

nPipe

line.

prepa

re_ex

tra_s

tep_k

wargs



    d

ef pr

epare

_extr

a_ste

p_kwa

rgs(s

elf, 

gener

ator,

 eta)

:



     

   # 

prepa

re ex

tra k

wargs

 for 

the s

chedu

ler s

tep, 

since

 not 

all s

chedu

lers 

have 

the s

ame s

ignat

ure



     

   # 

eta (

η) is

 only

 used

 with

 the 

DDIMS

chedu

ler, 

it wi

ll be

 igno

red f

or ot

her s

chedu

lers.



     

   # 

eta c

orres

ponds

 to η

 in D

DIM p

aper:

 http

s://a

rxiv.

org/a

bs/20

10.02

502



     

   # 

and s

hould

 be b

etwee

n [0,

 1]





     

   ac

cepts

_eta 

= "et

a" in

 set(

inspe

ct.si

gnatu

re(se

lf.sc

hedul

er.st

ep).p

arame

ters.

keys(

))



     

   ex

tra_s

tep_k

wargs

 = {}



     

   if

 acce

pts_e

ta:



     

     

  ext

ra_st

ep_kw

args[

"eta"

] = e

ta





     

   # 

check

 if t

he sc

hedul

er ac

cepts

 gene

rator



     

   ac

cepts

_gene

rator

 = "g

enera

tor" 

in se

t(ins

pect.

signa

ture(

self.

sched

uler.

step)

.para

meter

s.key

s())



     

   if

 acce

pts_g

enera

tor:



     

     

  rai

se Ru

ntime

Error

("If 

you f

ixed 

the l

ogic 

for g

enera

tor, 

pleas

e rem

ove t

his. 

Other

wise,

 plea

se us

e oth

er sa

mpler

.")



     

     

  ext

ra_st

ep_kw

args[

"gene

rator

"] = 

gener

ator



     

   re

turn 

extra

_step

_kwar

gs





    d

ef de

code_

laten

ts(se

lf, l

atent

s):



     

   # 

decod

e lat

ents 

with 

5-dim

s



     

   la

tents

 = 1 

/ sel

f.vae

.conf

ig.sc

aling

_fact

or * 

laten

ts





     

   bs

 = le

n(lat

ents)



     

   la

tents

 = re

arran

ge(la

tents

, 'b 

c ...

 -> (

b c) 

...')



     

   im

age =

 self

.vae.

decod

e(lat

ents)

.samp

le



     

   im

age =

 rear

range

(imag

e, '(

b c) 

... -

> b c

 ...'

, b=b

s)





     

   im

age =

 (ima

ge / 

2 + 0

.5).c

lamp(

0, 1)



     

   # 

we al

ways 

cast 

to fl

oat32

 as t

his d

oes n

ot ca

use s

ignif

icant

 over

head 

and i

s com

patib

le wi

th bf

loat1

6



     

   im

age =

 rear

range

(imag

e.cpu

(), '

... c

 h w 

-> ..

. h w

 c').

float

().nu

mpy()



     

   re

turn 

image





    @

torch

.no_g

rad()



    d

ef __

call_

_(



     

   se

lf,



     

   pr

ompt:

 Unio

n[str

, Lis

t[str

]],



     

   im

age: 

torch

.Floa

tTens

or,



     

   ca

mera_

param

: Uni

on[to

rch.T

ensor

, Non

e],



     

   he

ight:

 int,



     

   wi

dth: 

int,



     

   nu

m_inf

erenc

e_ste

ps: i

nt = 

50,



     

   gu

idanc

e_sca

le: f

loat 

= 7.5

,



     

   ne

gativ

e_pro

mpt: 

Optio

nal[U

nion[

str, 

List[

str]]

] = N

one,



     

   nu

m_ima

ges_p

er_pr

ompt:

 Opti

onal[

int] 

= 1,



     

   et

a: fl

oat =

 0.0,



     

   ge

nerat

or: O

ption

al[to

rch.G

enera

tor] 

= Non

e,



     

   la

tents

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   pr

ompt_

embed

s: Op

tiona

l[tor

ch.Fl

oatTe

nsor]

 = No

ne,



     

   ne

gativ

e_pro

mpt_e

mbeds

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   ou

tput_

type:

 Opti

onal[

str] 

= "pi

l",



     

   re

turn_

dict:

 bool

 = Tr

ue,



     

   ca

llbac

k: Op

tiona

l[Cal

lable

[[int

, int

, tor

ch.Fl

oatTe

nsor]

, Non

e]] =

 None

,



     

   ca

llbac

k_ste

ps: i

nt = 

1,



     

   cr

oss_a

ttent

ion_k

wargs

: Opt

ional

[Dict

[str,

 Any]

] = N

one,



     

   co

ntrol

net_c

ondit

ionin

g_sca

le: f

loat 

= 1,



     

   gu

ess_m

ode: 

bool 

= Fal

se,



     

   us

e_zer

o_map

_as_u

ncond

ition

al: b

ool =

 Fals

e,



     

   be

v_con

troln

et_kw

args 

= {},



     

   bb

ox_ma

x_len

gth =

 None

,



    )

:



     

   r"

""



     

   Fu

nctio

n inv

oked 

when 

calli

ng th

e pip

eline

 for 

gener

ation

.





     

   Ar

gs:



     

     

  pro

mpt (

`str`

 or `

List[

str]`

, *op

tiona

l*):



     

     

     

 The 

promp

t or 

promp

ts to

 guid

e the

 imag

e gen

erati

on. I

f not

 defi

ned, 

one h

as to

 pass

 `pro

mpt_e

mbeds

`.



     

     

     

 inst

ead.



     

     

  ima

ge (`

torch

.Floa

tTens

or`, 

`PIL.

Image

.Imag

e`, `

List[

torch

.Floa

tTens

or]`,

 `Lis

t[PIL

.Imag

e.Ima

ge]`,



     

     

     

     

`List

[List

[torc

h.Flo

atTen

sor]]

`, or

 `Lis

t[Lis

t[PIL

.Imag

e.Ima

ge]]`

):



     

     

     

 The 

Contr

olNet

 inpu

t con

ditio

n. Co

ntrol

Net u

ses t

his i

nput 

condi

tion 

to ge

nerat

e gui

dance

 to U

net. 

If



     

     

     

 the 

type 

is sp

ecifi

ed as

 `Tor

ch.Fl

oatTe

nsor`

, it 

is pa

ssed 

to Co

ntrol

Net a

s is.

 `PIL

.Imag

e.Ima

ge` c

an



     

     

     

 also

 be a

ccept

ed as

 an i

mage.

 The 

dimen

sions

 of t

he ou

tput 

image

 defa

ults 

to `i

mage`

's di

mensi

ons. 

If



     

     

     

 heig

ht an

d/or 

width

 are 

passe

d, `i

mage`

 is r

esize

d acc

ordin

g to 

them.

 If m

ultip

le Co

ntrol

Nets 

are



     

     

     

 spec

ified

 in i

nit, 

image

s mus

t be 

passe

d as 

a lis

t suc

h tha

t eac

h ele

ment 

of th

e lis

t can

 be c

orrec

tly



     

     

     

 batc

hed f

or in

put t

o a s

ingle

 cont

rolne

t.



     

     

  hei

ght (

`int`

, *op

tiona

l*, d

efaul

ts to

 self

.unet

.conf

ig.sa

mple_

size 

* sel

f.vae

_scal

e_fac

tor):



     

     

     

 The 

heigh

t in 

pixel

s of 

the g

enera

ted i

mage.



     

     

  wid

th (`

int`,

 *opt

ional

*, de

fault

s to 

self.

unet.

confi

g.sam

ple_s

ize *

 self

.vae_

scale

_fact

or):



     

     

     

 The 

width

 in p

ixels

 of t

he ge

nerat

ed im

age.



     

     

  num

_infe

rence

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 5

0):



     

     

     

 The 

numbe

r of 

denoi

sing 

steps

. Mor

e den

oisin

g ste

ps us

ually

 lead

 to a

 high

er qu

ality

 imag

e at 

the



     

     

     

 expe

nse o

f slo

wer i

nfere

nce.



     

     

  gui

dance

_scal

e (`f

loat`

, *op

tiona

l*, d

efaul

ts to

 7.5)

:



     

     

     

 Guid

ance 

scale

 as d

efine

d in 

[Clas

sifie

r-Fre

e Dif

fusio

n Gui

dance

](htt

ps://

arxiv

.org/

abs/2

207.1

2598)

.



     

     

     

 `gui

dance

_scal

e` is

 defi

ned a

s `w`

 of e

quati

on 2.

 of [

Image

n



     

     

     

 Pape

r](ht

tps:/

/arxi

v.org

/pdf/

2205.

11487

.pdf)

. Gui

dance

 scal

e is 

enabl

ed by

 sett

ing `

guida

nce_s

cale 

>



     

     

     

 1`. 

Highe

r gui

dance

 scal

e enc

ourag

es to

 gene

rate 

image

s tha

t are

 clos

ely l

inked

 to t

he te

xt `p

rompt

`,



     

     

     

 usua

lly a

t the

 expe

nse o

f low

er im

age q

ualit

y.



     

     

  neg

ative

_prom

pt (`

str` 

or `L

ist[s

tr]`,

 *opt

ional

*):



     

     

     

 The 

promp

t or 

promp

ts no

t to 

guide

 the 

image

 gene

ratio

n. If

 not 

defin

ed, o

ne ha

s to 

pass



     

     

     

 `neg

ative

_prom

pt_em

beds`

 inst

ead. 

Ignor

ed wh

en no

t usi

ng gu

idanc

e (i.

e., i

gnore

d if 

`guid

ance_

scale

` is



     

     

     

 less

 than

 `1`)

.



     

     

  num

_imag

es_pe

r_pro

mpt (

`int`

, *op

tiona

l*, d

efaul

ts to

 1):



     

     

     

 The 

numbe

r of 

image

s to 

gener

ate p

er pr

ompt.



     

     

  eta

 (`fl

oat`,

 *opt

ional

*, de

fault

s to 

0.0):



     

     

     

 Corr

espon

ds to

 para

meter

 eta 

(η) i

n the

 DDIM

 pape

r: ht

tps:/

/arxi

v.org

/abs/

2010.

02502

. Onl

y app

lies 

to



     

     

     

 [`sc

hedul

ers.D

DIMSc

hedul

er`],

 will

 be i

gnore

d for

 othe

rs.



     

     

  gen

erato

r (`t

orch.

Gener

ator`

 or `

List[

torch

.Gene

rator

]`, *

optio

nal*)

:



     

     

     

 One 

or a 

list 

of [t

orch 

gener

ator(

s)](h

ttps:

//pyt

orch.

org/d

ocs/s

table

/gene

rated

/torc

h.Gen

erato

r.htm

l)



     

     

     

 to m

ake g

enera

tion 

deter

minis

tic.



     

     

  lat

ents 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

noisy

 late

nts, 

sampl

ed fr

om a 

Gauss

ian d

istri

butio

n, to

 be u

sed a

s inp

uts f

or im

age



     

     

     

 gene

ratio

n. Ca

n be 

used 

to tw

eak t

he sa

me ge

nerat

ion w

ith d

iffer

ent p

rompt

s. If

 not 

provi

ded, 

a lat

ents



     

     

     

 tens

or wi

ll ge

 gene

rated

 by s

ampli

ng us

ing t

he su

pplie

d ran

dom `

gener

ator`

.



     

     

  pro

mpt_e

mbeds

 (`to

rch.F

loatT

ensor

`, *o

ption

al*):



     

     

     

 Pre-

gener

ated 

text 

embed

dings

. Can

 be u

sed t

o eas

ily t

weak 

text 

input

s, *e

.g.* 

promp

t wei

ghtin

g. If

 not



     

     

     

 prov

ided,

 text

 embe

dding

s wil

l be 

gener

ated 

from 

`prom

pt` i

nput 

argum

ent.



     

     

  neg

ative

_prom

pt_em

beds 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

negat

ive t

ext e

mbedd

ings.

 Can 

be us

ed to

 easi

ly tw

eak t

ext i

nputs

, *e.

g.* p

rompt



     

     

     

 weig

hting

. If 

not p

rovid

ed, n

egati

ve_pr

ompt_

embed

s wil

l be 

gener

ated 

from 

`nega

tive_

promp

t` in

put



     

     

     

 argu

ment.



     

     

  out

put_t

ype (

`str`

, *op

tiona

l*, d

efaul

ts to

 `"pi

l"`):



     

     

     

 The 

outpu

t for

mat o

f the

 gene

rate 

image

. Cho

ose b

etwee

n



     

     

     

 [PIL

](htt

ps://

pillo

w.rea

dthed

ocs.i

o/en/

stabl

e/): 

`PIL.

Image

.Imag

e` or

 `np.

array

`.



     

     

  ret

urn_d

ict (

`bool

`, *o

ption

al*, 

defau

lts t

o `Tr

ue`):



     

     

     

 Whet

her o

r not

 to r

eturn

 a [`

~pipe

lines

.stab

le_di

ffusi

on.St

ableD

iffus

ionPi

pelin

eOutp

ut`] 

inste

ad of

 a



     

     

     

 plai

n tup

le.



     

     

  cal

lback

 (`Ca

llabl

e`, *

optio

nal*)

:



     

     

     

 A fu

nctio

n tha

t wil

l be 

calle

d eve

ry `c

allba

ck_st

eps` 

steps

 duri

ng in

feren

ce. T

he fu

nctio

n wil

l be



     

     

     

 call

ed wi

th th

e fol

lowin

g arg

ument

s: `c

allba

ck(st

ep: i

nt, t

imest

ep: i

nt, l

atent

s: to

rch.F

loatT

ensor

)`.



     

     

  cal

lback

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 1

):



     

     

     

 The 

frequ

ency 

at wh

ich t

he `c

allba

ck` f

uncti

on wi

ll be

 call

ed. I

f not

 spec

ified

, the

 call

back 

will 

be



     

     

     

 call

ed at

 ever

y ste

p.



     

     

  cro

ss_at

tenti

on_kw

args 

(`dic

t`, *

optio

nal*)

:



     

     

     

 A kw

args 

dicti

onary

 that

 if s

pecif

ied i

s pas

sed a

long 

to th

e `At

tenti

onPro

cesso

r` as

 defi

ned u

nder



     

     

     

 `sel

f.pro

cesso

r` in



     

     

     

 [dif

fuser

s.cro

ss_at

tenti

on](h

ttps:

//git

hub.c

om/hu

gging

face/

diffu

sers/

blob/

main/

src/d

iffus

ers/m

odels

/cros

s_att

entio

n.py)

.



     

     

  con

troln

et_co

nditi

oning

_scal

e (`f

loat`

 or `

List[

float

]`, *

optio

nal*,

 defa

ults 

to 1.

0):



     

     

     

 The 

outpu

ts of

 the 

contr

olnet

 are 

multi

plied

 by `

contr

olnet

_cond

ition

ing_s

cale`

 befo

re th

ey ar

e add

ed



     

     

     

 to t

he re

sidua

l in 

the o

rigin

al un

et. I

f mul

tiple

 Cont

rolNe

ts ar

e spe

cifie

d in 

init,

 you 

can s

et th

e



     

     

     

 corr

espon

ding 

scale

 as a

 list

.



     

     

  gue

ss_mo

de (`

bool`

, *op

tiona

l*, d

efaul

ts to

 `Fal

se`):



     

     

     

 In t

his m

ode, 

the C

ontro

lNet 

encod

er wi

ll tr

y bes

t to 

recog

nize 

the c

onten

t of 

the i

nput 

image

 even

 if



     

     

     

 you 

remov

e all

 prom

pts. 

The `

guida

nce_s

cale`

 betw

een 3

.0 an

d 5.0

 is r

ecomm

ended

.





     

   Ex

ample

s:





     

   Re

turns

:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] o

r `tu

ple`:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] i

f `re

turn_

dict`

 is T

rue, 

other

wise 

a `tu

ple.



     

     

  Whe

n ret

urnin

g a t

uple,

 the 

first

 elem

ent i

s a l

ist w

ith t

he ge

nerat

ed im

ages,

 and 

the s

econd

 elem

ent i

s a



     

     

  lis

t of 

`bool

`s de

notin

g whe

ther 

the c

orres

pondi

ng ge

nerat

ed im

age l

ikely

 repr

esent

s "no

t-saf

e-for

-work

"



     

     

  (ns

fw) c

onten

t, ac

cordi

ng to

 the 

`safe

ty_ch

ecker

`.



     

   ""

"



     

   # 

0. De

fault

 heig

ht an

d wid

th to

 unet



     

   # 

BEV: 

we ca

nnot 

use t

he si

ze of

 imag

e



     

   # 

heigh

t, wi

dth =

 self

._def

ault_

heigh

t_wid

th(he

ight,

 widt

h, No

ne)





     

   # 

1. Ch

eck i

nputs

. Rai

se er

ror i

f not

 corr

ect



     

   # 

we do

 not 

need 

this,

 only

 some

 type

 asse

rtion



     

   # 

self.

check

_inpu

ts(



     

   # 

    p

rompt

,



     

   # 

    i

mage,



     

   # 

    h

eight

,



     

   # 

    w

idth,



     

   # 

    c

allba

ck_st

eps,



     

   # 

    n

egati

ve_pr

ompt,



     

   # 

    p

rompt

_embe

ds,



     

   # 

    n

egati

ve_pr

ompt_

embed

s,



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

   # 

)





     

   # 

2. De

fine 

call 

param

eters



     

   # 

NOTE:

 we g

et ba

tch_s

ize f

irst 

from 

promp

t, th

en al

ign w

ith i

t.



     

   if

 prom

pt is

 not 

None 

and i

sinst

ance(

promp

t, st

r):



     

     

  bat

ch_si

ze = 

1



     

   el

if pr

ompt 

is no

t Non

e and

 isin

stanc

e(pro

mpt, 

list)

:



     

     

  bat

ch_si

ze = 

len(p

rompt

)



     

   el

se:



     

     

  bat

ch_si

ze = 

promp

t_emb

eds.s

hape[

0]





     

   de

vice 

= sel

f._ex

ecuti

on_de

vice



     

   # 

here 

`guid

ance_

scale

` is 

defin

ed an

alog 

to th

e gui

dance

 weig

ht `w

` of 

equat

ion (

2)



     

   # 

of th

e Ima

gen p

aper:

 http

s://a

rxiv.

org/p

df/22

05.11

487.p

df . 

`guid

ance_

scale

 = 1`



     

   # 

corre

spond

s to 

doing

 no c

lassi

fier 

free 

guida

nce.



     

   do

_clas

sifie

r_fre

e_gui

dance

 = gu

idanc

e_sca

le > 

1.0





     

   ##

# BEV

, che

ck ca

mera_

param

 ###



     

   if

 came

ra_pa

ram i

s Non

e:



     

     

  # u

se un

cond_

cam a

nd di

sable

 clas

sifie

r fre

e gui

dance



     

     

  N_c

am = 

6  # 

TODO:

 hard

-code

d



     

     

  cam

era_p

aram 

= sel

f.con

troln

et.un

cond_

cam_p

aram(

(batc

h_siz

e, N_

cam))



     

     

  do_

class

ifier

_free

_guid

ance 

= Fal

se



     

   ##

# don

e ###





     

   # 

if is

insta

nce(s

elf.c

ontro

lnet,

 Mult

iCont

rolNe

tMode

l) an

d isi

nstan

ce(co

ntrol

net_c

ondit

ionin

g_sca

le, f

loat)

:



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale =

 [con

troln

et_co

nditi

oning

_scal

e] * 

len(s

elf.c

ontro

lnet.

nets)





     

   # 

3. En

code 

input

 prom

pt



     

   # 

NOTE:

 here

 they

 use 

paddi

ng to

 77, 

is th

is ne

cessa

ry?



     

   pr

ompt_

embed

s = s

elf._

encod

e_pro

mpt(



     

     

  pro

mpt,



     

     

  dev

ice,



     

     

  num

_imag

es_pe

r_pro

mpt,



     

     

  do_

class

ifier

_free

_guid

ance,



     

     

  neg

ative

_prom

pt,



     

     

  pro

mpt_e

mbeds

=prom

pt_em

beds,



     

     

  neg

ative

_prom

pt_em

beds=

negat

ive_p

rompt

_embe

ds,



     

   ) 

 # (2

 * b,

 77 +

 1, 7

68)





     

   # 

4. Pr

epare

 imag

e



     

   # 

NOTE:

 if i

mage 

is no

t ten

sor, 

there

 will

 be s

evera

l pro

cess.



     

   as

sert 

not s

elf.c

ontro

l_ima

ge_pr

ocess

or.co

nfig.

do_no

rmali

ze, "

Your 

contr

olnet

 shou

ld no

t nor

maliz

e the

 cont

rol i

mage.

"



     

   im

age =

 self

.prep

are_i

mage(



     

     

  ima

ge=im

age,



     

     

  wid

th=wi

dth,



     

     

  hei

ght=h

eight

,



     

     

  bat

ch_si

ze=ba

tch_s

ize *

 num_

image

s_per

_prom

pt,



     

     

  num

_imag

es_pe

r_pro

mpt=n

um_im

ages_

per_p

rompt

,



     

     

  dev

ice=d

evice

,



     

     

  dty

pe=se

lf.co

ntrol

net.d

type,



     

     

  do_

class

ifier

_free

_guid

ance=

do_cl

assif

ier_f

ree_g

uidan

ce,



     

     

  gue

ss_mo

de=gu

ess_m

ode,



     

   ) 

 # (2

 * b,

 c_26

, 200

, 200

)



     

   if

 use_

zero_

map_a

s_unc

ondit

ional

 and 

do_cl

assif

ier_f

ree_g

uidan

ce:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  _im

ages[

0] = 

torch

.zero

s_lik

e(_im

ages[

0])



     

     

  ima

ge = 

torch

.cat(

_imag

es)





     

   # 

5. Pr

epare

 time

steps



     

   se

lf.sc

hedul

er.se

t_tim

estep

s(num

_infe

rence

_step

s, de

vice=

devic

e)



     

   ti

meste

ps = 

self.

sched

uler.

times

teps





     

   # 

6. Pr

epare

 late

nt va

riabl

es



     

   nu

m_cha

nnels

_late

nts =

 self

.unet

.conf

ig.in

_chan

nels



     

   la

tents

 = se

lf.pr

epare

_late

nts(



     

     

  bat

ch_si

ze * 

num_i

mages

_per_

promp

t,



     

     

  num

_chan

nels_

laten

ts,



     

     

  hei

ght,



     

     

  wid

th,



     

     

  pro

mpt_e

mbeds

.dtyp

e,



     

     

  dev

ice,



     

     

  gen

erato

r,



     

     

  lat

ents,

  # w

ill u

se if

 not 

None,

 othe

rwise

 will

 gene

rate



     

   ) 

 # (b

, c, 

h/8, 

w/8) 

-> (b

s, 4,

 28, 

50)





     

   # 

7. Pr

epare

 extr

a ste

p kwa

rgs.



     

   ex

tra_s

tep_k

wargs

 = se

lf.pr

epare

_extr

a_ste

p_kwa

rgs(g

enera

tor, 

eta)





     

   ##

#### 

BEV: 

here 

we re

const

ruct 

each 

input

 form

at ##

####



     

   as

sert 

camer

a_par

am.sh

ape[0

] == 

batch

_size

, \



     

     

  f"E

xcept

 {bat

ch_si

ze} c

amera

 para

ms, b

ut yo

u hav

e bs=

{len(

camer

a_par

am)}"



     

   N_

cam =

 came

ra_pa

ram.s

hape[

1]



     

   la

tents

 = to

rch.s

tack(

[late

nts] 

* N_c

am, d

im=1)

  # b

s, 6,

 4, 2

8, 50



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ca

mera_

param

 = ca

mera_

param

.to(s

elf.d

evice

)



     

   if

 do_c

lassi

fier_

free_

guida

nce a

nd no

t gue

ss_mo

de:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  kwa

rgs_w

ith_u

ncond

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_kw

args(



     

     

     

 came

ra_pa

ram=c

amera

_para

m,



     

     

     

 imag

e=_im

ages[

0],  

# 0 i

s for

 unco

nditi

onal



     

     

     

 max_

len=b

box_m

ax_le

ngth,



     

     

     

 **be

v_con

troln

et_kw

args,



     

     

  )



     

     

  kwa

rgs_w

ith_u

ncond

.pop(

"max_

len",

 None

)  # 

some 

do no

t tak

e thi

s.



     

     

  cam

era_p

aram 

= kwa

rgs_w

ith_u

ncond

.pop(

"came

ra_pa

ram")



     

     

  _im

ages[

0] = 

kwarg

s_wit

h_unc

ond.p

op("i

mage"

)



     

     

  ima

ge = 

torch

.cat(

_imag

es)



     

     

  bev

_cont

rolne

t_kwa

rgs =

 move

_to(k

wargs

_with

_unco

nd, s

elf.d

evice

)



     

   ##

#### 

BEV e

nd ##

####





     

   # 

8. De

noisi

ng lo

op



     

   nu

m_war

mup_s

teps 

= len

(time

steps

) - n

um_in

feren

ce_st

eps *

 self

.sche

duler

.orde

r



     

   wi

th se

lf.pr

ogres

s_bar

(tota

l=num

_infe

rence

_step

s) as

 prog

ress_

bar:



     

     

  for

 i, t

 in e

numer

ate(t

imest

eps):



     

     

     

 # ex

pand 

the l

atent

s if 

we ar

e doi

ng cl

assif

ier f

ree g

uidan

ce



     

     

     

 # bs

*2, 6

, 4, 

28, 5

0



     

     

     

 late

nt_mo

del_i

nput 

= (



     

     

     

     

torch

.cat(

[late

nts] 

* 2) 

if do

_clas

sifie

r_fre

e_gui

dance

 else

 late

nts



     

     

     

 )



     

     

     

 late

nt_mo

del_i

nput 

= sel

f.sch

edule

r.sca

le_mo

del_i

nput(



     

     

     

     

laten

t_mod

el_in

put, 

t



     

     

     

 )





     

     

     

 # co

ntrol

net(s

) inf

erenc

e



     

     

     

 cont

rolne

t_t =

 t.un

squee

ze(0)



     

     

     

 # gu

ess_m

ode &

 clas

sifie

r_fre

e_gui

dance

 -> o

nly g

uidan

ce us

e con

troln

et



     

     

     

 # no

t gue

ss_mo

de & 

class

ifier

_free

_guid

ance 

-> al

l use

 cont

rolne

t



     

     

     

 # gu

ess_m

ode -

> nor

mal i

nput,

 take

 effe

ct in

 cont

rolne

t



     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

er Co

ntrol

Net o

nly f

or th

e con

ditio

nal b

atch.



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ents



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds

.chun

k(2)[

1]



     

     

     

 else

:



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ent_m

odel_

input



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds



     

     

     

 cont

rolne

t_t =

 cont

rolne

t_t.r

epeat

(len(

contr

olnet

_late

nt_mo

del_i

nput)

)





     

     

     

 # fm

t: of

f



     

     

     

 down

_bloc

k_res

_samp

les, 

mid_b

lock_

res_s

ample

, \



     

     

     

 enco

der_h

idden

_stat

es_wi

th_ca

m = s

elf.c

ontro

lnet(



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput,



     

     

     

     

contr

olnet

_t,



     

     

     

     

camer

a_par

am,  

# for

 BEV



     

     

     

     

encod

er_hi

dden_

state

s=con

troln

et_pr

ompt_

embed

s,



     

     

     

     

contr

olnet

_cond

=imag

e,



     

     

     

     

condi

tioni

ng_sc

ale=c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

     

     

     

guess

_mode

=gues

s_mod

e,



     

     

     

     

retur

n_dic

t=Fal

se,



     

     

     

     

**bev

_cont

rolne

t_kwa

rgs, 

# for

 BEV



     

     

     

 )



     

     

     

 # fm

t: on





     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

ered 

Contr

olNet

 only

 for 

the c

ondit

ional

 batc

h.



     

     

     

     

# To 

apply

 the 

outpu

t of 

Contr

olNet

 to b

oth t

he un

condi

tiona

l and

 cond

ition

al ba

tches

,



     

     

     

     

# add

 0 to

 the 

uncon

ditio

nal b

atch 

to ke

ep it

 unch

anged

.



     

     

     

     

down_

block

_res_

sampl

es = 

[



     

     

     

     

    t

orch.

cat([

torch

.zero

s_lik

e(d),

 d])



     

     

     

     

    f

or d 

in do

wn_bl

ock_r

es_sa

mples



     

     

     

     

]



     

     

     

     

mid_b

lock_

res_s

ample

 = to

rch.c

at(



     

     

     

     

    [

torch

.zero

s_lik

e(mid

_bloc

k_res

_samp

le), 

mid_b

lock_

res_s

ample

]



     

     

     

     

)



     

     

     

     

# add

 unco

nd en

coder

_hidd

en_st

ates_

with_

cam h

ere



     

     

     

     

encod

er_hi

dden_

state

s_wit

h_cam

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_em

b(



     

     

     

     

    p

rompt

_embe

ds.ch

unk(2

)[0],

 N_ca

m,



     

     

     

     

    e

ncode

r_hid

den_s

tates

_with

_cam,



     

     

     

     

)





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # St

ratin

g fro

m her

e, we

 use 

4-dim

 data

.



     

     

     

 # en

coder

_hidd

en_st

ates_

with_

cam: 

(2b x

 N), 

78, 7

68



     

     

     

 # la

tent_

model

_inpu

t: 2b

, N, 

4, 28

, 50 

-> 2b

 x N,

 4, 2

8, 50



     

     

     

 late

nt_mo

del_i

nput 

= rea

rrang

e(



     

     

     

     

laten

t_mod

el_in

put, 

'b n 

... -

> (b 

n) ..

.')



     

     

     

 late

nts =

 rear

range

(late

nts, 

'b n 

... -

> (b 

n) ..

.')





     

     

     

 # pr

edict

 the 

noise

 resi

dual:

 2bxN

, 4, 

28, 5

0



     

     

     

 addi

tiona

l_par

am = 

{}



     

     

     

 nois

e_pre

d = s

elf.u

net(



     

     

     

     

laten

t_mod

el_in

put, 

 # ma

y wit

h unc

ondit

ional



     

     

     

     

t,



     

     

     

     

encod

er_hi

dden_

state

s=enc

oder_

hidde

n_sta

tes_w

ith_c

am,



     

     

     

     

**add

ition

al_pa

ram, 

 # if

 use 

origi

nal u

net, 

it ca

nnot 

take 

kwarg

s



     

     

     

     

cross

_atte

ntion

_kwar

gs=cr

oss_a

ttent

ion_k

wargs

,



     

     

     

     

down_

block

_addi

tiona

l_res

idual

s=dow

n_blo

ck_re

s_sam

ples,



     

     

     

     

mid_b

lock_

addit

ional

_resi

dual=

mid_b

lock_

res_s

ample

,



     

     

     

 ).sa

mple





     

     

     

 # pe

rform

 guid

ance



     

     

     

 if d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# for

 each

: bxN

, 4, 

28, 5

0



     

     

     

     

noise

_pred

_unco

nd, n

oise_

pred_

text 

= noi

se_pr

ed.ch

unk(2

)



     

     

     

     

noise

_pred

 = no

ise_p

red_u

ncond

 + gu

idanc

e_sca

le * 

(



     

     

     

     

    n

oise_

pred_

text 

- noi

se_pr

ed_un

cond



     

     

     

     

)





     

     

     

 # co

mpute

 the 

previ

ous n

oisy 

sampl

e x_t

 -> x

_t-1



     

     

     

 # NO

TE: i

s the

 sche

duler

 use 

rando

mness

, ple

ase h

andle

 the 

logic



     

     

     

 # fo

r gen

erato

r.



     

     

     

 late

nts =

 self

.sche

duler

.step

(



     

     

     

     

noise

_pred

, t, 

laten

ts, *

*extr

a_ste

p_kwa

rgs



     

     

     

 ).pr

ev_sa

mple





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # no

w we 

add d

imens

ion b

ack, 

use 5

-dim 

data.



     

     

     

 # NO

TE: o

nly `

laten

ts` i

s upd

ated 

throu

gh th

e loo

p



     

     

     

 late

nts =

 rear

range

(late

nts, 

'(b n

) ...

 -> b

 n ..

.', n

=N_ca

m)





     

     

     

 # ca

ll th

e cal

lback

, if 

provi

ded



     

     

     

 if i

 == l

en(ti

meste

ps) -

 1 or

 (



     

     

     

     

(i + 

1) > 

num_w

armup

_step

s and

 (i +

 1) %

 self

.sche

duler

.orde

r == 

0



     

     

     

 ):



     

     

     

     

progr

ess_b

ar.up

date(

)



     

     

     

     

if ca

llbac

k is 

not N

one a

nd i 

% cal

lback

_step

s == 

0:



     

     

     

     

    c

allba

ck(i,

 t, l

atent

s)





     

   ##

#### 

BEV: 

here 

rebui

ld th

e sha

pes b

ack. 

post-

proce

ss st

ill a

ssume



     

   # 

laten

ts, n

o nee

d for

 b, n

, 4, 

28, 5

0



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ##

### B

EV en

d





     

   # 

If we

 do s

equen

tial 

model

 offl

oadin

g, le

t's o

ffloa

d une

t and

 cont

rolne

t



     

   # 

manua

lly f

or ma

x mem

ory s

aving

s



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.une

t.to(

"cpu"

)



     

     

  sel

f.con

troln

et.to

("cpu

")



     

     

  tor

ch.cu

da.em

pty_c

ache(

)





     

   if

 outp

ut_ty

pe ==

 "lat

ent":



     

     

  ima

ge = 

laten

ts



     

     

  has

_nsfw

_conc

ept =

 None



     

   el

if ou

tput_

type 

== "p

il":



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

     

  # 1

0. Co

nvert

 to P

IL



     

     

  ima

ge = 

self.

numpy

_to_p

il_do

uble(

image

)



     

   el

se:



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

   # 

Offlo

ad la

st mo

del t

o CPU



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.fin

al_of

fload

_hook

.offl

oad()





     

   if

 not 

retur

n_dic

t:



     

     

  ret

urn (

image

, has

_nsfw

_conc

ept)





     

   re

turn 

BEVSt

ableD

iffus

ionPi

pelin

eOutp

ut(



     

     

  ima

ges=i

mage,

 nsfw

_cont

ent_d

etect

ed=ha

s_nsf

w_con

cept



     

   )



from 

datac

lasse

s imp

ort d

atacl

ass



from 

typin

g imp

ort A

ny, C

allab

le, D

ict, 

List,

 Opti

onal,

 Tupl

e, Un

ion



impor

t ins

pect





impor

t tor

ch



impor

t PIL



impor

t num

py as

 np



from 

einop

s imp

ort r

earra

nge





from 

diffu

sers 

impor

t Sta

bleDi

ffusi

onCon

trolN

etPip

eline



from 

diffu

sers.

utils

 impo

rt Ba

seOut

put



from 

diffu

sers.

image

_proc

essor

 impo

rt Va

eImag

eProc

essor



from 

diffu

sers.

model

s imp

ort A

utoen

coder

KL, U

Net2D

Condi

tionM

odel



from 

diffu

sers.

pipel

ines.

stabl

e_dif

fusio

n imp

ort S

table

Diffu

sionS

afety

Check

er



from 

diffu

sers.

sched

ulers

.sche

dulin

g_uti

ls im

port 

Karra

sDiff

usion

Sched

ulers



from 

trans

forme

rs im

port 

CLIPI

mageP

roces

sor, 

CLIPT

extMo

del, 

CLIPT

okeni

zer





from 

..mis

c.com

mon i

mport

 move

_to







@data

class



class

 BEVS

table

Diffu

sionP

ipeli

neOut

put(B

aseOu

tput)

:



    "

""



    O

utput

 clas

s for

 Stab

le Di

ffusi

on pi

pelin

es.





    A

rgs:



     

   im

ages 

(`Lis

t[PIL

.Imag

e.Ima

ge]` 

or `n

p.nda

rray`

)



     

     

  Lis

t of 

denoi

sed P

IL im

ages 

of le

ngth 

`batc

h_siz

e` or

 nump

y arr

ay of

 shap

e `(b

atch_

size,

 heig

ht, w

idth,



     

     

  num

_chan

nels)

`. PI

L ima

ges o

r num

py ar

ray p

resen

t the

 deno

ised 

image

s of 

the d

iffus

ion p

ipeli

ne.



     

   ns

fw_co

ntent

_dete

cted 

(`Lis

t[boo

l]`)



     

     

  Lis

t of 

flags

 deno

ting 

wheth

er th

e cor

respo

nding

 gene

rated

 imag

e lik

ely r

epres

ents 

"not-

safe-

for-w

ork"



     

     

  (ns

fw) c

onten

t, or

 `Non

e` if

 safe

ty ch

eckin

g cou

ld no

t be 

perfo

rmed.



    "

""





    i

mages

: Uni

on[Li

st[Li

st[PI

L.Ima

ge.Im

age]]

, np.

ndarr

ay]



    n

sfw_c

onten

t_det

ected

: Opt

ional

[List

[bool

]]







class

 Stab

leDif

fusio

nBEVC

ontro

lNetP

ipeli

ne(St

ableD

iffus

ionCo

ntrol

NetPi

pelin

e):



    d

ef __

init_

_(



     

   se

lf,



     

   va

e: Au

toenc

oderK

L,



     

   te

xt_en

coder

: CLI

PText

Model

,



     

   un

et: U

Net2D

Condi

tionM

odel,



     

   co

ntrol

net,



     

   sc

hedul

er: K

arras

Diffu

sionS

chedu

lers,



     

   to

keniz

er: C

LIPTo

keniz

er,



     

   sa

fety_

check

er: S

table

Diffu

sionS

afety

Check

er = 

None,



     

   fe

ature

_extr

actor

: CLI

PImag

eProc

essor

 = No

ne,



     

   re

quire

s_saf

ety_c

hecke

r: bo

ol = 

False

,



    )

:



     

   su

per()

.__in

it__(



     

     

  vae

,



     

     

  tex

t_enc

oder,



     

     

  tok

enize

r,



     

     

  une

t,



     

     

  con

troln

et,



     

     

  sch

edule

r,



     

     

  saf

ety_c

hecke

r,



     

     

  fea

ture_

extra

ctor,



     

     

  req

uires

_safe

ty_ch

ecker

,



     

   )



     

   as

sert 

safet

y_che

cker 

== No

ne, "

Pleas

e do 

not u

se sa

fety_

check

er."



     

   se

lf.co

ntrol

_imag

e_pro

cesso

r = V

aeIma

gePro

cesso

r(



     

     

  vae

_scal

e_fac

tor=s

elf.v

ae_sc

ale_f

actor

,



     

     

  do_

resiz

e=Fal

se,



     

     

  do_

conve

rt_rg

b=Fal

se,



     

     

  do_

norma

lize=

False

,



     

   )





    d

ef nu

mpy_t

o_pil

_doub

le(se

lf, i

mages

):



     

   ""

"



     

   Co

nvert

 a nu

mpy i

mage 

or a 

batch

 of i

mages

 to a

 PIL 

image

.



     

   We

 need

 to h

andle

 5-di

m inp

uts a

nd re

ture 

2-dim

 list

.



     

   ""

"



     

   im

gs_li

st = 

[]



     

   fo

r img

s in 

image

s:



     

     

  img

s_lis

t.app

end(s

elf.n

umpy_

to_pi

l(img

s))



     

   re

turn 

imgs_

list





    #

 Copi

ed fr

om di

ffuse

rs.pi

pelin

es.st

able_

diffu

sion.

pipel

ine_s

table

_diff

usion

.Stab

leDif

fusio

nPipe

line.

prepa

re_ex

tra_s

tep_k

wargs



    d

ef pr

epare

_extr

a_ste

p_kwa

rgs(s

elf, 

gener

ator,

 eta)

:



     

   # 

prepa

re ex

tra k

wargs

 for 

the s

chedu

ler s

tep, 

since

 not 

all s

chedu

lers 

have 

the s

ame s

ignat

ure



     

   # 

eta (

η) is

 only

 used

 with

 the 

DDIMS

chedu

ler, 

it wi

ll be

 igno

red f

or ot

her s

chedu

lers.



     

   # 

eta c

orres

ponds

 to η

 in D

DIM p

aper:

 http

s://a

rxiv.

org/a

bs/20

10.02

502



     

   # 

and s

hould

 be b

etwee

n [0,

 1]





     

   ac

cepts

_eta 

= "et

a" in

 set(

inspe

ct.si

gnatu

re(se

lf.sc

hedul

er.st

ep).p

arame

ters.

keys(

))



     

   ex

tra_s

tep_k

wargs

 = {}



     

   if

 acce

pts_e

ta:



     

     

  ext

ra_st

ep_kw

args[

"eta"

] = e

ta





     

   # 

check

 if t

he sc

hedul

er ac

cepts

 gene

rator



     

   ac

cepts

_gene

rator

 = "g

enera

tor" 

in se

t(ins

pect.

signa

ture(

self.

sched

uler.

step)

.para

meter

s.key

s())



     

   if

 acce

pts_g

enera

tor:



     

     

  rai

se Ru

ntime

Error

("If 

you f

ixed 

the l

ogic 

for g

enera

tor, 

pleas

e rem

ove t

his. 

Other

wise,

 plea

se us

e oth

er sa

mpler

.")



     

     

  ext

ra_st

ep_kw

args[

"gene

rator

"] = 

gener

ator



     

   re

turn 

extra

_step

_kwar

gs





    d

ef de

code_

laten

ts(se

lf, l

atent

s):



     

   # 

decod

e lat

ents 

with 

5-dim

s



     

   la

tents

 = 1 

/ sel

f.vae

.conf

ig.sc

aling

_fact

or * 

laten

ts





     

   bs

 = le

n(lat

ents)



     

   la

tents

 = re

arran

ge(la

tents

, 'b 

c ...

 -> (

b c) 

...')



     

   im

age =

 self

.vae.

decod

e(lat

ents)

.samp

le



     

   im

age =

 rear

range

(imag

e, '(

b c) 

... -

> b c

 ...'

, b=b

s)





     

   im

age =

 (ima

ge / 

2 + 0

.5).c

lamp(

0, 1)



     

   # 

we al

ways 

cast 

to fl

oat32

 as t

his d

oes n

ot ca

use s

ignif

icant

 over

head 

and i

s com

patib

le wi

th bf

loat1

6



     

   im

age =

 rear

range

(imag

e.cpu

(), '

... c

 h w 

-> ..

. h w

 c').

float

().nu

mpy()



     

   re

turn 

image





    @

torch

.no_g

rad()



    d

ef __

call_

_(



     

   se

lf,



     

   pr

ompt:

 Unio

n[str

, Lis

t[str

]],



     

   im

age: 

torch

.Floa

tTens

or,



     

   ca

mera_

param

: Uni

on[to

rch.T

ensor

, Non

e],



     

   he

ight:

 int,



     

   wi

dth: 

int,



     

   nu

m_inf

erenc

e_ste

ps: i

nt = 

50,



     

   gu

idanc

e_sca

le: f

loat 

= 7.5

,



     

   ne

gativ

e_pro

mpt: 

Optio

nal[U

nion[

str, 

List[

str]]

] = N

one,



     

   nu

m_ima

ges_p

er_pr

ompt:

 Opti

onal[

int] 

= 1,



     

   et

a: fl

oat =

 0.0,



     

   ge

nerat

or: O

ption

al[to

rch.G

enera

tor] 

= Non

e,



     

   la

tents

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   pr

ompt_

embed

s: Op

tiona

l[tor

ch.Fl

oatTe

nsor]

 = No

ne,



     

   ne

gativ

e_pro

mpt_e

mbeds

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   ou

tput_

type:

 Opti

onal[

str] 

= "pi

l",



     

   re

turn_

dict:

 bool

 = Tr

ue,



     

   ca

llbac

k: Op

tiona

l[Cal

lable

[[int

, int

, tor

ch.Fl

oatTe

nsor]

, Non

e]] =

 None

,



     

   ca

llbac

k_ste

ps: i

nt = 

1,



     

   cr

oss_a

ttent

ion_k

wargs

: Opt

ional

[Dict

[str,

 Any]

] = N

one,



     

   co

ntrol

net_c

ondit

ionin

g_sca

le: f

loat 

= 1,



     

   gu

ess_m

ode: 

bool 

= Fal

se,



     

   us

e_zer

o_map

_as_u

ncond

ition

al: b

ool =

 Fals

e,



     

   be

v_con

troln

et_kw

args 

= {},



     

   bb

ox_ma

x_len

gth =

 None

,



    )

:



     

   r"

""



     

   Fu

nctio

n inv

oked 

when 

calli

ng th

e pip

eline

 for 

gener

ation

.





     

   Ar

gs:



     

     

  pro

mpt (

`str`

 or `

List[

str]`

, *op

tiona

l*):



     

     

     

 The 

promp

t or 

promp

ts to

 guid

e the

 imag

e gen

erati

on. I

f not

 defi

ned, 

one h

as to

 pass

 `pro

mpt_e

mbeds

`.



     

     

     

 inst

ead.



     

     

  ima

ge (`

torch

.Floa

tTens

or`, 

`PIL.

Image

.Imag

e`, `

List[

torch

.Floa

tTens

or]`,

 `Lis

t[PIL

.Imag

e.Ima

ge]`,



     

     

     

     

`List

[List

[torc

h.Flo

atTen

sor]]

`, or

 `Lis

t[Lis

t[PIL

.Imag

e.Ima

ge]]`

):



     

     

     

 The 

Contr

olNet

 inpu

t con

ditio

n. Co

ntrol

Net u

ses t

his i

nput 

condi

tion 

to ge

nerat

e gui

dance

 to U

net. 

If



     

     

     

 the 

type 

is sp

ecifi

ed as

 `Tor

ch.Fl

oatTe

nsor`

, it 

is pa

ssed 

to Co

ntrol

Net a

s is.

 `PIL

.Imag

e.Ima

ge` c

an



     

     

     

 also

 be a

ccept

ed as

 an i

mage.

 The 

dimen

sions

 of t

he ou

tput 

image

 defa

ults 

to `i

mage`

's di

mensi

ons. 

If



     

     

     

 heig

ht an

d/or 

width

 are 

passe

d, `i

mage`

 is r

esize

d acc

ordin

g to 

them.

 If m

ultip

le Co

ntrol

Nets 

are



     

     

     

 spec

ified

 in i

nit, 

image

s mus

t be 

passe

d as 

a lis

t suc

h tha

t eac

h ele

ment 

of th

e lis

t can

 be c

orrec

tly



     

     

     

 batc

hed f

or in

put t

o a s

ingle

 cont

rolne

t.



     

     

  hei

ght (

`int`

, *op

tiona

l*, d

efaul

ts to

 self

.unet

.conf

ig.sa

mple_

size 

* sel

f.vae

_scal

e_fac

tor):



     

     

     

 The 

heigh

t in 

pixel

s of 

the g

enera

ted i

mage.



     

     

  wid

th (`

int`,

 *opt

ional

*, de

fault

s to 

self.

unet.

confi

g.sam

ple_s

ize *

 self

.vae_

scale

_fact

or):



     

     

     

 The 

width

 in p

ixels

 of t

he ge

nerat

ed im

age.



     

     

  num

_infe

rence

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 5

0):



     

     

     

 The 

numbe

r of 

denoi

sing 

steps

. Mor

e den

oisin

g ste

ps us

ually

 lead

 to a

 high

er qu

ality

 imag

e at 

the



     

     

     

 expe

nse o

f slo

wer i

nfere

nce.



     

     

  gui

dance

_scal

e (`f

loat`

, *op

tiona

l*, d

efaul

ts to

 7.5)

:



     

     

     

 Guid

ance 

scale

 as d

efine

d in 

[Clas

sifie

r-Fre

e Dif

fusio

n Gui

dance

](htt

ps://

arxiv

.org/

abs/2

207.1

2598)

.



     

     

     

 `gui

dance

_scal

e` is

 defi

ned a

s `w`

 of e

quati

on 2.

 of [

Image

n



     

     

     

 Pape

r](ht

tps:/

/arxi

v.org

/pdf/

2205.

11487

.pdf)

. Gui

dance

 scal

e is 

enabl

ed by

 sett

ing `

guida

nce_s

cale 

>



     

     

     

 1`. 

Highe

r gui

dance

 scal

e enc

ourag

es to

 gene

rate 

image

s tha

t are

 clos

ely l

inked

 to t

he te

xt `p

rompt

`,



     

     

     

 usua

lly a

t the

 expe

nse o

f low

er im

age q

ualit

y.



     

     

  neg

ative

_prom

pt (`

str` 

or `L

ist[s

tr]`,

 *opt

ional

*):



     

     

     

 The 

promp

t or 

promp

ts no

t to 

guide

 the 

image

 gene

ratio

n. If

 not 

defin

ed, o

ne ha

s to 

pass



     

     

     

 `neg

ative

_prom

pt_em

beds`

 inst

ead. 

Ignor

ed wh

en no

t usi

ng gu

idanc

e (i.

e., i

gnore

d if 

`guid

ance_

scale

` is



     

     

     

 less

 than

 `1`)

.



     

     

  num

_imag

es_pe

r_pro

mpt (

`int`

, *op

tiona

l*, d

efaul

ts to

 1):



     

     

     

 The 

numbe

r of 

image

s to 

gener

ate p

er pr

ompt.



     

     

  eta

 (`fl

oat`,

 *opt

ional

*, de

fault

s to 

0.0):



     

     

     

 Corr

espon

ds to

 para

meter

 eta 

(η) i

n the

 DDIM

 pape

r: ht

tps:/

/arxi

v.org

/abs/

2010.

02502

. Onl

y app

lies 

to



     

     

     

 [`sc

hedul

ers.D

DIMSc

hedul

er`],

 will

 be i

gnore

d for

 othe

rs.



     

     

  gen

erato

r (`t

orch.

Gener

ator`

 or `

List[

torch

.Gene

rator

]`, *

optio

nal*)

:



     

     

     

 One 

or a 

list 

of [t

orch 

gener

ator(

s)](h

ttps:

//pyt

orch.

org/d

ocs/s

table

/gene

rated

/torc

h.Gen

erato

r.htm

l)



     

     

     

 to m

ake g

enera

tion 

deter

minis

tic.



     

     

  lat

ents 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

noisy

 late

nts, 

sampl

ed fr

om a 

Gauss

ian d

istri

butio

n, to

 be u

sed a

s inp

uts f

or im

age



     

     

     

 gene

ratio

n. Ca

n be 

used 

to tw

eak t

he sa

me ge

nerat

ion w

ith d

iffer

ent p

rompt

s. If

 not 

provi

ded, 

a lat

ents



     

     

     

 tens

or wi

ll ge

 gene

rated

 by s

ampli

ng us

ing t

he su

pplie

d ran

dom `

gener

ator`

.



     

     

  pro

mpt_e

mbeds

 (`to

rch.F

loatT

ensor

`, *o

ption

al*):



     

     

     

 Pre-

gener

ated 

text 

embed

dings

. Can

 be u

sed t

o eas

ily t

weak 

text 

input

s, *e

.g.* 

promp

t wei

ghtin

g. If

 not



     

     

     

 prov

ided,

 text

 embe

dding

s wil

l be 

gener

ated 

from 

`prom

pt` i

nput 

argum

ent.



     

     

  neg

ative

_prom

pt_em

beds 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

negat

ive t

ext e

mbedd

ings.

 Can 

be us

ed to

 easi

ly tw

eak t

ext i

nputs

, *e.

g.* p

rompt



     

     

     

 weig

hting

. If 

not p

rovid

ed, n

egati

ve_pr

ompt_

embed

s wil

l be 

gener

ated 

from 

`nega

tive_

promp

t` in

put



     

     

     

 argu

ment.



     

     

  out

put_t

ype (

`str`

, *op

tiona

l*, d

efaul

ts to

 `"pi

l"`):



     

     

     

 The 

outpu

t for

mat o

f the

 gene

rate 

image

. Cho

ose b

etwee

n



     

     

     

 [PIL

](htt

ps://

pillo

w.rea

dthed

ocs.i

o/en/

stabl

e/): 

`PIL.

Image

.Imag

e` or

 `np.

array

`.



     

     

  ret

urn_d

ict (

`bool

`, *o

ption

al*, 

defau

lts t

o `Tr

ue`):



     

     

     

 Whet

her o

r not

 to r

eturn

 a [`

~pipe

lines

.stab

le_di

ffusi

on.St

ableD

iffus

ionPi

pelin

eOutp

ut`] 

inste

ad of

 a



     

     

     

 plai

n tup

le.



     

     

  cal

lback

 (`Ca

llabl

e`, *

optio

nal*)

:



     

     

     

 A fu

nctio

n tha

t wil

l be 

calle

d eve

ry `c

allba

ck_st

eps` 

steps

 duri

ng in

feren

ce. T

he fu

nctio

n wil

l be



     

     

     

 call

ed wi

th th

e fol

lowin

g arg

ument

s: `c

allba

ck(st

ep: i

nt, t

imest

ep: i

nt, l

atent

s: to

rch.F

loatT

ensor

)`.



     

     

  cal

lback

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 1

):



     

     

     

 The 

frequ

ency 

at wh

ich t

he `c

allba

ck` f

uncti

on wi

ll be

 call

ed. I

f not

 spec

ified

, the

 call

back 

will 

be



     

     

     

 call

ed at

 ever

y ste

p.



     

     

  cro

ss_at

tenti

on_kw

args 

(`dic

t`, *

optio

nal*)

:



     

     

     

 A kw

args 

dicti

onary

 that

 if s

pecif

ied i

s pas

sed a

long 

to th

e `At

tenti

onPro

cesso

r` as

 defi

ned u

nder



     

     

     

 `sel

f.pro

cesso

r` in



     

     

     

 [dif

fuser

s.cro

ss_at

tenti

on](h

ttps:

//git

hub.c

om/hu

gging

face/

diffu

sers/

blob/

main/

src/d

iffus

ers/m

odels

/cros

s_att

entio

n.py)

.



     

     

  con

troln

et_co

nditi

oning

_scal

e (`f

loat`

 or `

List[

float

]`, *

optio

nal*,

 defa

ults 

to 1.

0):



     

     

     

 The 

outpu

ts of

 the 

contr

olnet

 are 

multi

plied

 by `

contr

olnet

_cond

ition

ing_s

cale`

 befo

re th

ey ar

e add

ed



     

     

     

 to t

he re

sidua

l in 

the o

rigin

al un

et. I

f mul

tiple

 Cont

rolNe

ts ar

e spe

cifie

d in 

init,

 you 

can s

et th

e



     

     

     

 corr

espon

ding 

scale

 as a

 list

.



     

     

  gue

ss_mo

de (`

bool`

, *op

tiona

l*, d

efaul

ts to

 `Fal

se`):



     

     

     

 In t

his m

ode, 

the C

ontro

lNet 

encod

er wi

ll tr

y bes

t to 

recog

nize 

the c

onten

t of 

the i

nput 

image

 even

 if



     

     

     

 you 

remov

e all

 prom

pts. 

The `

guida

nce_s

cale`

 betw

een 3

.0 an

d 5.0

 is r

ecomm

ended

.





     

   Ex

ample

s:





     

   Re

turns

:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] o

r `tu

ple`:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] i

f `re

turn_

dict`

 is T

rue, 

other

wise 

a `tu

ple.



     

     

  Whe

n ret

urnin

g a t

uple,

 the 

first

 elem

ent i

s a l

ist w

ith t

he ge

nerat

ed im

ages,

 and 

the s

econd

 elem

ent i

s a



     

     

  lis

t of 

`bool

`s de

notin

g whe

ther 

the c

orres

pondi

ng ge

nerat

ed im

age l

ikely

 repr

esent

s "no

t-saf

e-for

-work

"



     

     

  (ns

fw) c

onten

t, ac

cordi

ng to

 the 

`safe

ty_ch

ecker

`.



     

   ""

"



     

   # 

0. De

fault

 heig

ht an

d wid

th to

 unet



     

   # 

BEV: 

we ca

nnot 

use t

he si

ze of

 imag

e



     

   # 

heigh

t, wi

dth =

 self

._def

ault_

heigh

t_wid

th(he

ight,

 widt

h, No

ne)





     

   # 

1. Ch

eck i

nputs

. Rai

se er

ror i

f not

 corr

ect



     

   # 

we do

 not 

need 

this,

 only

 some

 type

 asse

rtion



     

   # 

self.

check

_inpu

ts(



     

   # 

    p

rompt

,



     

   # 

    i

mage,



     

   # 

    h

eight

,



     

   # 

    w

idth,



     

   # 

    c

allba

ck_st

eps,



     

   # 

    n

egati

ve_pr

ompt,



     

   # 

    p

rompt

_embe

ds,



     

   # 

    n

egati

ve_pr

ompt_

embed

s,



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

   # 

)





     

   # 

2. De

fine 

call 

param

eters



     

   # 

NOTE:

 we g

et ba

tch_s

ize f

irst 

from 

promp

t, th

en al

ign w

ith i

t.



     

   if

 prom

pt is

 not 

None 

and i

sinst

ance(

promp

t, st

r):



     

     

  bat

ch_si

ze = 

1



     

   el

if pr

ompt 

is no

t Non

e and

 isin

stanc

e(pro

mpt, 

list)

:



     

     

  bat

ch_si

ze = 

len(p

rompt

)



     

   el

se:



     

     

  bat

ch_si

ze = 

promp

t_emb

eds.s

hape[

0]





     

   de

vice 

= sel

f._ex

ecuti

on_de

vice



     

   # 

here 

`guid

ance_

scale

` is 

defin

ed an

alog 

to th

e gui

dance

 weig

ht `w

` of 

equat

ion (

2)



     

   # 

of th

e Ima

gen p

aper:

 http

s://a

rxiv.

org/p

df/22

05.11

487.p

df . 

`guid

ance_

scale

 = 1`



     

   # 

corre

spond

s to 

doing

 no c

lassi

fier 

free 

guida

nce.



     

   do

_clas

sifie

r_fre

e_gui

dance

 = gu

idanc

e_sca

le > 

1.0





     

   ##

# BEV

, che

ck ca

mera_

param

 ###



     

   if

 came

ra_pa

ram i

s Non

e:



     

     

  # u

se un

cond_

cam a

nd di

sable

 clas

sifie

r fre

e gui

dance



     

     

  N_c

am = 

6  # 

TODO:

 hard

-code

d



     

     

  cam

era_p

aram 

= sel

f.con

troln

et.un

cond_

cam_p

aram(

(batc

h_siz

e, N_

cam))



     

     

  do_

class

ifier

_free

_guid

ance 

= Fal

se



     

   ##

# don

e ###





     

   # 

if is

insta

nce(s

elf.c

ontro

lnet,

 Mult

iCont

rolNe

tMode

l) an

d isi

nstan

ce(co

ntrol

net_c

ondit

ionin

g_sca

le, f

loat)

:



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale =

 [con

troln

et_co

nditi

oning

_scal

e] * 

len(s

elf.c

ontro

lnet.

nets)





     

   # 

3. En

code 

input

 prom

pt



     

   # 

NOTE:

 here

 they

 use 

paddi

ng to

 77, 

is th

is ne

cessa

ry?



     

   pr

ompt_

embed

s = s

elf._

encod

e_pro

mpt(



     

     

  pro

mpt,



     

     

  dev

ice,



     

     

  num

_imag

es_pe

r_pro

mpt,



     

     

  do_

class

ifier

_free

_guid

ance,



     

     

  neg

ative

_prom

pt,



     

     

  pro

mpt_e

mbeds

=prom

pt_em

beds,



     

     

  neg

ative

_prom

pt_em

beds=

negat

ive_p

rompt

_embe

ds,



     

   ) 

 # (2

 * b,

 77 +

 1, 7

68)





     

   # 

4. Pr

epare

 imag

e



     

   # 

NOTE:

 if i

mage 

is no

t ten

sor, 

there

 will

 be s

evera

l pro

cess.



     

   as

sert 

not s

elf.c

ontro

l_ima

ge_pr

ocess

or.co

nfig.

do_no

rmali

ze, "

Your 

contr

olnet

 shou

ld no

t nor

maliz

e the

 cont

rol i

mage.

"



     

   im

age =

 self

.prep

are_i

mage(



     

     

  ima

ge=im

age,



     

     

  wid

th=wi

dth,



     

     

  hei

ght=h

eight

,



     

     

  bat

ch_si

ze=ba

tch_s

ize *

 num_

image

s_per

_prom

pt,



     

     

  num

_imag

es_pe

r_pro

mpt=n

um_im

ages_

per_p

rompt

,



     

     

  dev

ice=d

evice

,



     

     

  dty

pe=se

lf.co

ntrol

net.d

type,



     

     

  do_

class

ifier

_free

_guid

ance=

do_cl

assif

ier_f

ree_g

uidan

ce,



     

     

  gue

ss_mo

de=gu

ess_m

ode,



     

   ) 

 # (2

 * b,

 c_26

, 200

, 200

)



     

   if

 use_

zero_

map_a

s_unc

ondit

ional

 and 

do_cl

assif

ier_f

ree_g

uidan

ce:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  _im

ages[

0] = 

torch

.zero

s_lik

e(_im

ages[

0])



     

     

  ima

ge = 

torch

.cat(

_imag

es)





     

   # 

5. Pr

epare

 time

steps



     

   se

lf.sc

hedul

er.se

t_tim

estep

s(num

_infe

rence

_step

s, de

vice=

devic

e)



     

   ti

meste

ps = 

self.

sched

uler.

times

teps





     

   # 

6. Pr

epare

 late

nt va

riabl

es



     

   nu

m_cha

nnels

_late

nts =

 self

.unet

.conf

ig.in

_chan

nels



     

   la

tents

 = se

lf.pr

epare

_late

nts(



     

     

  bat

ch_si

ze * 

num_i

mages

_per_

promp

t,



     

     

  num

_chan

nels_

laten

ts,



     

     

  hei

ght,



     

     

  wid

th,



     

     

  pro

mpt_e

mbeds

.dtyp

e,



     

     

  dev

ice,



     

     

  gen

erato

r,



     

     

  lat

ents,

  # w

ill u

se if

 not 

None,

 othe

rwise

 will

 gene

rate



     

   ) 

 # (b

, c, 

h/8, 

w/8) 

-> (b

s, 4,

 28, 

50)





     

   # 

7. Pr

epare

 extr

a ste

p kwa

rgs.



     

   ex

tra_s

tep_k

wargs

 = se

lf.pr

epare

_extr

a_ste

p_kwa

rgs(g

enera

tor, 

eta)





     

   ##

#### 

BEV: 

here 

we re

const

ruct 

each 

input

 form

at ##

####



     

   as

sert 

camer

a_par

am.sh

ape[0

] == 

batch

_size

, \



     

     

  f"E

xcept

 {bat

ch_si

ze} c

amera

 para

ms, b

ut yo

u hav

e bs=

{len(

camer

a_par

am)}"



     

   N_

cam =

 came

ra_pa

ram.s

hape[

1]



     

   la

tents

 = to

rch.s

tack(

[late

nts] 

* N_c

am, d

im=1)

  # b

s, 6,

 4, 2

8, 50



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ca

mera_

param

 = ca

mera_

param

.to(s

elf.d

evice

)



     

   if

 do_c

lassi

fier_

free_

guida

nce a

nd no

t gue

ss_mo

de:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  kwa

rgs_w

ith_u

ncond

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_kw

args(



     

     

     

 came

ra_pa

ram=c

amera

_para

m,



     

     

     

 imag

e=_im

ages[

0],  

# 0 i

s for

 unco

nditi

onal



     

     

     

 max_

len=b

box_m

ax_le

ngth,



     

     

     

 **be

v_con

troln

et_kw

args,



     

     

  )



     

     

  kwa

rgs_w

ith_u

ncond

.pop(

"max_

len",

 None

)  # 

some 

do no

t tak

e thi

s.



     

     

  cam

era_p

aram 

= kwa

rgs_w

ith_u

ncond

.pop(

"came

ra_pa

ram")



     

     

  _im

ages[

0] = 

kwarg

s_wit

h_unc

ond.p

op("i

mage"

)



     

     

  ima

ge = 

torch

.cat(

_imag

es)



     

     

  bev

_cont

rolne

t_kwa

rgs =

 move

_to(k

wargs

_with

_unco

nd, s

elf.d

evice

)



     

   ##

#### 

BEV e

nd ##

####





     

   # 

8. De

noisi

ng lo

op



     

   nu

m_war

mup_s

teps 

= len

(time

steps

) - n

um_in

feren

ce_st

eps *

 self

.sche

duler

.orde

r



     

   wi

th se

lf.pr

ogres

s_bar

(tota

l=num

_infe

rence

_step

s) as

 prog

ress_

bar:



     

     

  for

 i, t

 in e

numer

ate(t

imest

eps):



     

     

     

 # ex

pand 

the l

atent

s if 

we ar

e doi

ng cl

assif

ier f

ree g

uidan

ce



     

     

     

 # bs

*2, 6

, 4, 

28, 5

0



     

     

     

 late

nt_mo

del_i

nput 

= (



     

     

     

     

torch

.cat(

[late

nts] 

* 2) 

if do

_clas

sifie

r_fre

e_gui

dance

 else

 late

nts



     

     

     

 )



     

     

     

 late

nt_mo

del_i

nput 

= sel

f.sch

edule

r.sca

le_mo

del_i

nput(



     

     

     

     

laten

t_mod

el_in

put, 

t



     

     

     

 )





     

     

     

 # co

ntrol

net(s

) inf

erenc

e



     

     

     

 cont

rolne

t_t =

 t.un

squee

ze(0)



     

     

     

 # gu

ess_m

ode &

 clas

sifie

r_fre

e_gui

dance

 -> o

nly g

uidan

ce us

e con

troln

et



     

     

     

 # no

t gue

ss_mo

de & 

class

ifier

_free

_guid

ance 

-> al

l use

 cont

rolne

t



     

     

     

 # gu

ess_m

ode -

> nor

mal i

nput,

 take

 effe

ct in

 cont

rolne

t



     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

er Co

ntrol

Net o

nly f

or th

e con

ditio

nal b

atch.



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ents



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds

.chun

k(2)[

1]



     

     

     

 else

:



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ent_m

odel_

input



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds



     

     

     

 cont

rolne

t_t =

 cont

rolne

t_t.r

epeat

(len(

contr

olnet

_late

nt_mo

del_i

nput)

)





     

     

     

 # fm

t: of

f



     

     

     

 down

_bloc

k_res

_samp

les, 

mid_b

lock_

res_s

ample

, \



     

     

     

 enco

der_h

idden

_stat

es_wi

th_ca

m = s

elf.c

ontro

lnet(



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput,



     

     

     

     

contr

olnet

_t,



     

     

     

     

camer

a_par

am,  

# for

 BEV



     

     

     

     

encod

er_hi

dden_

state

s=con

troln

et_pr

ompt_

embed

s,



     

     

     

     

contr

olnet

_cond

=imag

e,



     

     

     

     

condi

tioni

ng_sc

ale=c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

     

     

     

guess

_mode

=gues

s_mod

e,



     

     

     

     

retur

n_dic

t=Fal

se,



     

     

     

     

**bev

_cont

rolne

t_kwa

rgs, 

# for

 BEV



     

     

     

 )



     

     

     

 # fm

t: on





     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

ered 

Contr

olNet

 only

 for 

the c

ondit

ional

 batc

h.



     

     

     

     

# To 

apply

 the 

outpu

t of 

Contr

olNet

 to b

oth t

he un

condi

tiona

l and

 cond

ition

al ba

tches

,



     

     

     

     

# add

 0 to

 the 

uncon

ditio

nal b

atch 

to ke

ep it

 unch

anged

.



     

     

     

     

down_

block

_res_

sampl

es = 

[



     

     

     

     

    t

orch.

cat([

torch

.zero

s_lik

e(d),

 d])



     

     

     

     

    f

or d 

in do

wn_bl

ock_r

es_sa

mples



     

     

     

     

]



     

     

     

     

mid_b

lock_

res_s

ample

 = to

rch.c

at(



     

     

     

     

    [

torch

.zero

s_lik

e(mid

_bloc

k_res

_samp

le), 

mid_b

lock_

res_s

ample

]



     

     

     

     

)



     

     

     

     

# add

 unco

nd en

coder

_hidd

en_st

ates_

with_

cam h

ere



     

     

     

     

encod

er_hi

dden_

state

s_wit

h_cam

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_em

b(



     

     

     

     

    p

rompt

_embe

ds.ch

unk(2

)[0],

 N_ca

m,



     

     

     

     

    e

ncode

r_hid

den_s

tates

_with

_cam,



     

     

     

     

)





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # St

ratin

g fro

m her

e, we

 use 

4-dim

 data

.



     

     

     

 # en

coder

_hidd

en_st

ates_

with_

cam: 

(2b x

 N), 

78, 7

68



     

     

     

 # la

tent_

model

_inpu

t: 2b

, N, 

4, 28

, 50 

-> 2b

 x N,

 4, 2

8, 50



     

     

     

 late

nt_mo

del_i

nput 

= rea

rrang

e(



     

     

     

     

laten

t_mod

el_in

put, 

'b n 

... -

> (b 

n) ..

.')



     

     

     

 late

nts =

 rear

range

(late

nts, 

'b n 

... -

> (b 

n) ..

.')





     

     

     

 # pr

edict

 the 

noise

 resi

dual:

 2bxN

, 4, 

28, 5

0



     

     

     

 addi

tiona

l_par

am = 

{}



     

     

     

 nois

e_pre

d = s

elf.u

net(



     

     

     

     

laten

t_mod

el_in

put, 

 # ma

y wit

h unc

ondit

ional



     

     

     

     

t,



     

     

     

     

encod

er_hi

dden_

state

s=enc

oder_

hidde

n_sta

tes_w

ith_c

am,



     

     

     

     

**add

ition

al_pa

ram, 

 # if

 use 

origi

nal u

net, 

it ca

nnot 

take 

kwarg

s



     

     

     

     

cross

_atte

ntion

_kwar

gs=cr

oss_a

ttent

ion_k

wargs

,



     

     

     

     

down_

block

_addi

tiona

l_res

idual

s=dow

n_blo

ck_re

s_sam

ples,



     

     

     

     

mid_b

lock_

addit

ional

_resi

dual=

mid_b

lock_

res_s

ample

,



     

     

     

 ).sa

mple





     

     

     

 # pe

rform

 guid

ance



     

     

     

 if d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# for

 each

: bxN

, 4, 

28, 5

0



     

     

     

     

noise

_pred

_unco

nd, n

oise_

pred_

text 

= noi

se_pr

ed.ch

unk(2

)



     

     

     

     

noise

_pred

 = no

ise_p

red_u

ncond

 + gu

idanc

e_sca

le * 

(



     

     

     

     

    n

oise_

pred_

text 

- noi

se_pr

ed_un

cond



     

     

     

     

)





     

     

     

 # co

mpute

 the 

previ

ous n

oisy 

sampl

e x_t

 -> x

_t-1



     

     

     

 # NO

TE: i

s the

 sche

duler

 use 

rando

mness

, ple

ase h

andle

 the 

logic



     

     

     

 # fo

r gen

erato

r.



     

     

     

 late

nts =

 self

.sche

duler

.step

(



     

     

     

     

noise

_pred

, t, 

laten

ts, *

*extr

a_ste

p_kwa

rgs



     

     

     

 ).pr

ev_sa

mple





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # no

w we 

add d

imens

ion b

ack, 

use 5

-dim 

data.



     

     

     

 # NO

TE: o

nly `

laten

ts` i

s upd

ated 

throu

gh th

e loo

p



     

     

     

 late

nts =

 rear

range

(late

nts, 

'(b n

) ...

 -> b

 n ..

.', n

=N_ca

m)





     

     

     

 # ca

ll th

e cal

lback

, if 

provi

ded



     

     

     

 if i

 == l

en(ti

meste

ps) -

 1 or

 (



     

     

     

     

(i + 

1) > 

num_w

armup

_step

s and

 (i +

 1) %

 self

.sche

duler

.orde

r == 

0



     

     

     

 ):



     

     

     

     

progr

ess_b

ar.up

date(

)



     

     

     

     

if ca

llbac

k is 

not N

one a

nd i 

% cal

lback

_step

s == 

0:



     

     

     

     

    c

allba

ck(i,

 t, l

atent

s)





     

   ##

#### 

BEV: 

here 

rebui

ld th

e sha

pes b

ack. 

post-

proce

ss st

ill a

ssume



     

   # 

laten

ts, n

o nee

d for

 b, n

, 4, 

28, 5

0



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ##

### B

EV en

d





     

   # 

If we

 do s

equen

tial 

model

 offl

oadin

g, le

t's o

ffloa

d une

t and

 cont

rolne

t



     

   # 

manua

lly f

or ma

x mem

ory s

aving

s



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.une

t.to(

"cpu"

)



     

     

  sel

f.con

troln

et.to

("cpu

")



     

     

  tor

ch.cu

da.em

pty_c

ache(

)





     

   if

 outp

ut_ty

pe ==

 "lat

ent":



     

     

  ima

ge = 

laten

ts



     

     

  has

_nsfw

_conc

ept =

 None



     

   el

if ou

tput_

type 

== "p

il":



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

     

  # 1

0. Co

nvert

 to P

IL



     

     

  ima

ge = 

self.

numpy

_to_p

il_do

uble(

image

)



     

   el

se:



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

   # 

Offlo

ad la

st mo

del t

o CPU



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.fin

al_of

fload

_hook

.offl

oad()





     

   if

 not 

retur

n_dic

t:



     

     

  ret

urn (

image

, has

_nsfw

_conc

ept)





     

   re

turn 

BEVSt

ableD

iffus

ionPi

pelin

eOutp

ut(



     

     

  ima

ges=i

mage,

 nsfw

_cont

ent_d

etect

ed=ha

s_nsf

w_con

cept



     

   )



from 

datac

lasse

s imp

ort d

atacl

ass



from 

typin

g imp

ort A

ny, C

allab

le, D

ict, 

List,

 Opti

onal,

 Tupl

e, Un

ion



impor

t ins

pect





impor

t tor

ch



impor

t PIL



impor

t num

py as

 np



from 

einop

s imp

ort r

earra

nge





from 

diffu

sers 

impor

t Sta

bleDi

ffusi

onCon

trolN

etPip

eline



from 

diffu

sers.

utils

 impo

rt Ba

seOut

put



from 

diffu

sers.

image

_proc

essor

 impo

rt Va

eImag

eProc

essor



from 

diffu

sers.

model

s imp

ort A

utoen

coder

KL, U

Net2D

Condi

tionM

odel



from 

diffu

sers.

pipel

ines.

stabl

e_dif

fusio

n imp

ort S

table

Diffu

sionS

afety

Check

er



from 

diffu

sers.

sched

ulers

.sche

dulin

g_uti

ls im

port 

Karra

sDiff

usion

Sched

ulers



from 

trans

forme

rs im

port 

CLIPI

mageP

roces

sor, 

CLIPT

extMo

del, 

CLIPT

okeni

zer





from 

..mis

c.com

mon i

mport

 move

_to







@data

class



class

 BEVS

table

Diffu

sionP

ipeli

neOut

put(B

aseOu

tput)

:



    "

""



    O

utput

 clas

s for

 Stab

le Di

ffusi

on pi

pelin

es.





    A

rgs:



     

   im

ages 

(`Lis

t[PIL

.Imag

e.Ima

ge]` 

or `n

p.nda

rray`

)



     

     

  Lis

t of 

denoi

sed P

IL im

ages 

of le

ngth 

`batc

h_siz

e` or

 nump

y arr

ay of

 shap

e `(b

atch_

size,

 heig

ht, w

idth,



     

     

  num

_chan

nels)

`. PI

L ima

ges o

r num

py ar

ray p

resen

t the

 deno

ised 

image

s of 

the d

iffus

ion p

ipeli

ne.



     

   ns

fw_co

ntent

_dete

cted 

(`Lis

t[boo

l]`)



     

     

  Lis

t of 

flags

 deno

ting 

wheth

er th

e cor

respo

nding

 gene

rated

 imag

e lik

ely r

epres

ents 

"not-

safe-

for-w

ork"



     

     

  (ns

fw) c

onten

t, or

 `Non

e` if

 safe

ty ch

eckin

g cou

ld no

t be 

perfo

rmed.



    "

""





    i

mages

: Uni

on[Li

st[Li

st[PI

L.Ima

ge.Im

age]]

, np.

ndarr

ay]



    n

sfw_c

onten

t_det

ected

: Opt

ional

[List

[bool

]]







class

 Stab

leDif

fusio

nBEVC

ontro

lNetP

ipeli

ne(St

ableD

iffus

ionCo

ntrol

NetPi

pelin

e):



    d

ef __

init_

_(



     

   se

lf,



     

   va

e: Au

toenc

oderK

L,



     

   te

xt_en

coder

: CLI

PText

Model

,



     

   un

et: U

Net2D

Condi

tionM

odel,



     

   co

ntrol

net,



     

   sc

hedul

er: K

arras

Diffu

sionS

chedu

lers,



     

   to

keniz

er: C

LIPTo

keniz

er,



     

   sa

fety_

check

er: S

table

Diffu

sionS

afety

Check

er = 

None,



     

   fe

ature

_extr

actor

: CLI

PImag

eProc

essor

 = No

ne,



     

   re

quire

s_saf

ety_c

hecke

r: bo

ol = 

False

,



    )

:



     

   su

per()

.__in

it__(



     

     

  vae

,



     

     

  tex

t_enc

oder,



     

     

  tok

enize

r,



     

     

  une

t,



     

     

  con

troln

et,



     

     

  sch

edule

r,



     

     

  saf

ety_c

hecke

r,



     

     

  fea

ture_

extra

ctor,



     

     

  req

uires

_safe

ty_ch

ecker

,



     

   )



     

   as

sert 

safet

y_che

cker 

== No

ne, "

Pleas

e do 

not u

se sa

fety_

check

er."



     

   se

lf.co

ntrol

_imag

e_pro

cesso

r = V

aeIma

gePro

cesso

r(



     

     

  vae

_scal

e_fac

tor=s

elf.v

ae_sc

ale_f

actor

,



     

     

  do_

resiz

e=Fal

se,



     

     

  do_

conve

rt_rg

b=Fal

se,



     

     

  do_

norma

lize=

False

,



     

   )





    d

ef nu

mpy_t

o_pil

_doub

le(se

lf, i

mages

):



     

   ""

"



     

   Co

nvert

 a nu

mpy i

mage 

or a 

batch

 of i

mages

 to a

 PIL 

image

.



     

   We

 need

 to h

andle

 5-di

m inp

uts a

nd re

ture 

2-dim

 list

.



     

   ""

"



     

   im

gs_li

st = 

[]



     

   fo

r img

s in 

image

s:



     

     

  img

s_lis

t.app

end(s

elf.n

umpy_

to_pi

l(img

s))



     

   re

turn 

imgs_

list





    #

 Copi

ed fr

om di

ffuse

rs.pi

pelin

es.st

able_

diffu

sion.

pipel

ine_s

table

_diff

usion

.Stab

leDif

fusio

nPipe

line.

prepa

re_ex

tra_s

tep_k

wargs



    d

ef pr

epare

_extr

a_ste

p_kwa

rgs(s

elf, 

gener

ator,

 eta)

:



     

   # 

prepa

re ex

tra k

wargs

 for 

the s

chedu

ler s

tep, 

since

 not 

all s

chedu

lers 

have 

the s

ame s

ignat

ure



     

   # 

eta (

η) is

 only

 used

 with

 the 

DDIMS

chedu

ler, 

it wi

ll be

 igno

red f

or ot

her s

chedu

lers.



     

   # 

eta c

orres

ponds

 to η

 in D

DIM p

aper:

 http

s://a

rxiv.

org/a

bs/20

10.02

502



     

   # 

and s

hould

 be b

etwee

n [0,

 1]





     

   ac

cepts

_eta 

= "et

a" in

 set(

inspe

ct.si

gnatu

re(se

lf.sc

hedul

er.st

ep).p

arame

ters.

keys(

))



     

   ex

tra_s

tep_k

wargs

 = {}



     

   if

 acce

pts_e

ta:



     

     

  ext

ra_st

ep_kw

args[

"eta"

] = e

ta





     

   # 

check

 if t

he sc

hedul

er ac

cepts

 gene

rator



     

   ac

cepts

_gene

rator

 = "g

enera

tor" 

in se

t(ins

pect.

signa

ture(

self.

sched

uler.

step)

.para

meter

s.key

s())



     

   if

 acce

pts_g

enera

tor:



     

     

  rai

se Ru

ntime

Error

("If 

you f

ixed 

the l

ogic 

for g

enera

tor, 

pleas

e rem

ove t

his. 

Other

wise,

 plea

se us

e oth

er sa

mpler

.")



     

     

  ext

ra_st

ep_kw

args[

"gene

rator

"] = 

gener

ator



     

   re

turn 

extra

_step

_kwar

gs





    d

ef de

code_

laten

ts(se

lf, l

atent

s):



     

   # 

decod

e lat

ents 

with 

5-dim

s



     

   la

tents

 = 1 

/ sel

f.vae

.conf

ig.sc

aling

_fact

or * 

laten

ts





     

   bs

 = le

n(lat

ents)



     

   la

tents

 = re

arran

ge(la

tents

, 'b 

c ...

 -> (

b c) 

...')



     

   im

age =

 self

.vae.

decod

e(lat

ents)

.samp

le



     

   im

age =

 rear

range

(imag

e, '(

b c) 

... -

> b c

 ...'

, b=b

s)





     

   im

age =

 (ima

ge / 

2 + 0

.5).c

lamp(

0, 1)



     

   # 

we al

ways 

cast 

to fl

oat32

 as t

his d

oes n

ot ca

use s

ignif

icant

 over

head 

and i

s com

patib

le wi

th bf

loat1

6



     

   im

age =

 rear

range

(imag

e.cpu

(), '

... c

 h w 

-> ..

. h w

 c').

float

().nu

mpy()



     

   re

turn 

image





    @

torch

.no_g

rad()



    d

ef __

call_

_(



     

   se

lf,



     

   pr

ompt:

 Unio

n[str

, Lis

t[str

]],



     

   im

age: 

torch

.Floa

tTens

or,



     

   ca

mera_

param

: Uni

on[to

rch.T

ensor

, Non

e],



     

   he

ight:

 int,



     

   wi

dth: 

int,



     

   nu

m_inf

erenc

e_ste

ps: i

nt = 

50,



     

   gu

idanc

e_sca

le: f

loat 

= 7.5

,



     

   ne

gativ

e_pro

mpt: 

Optio

nal[U

nion[

str, 

List[

str]]

] = N

one,



     

   nu

m_ima

ges_p

er_pr

ompt:

 Opti

onal[

int] 

= 1,



     

   et

a: fl

oat =

 0.0,



     

   ge

nerat

or: O

ption

al[to

rch.G

enera

tor] 

= Non

e,



     

   la

tents

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   pr

ompt_

embed

s: Op

tiona

l[tor

ch.Fl

oatTe

nsor]

 = No

ne,



     

   ne

gativ

e_pro

mpt_e

mbeds

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   ou

tput_

type:

 Opti

onal[

str] 

= "pi

l",



     

   re

turn_

dict:

 bool

 = Tr

ue,



     

   ca

llbac

k: Op

tiona

l[Cal

lable

[[int

, int

, tor

ch.Fl

oatTe

nsor]

, Non

e]] =

 None

,



     

   ca

llbac

k_ste

ps: i

nt = 

1,



     

   cr

oss_a

ttent

ion_k

wargs

: Opt

ional

[Dict

[str,

 Any]

] = N

one,



     

   co

ntrol

net_c

ondit

ionin

g_sca

le: f

loat 

= 1,



     

   gu

ess_m

ode: 

bool 

= Fal

se,



     

   us

e_zer

o_map

_as_u

ncond

ition

al: b

ool =

 Fals

e,



     

   be

v_con

troln

et_kw

args 

= {},



     

   bb

ox_ma

x_len

gth =

 None

,



    )

:



     

   r"

""



     

   Fu

nctio

n inv

oked 

when 

calli

ng th

e pip

eline

 for 

gener

ation

.





     

   Ar

gs:



     

     

  pro

mpt (

`str`

 or `

List[

str]`

, *op

tiona

l*):



     

     

     

 The 

promp

t or 

promp

ts to

 guid

e the

 imag

e gen

erati

on. I

f not

 defi

ned, 

one h

as to

 pass

 `pro

mpt_e

mbeds

`.



     

     

     

 inst

ead.



     

     

  ima

ge (`

torch

.Floa

tTens

or`, 

`PIL.

Image

.Imag

e`, `

List[

torch

.Floa

tTens

or]`,

 `Lis

t[PIL

.Imag

e.Ima

ge]`,



     

     

     

     

`List

[List

[torc

h.Flo

atTen

sor]]

`, or

 `Lis

t[Lis

t[PIL

.Imag

e.Ima

ge]]`

):



     

     

     

 The 

Contr

olNet

 inpu

t con

ditio

n. Co

ntrol

Net u

ses t

his i

nput 

condi

tion 

to ge

nerat

e gui

dance

 to U

net. 

If



     

     

     

 the 

type 

is sp

ecifi

ed as

 `Tor

ch.Fl

oatTe

nsor`

, it 

is pa

ssed 

to Co

ntrol

Net a

s is.

 `PIL

.Imag

e.Ima

ge` c

an



     

     

     

 also

 be a

ccept

ed as

 an i

mage.

 The 

dimen

sions

 of t

he ou

tput 

image

 defa

ults 

to `i

mage`

's di

mensi

ons. 

If



     

     

     

 heig

ht an

d/or 

width

 are 

passe

d, `i

mage`

 is r

esize

d acc

ordin

g to 

them.

 If m

ultip

le Co

ntrol

Nets 

are



     

     

     

 spec

ified

 in i

nit, 

image

s mus

t be 

passe

d as 

a lis

t suc

h tha

t eac

h ele

ment 

of th

e lis

t can

 be c

orrec

tly



     

     

     

 batc

hed f

or in

put t

o a s

ingle

 cont

rolne

t.



     

     

  hei

ght (

`int`

, *op

tiona

l*, d

efaul

ts to

 self

.unet

.conf

ig.sa

mple_

size 

* sel

f.vae

_scal

e_fac

tor):



     

     

     

 The 

heigh

t in 

pixel

s of 

the g

enera

ted i

mage.



     

     

  wid

th (`

int`,

 *opt

ional

*, de

fault

s to 

self.

unet.

confi

g.sam

ple_s

ize *

 self

.vae_

scale

_fact

or):



     

     

     

 The 

width

 in p

ixels

 of t

he ge

nerat

ed im

age.



     

     

  num

_infe

rence

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 5

0):



     

     

     

 The 

numbe

r of 

denoi

sing 

steps

. Mor

e den

oisin

g ste

ps us

ually

 lead

 to a

 high

er qu

ality

 imag

e at 

the



     

     

     

 expe

nse o

f slo

wer i

nfere

nce.



     

     

  gui

dance

_scal

e (`f

loat`

, *op

tiona

l*, d

efaul

ts to

 7.5)

:



     

     

     

 Guid

ance 

scale

 as d

efine

d in 

[Clas

sifie

r-Fre

e Dif

fusio

n Gui

dance

](htt

ps://

arxiv

.org/

abs/2

207.1

2598)

.



     

     

     

 `gui

dance

_scal

e` is

 defi

ned a

s `w`

 of e

quati

on 2.

 of [

Image

n



     

     

     

 Pape

r](ht

tps:/

/arxi

v.org

/pdf/

2205.

11487

.pdf)

. Gui

dance

 scal

e is 

enabl

ed by

 sett

ing `

guida

nce_s

cale 

>



     

     

     

 1`. 

Highe

r gui

dance

 scal

e enc

ourag

es to

 gene

rate 

image

s tha

t are

 clos

ely l

inked

 to t

he te

xt `p

rompt

`,



     

     

     

 usua

lly a

t the

 expe

nse o

f low

er im

age q

ualit

y.



     

     

  neg

ative

_prom

pt (`

str` 

or `L

ist[s

tr]`,

 *opt

ional

*):



     

     

     

 The 

promp

t or 

promp

ts no

t to 

guide

 the 

image

 gene

ratio

n. If

 not 

defin

ed, o

ne ha

s to 

pass



     

     

     

 `neg

ative

_prom

pt_em

beds`

 inst

ead. 

Ignor

ed wh

en no

t usi

ng gu

idanc

e (i.

e., i

gnore

d if 

`guid

ance_

scale

` is



     

     

     

 less

 than

 `1`)

.



     

     

  num

_imag

es_pe

r_pro

mpt (

`int`

, *op

tiona

l*, d

efaul

ts to

 1):



     

     

     

 The 

numbe

r of 

image

s to 

gener

ate p

er pr

ompt.



     

     

  eta

 (`fl

oat`,

 *opt

ional

*, de

fault

s to 

0.0):



     

     

     

 Corr

espon

ds to

 para

meter

 eta 

(η) i

n the

 DDIM

 pape

r: ht

tps:/

/arxi

v.org

/abs/

2010.

02502

. Onl

y app

lies 

to



     

     

     

 [`sc

hedul

ers.D

DIMSc

hedul

er`],

 will

 be i

gnore

d for

 othe

rs.



     

     

  gen

erato

r (`t

orch.

Gener

ator`

 or `

List[

torch

.Gene

rator

]`, *

optio

nal*)

:



     

     

     

 One 

or a 

list 

of [t

orch 

gener

ator(

s)](h

ttps:

//pyt

orch.

org/d

ocs/s

table

/gene

rated

/torc

h.Gen

erato

r.htm

l)



     

     

     

 to m

ake g

enera

tion 

deter

minis

tic.



     

     

  lat

ents 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

noisy

 late

nts, 

sampl

ed fr

om a 

Gauss

ian d

istri

butio

n, to

 be u

sed a

s inp

uts f

or im

age



     

     

     

 gene

ratio

n. Ca

n be 

used 

to tw

eak t

he sa

me ge

nerat

ion w

ith d

iffer

ent p

rompt

s. If

 not 

provi

ded, 

a lat

ents



     

     

     

 tens

or wi

ll ge

 gene

rated

 by s

ampli

ng us

ing t

he su

pplie

d ran

dom `

gener

ator`

.



     

     

  pro

mpt_e

mbeds

 (`to

rch.F

loatT

ensor

`, *o

ption

al*):



     

     

     

 Pre-

gener

ated 

text 

embed

dings

. Can

 be u

sed t

o eas

ily t

weak 

text 

input

s, *e

.g.* 

promp

t wei

ghtin

g. If

 not



     

     

     

 prov

ided,

 text

 embe

dding

s wil

l be 

gener

ated 

from 

`prom

pt` i

nput 

argum

ent.



     

     

  neg

ative

_prom

pt_em

beds 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

negat

ive t

ext e

mbedd

ings.

 Can 

be us

ed to

 easi

ly tw

eak t

ext i

nputs

, *e.

g.* p

rompt



     

     

     

 weig

hting

. If 

not p

rovid

ed, n

egati

ve_pr

ompt_

embed

s wil

l be 

gener

ated 

from 

`nega

tive_

promp

t` in

put



     

     

     

 argu

ment.



     

     

  out

put_t

ype (

`str`

, *op

tiona

l*, d

efaul

ts to

 `"pi

l"`):



     

     

     

 The 

outpu

t for

mat o

f the

 gene

rate 

image

. Cho

ose b

etwee

n



     

     

     

 [PIL

](htt

ps://

pillo

w.rea

dthed

ocs.i

o/en/

stabl

e/): 

`PIL.

Image

.Imag

e` or

 `np.

array

`.



     

     

  ret

urn_d

ict (

`bool

`, *o

ption

al*, 

defau

lts t

o `Tr

ue`):



     

     

     

 Whet

her o

r not

 to r

eturn

 a [`

~pipe

lines

.stab

le_di

ffusi

on.St

ableD

iffus

ionPi

pelin

eOutp

ut`] 

inste

ad of

 a



     

     

     

 plai

n tup

le.



     

     

  cal

lback

 (`Ca

llabl

e`, *

optio

nal*)

:



     

     

     

 A fu

nctio

n tha

t wil

l be 

calle

d eve

ry `c

allba

ck_st

eps` 

steps

 duri

ng in

feren

ce. T

he fu

nctio

n wil

l be



     

     

     

 call

ed wi

th th

e fol

lowin

g arg

ument

s: `c

allba

ck(st

ep: i

nt, t

imest

ep: i

nt, l

atent

s: to

rch.F

loatT

ensor

)`.



     

     

  cal

lback

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 1

):



     

     

     

 The 

frequ

ency 

at wh

ich t

he `c

allba

ck` f

uncti

on wi

ll be

 call

ed. I

f not

 spec

ified

, the

 call

back 

will 

be



     

     

     

 call

ed at

 ever

y ste

p.



     

     

  cro

ss_at

tenti

on_kw

args 

(`dic

t`, *

optio

nal*)

:



     

     

     

 A kw

args 

dicti

onary

 that

 if s

pecif

ied i

s pas

sed a

long 

to th

e `At

tenti

onPro

cesso

r` as

 defi

ned u

nder



     

     

     

 `sel

f.pro

cesso

r` in



     

     

     

 [dif

fuser

s.cro

ss_at

tenti

on](h

ttps:

//git

hub.c

om/hu

gging

face/

diffu

sers/

blob/

main/

src/d

iffus

ers/m

odels

/cros

s_att

entio

n.py)

.



     

     

  con

troln

et_co

nditi

oning

_scal

e (`f

loat`

 or `

List[

float

]`, *

optio

nal*,

 defa

ults 

to 1.

0):



     

     

     

 The 

outpu

ts of

 the 

contr

olnet

 are 

multi

plied

 by `

contr

olnet

_cond

ition

ing_s

cale`

 befo

re th

ey ar

e add

ed



     

     

     

 to t

he re

sidua

l in 

the o

rigin

al un

et. I

f mul

tiple

 Cont

rolNe

ts ar

e spe

cifie

d in 

init,

 you 

can s

et th

e



     

     

     

 corr

espon

ding 

scale

 as a

 list

.



     

     

  gue

ss_mo

de (`

bool`

, *op

tiona

l*, d

efaul

ts to

 `Fal

se`):



     

     

     

 In t

his m

ode, 

the C

ontro

lNet 

encod

er wi

ll tr

y bes

t to 

recog

nize 

the c

onten

t of 

the i

nput 

image

 even

 if



     

     

     

 you 

remov

e all

 prom

pts. 

The `

guida

nce_s

cale`

 betw

een 3

.0 an

d 5.0

 is r

ecomm

ended

.





     

   Ex

ample

s:





     

   Re

turns

:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] o

r `tu

ple`:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] i

f `re

turn_

dict`

 is T

rue, 

other

wise 

a `tu

ple.



     

     

  Whe

n ret

urnin

g a t

uple,

 the 

first

 elem

ent i

s a l

ist w

ith t

he ge

nerat

ed im

ages,

 and 

the s

econd

 elem

ent i

s a



     

     

  lis

t of 

`bool

`s de

notin

g whe

ther 

the c

orres

pondi

ng ge

nerat

ed im

age l

ikely

 repr

esent

s "no

t-saf

e-for

-work

"



     

     

  (ns

fw) c

onten

t, ac

cordi

ng to

 the 

`safe

ty_ch

ecker

`.



     

   ""

"



     

   # 

0. De

fault

 heig

ht an

d wid

th to

 unet



     

   # 

BEV: 

we ca

nnot 

use t

he si

ze of

 imag

e



     

   # 

heigh

t, wi

dth =

 self

._def

ault_

heigh

t_wid

th(he

ight,

 widt

h, No

ne)





     

   # 

1. Ch

eck i

nputs

. Rai

se er

ror i

f not

 corr

ect



     

   # 

we do

 not 

need 

this,

 only

 some

 type

 asse

rtion



     

   # 

self.

check

_inpu

ts(



     

   # 

    p

rompt

,



     

   # 

    i

mage,



     

   # 

    h

eight

,



     

   # 

    w

idth,



     

   # 

    c

allba

ck_st

eps,



     

   # 

    n

egati

ve_pr

ompt,



     

   # 

    p

rompt

_embe

ds,



     

   # 

    n

egati

ve_pr

ompt_

embed

s,



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

   # 

)





     

   # 

2. De

fine 

call 

param

eters



     

   # 

NOTE:

 we g

et ba

tch_s

ize f

irst 

from 

promp

t, th

en al

ign w

ith i

t.



     

   if

 prom

pt is

 not 

None 

and i

sinst

ance(

promp

t, st

r):



     

     

  bat

ch_si

ze = 

1



     

   el

if pr

ompt 

is no

t Non

e and

 isin

stanc

e(pro

mpt, 

list)

:



     

     

  bat

ch_si

ze = 

len(p

rompt

)



     

   el

se:



     

     

  bat

ch_si

ze = 

promp

t_emb

eds.s

hape[

0]





     

   de

vice 

= sel

f._ex

ecuti

on_de

vice



     

   # 

here 

`guid

ance_

scale

` is 

defin

ed an

alog 

to th

e gui

dance

 weig

ht `w

` of 

equat

ion (

2)



     

   # 

of th

e Ima

gen p

aper:

 http

s://a

rxiv.

org/p

df/22

05.11

487.p

df . 

`guid

ance_

scale

 = 1`



     

   # 

corre

spond

s to 

doing

 no c

lassi

fier 

free 

guida

nce.



     

   do

_clas

sifie

r_fre

e_gui

dance

 = gu

idanc

e_sca

le > 

1.0





     

   ##

# BEV

, che

ck ca

mera_

param

 ###



     

   if

 came

ra_pa

ram i

s Non

e:



     

     

  # u

se un

cond_

cam a

nd di

sable

 clas

sifie

r fre

e gui

dance



     

     

  N_c

am = 

6  # 

TODO:

 hard

-code

d



     

     

  cam

era_p

aram 

= sel

f.con

troln

et.un

cond_

cam_p

aram(

(batc

h_siz

e, N_

cam))



     

     

  do_

class

ifier

_free

_guid

ance 

= Fal

se



     

   ##

# don

e ###





     

   # 

if is

insta

nce(s

elf.c

ontro

lnet,

 Mult

iCont

rolNe

tMode

l) an

d isi

nstan

ce(co

ntrol

net_c

ondit

ionin

g_sca

le, f

loat)

:



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale =

 [con

troln

et_co

nditi

oning

_scal

e] * 

len(s

elf.c

ontro

lnet.

nets)





     

   # 

3. En

code 

input

 prom

pt



     

   # 

NOTE:

 here

 they

 use 

paddi

ng to

 77, 

is th

is ne

cessa

ry?



     

   pr

ompt_

embed

s = s

elf._

encod

e_pro

mpt(



     

     

  pro

mpt,



     

     

  dev

ice,



     

     

  num

_imag

es_pe

r_pro

mpt,



     

     

  do_

class

ifier

_free

_guid

ance,



     

     

  neg

ative

_prom

pt,



     

     

  pro

mpt_e

mbeds

=prom

pt_em

beds,



     

     

  neg

ative

_prom

pt_em

beds=

negat

ive_p

rompt

_embe

ds,



     

   ) 

 # (2

 * b,

 77 +

 1, 7

68)





     

   # 

4. Pr

epare

 imag

e



     

   # 

NOTE:

 if i

mage 

is no

t ten

sor, 

there

 will

 be s

evera

l pro

cess.



     

   as

sert 

not s

elf.c

ontro

l_ima

ge_pr

ocess

or.co

nfig.

do_no

rmali

ze, "

Your 

contr

olnet

 shou

ld no

t nor

maliz

e the

 cont

rol i

mage.

"



     

   im

age =

 self

.prep

are_i

mage(



     

     

  ima

ge=im

age,



     

     

  wid

th=wi

dth,



     

     

  hei

ght=h

eight

,



     

     

  bat

ch_si

ze=ba

tch_s

ize *

 num_

image

s_per

_prom

pt,



     

     

  num

_imag

es_pe

r_pro

mpt=n

um_im

ages_

per_p

rompt

,



     

     

  dev

ice=d

evice

,



     

     

  dty

pe=se

lf.co

ntrol

net.d

type,



     

     

  do_

class

ifier

_free

_guid

ance=

do_cl

assif

ier_f

ree_g

uidan

ce,



     

     

  gue

ss_mo

de=gu

ess_m

ode,



     

   ) 

 # (2

 * b,

 c_26

, 200

, 200

)



     

   if

 use_

zero_

map_a

s_unc

ondit

ional

 and 

do_cl

assif

ier_f

ree_g

uidan

ce:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  _im

ages[

0] = 

torch

.zero

s_lik

e(_im

ages[

0])



     

     

  ima

ge = 

torch

.cat(

_imag

es)





     

   # 

5. Pr

epare

 time

steps



     

   se

lf.sc

hedul

er.se

t_tim

estep

s(num

_infe

rence

_step

s, de

vice=

devic

e)



     

   ti

meste

ps = 

self.

sched

uler.

times

teps





     

   # 

6. Pr

epare

 late

nt va

riabl

es



     

   nu

m_cha

nnels

_late

nts =

 self

.unet

.conf

ig.in

_chan

nels



     

   la

tents

 = se

lf.pr

epare

_late

nts(



     

     

  bat

ch_si

ze * 

num_i

mages

_per_

promp

t,



     

     

  num

_chan

nels_

laten

ts,



     

     

  hei

ght,



     

     

  wid

th,



     

     

  pro

mpt_e

mbeds

.dtyp

e,



     

     

  dev

ice,



     

     

  gen

erato

r,



     

     

  lat

ents,

  # w

ill u

se if

 not 

None,

 othe

rwise

 will

 gene

rate



     

   ) 

 # (b

, c, 

h/8, 

w/8) 

-> (b

s, 4,

 28, 

50)





     

   # 

7. Pr

epare

 extr

a ste

p kwa

rgs.



     

   ex

tra_s

tep_k

wargs

 = se

lf.pr

epare

_extr

a_ste

p_kwa

rgs(g

enera

tor, 

eta)





     

   ##

#### 

BEV: 

here 

we re

const

ruct 

each 

input

 form

at ##

####



     

   as

sert 

camer

a_par

am.sh

ape[0

] == 

batch

_size

, \



     

     

  f"E

xcept

 {bat

ch_si

ze} c

amera

 para

ms, b

ut yo

u hav

e bs=

{len(

camer

a_par

am)}"



     

   N_

cam =

 came

ra_pa

ram.s

hape[

1]



     

   la

tents

 = to

rch.s

tack(

[late

nts] 

* N_c

am, d

im=1)

  # b

s, 6,

 4, 2

8, 50



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ca

mera_

param

 = ca

mera_

param

.to(s

elf.d

evice

)



     

   if

 do_c

lassi

fier_

free_

guida

nce a

nd no

t gue

ss_mo

de:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  kwa

rgs_w

ith_u

ncond

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_kw

args(



     

     

     

 came

ra_pa

ram=c

amera

_para

m,



     

     

     

 imag

e=_im

ages[

0],  

# 0 i

s for

 unco

nditi

onal



     

     

     

 max_

len=b

box_m

ax_le

ngth,



     

     

     

 **be

v_con

troln

et_kw

args,



     

     

  )



     

     

  kwa

rgs_w

ith_u

ncond

.pop(

"max_

len",

 None

)  # 

some 

do no

t tak

e thi

s.



     

     

  cam

era_p

aram 

= kwa

rgs_w

ith_u

ncond

.pop(

"came

ra_pa

ram")



     

     

  _im

ages[

0] = 

kwarg

s_wit

h_unc

ond.p

op("i

mage"

)



     

     

  ima

ge = 

torch

.cat(

_imag

es)



     

     

  bev

_cont

rolne

t_kwa

rgs =

 move

_to(k

wargs

_with

_unco

nd, s

elf.d

evice

)



     

   ##

#### 

BEV e

nd ##

####





     

   # 

8. De

noisi

ng lo

op



     

   nu

m_war

mup_s

teps 

= len

(time

steps

) - n

um_in

feren

ce_st

eps *

 self

.sche

duler

.orde

r



     

   wi

th se

lf.pr

ogres

s_bar

(tota

l=num

_infe

rence

_step

s) as

 prog

ress_

bar:



     

     

  for

 i, t

 in e

numer

ate(t

imest

eps):



     

     

     

 # ex

pand 

the l

atent

s if 

we ar

e doi

ng cl

assif

ier f

ree g

uidan

ce



     

     

     

 # bs

*2, 6

, 4, 

28, 5

0



     

     

     

 late

nt_mo

del_i

nput 

= (



     

     

     

     

torch

.cat(

[late

nts] 

* 2) 

if do

_clas

sifie

r_fre

e_gui

dance

 else

 late

nts



     

     

     

 )



     

     

     

 late

nt_mo

del_i

nput 

= sel

f.sch

edule

r.sca

le_mo

del_i

nput(



     

     

     

     

laten

t_mod

el_in

put, 

t



     

     

     

 )





     

     

     

 # co

ntrol

net(s

) inf

erenc

e



     

     

     

 cont

rolne

t_t =

 t.un

squee

ze(0)



     

     

     

 # gu

ess_m

ode &

 clas

sifie

r_fre

e_gui

dance

 -> o

nly g

uidan

ce us

e con

troln

et



     

     

     

 # no

t gue

ss_mo

de & 

class

ifier

_free

_guid

ance 

-> al

l use

 cont

rolne

t



     

     

     

 # gu

ess_m

ode -

> nor

mal i

nput,

 take

 effe

ct in

 cont

rolne

t



     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

er Co

ntrol

Net o

nly f

or th

e con

ditio

nal b

atch.



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ents



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds

.chun

k(2)[

1]



     

     

     

 else

:



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ent_m

odel_

input



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds



     

     

     

 cont

rolne

t_t =

 cont

rolne

t_t.r

epeat

(len(

contr

olnet

_late

nt_mo

del_i

nput)

)





     

     

     

 # fm

t: of

f



     

     

     

 down

_bloc

k_res

_samp

les, 

mid_b

lock_

res_s

ample

, \



     

     

     

 enco

der_h

idden

_stat

es_wi

th_ca

m = s

elf.c

ontro

lnet(



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput,



     

     

     

     

contr

olnet

_t,



     

     

     

     

camer

a_par

am,  

# for

 BEV



     

     

     

     

encod

er_hi

dden_

state

s=con

troln

et_pr

ompt_

embed

s,



     

     

     

     

contr

olnet

_cond

=imag

e,



     

     

     

     

condi

tioni

ng_sc

ale=c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

     

     

     

guess

_mode

=gues

s_mod

e,



     

     

     

     

retur

n_dic

t=Fal

se,



     

     

     

     

**bev

_cont

rolne

t_kwa

rgs, 

# for

 BEV



     

     

     

 )



     

     

     

 # fm

t: on





     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

ered 

Contr

olNet

 only

 for 

the c

ondit

ional

 batc

h.



     

     

     

     

# To 

apply

 the 

outpu

t of 

Contr

olNet

 to b

oth t

he un

condi

tiona

l and

 cond

ition

al ba

tches

,



     

     

     

     

# add

 0 to

 the 

uncon

ditio

nal b

atch 

to ke

ep it

 unch

anged

.



     

     

     

     

down_

block

_res_

sampl

es = 

[



     

     

     

     

    t

orch.

cat([

torch

.zero

s_lik

e(d),

 d])



     

     

     

     

    f

or d 

in do

wn_bl

ock_r

es_sa

mples



     

     

     

     

]



     

     

     

     

mid_b

lock_

res_s

ample

 = to

rch.c

at(



     

     

     

     

    [

torch

.zero

s_lik

e(mid

_bloc

k_res

_samp

le), 

mid_b

lock_

res_s

ample

]



     

     

     

     

)



     

     

     

     

# add

 unco

nd en

coder

_hidd

en_st

ates_

with_

cam h

ere



     

     

     

     

encod

er_hi

dden_

state

s_wit

h_cam

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_em

b(



     

     

     

     

    p

rompt

_embe

ds.ch

unk(2

)[0],

 N_ca

m,



     

     

     

     

    e

ncode

r_hid

den_s

tates

_with

_cam,



     

     

     

     

)





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # St

ratin

g fro

m her

e, we

 use 

4-dim

 data

.



     

     

     

 # en

coder

_hidd

en_st

ates_

with_

cam: 

(2b x

 N), 

78, 7

68



     

     

     

 # la

tent_

model

_inpu

t: 2b

, N, 

4, 28

, 50 

-> 2b

 x N,

 4, 2

8, 50



     

     

     

 late

nt_mo

del_i

nput 

= rea

rrang

e(



     

     

     

     

laten

t_mod

el_in

put, 

'b n 

... -

> (b 

n) ..

.')



     

     

     

 late

nts =

 rear

range

(late

nts, 

'b n 

... -

> (b 

n) ..

.')





     

     

     

 # pr

edict

 the 

noise

 resi

dual:

 2bxN

, 4, 

28, 5

0



     

     

     

 addi

tiona

l_par

am = 

{}



     

     

     

 nois

e_pre

d = s

elf.u

net(



     

     

     

     

laten

t_mod

el_in

put, 

 # ma

y wit

h unc

ondit

ional



     

     

     

     

t,



     

     

     

     

encod

er_hi

dden_

state

s=enc

oder_

hidde

n_sta

tes_w

ith_c

am,



     

     

     

     

**add

ition

al_pa

ram, 

 # if

 use 

origi

nal u

net, 

it ca

nnot 

take 

kwarg

s



     

     

     

     

cross

_atte

ntion

_kwar

gs=cr

oss_a

ttent

ion_k

wargs

,



     

     

     

     

down_

block

_addi

tiona

l_res

idual

s=dow

n_blo

ck_re

s_sam

ples,



     

     

     

     

mid_b

lock_

addit

ional

_resi

dual=

mid_b

lock_

res_s

ample

,



     

     

     

 ).sa

mple





     

     

     

 # pe

rform

 guid

ance



     

     

     

 if d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# for

 each

: bxN

, 4, 

28, 5

0



     

     

     

     

noise

_pred

_unco

nd, n

oise_

pred_

text 

= noi

se_pr

ed.ch

unk(2

)



     

     

     

     

noise

_pred

 = no

ise_p

red_u

ncond

 + gu

idanc

e_sca

le * 

(



     

     

     

     

    n

oise_

pred_

text 

- noi

se_pr

ed_un

cond



     

     

     

     

)





     

     

     

 # co

mpute

 the 

previ

ous n

oisy 

sampl

e x_t

 -> x

_t-1



     

     

     

 # NO

TE: i

s the

 sche

duler

 use 

rando

mness

, ple

ase h

andle

 the 

logic



     

     

     

 # fo

r gen

erato

r.



     

     

     

 late

nts =

 self

.sche

duler

.step

(



     

     

     

     

noise

_pred

, t, 

laten

ts, *

*extr

a_ste

p_kwa

rgs



     

     

     

 ).pr

ev_sa

mple





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # no

w we 

add d

imens

ion b

ack, 

use 5

-dim 

data.



     

     

     

 # NO

TE: o

nly `

laten

ts` i

s upd

ated 

throu

gh th

e loo

p



     

     

     

 late

nts =

 rear

range

(late

nts, 

'(b n

) ...

 -> b

 n ..

.', n

=N_ca

m)





     

     

     

 # ca

ll th

e cal

lback

, if 

provi

ded



     

     

     

 if i

 == l

en(ti

meste

ps) -

 1 or

 (



     

     

     

     

(i + 

1) > 

num_w

armup

_step

s and

 (i +

 1) %

 self

.sche

duler

.orde

r == 

0



     

     

     

 ):



     

     

     

     

progr

ess_b

ar.up

date(

)



     

     

     

     

if ca

llbac

k is 

not N

one a

nd i 

% cal

lback

_step

s == 

0:



     

     

     

     

    c

allba

ck(i,

 t, l

atent

s)





     

   ##

#### 

BEV: 

here 

rebui

ld th

e sha

pes b

ack. 

post-

proce

ss st

ill a

ssume



     

   # 

laten

ts, n

o nee

d for

 b, n

, 4, 

28, 5

0



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ##

### B

EV en

d





     

   # 

If we

 do s

equen

tial 

model

 offl

oadin

g, le

t's o

ffloa

d une

t and

 cont

rolne

t



     

   # 

manua

lly f

or ma

x mem

ory s

aving

s



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.une

t.to(

"cpu"

)



     

     

  sel

f.con

troln

et.to

("cpu

")



     

     

  tor

ch.cu

da.em

pty_c

ache(

)





     

   if

 outp

ut_ty

pe ==

 "lat

ent":



     

     

  ima

ge = 

laten

ts



     

     

  has

_nsfw

_conc

ept =

 None



     

   el

if ou

tput_

type 

== "p

il":



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

     

  # 1

0. Co

nvert

 to P

IL



     

     

  ima

ge = 

self.

numpy

_to_p

il_do

uble(

image

)



     

   el

se:



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

   # 

Offlo

ad la

st mo

del t

o CPU



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.fin

al_of

fload

_hook

.offl

oad()





     

   if

 not 

retur

n_dic

t:



     

     

  ret

urn (

image

, has

_nsfw

_conc

ept)





     

   re

turn 

BEVSt

ableD

iffus

ionPi

pelin

eOutp

ut(



     

     

  ima

ges=i

mage,

 nsfw

_cont

ent_d

etect

ed=ha

s_nsf

w_con

cept



     

   )



from 

datac

lasse

s imp

ort d

atacl

ass



from 

typin

g imp

ort A

ny, C

allab

le, D

ict, 

List,

 Opti

onal,

 Tupl

e, Un

ion



impor

t ins

pect





impor

t tor

ch



impor

t PIL



impor

t num

py as

 np



from 

einop

s imp

ort r

earra

nge





from 

diffu

sers 

impor

t Sta

bleDi

ffusi

onCon

trolN

etPip

eline



from 

diffu

sers.

utils

 impo

rt Ba

seOut

put



from 

diffu

sers.

image

_proc

essor

 impo

rt Va

eImag

eProc

essor



from 

diffu

sers.

model

s imp

ort A

utoen

coder

KL, U

Net2D

Condi

tionM

odel



from 

diffu

sers.

pipel

ines.

stabl

e_dif

fusio

n imp

ort S

table

Diffu

sionS

afety

Check

er



from 

diffu

sers.

sched

ulers

.sche

dulin

g_uti

ls im

port 

Karra

sDiff

usion

Sched

ulers



from 

trans

forme

rs im

port 

CLIPI

mageP

roces

sor, 

CLIPT

extMo

del, 

CLIPT

okeni

zer





from 

..mis

c.com

mon i

mport

 move

_to







@data

class



class

 BEVS

table

Diffu

sionP

ipeli

neOut

put(B

aseOu

tput)

:



    "

""



    O

utput

 clas

s for

 Stab

le Di

ffusi

on pi

pelin

es.





    A

rgs:



     

   im

ages 

(`Lis

t[PIL

.Imag

e.Ima

ge]` 

or `n

p.nda

rray`

)



     

     

  Lis

t of 

denoi

sed P

IL im

ages 

of le

ngth 

`batc

h_siz

e` or

 nump

y arr

ay of

 shap

e `(b

atch_

size,

 heig

ht, w

idth,



     

     

  num

_chan

nels)

`. PI

L ima

ges o

r num

py ar

ray p

resen

t the

 deno

ised 

image

s of 

the d

iffus

ion p

ipeli

ne.



     

   ns

fw_co

ntent

_dete

cted 

(`Lis

t[boo

l]`)



     

     

  Lis

t of 

flags

 deno

ting 

wheth

er th

e cor

respo

nding

 gene

rated

 imag

e lik

ely r

epres

ents 

"not-

safe-

for-w

ork"



     

     

  (ns

fw) c

onten

t, or

 `Non

e` if

 safe

ty ch

eckin

g cou

ld no

t be 

perfo

rmed.



    "

""





    i

mages

: Uni

on[Li

st[Li

st[PI

L.Ima

ge.Im

age]]

, np.

ndarr

ay]



    n

sfw_c

onten

t_det

ected

: Opt

ional

[List

[bool

]]







class

 Stab

leDif

fusio

nBEVC

ontro

lNetP

ipeli

ne(St

ableD

iffus

ionCo

ntrol

NetPi

pelin

e):



    d

ef __

init_

_(



     

   se

lf,



     

   va

e: Au

toenc

oderK

L,



     

   te

xt_en

coder

: CLI

PText

Model

,



     

   un

et: U

Net2D

Condi

tionM

odel,



     

   co

ntrol

net,



     

   sc

hedul

er: K

arras

Diffu

sionS

chedu

lers,



     

   to

keniz

er: C

LIPTo

keniz

er,



     

   sa

fety_

check

er: S

table

Diffu

sionS

afety

Check

er = 

None,



     

   fe

ature

_extr

actor

: CLI

PImag

eProc

essor

 = No

ne,



     

   re

quire

s_saf

ety_c

hecke

r: bo

ol = 

False

,



    )

:



     

   su

per()

.__in

it__(



     

     

  vae

,



     

     

  tex

t_enc

oder,



     

     

  tok

enize

r,



     

     

  une

t,



     

     

  con

troln

et,



     

     

  sch

edule

r,



     

     

  saf

ety_c

hecke

r,



     

     

  fea

ture_

extra

ctor,



     

     

  req

uires

_safe

ty_ch

ecker

,



     

   )



     

   as

sert 

safet

y_che

cker 

== No

ne, "

Pleas

e do 

not u

se sa

fety_

check

er."



     

   se

lf.co

ntrol

_imag

e_pro

cesso

r = V

aeIma

gePro

cesso

r(



     

     

  vae

_scal

e_fac

tor=s

elf.v

ae_sc

ale_f

actor

,



     

     

  do_

resiz

e=Fal

se,



     

     

  do_

conve

rt_rg

b=Fal

se,



     

     

  do_

norma

lize=

False

,



     

   )





    d

ef nu

mpy_t

o_pil

_doub

le(se

lf, i

mages

):



     

   ""

"



     

   Co

nvert

 a nu

mpy i

mage 

or a 

batch

 of i

mages

 to a

 PIL 

image

.



     

   We

 need

 to h

andle

 5-di

m inp

uts a

nd re

ture 

2-dim

 list

.



     

   ""

"



     

   im

gs_li

st = 

[]



     

   fo

r img

s in 

image

s:



     

     

  img

s_lis

t.app

end(s

elf.n

umpy_

to_pi

l(img

s))



     

   re

turn 

imgs_

list





    #

 Copi

ed fr

om di

ffuse

rs.pi

pelin

es.st

able_

diffu

sion.

pipel

ine_s

table

_diff

usion

.Stab

leDif

fusio

nPipe

line.

prepa

re_ex

tra_s

tep_k

wargs



    d

ef pr

epare

_extr

a_ste

p_kwa

rgs(s

elf, 

gener

ator,

 eta)

:



     

   # 

prepa

re ex

tra k

wargs

 for 

the s

chedu

ler s

tep, 

since

 not 

all s

chedu

lers 

have 

the s

ame s

ignat

ure



     

   # 

eta (

η) is

 only

 used

 with

 the 

DDIMS

chedu

ler, 

it wi

ll be

 igno

red f

or ot

her s

chedu

lers.



     

   # 

eta c

orres

ponds

 to η

 in D

DIM p

aper:

 http

s://a

rxiv.

org/a

bs/20

10.02

502



     

   # 

and s

hould

 be b

etwee

n [0,

 1]





     

   ac

cepts

_eta 

= "et

a" in

 set(

inspe

ct.si

gnatu

re(se

lf.sc

hedul

er.st

ep).p

arame

ters.

keys(

))



     

   ex

tra_s

tep_k

wargs

 = {}



     

   if

 acce

pts_e

ta:



     

     

  ext

ra_st

ep_kw

args[

"eta"

] = e

ta





     

   # 

check

 if t

he sc

hedul

er ac

cepts

 gene

rator



     

   ac

cepts

_gene

rator

 = "g

enera

tor" 

in se

t(ins

pect.

signa

ture(

self.

sched

uler.

step)

.para

meter

s.key

s())



     

   if

 acce

pts_g

enera

tor:



     

     

  rai

se Ru

ntime

Error

("If 

you f

ixed 

the l

ogic 

for g

enera

tor, 

pleas

e rem

ove t

his. 

Other

wise,

 plea

se us

e oth

er sa

mpler

.")



     

     

  ext

ra_st

ep_kw

args[

"gene

rator

"] = 

gener

ator



     

   re

turn 

extra

_step

_kwar

gs





    d

ef de

code_

laten

ts(se

lf, l

atent

s):



     

   # 

decod

e lat

ents 

with 

5-dim

s



     

   la

tents

 = 1 

/ sel

f.vae

.conf

ig.sc

aling

_fact

or * 

laten

ts





     

   bs

 = le

n(lat

ents)



     

   la

tents

 = re

arran

ge(la

tents

, 'b 

c ...

 -> (

b c) 

...')



     

   im

age =

 self

.vae.

decod

e(lat

ents)

.samp

le



     

   im

age =

 rear

range

(imag

e, '(

b c) 

... -

> b c

 ...'

, b=b

s)





     

   im

age =

 (ima

ge / 

2 + 0

.5).c

lamp(

0, 1)



     

   # 

we al

ways 

cast 

to fl

oat32

 as t

his d

oes n

ot ca

use s

ignif

icant

 over

head 

and i

s com

patib

le wi

th bf

loat1

6



     

   im

age =

 rear

range

(imag

e.cpu

(), '

... c

 h w 

-> ..

. h w

 c').

float

().nu

mpy()



     

   re

turn 

image





    @

torch

.no_g

rad()



    d

ef __

call_

_(



     

   se

lf,



     

   pr

ompt:

 Unio

n[str

, Lis

t[str

]],



     

   im

age: 

torch

.Floa

tTens

or,



     

   ca

mera_

param

: Uni

on[to

rch.T

ensor

, Non

e],



     

   he

ight:

 int,



     

   wi

dth: 

int,



     

   nu

m_inf

erenc

e_ste

ps: i

nt = 

50,



     

   gu

idanc

e_sca

le: f

loat 

= 7.5

,



     

   ne

gativ

e_pro

mpt: 

Optio

nal[U

nion[

str, 

List[

str]]

] = N

one,



     

   nu

m_ima

ges_p

er_pr

ompt:

 Opti

onal[

int] 

= 1,



     

   et

a: fl

oat =

 0.0,



     

   ge

nerat

or: O

ption

al[to

rch.G

enera

tor] 

= Non

e,



     

   la

tents

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   pr

ompt_

embed

s: Op

tiona

l[tor

ch.Fl

oatTe

nsor]

 = No

ne,



     

   ne

gativ

e_pro

mpt_e

mbeds

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   ou

tput_

type:

 Opti

onal[

str] 

= "pi

l",



     

   re

turn_

dict:

 bool

 = Tr

ue,



     

   ca

llbac

k: Op

tiona

l[Cal

lable

[[int

, int

, tor

ch.Fl

oatTe

nsor]

, Non

e]] =

 None

,



     

   ca

llbac

k_ste

ps: i

nt = 

1,



     

   cr

oss_a

ttent

ion_k

wargs

: Opt

ional

[Dict

[str,

 Any]

] = N

one,



     

   co

ntrol

net_c

ondit

ionin

g_sca

le: f

loat 

= 1,



     

   gu

ess_m

ode: 

bool 

= Fal

se,



     

   us

e_zer

o_map

_as_u

ncond

ition

al: b

ool =

 Fals

e,



     

   be

v_con

troln

et_kw

args 

= {},



     

   bb

ox_ma

x_len

gth =

 None

,



    )

:



     

   r"

""



     

   Fu

nctio

n inv

oked 

when 

calli

ng th

e pip

eline

 for 

gener

ation

.





     

   Ar

gs:



     

     

  pro

mpt (

`str`

 or `

List[

str]`

, *op

tiona

l*):



     

     

     

 The 

promp

t or 

promp

ts to

 guid

e the

 imag

e gen

erati

on. I

f not

 defi

ned, 

one h

as to

 pass

 `pro

mpt_e

mbeds

`.



     

     

     

 inst

ead.



     

     

  ima

ge (`

torch

.Floa

tTens

or`, 

`PIL.

Image

.Imag

e`, `

List[

torch

.Floa

tTens

or]`,

 `Lis

t[PIL

.Imag

e.Ima

ge]`,



     

     

     

     

`List

[List

[torc

h.Flo

atTen

sor]]

`, or

 `Lis

t[Lis

t[PIL

.Imag

e.Ima

ge]]`

):



     

     

     

 The 

Contr

olNet

 inpu

t con

ditio

n. Co

ntrol

Net u

ses t

his i

nput 

condi

tion 

to ge

nerat

e gui

dance

 to U

net. 

If



     

     

     

 the 

type 

is sp

ecifi

ed as

 `Tor

ch.Fl

oatTe

nsor`

, it 

is pa

ssed 

to Co

ntrol

Net a

s is.

 `PIL

.Imag

e.Ima

ge` c

an



     

     

     

 also

 be a

ccept

ed as

 an i

mage.

 The 

dimen

sions

 of t

he ou

tput 

image

 defa

ults 

to `i

mage`

's di

mensi

ons. 

If



     

     

     

 heig

ht an

d/or 

width

 are 

passe

d, `i

mage`

 is r

esize

d acc

ordin

g to 

them.

 If m

ultip

le Co

ntrol

Nets 

are



     

     

     

 spec

ified

 in i

nit, 

image

s mus

t be 

passe

d as 

a lis

t suc

h tha

t eac

h ele

ment 

of th

e lis

t can

 be c

orrec

tly



     

     

     

 batc

hed f

or in

put t

o a s

ingle

 cont

rolne

t.



     

     

  hei

ght (

`int`

, *op

tiona

l*, d

efaul

ts to

 self

.unet

.conf

ig.sa

mple_

size 

* sel

f.vae

_scal

e_fac

tor):



     

     

     

 The 

heigh

t in 

pixel

s of 

the g

enera

ted i

mage.



     

     

  wid

th (`

int`,

 *opt

ional

*, de

fault

s to 

self.

unet.

confi

g.sam

ple_s

ize *

 self

.vae_

scale

_fact

or):



     

     

     

 The 

width

 in p

ixels

 of t

he ge

nerat

ed im

age.



     

     

  num

_infe

rence

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 5

0):



     

     

     

 The 

numbe

r of 

denoi

sing 

steps

. Mor

e den

oisin

g ste

ps us

ually

 lead

 to a

 high

er qu

ality

 imag

e at 

the



     

     

     

 expe

nse o

f slo

wer i

nfere

nce.



     

     

  gui

dance

_scal

e (`f

loat`

, *op

tiona

l*, d

efaul

ts to

 7.5)

:



     

     

     

 Guid

ance 

scale

 as d

efine

d in 

[Clas

sifie

r-Fre

e Dif

fusio

n Gui

dance

](htt

ps://

arxiv

.org/

abs/2

207.1

2598)

.



     

     

     

 `gui

dance

_scal

e` is

 defi

ned a

s `w`

 of e

quati

on 2.

 of [

Image

n



     

     

     

 Pape

r](ht

tps:/

/arxi

v.org

/pdf/

2205.

11487

.pdf)

. Gui

dance

 scal

e is 

enabl

ed by

 sett

ing `

guida

nce_s

cale 

>



     

     

     

 1`. 

Highe

r gui

dance

 scal

e enc

ourag

es to

 gene

rate 

image

s tha

t are

 clos

ely l

inked

 to t

he te

xt `p

rompt

`,



     

     

     

 usua

lly a

t the

 expe

nse o

f low

er im

age q

ualit

y.



     

     

  neg

ative

_prom

pt (`

str` 

or `L

ist[s

tr]`,

 *opt

ional

*):



     

     

     

 The 

promp

t or 

promp

ts no

t to 

guide

 the 

image

 gene

ratio

n. If

 not 

defin

ed, o

ne ha

s to 

pass



     

     

     

 `neg

ative

_prom

pt_em

beds`

 inst

ead. 

Ignor

ed wh

en no

t usi

ng gu

idanc

e (i.

e., i

gnore

d if 

`guid

ance_

scale

` is



     

     

     

 less

 than

 `1`)

.



     

     

  num

_imag

es_pe

r_pro

mpt (

`int`

, *op

tiona

l*, d

efaul

ts to

 1):



     

     

     

 The 

numbe

r of 

image

s to 

gener

ate p

er pr

ompt.



     

     

  eta

 (`fl

oat`,

 *opt

ional

*, de

fault

s to 

0.0):



     

     

     

 Corr

espon

ds to

 para

meter

 eta 

(η) i

n the

 DDIM

 pape

r: ht

tps:/

/arxi

v.org

/abs/

2010.

02502

. Onl

y app

lies 

to



     

     

     

 [`sc

hedul

ers.D

DIMSc

hedul

er`],

 will

 be i

gnore

d for

 othe

rs.



     

     

  gen

erato

r (`t

orch.

Gener

ator`

 or `

List[

torch

.Gene

rator

]`, *

optio

nal*)

:



     

     

     

 One 

or a 

list 

of [t

orch 

gener

ator(

s)](h

ttps:

//pyt

orch.

org/d

ocs/s

table

/gene

rated

/torc

h.Gen

erato

r.htm

l)



     

     

     

 to m

ake g

enera

tion 

deter

minis

tic.



     

     

  lat

ents 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

noisy

 late

nts, 

sampl

ed fr

om a 

Gauss

ian d

istri

butio

n, to

 be u

sed a

s inp

uts f

or im

age



     

     

     

 gene

ratio

n. Ca

n be 

used 

to tw

eak t

he sa

me ge

nerat

ion w

ith d

iffer

ent p

rompt

s. If

 not 

provi

ded, 

a lat

ents



     

     

     

 tens

or wi

ll ge

 gene

rated

 by s

ampli

ng us

ing t

he su

pplie

d ran

dom `

gener

ator`

.



     

     

  pro

mpt_e

mbeds

 (`to

rch.F

loatT

ensor

`, *o

ption

al*):



     

     

     

 Pre-

gener

ated 

text 

embed

dings

. Can

 be u

sed t

o eas

ily t

weak 

text 

input

s, *e

.g.* 

promp

t wei

ghtin

g. If

 not



     

     

     

 prov

ided,

 text

 embe

dding

s wil

l be 

gener

ated 

from 

`prom

pt` i

nput 

argum

ent.



     

     

  neg

ative

_prom

pt_em

beds 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

negat

ive t

ext e

mbedd

ings.

 Can 

be us

ed to

 easi

ly tw

eak t

ext i

nputs

, *e.

g.* p

rompt



     

     

     

 weig

hting

. If 

not p

rovid

ed, n

egati

ve_pr

ompt_

embed

s wil

l be 

gener

ated 

from 

`nega

tive_

promp

t` in

put



     

     

     

 argu

ment.



     

     

  out

put_t

ype (

`str`

, *op

tiona

l*, d

efaul

ts to

 `"pi

l"`):



     

     

     

 The 

outpu

t for

mat o

f the

 gene

rate 

image

. Cho

ose b

etwee

n



     

     

     

 [PIL

](htt

ps://

pillo

w.rea

dthed

ocs.i

o/en/

stabl

e/): 

`PIL.

Image

.Imag

e` or

 `np.

array

`.



     

     

  ret

urn_d

ict (

`bool

`, *o

ption

al*, 

defau

lts t

o `Tr

ue`):



     

     

     

 Whet

her o

r not

 to r

eturn

 a [`

~pipe

lines

.stab

le_di

ffusi

on.St

ableD

iffus

ionPi

pelin

eOutp

ut`] 

inste

ad of

 a



     

     

     

 plai

n tup

le.



     

     

  cal

lback

 (`Ca

llabl

e`, *

optio

nal*)

:



     

     

     

 A fu

nctio

n tha

t wil

l be 

calle

d eve

ry `c

allba

ck_st

eps` 

steps

 duri

ng in

feren

ce. T

he fu

nctio

n wil

l be



     

     

     

 call

ed wi

th th

e fol

lowin

g arg

ument

s: `c

allba

ck(st

ep: i

nt, t

imest

ep: i

nt, l

atent

s: to

rch.F

loatT

ensor

)`.



     

     

  cal

lback

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 1

):



     

     

     

 The 

frequ

ency 

at wh

ich t

he `c

allba

ck` f

uncti

on wi

ll be

 call

ed. I

f not

 spec

ified

, the

 call

back 

will 

be



     

     

     

 call

ed at

 ever

y ste

p.



     

     

  cro

ss_at

tenti

on_kw

args 

(`dic

t`, *

optio

nal*)

:



     

     

     

 A kw

args 

dicti

onary

 that

 if s

pecif

ied i

s pas

sed a

long 

to th

e `At

tenti

onPro

cesso

r` as

 defi

ned u

nder



     

     

     

 `sel

f.pro

cesso

r` in



     

     

     

 [dif

fuser

s.cro

ss_at

tenti

on](h

ttps:

//git

hub.c

om/hu

gging

face/

diffu

sers/

blob/

main/

src/d

iffus

ers/m

odels

/cros

s_att

entio

n.py)

.



     

     

  con

troln

et_co

nditi

oning

_scal

e (`f

loat`

 or `

List[

float

]`, *

optio

nal*,

 defa

ults 

to 1.

0):



     

     

     

 The 

outpu

ts of

 the 

contr

olnet

 are 

multi

plied

 by `

contr

olnet

_cond

ition

ing_s

cale`

 befo

re th

ey ar

e add

ed



     

     

     

 to t

he re

sidua

l in 

the o

rigin

al un

et. I

f mul

tiple

 Cont

rolNe

ts ar

e spe

cifie

d in 

init,

 you 

can s

et th

e



     

     

     

 corr

espon

ding 

scale

 as a

 list

.



     

     

  gue

ss_mo

de (`

bool`

, *op

tiona

l*, d

efaul

ts to

 `Fal

se`):



     

     

     

 In t

his m

ode, 

the C

ontro

lNet 

encod

er wi

ll tr

y bes

t to 

recog

nize 

the c

onten

t of 

the i

nput 

image

 even

 if



     

     

     

 you 

remov

e all

 prom

pts. 

The `

guida

nce_s

cale`

 betw

een 3

.0 an

d 5.0

 is r

ecomm

ended

.





     

   Ex

ample

s:





     

   Re

turns

:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] o

r `tu

ple`:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] i

f `re

turn_

dict`

 is T

rue, 

other

wise 

a `tu

ple.



     

     

  Whe

n ret

urnin

g a t

uple,

 the 

first

 elem

ent i

s a l

ist w

ith t

he ge

nerat

ed im

ages,

 and 

the s

econd

 elem

ent i

s a



     

     

  lis

t of 

`bool

`s de

notin

g whe

ther 

the c

orres

pondi

ng ge

nerat

ed im

age l

ikely

 repr

esent

s "no

t-saf

e-for

-work

"



     

     

  (ns

fw) c

onten

t, ac

cordi

ng to

 the 

`safe

ty_ch

ecker

`.



     

   ""

"



     

   # 

0. De

fault

 heig

ht an

d wid

th to

 unet



     

   # 

BEV: 

we ca

nnot 

use t

he si

ze of

 imag

e



     

   # 

heigh

t, wi

dth =

 self

._def

ault_

heigh

t_wid

th(he

ight,

 widt

h, No

ne)





     

   # 

1. Ch

eck i

nputs

. Rai

se er

ror i

f not

 corr

ect



     

   # 

we do

 not 

need 

this,

 only

 some

 type

 asse

rtion



     

   # 

self.

check

_inpu

ts(



     

   # 

    p

rompt

,



     

   # 

    i

mage,



     

   # 

    h

eight

,



     

   # 

    w

idth,



     

   # 

    c

allba

ck_st

eps,



     

   # 

    n

egati

ve_pr

ompt,



     

   # 

    p

rompt

_embe

ds,



     

   # 

    n

egati

ve_pr

ompt_

embed

s,



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

   # 

)





     

   # 

2. De

fine 

call 

param

eters



     

   # 

NOTE:

 we g

et ba

tch_s

ize f

irst 

from 

promp

t, th

en al

ign w

ith i

t.



     

   if

 prom

pt is

 not 

None 

and i

sinst

ance(

promp

t, st

r):



     

     

  bat

ch_si

ze = 

1



     

   el

if pr

ompt 

is no

t Non

e and

 isin

stanc

e(pro

mpt, 

list)

:



     

     

  bat

ch_si

ze = 

len(p

rompt

)



     

   el

se:



     

     

  bat

ch_si

ze = 

promp

t_emb

eds.s

hape[

0]





     

   de

vice 

= sel

f._ex

ecuti

on_de

vice



     

   # 

here 

`guid

ance_

scale

` is 

defin

ed an

alog 

to th

e gui

dance

 weig

ht `w

` of 

equat

ion (

2)



     

   # 

of th

e Ima

gen p

aper:

 http

s://a

rxiv.

org/p

df/22

05.11

487.p

df . 

`guid

ance_

scale

 = 1`



     

   # 

corre

spond

s to 

doing

 no c

lassi

fier 

free 

guida

nce.



     

   do

_clas

sifie

r_fre

e_gui

dance

 = gu

idanc

e_sca

le > 

1.0





     

   ##

# BEV

, che

ck ca

mera_

param

 ###



     

   if

 came

ra_pa

ram i

s Non

e:



     

     

  # u

se un

cond_

cam a

nd di

sable

 clas

sifie

r fre

e gui

dance



     

     

  N_c

am = 

6  # 

TODO:

 hard

-code

d



     

     

  cam

era_p

aram 

= sel

f.con

troln

et.un

cond_

cam_p

aram(

(batc

h_siz

e, N_

cam))



     

     

  do_

class

ifier

_free

_guid

ance 

= Fal

se



     

   ##

# don

e ###





     

   # 

if is

insta

nce(s

elf.c

ontro

lnet,

 Mult

iCont

rolNe

tMode

l) an

d isi

nstan

ce(co

ntrol

net_c

ondit

ionin

g_sca

le, f

loat)

:



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale =

 [con

troln

et_co

nditi

oning

_scal

e] * 

len(s

elf.c

ontro

lnet.

nets)





     

   # 

3. En

code 

input

 prom

pt



     

   # 

NOTE:

 here

 they

 use 

paddi

ng to

 77, 

is th

is ne

cessa

ry?



     

   pr

ompt_

embed

s = s

elf._

encod

e_pro

mpt(



     

     

  pro

mpt,



     

     

  dev

ice,



     

     

  num

_imag

es_pe

r_pro

mpt,



     

     

  do_

class

ifier

_free

_guid

ance,



     

     

  neg

ative

_prom

pt,



     

     

  pro

mpt_e

mbeds

=prom

pt_em

beds,



     

     

  neg

ative

_prom

pt_em

beds=

negat

ive_p

rompt

_embe

ds,



     

   ) 

 # (2

 * b,

 77 +

 1, 7

68)





     

   # 

4. Pr

epare

 imag

e



     

   # 

NOTE:

 if i

mage 

is no

t ten

sor, 

there

 will

 be s

evera

l pro

cess.



     

   as

sert 

not s

elf.c

ontro

l_ima

ge_pr

ocess

or.co

nfig.

do_no

rmali

ze, "

Your 

contr

olnet

 shou

ld no

t nor

maliz

e the

 cont

rol i

mage.

"



     

   im

age =

 self

.prep

are_i

mage(



     

     

  ima

ge=im

age,



     

     

  wid

th=wi

dth,



     

     

  hei

ght=h

eight

,



     

     

  bat

ch_si

ze=ba

tch_s

ize *

 num_

image

s_per

_prom

pt,



     

     

  num

_imag

es_pe

r_pro

mpt=n

um_im

ages_

per_p

rompt

,



     

     

  dev

ice=d

evice

,



     

     

  dty

pe=se

lf.co

ntrol

net.d

type,



     

     

  do_

class

ifier

_free

_guid

ance=

do_cl

assif

ier_f

ree_g

uidan

ce,



     

     

  gue

ss_mo

de=gu

ess_m

ode,



     

   ) 

 # (2

 * b,

 c_26

, 200

, 200

)



     

   if

 use_

zero_

map_a

s_unc

ondit

ional

 and 

do_cl

assif

ier_f

ree_g

uidan

ce:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  _im

ages[

0] = 

torch

.zero

s_lik

e(_im

ages[

0])



     

     

  ima

ge = 

torch

.cat(

_imag

es)





     

   # 

5. Pr

epare

 time

steps



     

   se

lf.sc

hedul

er.se

t_tim

estep

s(num

_infe

rence

_step

s, de

vice=

devic

e)



     

   ti

meste

ps = 

self.

sched

uler.

times

teps





     

   # 

6. Pr

epare

 late

nt va

riabl

es



     

   nu

m_cha

nnels

_late

nts =

 self

.unet

.conf

ig.in

_chan

nels



     

   la

tents

 = se

lf.pr

epare

_late

nts(



     

     

  bat

ch_si

ze * 

num_i

mages

_per_

promp

t,



     

     

  num

_chan

nels_

laten

ts,



     

     

  hei

ght,



     

     

  wid

th,



     

     

  pro

mpt_e

mbeds

.dtyp

e,



     

     

  dev

ice,



     

     

  gen

erato

r,



     

     

  lat

ents,

  # w

ill u

se if

 not 

None,

 othe

rwise

 will

 gene

rate



     

   ) 

 # (b

, c, 

h/8, 

w/8) 

-> (b

s, 4,

 28, 

50)





     

   # 

7. Pr

epare

 extr

a ste

p kwa

rgs.



     

   ex

tra_s

tep_k

wargs

 = se

lf.pr

epare

_extr

a_ste

p_kwa

rgs(g

enera

tor, 

eta)





     

   ##

#### 

BEV: 

here 

we re

const

ruct 

each 

input

 form

at ##

####



     

   as

sert 

camer

a_par

am.sh

ape[0

] == 

batch

_size

, \



     

     

  f"E

xcept

 {bat

ch_si

ze} c

amera

 para

ms, b

ut yo

u hav

e bs=

{len(

camer

a_par

am)}"



     

   N_

cam =

 came

ra_pa

ram.s

hape[

1]



     

   la

tents

 = to

rch.s

tack(

[late

nts] 

* N_c

am, d

im=1)

  # b

s, 6,

 4, 2

8, 50



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ca

mera_

param

 = ca

mera_

param

.to(s

elf.d

evice

)



     

   if

 do_c

lassi

fier_

free_

guida

nce a

nd no

t gue

ss_mo

de:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  kwa

rgs_w

ith_u

ncond

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_kw

args(



     

     

     

 came

ra_pa

ram=c

amera

_para

m,



     

     

     

 imag

e=_im

ages[

0],  

# 0 i

s for

 unco

nditi

onal



     

     

     

 max_

len=b

box_m

ax_le

ngth,



     

     

     

 **be

v_con

troln

et_kw

args,



     

     

  )



     

     

  kwa

rgs_w

ith_u

ncond

.pop(

"max_

len",

 None

)  # 

some 

do no

t tak

e thi

s.



     

     

  cam

era_p

aram 

= kwa

rgs_w

ith_u

ncond

.pop(

"came

ra_pa

ram")



     

     

  _im

ages[

0] = 

kwarg

s_wit

h_unc

ond.p

op("i

mage"

)



     

     

  ima

ge = 

torch

.cat(

_imag

es)



     

     

  bev

_cont

rolne

t_kwa

rgs =

 move

_to(k

wargs

_with

_unco

nd, s

elf.d

evice

)



     

   ##

#### 

BEV e

nd ##

####





     

   # 

8. De

noisi

ng lo

op



     

   nu

m_war

mup_s

teps 

= len

(time

steps

) - n

um_in

feren

ce_st

eps *

 self

.sche

duler

.orde

r



     

   wi

th se

lf.pr

ogres

s_bar

(tota

l=num

_infe

rence

_step

s) as

 prog

ress_

bar:



     

     

  for

 i, t

 in e

numer

ate(t

imest

eps):



     

     

     

 # ex

pand 

the l

atent

s if 

we ar

e doi

ng cl

assif

ier f

ree g

uidan

ce



     

     

     

 # bs

*2, 6

, 4, 

28, 5

0



     

     

     

 late

nt_mo

del_i

nput 

= (



     

     

     

     

torch

.cat(

[late

nts] 

* 2) 

if do

_clas

sifie

r_fre

e_gui

dance

 else

 late

nts



     

     

     

 )



     

     

     

 late

nt_mo

del_i

nput 

= sel

f.sch

edule

r.sca

le_mo

del_i

nput(



     

     

     

     

laten

t_mod

el_in

put, 

t



     

     

     

 )





     

     

     

 # co

ntrol

net(s

) inf

erenc

e



     

     

     

 cont

rolne

t_t =

 t.un

squee

ze(0)



     

     

     

 # gu

ess_m

ode &

 clas

sifie

r_fre

e_gui

dance

 -> o

nly g

uidan

ce us

e con

troln

et



     

     

     

 # no

t gue

ss_mo

de & 

class

ifier

_free

_guid

ance 

-> al

l use

 cont

rolne

t



     

     

     

 # gu

ess_m

ode -

> nor

mal i

nput,

 take

 effe

ct in

 cont

rolne

t



     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

er Co

ntrol

Net o

nly f

or th

e con

ditio

nal b

atch.



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ents



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds

.chun

k(2)[

1]



     

     

     

 else

:



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ent_m

odel_

input



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds



     

     

     

 cont

rolne

t_t =

 cont

rolne

t_t.r

epeat

(len(

contr

olnet

_late

nt_mo

del_i

nput)

)





     

     

     

 # fm

t: of

f



     

     

     

 down

_bloc

k_res

_samp

les, 

mid_b

lock_

res_s

ample

, \



     

     

     

 enco

der_h

idden

_stat

es_wi

th_ca

m = s

elf.c

ontro

lnet(



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput,



     

     

     

     

contr

olnet

_t,



     

     

     

     

camer

a_par

am,  

# for

 BEV



     

     

     

     

encod

er_hi

dden_

state

s=con

troln

et_pr

ompt_

embed

s,



     

     

     

     

contr

olnet

_cond

=imag

e,



     

     

     

     

condi

tioni

ng_sc

ale=c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

     

     

     

guess

_mode

=gues

s_mod

e,



     

     

     

     

retur

n_dic

t=Fal

se,



     

     

     

     

**bev

_cont

rolne

t_kwa

rgs, 

# for

 BEV



     

     

     

 )



     

     

     

 # fm

t: on





     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

ered 

Contr

olNet

 only

 for 

the c

ondit

ional

 batc

h.



     

     

     

     

# To 

apply

 the 

outpu

t of 

Contr

olNet

 to b

oth t

he un

condi

tiona

l and

 cond

ition

al ba

tches

,



     

     

     

     

# add

 0 to

 the 

uncon

ditio

nal b

atch 

to ke

ep it

 unch

anged

.



     

     

     

     

down_

block

_res_

sampl

es = 

[



     

     

     

     

    t

orch.

cat([

torch

.zero

s_lik

e(d),

 d])



     

     

     

     

    f

or d 

in do

wn_bl

ock_r

es_sa

mples



     

     

     

     

]



     

     

     

     

mid_b

lock_

res_s

ample

 = to

rch.c

at(



     

     

     

     

    [

torch

.zero

s_lik

e(mid

_bloc

k_res

_samp

le), 

mid_b

lock_

res_s

ample

]



     

     

     

     

)



     

     

     

     

# add

 unco

nd en

coder

_hidd

en_st

ates_

with_

cam h

ere



     

     

     

     

encod

er_hi

dden_

state

s_wit

h_cam

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_em

b(



     

     

     

     

    p

rompt

_embe

ds.ch

unk(2

)[0],

 N_ca

m,



     

     

     

     

    e

ncode

r_hid

den_s

tates

_with

_cam,



     

     

     

     

)





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # St

ratin

g fro

m her

e, we

 use 

4-dim

 data

.



     

     

     

 # en

coder

_hidd

en_st

ates_

with_

cam: 

(2b x

 N), 

78, 7

68



     

     

     

 # la

tent_

model

_inpu

t: 2b

, N, 

4, 28

, 50 

-> 2b

 x N,

 4, 2

8, 50



     

     

     

 late

nt_mo

del_i

nput 

= rea

rrang

e(



     

     

     

     

laten

t_mod

el_in

put, 

'b n 

... -

> (b 

n) ..

.')



     

     

     

 late

nts =

 rear

range

(late

nts, 

'b n 

... -

> (b 

n) ..

.')





     

     

     

 # pr

edict

 the 

noise

 resi

dual:

 2bxN

, 4, 

28, 5

0



     

     

     

 addi

tiona

l_par

am = 

{}



     

     

     

 nois

e_pre

d = s

elf.u

net(



     

     

     

     

laten

t_mod

el_in

put, 

 # ma

y wit

h unc

ondit

ional



     

     

     

     

t,



     

     

     

     

encod

er_hi

dden_

state

s=enc

oder_

hidde

n_sta

tes_w

ith_c

am,



     

     

     

     

**add

ition

al_pa

ram, 

 # if

 use 

origi

nal u

net, 

it ca

nnot 

take 

kwarg

s



     

     

     

     

cross

_atte

ntion

_kwar

gs=cr

oss_a

ttent

ion_k

wargs

,



     

     

     

     

down_

block

_addi

tiona

l_res

idual

s=dow

n_blo

ck_re

s_sam

ples,



     

     

     

     

mid_b

lock_

addit

ional

_resi

dual=

mid_b

lock_

res_s

ample

,



     

     

     

 ).sa

mple





     

     

     

 # pe

rform

 guid

ance



     

     

     

 if d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# for

 each

: bxN

, 4, 

28, 5

0



     

     

     

     

noise

_pred

_unco

nd, n

oise_

pred_

text 

= noi

se_pr

ed.ch

unk(2

)



     

     

     

     

noise

_pred

 = no

ise_p

red_u

ncond

 + gu

idanc

e_sca

le * 

(



     

     

     

     

    n

oise_

pred_

text 

- noi

se_pr

ed_un

cond



     

     

     

     

)





     

     

     

 # co

mpute

 the 

previ

ous n

oisy 

sampl

e x_t

 -> x

_t-1



     

     

     

 # NO

TE: i

s the

 sche

duler

 use 

rando

mness

, ple

ase h

andle

 the 

logic



     

     

     

 # fo

r gen

erato

r.



     

     

     

 late

nts =

 self

.sche

duler

.step

(



     

     

     

     

noise

_pred

, t, 

laten

ts, *

*extr

a_ste

p_kwa

rgs



     

     

     

 ).pr

ev_sa

mple





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # no

w we 

add d

imens

ion b

ack, 

use 5

-dim 

data.



     

     

     

 # NO

TE: o

nly `

laten

ts` i

s upd

ated 

throu

gh th

e loo

p



     

     

     

 late

nts =

 rear

range

(late

nts, 

'(b n

) ...

 -> b

 n ..

.', n

=N_ca

m)





     

     

     

 # ca

ll th

e cal

lback

, if 

provi

ded



     

     

     

 if i

 == l

en(ti

meste

ps) -

 1 or

 (



     

     

     

     

(i + 

1) > 

num_w

armup

_step

s and

 (i +

 1) %

 self

.sche

duler

.orde

r == 

0



     

     

     

 ):



     

     

     

     

progr

ess_b

ar.up

date(

)



     

     

     

     

if ca

llbac

k is 

not N

one a

nd i 

% cal

lback

_step

s == 

0:



     

     

     

     

    c

allba

ck(i,

 t, l

atent

s)





     

   ##

#### 

BEV: 

here 

rebui

ld th

e sha

pes b

ack. 

post-

proce

ss st

ill a

ssume



     

   # 

laten

ts, n

o nee

d for

 b, n

, 4, 

28, 5

0



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ##

### B

EV en

d





     

   # 

If we

 do s

equen

tial 

model

 offl

oadin

g, le

t's o

ffloa

d une

t and

 cont

rolne

t



     

   # 

manua

lly f

or ma

x mem

ory s

aving

s



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.une

t.to(

"cpu"

)



     

     

  sel

f.con

troln

et.to

("cpu

")



     

     

  tor

ch.cu

da.em

pty_c

ache(

)





     

   if

 outp

ut_ty

pe ==

 "lat

ent":



     

     

  ima

ge = 

laten

ts



     

     

  has

_nsfw

_conc

ept =

 None



     

   el

if ou

tput_

type 

== "p

il":



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

     

  # 1

0. Co

nvert

 to P

IL



     

     

  ima

ge = 

self.

numpy

_to_p

il_do

uble(

image

)



     

   el

se:



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

   # 

Offlo

ad la

st mo

del t

o CPU



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.fin

al_of

fload

_hook

.offl

oad()





     

   if

 not 

retur

n_dic

t:



     

     

  ret

urn (

image

, has

_nsfw

_conc

ept)





     

   re

turn 

BEVSt

ableD

iffus

ionPi

pelin

eOutp

ut(



     

     

  ima

ges=i

mage,

 nsfw

_cont

ent_d

etect

ed=ha

s_nsf

w_con

cept



     

   )



from 

datac

lasse

s imp

ort d

atacl

ass



from 

typin

g imp

ort A

ny, C

allab

le, D

ict, 

List,

 Opti

onal,

 Tupl

e, Un

ion



impor

t ins

pect





impor

t tor

ch



impor

t PIL



impor

t num

py as

 np



from 

einop

s imp

ort r

earra

nge





from 

diffu

sers 

impor

t Sta

bleDi

ffusi

onCon

trolN

etPip

eline



from 

diffu

sers.

utils

 impo

rt Ba

seOut

put



from 

diffu

sers.

image

_proc

essor

 impo

rt Va

eImag

eProc

essor



from 

diffu

sers.

model

s imp

ort A

utoen

coder

KL, U

Net2D

Condi

tionM

odel



from 

diffu

sers.

pipel

ines.

stabl

e_dif

fusio

n imp

ort S

table

Diffu

sionS

afety

Check

er



from 

diffu

sers.

sched

ulers

.sche

dulin

g_uti

ls im

port 

Karra

sDiff

usion

Sched

ulers



from 

trans

forme

rs im

port 

CLIPI

mageP

roces

sor, 

CLIPT

extMo

del, 

CLIPT

okeni

zer





from 

..mis

c.com

mon i

mport

 move

_to







@data

class



class

 BEVS

table

Diffu

sionP

ipeli

neOut

put(B

aseOu

tput)

:



    "

""



    O

utput

 clas

s for

 Stab

le Di

ffusi

on pi

pelin

es.





    A

rgs:



     

   im

ages 

(`Lis

t[PIL

.Imag

e.Ima

ge]` 

or `n

p.nda

rray`

)



     

     

  Lis

t of 

denoi

sed P

IL im

ages 

of le

ngth 

`batc

h_siz

e` or

 nump

y arr

ay of

 shap

e `(b

atch_

size,

 heig

ht, w

idth,



     

     

  num

_chan

nels)

`. PI

L ima

ges o

r num

py ar

ray p

resen

t the

 deno

ised 

image

s of 

the d

iffus

ion p

ipeli

ne.



     

   ns

fw_co

ntent

_dete

cted 

(`Lis

t[boo

l]`)



     

     

  Lis

t of 

flags

 deno

ting 

wheth

er th

e cor

respo

nding

 gene

rated

 imag

e lik

ely r

epres

ents 

"not-

safe-

for-w

ork"



     

     

  (ns

fw) c

onten

t, or

 `Non

e` if

 safe

ty ch

eckin

g cou

ld no

t be 

perfo

rmed.



    "

""





    i

mages

: Uni

on[Li

st[Li

st[PI

L.Ima

ge.Im

age]]

, np.

ndarr

ay]



    n

sfw_c

onten

t_det

ected

: Opt

ional

[List

[bool

]]







class

 Stab

leDif

fusio

nBEVC

ontro

lNetP

ipeli

ne(St

ableD

iffus

ionCo

ntrol

NetPi

pelin

e):



    d

ef __

init_

_(



     

   se

lf,



     

   va

e: Au

toenc

oderK

L,



     

   te

xt_en

coder

: CLI

PText

Model

,



     

   un

et: U

Net2D

Condi

tionM

odel,



     

   co

ntrol

net,



     

   sc

hedul

er: K

arras

Diffu

sionS

chedu

lers,



     

   to

keniz

er: C

LIPTo

keniz

er,



     

   sa

fety_

check

er: S

table

Diffu

sionS

afety

Check

er = 

None,



     

   fe

ature

_extr

actor

: CLI

PImag

eProc

essor

 = No

ne,



     

   re

quire

s_saf

ety_c

hecke

r: bo

ol = 

False

,



    )

:



     

   su

per()

.__in

it__(



     

     

  vae

,



     

     

  tex

t_enc

oder,



     

     

  tok

enize

r,



     

     

  une

t,



     

     

  con

troln

et,



     

     

  sch

edule

r,



     

     

  saf

ety_c

hecke

r,



     

     

  fea

ture_

extra

ctor,



     

     

  req

uires

_safe

ty_ch

ecker

,



     

   )



     

   as

sert 

safet

y_che

cker 

== No

ne, "

Pleas

e do 

not u

se sa

fety_

check

er."



     

   se

lf.co

ntrol

_imag

e_pro

cesso

r = V

aeIma

gePro

cesso

r(



     

     

  vae

_scal

e_fac

tor=s

elf.v

ae_sc

ale_f

actor

,



     

     

  do_

resiz

e=Fal

se,



     

     

  do_

conve

rt_rg

b=Fal

se,



     

     

  do_

norma

lize=

False

,



     

   )





    d

ef nu

mpy_t

o_pil

_doub

le(se

lf, i

mages

):



     

   ""

"



     

   Co

nvert

 a nu

mpy i

mage 

or a 

batch

 of i

mages

 to a

 PIL 

image

.



     

   We

 need

 to h

andle

 5-di

m inp

uts a

nd re

ture 

2-dim

 list

.



     

   ""

"



     

   im

gs_li

st = 

[]



     

   fo

r img

s in 

image

s:



     

     

  img

s_lis

t.app

end(s

elf.n

umpy_

to_pi

l(img

s))



     

   re

turn 

imgs_

list





    #

 Copi

ed fr

om di

ffuse

rs.pi

pelin

es.st

able_

diffu

sion.

pipel

ine_s

table

_diff

usion

.Stab

leDif

fusio

nPipe

line.

prepa

re_ex

tra_s

tep_k

wargs



    d

ef pr

epare

_extr

a_ste

p_kwa

rgs(s

elf, 

gener

ator,

 eta)

:



     

   # 

prepa

re ex

tra k

wargs

 for 

the s

chedu

ler s

tep, 

since

 not 

all s

chedu

lers 

have 

the s

ame s

ignat

ure



     

   # 

eta (

η) is

 only

 used

 with

 the 

DDIMS

chedu

ler, 

it wi

ll be

 igno

red f

or ot

her s

chedu

lers.



     

   # 

eta c

orres

ponds

 to η

 in D

DIM p

aper:

 http

s://a

rxiv.

org/a

bs/20

10.02

502



     

   # 

and s

hould

 be b

etwee

n [0,

 1]





     

   ac

cepts

_eta 

= "et

a" in

 set(

inspe

ct.si

gnatu

re(se

lf.sc

hedul

er.st

ep).p

arame

ters.

keys(

))



     

   ex

tra_s

tep_k

wargs

 = {}



     

   if

 acce

pts_e

ta:



     

     

  ext

ra_st

ep_kw

args[

"eta"

] = e

ta





     

   # 

check

 if t

he sc

hedul

er ac

cepts

 gene

rator



     

   ac

cepts

_gene

rator

 = "g

enera

tor" 

in se

t(ins

pect.

signa

ture(

self.

sched

uler.

step)

.para

meter

s.key

s())



     

   if

 acce

pts_g

enera

tor:



     

     

  rai

se Ru

ntime

Error

("If 

you f

ixed 

the l

ogic 

for g

enera

tor, 

pleas

e rem

ove t

his. 

Other

wise,

 plea

se us

e oth

er sa

mpler

.")



     

     

  ext

ra_st

ep_kw

args[

"gene

rator

"] = 

gener

ator



     

   re

turn 

extra

_step

_kwar

gs





    d

ef de

code_

laten

ts(se

lf, l

atent

s):



     

   # 

decod

e lat

ents 

with 

5-dim

s



     

   la

tents

 = 1 

/ sel

f.vae

.conf

ig.sc

aling

_fact

or * 

laten

ts





     

   bs

 = le

n(lat

ents)



     

   la

tents

 = re

arran

ge(la

tents

, 'b 

c ...

 -> (

b c) 

...')



     

   im

age =

 self

.vae.

decod

e(lat

ents)

.samp

le



     

   im

age =

 rear

range

(imag

e, '(

b c) 

... -

> b c

 ...'

, b=b

s)





     

   im

age =

 (ima

ge / 

2 + 0

.5).c

lamp(

0, 1)



     

   # 

we al

ways 

cast 

to fl

oat32

 as t

his d

oes n

ot ca

use s

ignif

icant

 over

head 

and i

s com

patib

le wi

th bf

loat1

6



     

   im

age =

 rear

range

(imag

e.cpu

(), '

... c

 h w 

-> ..

. h w

 c').

float

().nu

mpy()



     

   re

turn 

image





    @

torch

.no_g

rad()



    d

ef __

call_

_(



     

   se

lf,



     

   pr

ompt:

 Unio

n[str

, Lis

t[str

]],



     

   im

age: 

torch

.Floa

tTens

or,



     

   ca

mera_

param

: Uni

on[to

rch.T

ensor

, Non

e],



     

   he

ight:

 int,



     

   wi

dth: 

int,



     

   nu

m_inf

erenc

e_ste

ps: i

nt = 

50,



     

   gu

idanc

e_sca

le: f

loat 

= 7.5

,



     

   ne

gativ

e_pro

mpt: 

Optio

nal[U

nion[

str, 

List[

str]]

] = N

one,



     

   nu

m_ima

ges_p

er_pr

ompt:

 Opti

onal[

int] 

= 1,



     

   et

a: fl

oat =

 0.0,



     

   ge

nerat

or: O

ption

al[to

rch.G

enera

tor] 

= Non

e,



     

   la

tents

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   pr

ompt_

embed

s: Op

tiona

l[tor

ch.Fl

oatTe

nsor]

 = No

ne,



     

   ne

gativ

e_pro

mpt_e

mbeds

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   ou

tput_

type:

 Opti

onal[

str] 

= "pi

l",



     

   re

turn_

dict:

 bool

 = Tr

ue,



     

   ca

llbac

k: Op

tiona

l[Cal

lable

[[int

, int

, tor

ch.Fl

oatTe

nsor]

, Non

e]] =

 None

,



     

   ca

llbac

k_ste

ps: i

nt = 

1,



     

   cr

oss_a

ttent

ion_k

wargs

: Opt

ional

[Dict

[str,

 Any]

] = N

one,



     

   co

ntrol

net_c

ondit

ionin

g_sca

le: f

loat 

= 1,



     

   gu

ess_m

ode: 

bool 

= Fal

se,



     

   us

e_zer

o_map

_as_u

ncond

ition

al: b

ool =

 Fals

e,



     

   be

v_con

troln

et_kw

args 

= {},



     

   bb

ox_ma

x_len

gth =

 None

,



    )

:



     

   r"

""



     

   Fu

nctio

n inv

oked 

when 

calli

ng th

e pip

eline

 for 

gener

ation

.





     

   Ar

gs:



     

     

  pro

mpt (

`str`

 or `

List[

str]`

, *op

tiona

l*):



     

     

     

 The 

promp

t or 

promp

ts to

 guid

e the

 imag

e gen

erati

on. I

f not

 defi

ned, 

one h

as to

 pass

 `pro

mpt_e

mbeds

`.



     

     

     

 inst

ead.



     

     

  ima

ge (`

torch

.Floa

tTens

or`, 

`PIL.

Image

.Imag

e`, `

List[

torch

.Floa

tTens

or]`,

 `Lis

t[PIL

.Imag

e.Ima

ge]`,



     

     

     

     

`List

[List

[torc

h.Flo

atTen

sor]]

`, or

 `Lis

t[Lis

t[PIL

.Imag

e.Ima

ge]]`

):



     

     

     

 The 

Contr

olNet

 inpu

t con

ditio

n. Co

ntrol

Net u

ses t

his i

nput 

condi

tion 

to ge

nerat

e gui

dance

 to U

net. 

If



     

     

     

 the 

type 

is sp

ecifi

ed as

 `Tor

ch.Fl

oatTe

nsor`

, it 

is pa

ssed 

to Co

ntrol

Net a

s is.

 `PIL

.Imag

e.Ima

ge` c

an



     

     

     

 also

 be a

ccept

ed as

 an i

mage.

 The 

dimen

sions

 of t

he ou

tput 

image

 defa

ults 

to `i

mage`

's di

mensi

ons. 

If



     

     

     

 heig

ht an

d/or 

width

 are 

passe

d, `i

mage`

 is r

esize

d acc

ordin

g to 

them.

 If m

ultip

le Co

ntrol

Nets 

are



     

     

     

 spec

ified

 in i

nit, 

image

s mus

t be 

passe

d as 

a lis

t suc

h tha

t eac

h ele

ment 

of th

e lis

t can

 be c

orrec

tly



     

     

     

 batc

hed f

or in

put t

o a s

ingle

 cont

rolne

t.



     

     

  hei

ght (

`int`

, *op

tiona

l*, d

efaul

ts to

 self

.unet

.conf

ig.sa

mple_

size 

* sel

f.vae

_scal

e_fac

tor):



     

     

     

 The 

heigh

t in 

pixel

s of 

the g

enera

ted i

mage.



     

     

  wid

th (`

int`,

 *opt

ional

*, de

fault

s to 

self.

unet.

confi

g.sam

ple_s

ize *

 self

.vae_

scale

_fact

or):



     

     

     

 The 

width

 in p

ixels

 of t

he ge

nerat

ed im

age.



     

     

  num

_infe

rence

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 5

0):



     

     

     

 The 

numbe

r of 

denoi

sing 

steps

. Mor

e den

oisin

g ste

ps us

ually

 lead

 to a

 high

er qu

ality

 imag

e at 

the



     

     

     

 expe

nse o

f slo

wer i

nfere

nce.



     

     

  gui

dance

_scal

e (`f

loat`

, *op

tiona

l*, d

efaul

ts to

 7.5)

:



     

     

     

 Guid

ance 

scale

 as d

efine

d in 

[Clas

sifie

r-Fre

e Dif

fusio

n Gui

dance

](htt

ps://

arxiv

.org/

abs/2

207.1

2598)

.



     

     

     

 `gui

dance

_scal

e` is

 defi

ned a

s `w`

 of e

quati

on 2.

 of [

Image

n



     

     

     

 Pape

r](ht

tps:/

/arxi

v.org

/pdf/

2205.

11487

.pdf)

. Gui

dance

 scal

e is 

enabl

ed by

 sett

ing `

guida

nce_s

cale 

>



     

     

     

 1`. 

Highe

r gui

dance

 scal

e enc

ourag

es to

 gene

rate 

image

s tha

t are

 clos

ely l

inked

 to t

he te

xt `p

rompt

`,



     

     

     

 usua

lly a

t the

 expe

nse o

f low

er im

age q

ualit

y.



     

     

  neg

ative

_prom

pt (`

str` 

or `L

ist[s

tr]`,

 *opt

ional

*):



     

     

     

 The 

promp

t or 

promp

ts no

t to 

guide

 the 

image

 gene

ratio

n. If

 not 

defin

ed, o

ne ha

s to 

pass



     

     

     

 `neg

ative

_prom

pt_em

beds`

 inst

ead. 

Ignor

ed wh

en no

t usi

ng gu

idanc

e (i.

e., i

gnore

d if 

`guid

ance_

scale

` is



     

     

     

 less

 than

 `1`)

.



     

     

  num

_imag

es_pe

r_pro

mpt (

`int`

, *op

tiona

l*, d

efaul

ts to

 1):



     

     

     

 The 

numbe

r of 

image

s to 

gener

ate p

er pr

ompt.



     

     

  eta

 (`fl

oat`,

 *opt

ional

*, de

fault

s to 

0.0):



     

     

     

 Corr

espon

ds to

 para

meter

 eta 

(η) i

n the

 DDIM

 pape

r: ht

tps:/

/arxi

v.org

/abs/

2010.

02502

. Onl

y app

lies 

to



     

     

     

 [`sc

hedul

ers.D

DIMSc

hedul

er`],

 will

 be i

gnore

d for

 othe

rs.



     

     

  gen

erato

r (`t

orch.

Gener

ator`

 or `

List[

torch

.Gene

rator

]`, *

optio

nal*)

:



     

     

     

 One 

or a 

list 

of [t

orch 

gener

ator(

s)](h

ttps:

//pyt

orch.

org/d

ocs/s

table

/gene

rated

/torc

h.Gen

erato

r.htm

l)



     

     

     

 to m

ake g

enera

tion 

deter

minis

tic.



     

     

  lat

ents 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

noisy

 late

nts, 

sampl

ed fr

om a 

Gauss

ian d

istri

butio

n, to

 be u

sed a

s inp

uts f

or im

age



     

     

     

 gene

ratio

n. Ca

n be 

used 

to tw

eak t

he sa

me ge

nerat

ion w

ith d

iffer

ent p

rompt

s. If

 not 

provi

ded, 

a lat

ents



     

     

     

 tens

or wi

ll ge

 gene

rated

 by s

ampli

ng us

ing t

he su

pplie

d ran

dom `

gener

ator`

.



     

     

  pro

mpt_e

mbeds

 (`to

rch.F

loatT

ensor

`, *o

ption

al*):



     

     

     

 Pre-

gener

ated 

text 

embed

dings

. Can

 be u

sed t

o eas

ily t

weak 

text 

input

s, *e

.g.* 

promp

t wei

ghtin

g. If

 not



     

     

     

 prov

ided,

 text

 embe

dding

s wil

l be 

gener

ated 

from 

`prom

pt` i

nput 

argum

ent.



     

     

  neg

ative

_prom

pt_em

beds 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

negat

ive t

ext e

mbedd

ings.

 Can 

be us

ed to

 easi

ly tw

eak t

ext i

nputs

, *e.

g.* p

rompt



     

     

     

 weig

hting

. If 

not p

rovid

ed, n

egati

ve_pr

ompt_

embed

s wil

l be 

gener

ated 

from 

`nega

tive_

promp

t` in

put



     

     

     

 argu

ment.



     

     

  out

put_t

ype (

`str`

, *op

tiona

l*, d

efaul

ts to

 `"pi

l"`):



     

     

     

 The 

outpu

t for

mat o

f the

 gene

rate 

image

. Cho

ose b

etwee

n



     

     

     

 [PIL

](htt

ps://

pillo

w.rea

dthed

ocs.i

o/en/

stabl

e/): 

`PIL.

Image

.Imag

e` or

 `np.

array

`.



     

     

  ret

urn_d

ict (

`bool

`, *o

ption

al*, 

defau

lts t

o `Tr

ue`):



     

     

     

 Whet

her o

r not

 to r

eturn

 a [`

~pipe

lines

.stab

le_di

ffusi

on.St

ableD

iffus

ionPi

pelin

eOutp

ut`] 

inste

ad of

 a



     

     

     

 plai

n tup

le.



     

     

  cal

lback

 (`Ca

llabl

e`, *

optio

nal*)

:



     

     

     

 A fu

nctio

n tha

t wil

l be 

calle

d eve

ry `c

allba

ck_st

eps` 

steps

 duri

ng in

feren

ce. T

he fu

nctio

n wil

l be



     

     

     

 call

ed wi

th th

e fol

lowin

g arg

ument

s: `c

allba

ck(st

ep: i

nt, t

imest

ep: i

nt, l

atent

s: to

rch.F

loatT

ensor

)`.



     

     

  cal

lback

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 1

):



     

     

     

 The 

frequ

ency 

at wh

ich t

he `c

allba

ck` f

uncti

on wi

ll be

 call

ed. I

f not

 spec

ified

, the

 call

back 

will 

be



     

     

     

 call

ed at

 ever

y ste

p.



     

     

  cro

ss_at

tenti

on_kw

args 

(`dic

t`, *

optio

nal*)

:



     

     

     

 A kw

args 

dicti

onary

 that

 if s

pecif

ied i

s pas

sed a

long 

to th

e `At

tenti

onPro

cesso

r` as

 defi

ned u

nder



     

     

     

 `sel

f.pro

cesso

r` in



     

     

     

 [dif

fuser

s.cro

ss_at

tenti

on](h

ttps:

//git

hub.c

om/hu

gging

face/

diffu

sers/

blob/

main/

src/d

iffus

ers/m

odels

/cros

s_att

entio

n.py)

.



     

     

  con

troln

et_co

nditi

oning

_scal

e (`f

loat`

 or `

List[

float

]`, *

optio

nal*,

 defa

ults 

to 1.

0):



     

     

     

 The 

outpu

ts of

 the 

contr

olnet

 are 

multi

plied

 by `

contr

olnet

_cond

ition

ing_s

cale`

 befo

re th

ey ar

e add

ed



     

     

     

 to t

he re

sidua

l in 

the o

rigin

al un

et. I

f mul

tiple

 Cont

rolNe

ts ar

e spe

cifie

d in 

init,

 you 

can s

et th

e



     

     

     

 corr

espon

ding 

scale

 as a

 list

.



     

     

  gue

ss_mo

de (`

bool`

, *op

tiona

l*, d

efaul

ts to

 `Fal

se`):



     

     

     

 In t

his m

ode, 

the C

ontro

lNet 

encod

er wi

ll tr

y bes

t to 

recog

nize 

the c

onten

t of 

the i

nput 

image

 even

 if



     

     

     

 you 

remov

e all

 prom

pts. 

The `

guida

nce_s

cale`

 betw

een 3

.0 an

d 5.0

 is r

ecomm

ended

.





     

   Ex

ample

s:





     

   Re

turns

:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] o

r `tu

ple`:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] i

f `re

turn_

dict`

 is T

rue, 

other

wise 

a `tu

ple.



     

     

  Whe

n ret

urnin

g a t

uple,

 the 

first

 elem

ent i

s a l

ist w

ith t

he ge

nerat

ed im

ages,

 and 

the s

econd

 elem

ent i

s a



     

     

  lis

t of 

`bool

`s de

notin

g whe

ther 

the c

orres

pondi

ng ge

nerat

ed im

age l

ikely

 repr

esent

s "no

t-saf

e-for

-work

"



     

     

  (ns

fw) c

onten

t, ac

cordi

ng to

 the 

`safe

ty_ch

ecker

`.



     

   ""

"



     

   # 

0. De

fault

 heig

ht an

d wid

th to

 unet



     

   # 

BEV: 

we ca

nnot 

use t

he si

ze of

 imag

e



     

   # 

heigh

t, wi

dth =

 self

._def

ault_

heigh

t_wid

th(he

ight,

 widt

h, No

ne)





     

   # 

1. Ch

eck i

nputs

. Rai

se er

ror i

f not

 corr

ect



     

   # 

we do

 not 

need 

this,

 only

 some

 type

 asse

rtion



     

   # 

self.

check

_inpu

ts(



     

   # 

    p

rompt

,



     

   # 

    i

mage,



     

   # 

    h

eight

,



     

   # 

    w

idth,



     

   # 

    c

allba

ck_st

eps,



     

   # 

    n

egati

ve_pr

ompt,



     

   # 

    p

rompt

_embe

ds,



     

   # 

    n

egati

ve_pr

ompt_

embed

s,



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

   # 

)





     

   # 

2. De

fine 

call 

param

eters



     

   # 

NOTE:

 we g

et ba

tch_s

ize f

irst 

from 

promp

t, th

en al

ign w

ith i

t.



     

   if

 prom

pt is

 not 

None 

and i

sinst

ance(

promp

t, st

r):



     

     

  bat

ch_si

ze = 

1



     

   el

if pr

ompt 

is no

t Non

e and

 isin

stanc

e(pro

mpt, 

list)

:



     

     

  bat

ch_si

ze = 

len(p

rompt

)



     

   el

se:



     

     

  bat

ch_si

ze = 

promp

t_emb

eds.s

hape[

0]





     

   de

vice 

= sel

f._ex

ecuti

on_de

vice



     

   # 

here 

`guid

ance_

scale

` is 

defin

ed an

alog 

to th

e gui

dance

 weig

ht `w

` of 

equat

ion (

2)



     

   # 

of th

e Ima

gen p

aper:

 http

s://a

rxiv.

org/p

df/22

05.11

487.p

df . 

`guid

ance_

scale

 = 1`



     

   # 

corre

spond

s to 

doing

 no c

lassi

fier 

free 

guida

nce.



     

   do

_clas

sifie

r_fre

e_gui

dance

 = gu

idanc

e_sca

le > 

1.0





     

   ##

# BEV

, che

ck ca

mera_

param

 ###



     

   if

 came

ra_pa

ram i

s Non

e:



     

     

  # u

se un

cond_

cam a

nd di

sable

 clas

sifie

r fre

e gui

dance



     

     

  N_c

am = 

6  # 

TODO:

 hard

-code

d



     

     

  cam

era_p

aram 

= sel

f.con

troln

et.un

cond_

cam_p

aram(

(batc

h_siz

e, N_

cam))



     

     

  do_

class

ifier

_free

_guid

ance 

= Fal

se



     

   ##

# don

e ###





     

   # 

if is

insta

nce(s

elf.c

ontro

lnet,

 Mult

iCont

rolNe

tMode

l) an

d isi

nstan

ce(co

ntrol

net_c

ondit

ionin

g_sca

le, f

loat)

:



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale =

 [con

troln

et_co

nditi

oning

_scal

e] * 

len(s

elf.c

ontro

lnet.

nets)





     

   # 

3. En

code 

input

 prom

pt



     

   # 

NOTE:

 here

 they

 use 

paddi

ng to

 77, 

is th

is ne

cessa

ry?



     

   pr

ompt_

embed

s = s

elf._

encod

e_pro

mpt(



     

     

  pro

mpt,



     

     

  dev

ice,



     

     

  num

_imag

es_pe

r_pro

mpt,



     

     

  do_

class

ifier

_free

_guid

ance,



     

     

  neg

ative

_prom

pt,



     

     

  pro

mpt_e

mbeds

=prom

pt_em

beds,



     

     

  neg

ative

_prom

pt_em

beds=

negat

ive_p

rompt

_embe

ds,



     

   ) 

 # (2

 * b,

 77 +

 1, 7

68)





     

   # 

4. Pr

epare

 imag

e



     

   # 

NOTE:

 if i

mage 

is no

t ten

sor, 

there

 will

 be s

evera

l pro

cess.



     

   as

sert 

not s

elf.c

ontro

l_ima

ge_pr

ocess

or.co

nfig.

do_no

rmali

ze, "

Your 

contr

olnet

 shou

ld no

t nor

maliz

e the

 cont

rol i

mage.

"



     

   im

age =

 self

.prep

are_i

mage(



     

     

  ima

ge=im

age,



     

     

  wid

th=wi

dth,



     

     

  hei

ght=h

eight

,



     

     

  bat

ch_si

ze=ba

tch_s

ize *

 num_

image

s_per

_prom

pt,



     

     

  num

_imag

es_pe

r_pro

mpt=n

um_im

ages_

per_p

rompt

,



     

     

  dev

ice=d

evice

,



     

     

  dty

pe=se

lf.co

ntrol

net.d

type,



     

     

  do_

class

ifier

_free

_guid

ance=

do_cl

assif

ier_f

ree_g

uidan

ce,



     

     

  gue

ss_mo

de=gu

ess_m

ode,



     

   ) 

 # (2

 * b,

 c_26

, 200

, 200

)



     

   if

 use_

zero_

map_a

s_unc

ondit

ional

 and 

do_cl

assif

ier_f

ree_g

uidan

ce:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  _im

ages[

0] = 

torch

.zero

s_lik

e(_im

ages[

0])



     

     

  ima

ge = 

torch

.cat(

_imag

es)





     

   # 

5. Pr

epare

 time

steps



     

   se

lf.sc

hedul

er.se

t_tim

estep

s(num

_infe

rence

_step

s, de

vice=

devic

e)



     

   ti

meste

ps = 

self.

sched

uler.

times

teps





     

   # 

6. Pr

epare

 late

nt va

riabl

es



     

   nu

m_cha

nnels

_late

nts =

 self

.unet

.conf

ig.in

_chan

nels



     

   la

tents

 = se

lf.pr

epare

_late

nts(



     

     

  bat

ch_si

ze * 

num_i

mages

_per_

promp

t,



     

     

  num

_chan

nels_

laten

ts,



     

     

  hei

ght,



     

     

  wid

th,



     

     

  pro

mpt_e

mbeds

.dtyp

e,



     

     

  dev

ice,



     

     

  gen

erato

r,



     

     

  lat

ents,

  # w

ill u

se if

 not 

None,

 othe

rwise

 will

 gene

rate



     

   ) 

 # (b

, c, 

h/8, 

w/8) 

-> (b

s, 4,

 28, 

50)





     

   # 

7. Pr

epare

 extr

a ste

p kwa

rgs.



     

   ex

tra_s

tep_k

wargs

 = se

lf.pr

epare

_extr

a_ste

p_kwa

rgs(g

enera

tor, 

eta)





     

   ##

#### 

BEV: 

here 

we re

const

ruct 

each 

input

 form

at ##

####



     

   as

sert 

camer

a_par

am.sh

ape[0

] == 

batch

_size

, \



     

     

  f"E

xcept

 {bat

ch_si

ze} c

amera

 para

ms, b

ut yo

u hav

e bs=

{len(

camer

a_par

am)}"



     

   N_

cam =

 came

ra_pa

ram.s

hape[

1]



     

   la

tents

 = to

rch.s

tack(

[late

nts] 

* N_c

am, d

im=1)

  # b

s, 6,

 4, 2

8, 50



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ca

mera_

param

 = ca

mera_

param

.to(s

elf.d

evice

)



     

   if

 do_c

lassi

fier_

free_

guida

nce a

nd no

t gue

ss_mo

de:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  kwa

rgs_w

ith_u

ncond

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_kw

args(



     

     

     

 came

ra_pa

ram=c

amera

_para

m,



     

     

     

 imag

e=_im

ages[

0],  

# 0 i

s for

 unco

nditi

onal



     

     

     

 max_

len=b

box_m

ax_le

ngth,



     

     

     

 **be

v_con

troln

et_kw

args,



     

     

  )



     

     

  kwa

rgs_w

ith_u

ncond

.pop(

"max_

len",

 None

)  # 

some 

do no

t tak

e thi

s.



     

     

  cam

era_p

aram 

= kwa

rgs_w

ith_u

ncond

.pop(

"came

ra_pa

ram")



     

     

  _im

ages[

0] = 

kwarg

s_wit

h_unc

ond.p

op("i

mage"

)



     

     

  ima

ge = 

torch

.cat(

_imag

es)



     

     

  bev

_cont

rolne

t_kwa

rgs =

 move

_to(k

wargs

_with

_unco

nd, s

elf.d

evice

)



     

   ##

#### 

BEV e

nd ##

####





     

   # 

8. De

noisi

ng lo

op



     

   nu

m_war

mup_s

teps 

= len

(time

steps

) - n

um_in

feren

ce_st

eps *

 self

.sche

duler

.orde

r



     

   wi

th se

lf.pr

ogres

s_bar

(tota

l=num

_infe

rence

_step

s) as

 prog

ress_

bar:



     

     

  for

 i, t

 in e

numer

ate(t

imest

eps):



     

     

     

 # ex

pand 

the l

atent

s if 

we ar

e doi

ng cl

assif

ier f

ree g

uidan

ce



     

     

     

 # bs

*2, 6

, 4, 

28, 5

0



     

     

     

 late

nt_mo

del_i

nput 

= (



     

     

     

     

torch

.cat(

[late

nts] 

* 2) 

if do

_clas

sifie

r_fre

e_gui

dance

 else

 late

nts



     

     

     

 )



     

     

     

 late

nt_mo

del_i

nput 

= sel

f.sch

edule

r.sca

le_mo

del_i

nput(



     

     

     

     

laten

t_mod

el_in

put, 

t



     

     

     

 )





     

     

     

 # co

ntrol

net(s

) inf

erenc

e



     

     

     

 cont

rolne

t_t =

 t.un

squee

ze(0)



     

     

     

 # gu

ess_m

ode &

 clas

sifie

r_fre

e_gui

dance

 -> o

nly g

uidan

ce us

e con

troln

et



     

     

     

 # no

t gue

ss_mo

de & 

class

ifier

_free

_guid

ance 

-> al

l use

 cont

rolne

t



     

     

     

 # gu

ess_m

ode -

> nor

mal i

nput,

 take

 effe

ct in

 cont

rolne

t



     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

er Co

ntrol

Net o

nly f

or th

e con

ditio

nal b

atch.



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ents



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds

.chun

k(2)[

1]



     

     

     

 else

:



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ent_m

odel_

input



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds



     

     

     

 cont

rolne

t_t =

 cont

rolne

t_t.r

epeat

(len(

contr

olnet

_late

nt_mo

del_i

nput)

)





     

     

     

 # fm

t: of

f



     

     

     

 down

_bloc

k_res

_samp

les, 

mid_b

lock_

res_s

ample

, \



     

     

     

 enco

der_h

idden

_stat

es_wi

th_ca

m = s

elf.c

ontro

lnet(



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput,



     

     

     

     

contr

olnet

_t,



     

     

     

     

camer

a_par

am,  

# for

 BEV



     

     

     

     

encod

er_hi

dden_

state

s=con

troln

et_pr

ompt_

embed

s,



     

     

     

     

contr

olnet

_cond

=imag

e,



     

     

     

     

condi

tioni

ng_sc

ale=c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

     

     

     

guess

_mode

=gues

s_mod

e,



     

     

     

     

retur

n_dic

t=Fal

se,



     

     

     

     

**bev

_cont

rolne

t_kwa

rgs, 

# for

 BEV



     

     

     

 )



     

     

     

 # fm

t: on





     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

ered 

Contr

olNet

 only

 for 

the c

ondit

ional

 batc

h.



     

     

     

     

# To 

apply

 the 

outpu

t of 

Contr

olNet

 to b

oth t

he un

condi

tiona

l and

 cond

ition

al ba

tches

,



     

     

     

     

# add

 0 to

 the 

uncon

ditio

nal b

atch 

to ke

ep it

 unch

anged

.



     

     

     

     

down_

block

_res_

sampl

es = 

[



     

     

     

     

    t

orch.

cat([

torch

.zero

s_lik

e(d),

 d])



     

     

     

     

    f

or d 

in do

wn_bl

ock_r

es_sa

mples



     

     

     

     

]



     

     

     

     

mid_b

lock_

res_s

ample

 = to

rch.c

at(



     

     

     

     

    [

torch

.zero

s_lik

e(mid

_bloc

k_res

_samp

le), 

mid_b

lock_

res_s

ample

]



     

     

     

     

)



     

     

     

     

# add

 unco

nd en

coder

_hidd

en_st

ates_

with_

cam h

ere



     

     

     

     

encod

er_hi

dden_

state

s_wit

h_cam

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_em

b(



     

     

     

     

    p

rompt

_embe

ds.ch

unk(2

)[0],

 N_ca

m,



     

     

     

     

    e

ncode

r_hid

den_s

tates

_with

_cam,



     

     

     

     

)





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # St

ratin

g fro

m her

e, we

 use 

4-dim

 data

.



     

     

     

 # en

coder

_hidd

en_st

ates_

with_

cam: 

(2b x

 N), 

78, 7

68



     

     

     

 # la

tent_

model

_inpu

t: 2b

, N, 

4, 28

, 50 

-> 2b

 x N,

 4, 2

8, 50



     

     

     

 late

nt_mo

del_i

nput 

= rea

rrang

e(



     

     

     

     

laten

t_mod

el_in

put, 

'b n 

... -

> (b 

n) ..

.')



     

     

     

 late

nts =

 rear

range

(late

nts, 

'b n 

... -

> (b 

n) ..

.')





     

     

     

 # pr

edict

 the 

noise

 resi

dual:

 2bxN

, 4, 

28, 5

0



     

     

     

 addi

tiona

l_par

am = 

{}



     

     

     

 nois

e_pre

d = s

elf.u

net(



     

     

     

     

laten

t_mod

el_in

put, 

 # ma

y wit

h unc

ondit

ional



     

     

     

     

t,



     

     

     

     

encod

er_hi

dden_

state

s=enc

oder_

hidde

n_sta

tes_w

ith_c

am,



     

     

     

     

**add

ition

al_pa

ram, 

 # if

 use 

origi

nal u

net, 

it ca

nnot 

take 

kwarg

s



     

     

     

     

cross

_atte

ntion

_kwar

gs=cr

oss_a

ttent

ion_k

wargs

,



     

     

     

     

down_

block

_addi

tiona

l_res

idual

s=dow

n_blo

ck_re

s_sam

ples,



     

     

     

     

mid_b

lock_

addit

ional

_resi

dual=

mid_b

lock_

res_s

ample

,



     

     

     

 ).sa

mple





     

     

     

 # pe

rform

 guid

ance



     

     

     

 if d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# for

 each

: bxN

, 4, 

28, 5

0



     

     

     

     

noise

_pred

_unco

nd, n

oise_

pred_

text 

= noi

se_pr

ed.ch

unk(2

)



     

     

     

     

noise

_pred

 = no

ise_p

red_u

ncond

 + gu

idanc

e_sca

le * 

(



     

     

     

     

    n

oise_

pred_

text 

- noi

se_pr

ed_un

cond



     

     

     

     

)





     

     

     

 # co

mpute

 the 

previ

ous n

oisy 

sampl

e x_t

 -> x

_t-1



     

     

     

 # NO

TE: i

s the

 sche

duler

 use 

rando

mness

, ple

ase h

andle

 the 

logic



     

     

     

 # fo

r gen

erato

r.



     

     

     

 late

nts =

 self

.sche

duler

.step

(



     

     

     

     

noise

_pred

, t, 

laten

ts, *

*extr

a_ste

p_kwa

rgs



     

     

     

 ).pr

ev_sa

mple





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # no

w we 

add d

imens

ion b

ack, 

use 5

-dim 

data.



     

     

     

 # NO

TE: o

nly `

laten

ts` i

s upd

ated 

throu

gh th

e loo

p



     

     

     

 late

nts =

 rear

range

(late

nts, 

'(b n

) ...

 -> b

 n ..

.', n

=N_ca

m)





     

     

     

 # ca

ll th

e cal

lback

, if 

provi

ded



     

     

     

 if i

 == l

en(ti

meste

ps) -

 1 or

 (



     

     

     

     

(i + 

1) > 

num_w

armup

_step

s and

 (i +

 1) %

 self

.sche

duler

.orde

r == 

0



     

     

     

 ):



     

     

     

     

progr

ess_b

ar.up

date(

)



     

     

     

     

if ca

llbac

k is 

not N

one a

nd i 

% cal

lback

_step

s == 

0:



     

     

     

     

    c

allba

ck(i,

 t, l

atent

s)





     

   ##

#### 

BEV: 

here 

rebui

ld th

e sha

pes b

ack. 

post-

proce

ss st

ill a

ssume



     

   # 

laten

ts, n

o nee

d for

 b, n

, 4, 

28, 5

0



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ##

### B

EV en

d





     

   # 

If we

 do s

equen

tial 

model

 offl

oadin

g, le

t's o

ffloa

d une

t and

 cont

rolne

t



     

   # 

manua

lly f

or ma

x mem

ory s

aving

s



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.une

t.to(

"cpu"

)



     

     

  sel

f.con

troln

et.to

("cpu

")



     

     

  tor

ch.cu

da.em

pty_c

ache(

)





     

   if

 outp

ut_ty

pe ==

 "lat

ent":



     

     

  ima

ge = 

laten

ts



     

     

  has

_nsfw

_conc

ept =

 None



     

   el

if ou

tput_

type 

== "p

il":



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

     

  # 1

0. Co

nvert

 to P

IL



     

     

  ima

ge = 

self.

numpy

_to_p

il_do

uble(

image

)



     

   el

se:



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

   # 

Offlo

ad la

st mo

del t

o CPU



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.fin

al_of

fload

_hook

.offl

oad()





     

   if

 not 

retur

n_dic

t:



     

     

  ret

urn (

image

, has

_nsfw

_conc

ept)





     

   re

turn 

BEVSt

ableD

iffus

ionPi

pelin

eOutp

ut(



     

     

  ima

ges=i

mage,

 nsfw

_cont

ent_d

etect

ed=ha

s_nsf

w_con

cept



     

   )



from 

datac

lasse

s imp

ort d

atacl

ass



from 

typin

g imp

ort A

ny, C

allab

le, D

ict, 

List,

 Opti

onal,

 Tupl

e, Un

ion



impor

t ins

pect





impor

t tor

ch



impor

t PIL



impor

t num

py as

 np



from 

einop

s imp

ort r

earra

nge





from 

diffu

sers 

impor

t Sta

bleDi

ffusi

onCon

trolN

etPip

eline



from 

diffu

sers.

utils

 impo

rt Ba

seOut

put



from 

diffu

sers.

image

_proc

essor

 impo

rt Va

eImag

eProc

essor



from 

diffu

sers.

model

s imp

ort A

utoen

coder

KL, U

Net2D

Condi

tionM

odel



from 

diffu

sers.

pipel

ines.

stabl

e_dif

fusio

n imp

ort S

table

Diffu

sionS

afety

Check

er



from 

diffu

sers.

sched

ulers

.sche

dulin

g_uti

ls im

port 

Karra

sDiff

usion

Sched

ulers



from 

trans

forme

rs im

port 

CLIPI

mageP

roces

sor, 

CLIPT

extMo

del, 

CLIPT

okeni

zer





from 

..mis

c.com

mon i

mport

 move

_to







@data

class



class

 BEVS

table

Diffu

sionP

ipeli

neOut

put(B

aseOu

tput)

:



    "

""



    O

utput

 clas

s for

 Stab

le Di

ffusi

on pi

pelin

es.





    A

rgs:



     

   im

ages 

(`Lis

t[PIL

.Imag

e.Ima

ge]` 

or `n

p.nda

rray`

)



     

     

  Lis

t of 

denoi

sed P

IL im

ages 

of le

ngth 

`batc

h_siz

e` or

 nump

y arr

ay of

 shap

e `(b

atch_

size,

 heig

ht, w

idth,



     

     

  num

_chan

nels)

`. PI

L ima

ges o

r num

py ar

ray p

resen

t the

 deno

ised 

image

s of 

the d

iffus

ion p

ipeli

ne.



     

   ns

fw_co

ntent

_dete

cted 

(`Lis

t[boo

l]`)



     

     

  Lis

t of 

flags

 deno

ting 

wheth

er th

e cor

respo

nding

 gene

rated

 imag

e lik

ely r

epres

ents 

"not-

safe-

for-w

ork"



     

     

  (ns

fw) c

onten

t, or

 `Non

e` if

 safe

ty ch

eckin

g cou

ld no

t be 

perfo

rmed.



    "

""





    i

mages

: Uni

on[Li

st[Li

st[PI

L.Ima

ge.Im

age]]

, np.

ndarr

ay]



    n

sfw_c

onten

t_det

ected

: Opt

ional

[List

[bool

]]







class

 Stab

leDif

fusio

nBEVC

ontro

lNetP

ipeli

ne(St

ableD

iffus

ionCo

ntrol

NetPi

pelin

e):



    d

ef __

init_

_(



     

   se

lf,



     

   va

e: Au

toenc

oderK

L,



     

   te

xt_en

coder

: CLI

PText

Model

,



     

   un

et: U

Net2D

Condi

tionM

odel,



     

   co

ntrol

net,



     

   sc

hedul

er: K

arras

Diffu

sionS

chedu

lers,



     

   to

keniz

er: C

LIPTo

keniz

er,



     

   sa

fety_

check

er: S

table

Diffu

sionS

afety

Check

er = 

None,



     

   fe

ature

_extr

actor

: CLI

PImag

eProc

essor

 = No

ne,



     

   re

quire

s_saf

ety_c

hecke

r: bo

ol = 

False

,



    )

:



     

   su

per()

.__in

it__(



     

     

  vae

,



     

     

  tex

t_enc

oder,



     

     

  tok

enize

r,



     

     

  une

t,



     

     

  con

troln

et,



     

     

  sch

edule

r,



     

     

  saf

ety_c

hecke

r,



     

     

  fea

ture_

extra

ctor,



     

     

  req

uires

_safe

ty_ch

ecker

,



     

   )



     

   as

sert 

safet

y_che

cker 

== No

ne, "

Pleas

e do 

not u

se sa

fety_

check

er."



     

   se

lf.co

ntrol

_imag

e_pro

cesso

r = V

aeIma

gePro

cesso

r(



     

     

  vae

_scal

e_fac

tor=s

elf.v

ae_sc

ale_f

actor

,



     

     

  do_

resiz

e=Fal

se,



     

     

  do_

conve

rt_rg

b=Fal

se,



     

     

  do_

norma

lize=

False

,



     

   )





    d

ef nu

mpy_t

o_pil

_doub

le(se

lf, i

mages

):



     

   ""

"



     

   Co

nvert

 a nu

mpy i

mage 

or a 

batch

 of i

mages

 to a

 PIL 

image

.



     

   We

 need

 to h

andle

 5-di

m inp

uts a

nd re

ture 

2-dim

 list

.



     

   ""

"



     

   im

gs_li

st = 

[]



     

   fo

r img

s in 

image

s:



     

     

  img

s_lis

t.app

end(s

elf.n

umpy_

to_pi

l(img

s))



     

   re

turn 

imgs_

list





    #

 Copi

ed fr

om di

ffuse

rs.pi

pelin

es.st

able_

diffu

sion.

pipel

ine_s

table

_diff

usion

.Stab

leDif

fusio

nPipe

line.

prepa

re_ex

tra_s

tep_k

wargs



    d

ef pr

epare

_extr

a_ste

p_kwa

rgs(s

elf, 

gener

ator,

 eta)

:



     

   # 

prepa

re ex

tra k

wargs

 for 

the s

chedu

ler s

tep, 

since

 not 

all s

chedu

lers 

have 

the s

ame s

ignat

ure



     

   # 

eta (

η) is

 only

 used

 with

 the 

DDIMS

chedu

ler, 

it wi

ll be

 igno

red f

or ot

her s

chedu

lers.



     

   # 

eta c

orres

ponds

 to η

 in D

DIM p

aper:

 http

s://a

rxiv.

org/a

bs/20

10.02

502



     

   # 

and s

hould

 be b

etwee

n [0,

 1]





     

   ac

cepts

_eta 

= "et

a" in

 set(

inspe

ct.si

gnatu

re(se

lf.sc

hedul

er.st

ep).p

arame

ters.

keys(

))



     

   ex

tra_s

tep_k

wargs

 = {}



     

   if

 acce

pts_e

ta:



     

     

  ext

ra_st

ep_kw

args[

"eta"

] = e

ta





     

   # 

check

 if t

he sc

hedul

er ac

cepts

 gene

rator



     

   ac

cepts

_gene

rator

 = "g

enera

tor" 

in se

t(ins

pect.

signa

ture(

self.

sched

uler.

step)

.para

meter

s.key

s())



     

   if

 acce

pts_g

enera

tor:



     

     

  rai

se Ru

ntime

Error

("If 

you f

ixed 

the l

ogic 

for g

enera

tor, 

pleas

e rem

ove t

his. 

Other

wise,

 plea

se us

e oth

er sa

mpler

.")



     

     

  ext

ra_st

ep_kw

args[

"gene

rator

"] = 

gener

ator



     

   re

turn 

extra

_step

_kwar

gs





    d

ef de

code_

laten

ts(se

lf, l

atent

s):



     

   # 

decod

e lat

ents 

with 

5-dim

s



     

   la

tents

 = 1 

/ sel

f.vae

.conf

ig.sc

aling

_fact

or * 

laten

ts





     

   bs

 = le

n(lat

ents)



     

   la

tents

 = re

arran

ge(la

tents

, 'b 

c ...

 -> (

b c) 

...')



     

   im

age =

 self

.vae.

decod

e(lat

ents)

.samp

le



     

   im

age =

 rear

range

(imag

e, '(

b c) 

... -

> b c

 ...'

, b=b

s)





     

   im

age =

 (ima

ge / 

2 + 0

.5).c

lamp(

0, 1)



     

   # 

we al

ways 

cast 

to fl

oat32

 as t

his d

oes n

ot ca

use s

ignif

icant

 over

head 

and i

s com

patib

le wi

th bf

loat1

6



     

   im

age =

 rear

range

(imag

e.cpu

(), '

... c

 h w 

-> ..

. h w

 c').

float

().nu

mpy()



     

   re

turn 

image





    @

torch

.no_g

rad()



    d

ef __

call_

_(



     

   se

lf,



     

   pr

ompt:

 Unio

n[str

, Lis

t[str

]],



     

   im

age: 

torch

.Floa

tTens

or,



     

   ca

mera_

param

: Uni

on[to

rch.T

ensor

, Non

e],



     

   he

ight:

 int,



     

   wi

dth: 

int,



     

   nu

m_inf

erenc

e_ste

ps: i

nt = 

50,



     

   gu

idanc

e_sca

le: f

loat 

= 7.5

,



     

   ne

gativ

e_pro

mpt: 

Optio

nal[U

nion[

str, 

List[

str]]

] = N

one,



     

   nu

m_ima

ges_p

er_pr

ompt:

 Opti

onal[

int] 

= 1,



     

   et

a: fl

oat =

 0.0,



     

   ge

nerat

or: O

ption

al[to

rch.G

enera

tor] 

= Non

e,



     

   la

tents

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   pr

ompt_

embed

s: Op

tiona

l[tor

ch.Fl

oatTe

nsor]

 = No

ne,



     

   ne

gativ

e_pro

mpt_e

mbeds

: Opt

ional

[torc

h.Flo

atTen

sor] 

= Non

e,



     

   ou

tput_

type:

 Opti

onal[

str] 

= "pi

l",



     

   re

turn_

dict:

 bool

 = Tr

ue,



     

   ca

llbac

k: Op

tiona

l[Cal

lable

[[int

, int

, tor

ch.Fl

oatTe

nsor]

, Non

e]] =

 None

,



     

   ca

llbac

k_ste

ps: i

nt = 

1,



     

   cr

oss_a

ttent

ion_k

wargs

: Opt

ional

[Dict

[str,

 Any]

] = N

one,



     

   co

ntrol

net_c

ondit

ionin

g_sca

le: f

loat 

= 1,



     

   gu

ess_m

ode: 

bool 

= Fal

se,



     

   us

e_zer

o_map

_as_u

ncond

ition

al: b

ool =

 Fals

e,



     

   be

v_con

troln

et_kw

args 

= {},



     

   bb

ox_ma

x_len

gth =

 None

,



    )

:



     

   r"

""



     

   Fu

nctio

n inv

oked 

when 

calli

ng th

e pip

eline

 for 

gener

ation

.





     

   Ar

gs:



     

     

  pro

mpt (

`str`

 or `

List[

str]`

, *op

tiona

l*):



     

     

     

 The 

promp

t or 

promp

ts to

 guid

e the

 imag

e gen

erati

on. I

f not

 defi

ned, 

one h

as to

 pass

 `pro

mpt_e

mbeds

`.



     

     

     

 inst

ead.



     

     

  ima

ge (`

torch

.Floa

tTens

or`, 

`PIL.

Image

.Imag

e`, `

List[

torch

.Floa

tTens

or]`,

 `Lis

t[PIL

.Imag

e.Ima

ge]`,



     

     

     

     

`List

[List

[torc

h.Flo

atTen

sor]]

`, or

 `Lis

t[Lis

t[PIL

.Imag

e.Ima

ge]]`

):



     

     

     

 The 

Contr

olNet

 inpu

t con

ditio

n. Co

ntrol

Net u

ses t

his i

nput 

condi

tion 

to ge

nerat

e gui

dance

 to U

net. 

If



     

     

     

 the 

type 

is sp

ecifi

ed as

 `Tor

ch.Fl

oatTe

nsor`

, it 

is pa

ssed 

to Co

ntrol

Net a

s is.

 `PIL

.Imag

e.Ima

ge` c

an



     

     

     

 also

 be a

ccept

ed as

 an i

mage.

 The 

dimen

sions

 of t

he ou

tput 

image

 defa

ults 

to `i

mage`

's di

mensi

ons. 

If



     

     

     

 heig

ht an

d/or 

width

 are 

passe

d, `i

mage`

 is r

esize

d acc

ordin

g to 

them.

 If m

ultip

le Co

ntrol

Nets 

are



     

     

     

 spec

ified

 in i

nit, 

image

s mus

t be 

passe

d as 

a lis

t suc

h tha

t eac

h ele

ment 

of th

e lis

t can

 be c

orrec

tly



     

     

     

 batc

hed f

or in

put t

o a s

ingle

 cont

rolne

t.



     

     

  hei

ght (

`int`

, *op

tiona

l*, d

efaul

ts to

 self

.unet

.conf

ig.sa

mple_

size 

* sel

f.vae

_scal

e_fac

tor):



     

     

     

 The 

heigh

t in 

pixel

s of 

the g

enera

ted i

mage.



     

     

  wid

th (`

int`,

 *opt

ional

*, de

fault

s to 

self.

unet.

confi

g.sam

ple_s

ize *

 self

.vae_

scale

_fact

or):



     

     

     

 The 

width

 in p

ixels

 of t

he ge

nerat

ed im

age.



     

     

  num

_infe

rence

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 5

0):



     

     

     

 The 

numbe

r of 

denoi

sing 

steps

. Mor

e den

oisin

g ste

ps us

ually

 lead

 to a

 high

er qu

ality

 imag

e at 

the



     

     

     

 expe

nse o

f slo

wer i

nfere

nce.



     

     

  gui

dance

_scal

e (`f

loat`

, *op

tiona

l*, d

efaul

ts to

 7.5)

:



     

     

     

 Guid

ance 

scale

 as d

efine

d in 

[Clas

sifie

r-Fre

e Dif

fusio

n Gui

dance

](htt

ps://

arxiv

.org/

abs/2

207.1

2598)

.



     

     

     

 `gui

dance

_scal

e` is

 defi

ned a

s `w`

 of e

quati

on 2.

 of [

Image

n



     

     

     

 Pape

r](ht

tps:/

/arxi

v.org

/pdf/

2205.

11487

.pdf)

. Gui

dance

 scal

e is 

enabl

ed by

 sett

ing `

guida

nce_s

cale 

>



     

     

     

 1`. 

Highe

r gui

dance

 scal

e enc

ourag

es to

 gene

rate 

image

s tha

t are

 clos

ely l

inked

 to t

he te

xt `p

rompt

`,



     

     

     

 usua

lly a

t the

 expe

nse o

f low

er im

age q

ualit

y.



     

     

  neg

ative

_prom

pt (`

str` 

or `L

ist[s

tr]`,

 *opt

ional

*):



     

     

     

 The 

promp

t or 

promp

ts no

t to 

guide

 the 

image

 gene

ratio

n. If

 not 

defin

ed, o

ne ha

s to 

pass



     

     

     

 `neg

ative

_prom

pt_em

beds`

 inst

ead. 

Ignor

ed wh

en no

t usi

ng gu

idanc

e (i.

e., i

gnore

d if 

`guid

ance_

scale

` is



     

     

     

 less

 than

 `1`)

.



     

     

  num

_imag

es_pe

r_pro

mpt (

`int`

, *op

tiona

l*, d

efaul

ts to

 1):



     

     

     

 The 

numbe

r of 

image

s to 

gener

ate p

er pr

ompt.



     

     

  eta

 (`fl

oat`,

 *opt

ional

*, de

fault

s to 

0.0):



     

     

     

 Corr

espon

ds to

 para

meter

 eta 

(η) i

n the

 DDIM

 pape

r: ht

tps:/

/arxi

v.org

/abs/

2010.

02502

. Onl

y app

lies 

to



     

     

     

 [`sc

hedul

ers.D

DIMSc

hedul

er`],

 will

 be i

gnore

d for

 othe

rs.



     

     

  gen

erato

r (`t

orch.

Gener

ator`

 or `

List[

torch

.Gene

rator

]`, *

optio

nal*)

:



     

     

     

 One 

or a 

list 

of [t

orch 

gener

ator(

s)](h

ttps:

//pyt

orch.

org/d

ocs/s

table

/gene

rated

/torc

h.Gen

erato

r.htm

l)



     

     

     

 to m

ake g

enera

tion 

deter

minis

tic.



     

     

  lat

ents 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

noisy

 late

nts, 

sampl

ed fr

om a 

Gauss

ian d

istri

butio

n, to

 be u

sed a

s inp

uts f

or im

age



     

     

     

 gene

ratio

n. Ca

n be 

used 

to tw

eak t

he sa

me ge

nerat

ion w

ith d

iffer

ent p

rompt

s. If

 not 

provi

ded, 

a lat

ents



     

     

     

 tens

or wi

ll ge

 gene

rated

 by s

ampli

ng us

ing t

he su

pplie

d ran

dom `

gener

ator`

.



     

     

  pro

mpt_e

mbeds

 (`to

rch.F

loatT

ensor

`, *o

ption

al*):



     

     

     

 Pre-

gener

ated 

text 

embed

dings

. Can

 be u

sed t

o eas

ily t

weak 

text 

input

s, *e

.g.* 

promp

t wei

ghtin

g. If

 not



     

     

     

 prov

ided,

 text

 embe

dding

s wil

l be 

gener

ated 

from 

`prom

pt` i

nput 

argum

ent.



     

     

  neg

ative

_prom

pt_em

beds 

(`tor

ch.Fl

oatTe

nsor`

, *op

tiona

l*):



     

     

     

 Pre-

gener

ated 

negat

ive t

ext e

mbedd

ings.

 Can 

be us

ed to

 easi

ly tw

eak t

ext i

nputs

, *e.

g.* p

rompt



     

     

     

 weig

hting

. If 

not p

rovid

ed, n

egati

ve_pr

ompt_

embed

s wil

l be 

gener

ated 

from 

`nega

tive_

promp

t` in

put



     

     

     

 argu

ment.



     

     

  out

put_t

ype (

`str`

, *op

tiona

l*, d

efaul

ts to

 `"pi

l"`):



     

     

     

 The 

outpu

t for

mat o

f the

 gene

rate 

image

. Cho

ose b

etwee

n



     

     

     

 [PIL

](htt

ps://

pillo

w.rea

dthed

ocs.i

o/en/

stabl

e/): 

`PIL.

Image

.Imag

e` or

 `np.

array

`.



     

     

  ret

urn_d

ict (

`bool

`, *o

ption

al*, 

defau

lts t

o `Tr

ue`):



     

     

     

 Whet

her o

r not

 to r

eturn

 a [`

~pipe

lines

.stab

le_di

ffusi

on.St

ableD

iffus

ionPi

pelin

eOutp

ut`] 

inste

ad of

 a



     

     

     

 plai

n tup

le.



     

     

  cal

lback

 (`Ca

llabl

e`, *

optio

nal*)

:



     

     

     

 A fu

nctio

n tha

t wil

l be 

calle

d eve

ry `c

allba

ck_st

eps` 

steps

 duri

ng in

feren

ce. T

he fu

nctio

n wil

l be



     

     

     

 call

ed wi

th th

e fol

lowin

g arg

ument

s: `c

allba

ck(st

ep: i

nt, t

imest

ep: i

nt, l

atent

s: to

rch.F

loatT

ensor

)`.



     

     

  cal

lback

_step

s (`i

nt`, 

*opti

onal*

, def

aults

 to 1

):



     

     

     

 The 

frequ

ency 

at wh

ich t

he `c

allba

ck` f

uncti

on wi

ll be

 call

ed. I

f not

 spec

ified

, the

 call

back 

will 

be



     

     

     

 call

ed at

 ever

y ste

p.



     

     

  cro

ss_at

tenti

on_kw

args 

(`dic

t`, *

optio

nal*)

:



     

     

     

 A kw

args 

dicti

onary

 that

 if s

pecif

ied i

s pas

sed a

long 

to th

e `At

tenti

onPro

cesso

r` as

 defi

ned u

nder



     

     

     

 `sel

f.pro

cesso

r` in



     

     

     

 [dif

fuser

s.cro

ss_at

tenti

on](h

ttps:

//git

hub.c

om/hu

gging

face/

diffu

sers/

blob/

main/

src/d

iffus

ers/m

odels

/cros

s_att

entio

n.py)

.



     

     

  con

troln

et_co

nditi

oning

_scal

e (`f

loat`

 or `

List[

float

]`, *

optio

nal*,

 defa

ults 

to 1.

0):



     

     

     

 The 

outpu

ts of

 the 

contr

olnet

 are 

multi

plied

 by `

contr

olnet

_cond

ition

ing_s

cale`

 befo

re th

ey ar

e add

ed



     

     

     

 to t

he re

sidua

l in 

the o

rigin

al un

et. I

f mul

tiple

 Cont

rolNe

ts ar

e spe

cifie

d in 

init,

 you 

can s

et th

e



     

     

     

 corr

espon

ding 

scale

 as a

 list

.



     

     

  gue

ss_mo

de (`

bool`

, *op

tiona

l*, d

efaul

ts to

 `Fal

se`):



     

     

     

 In t

his m

ode, 

the C

ontro

lNet 

encod

er wi

ll tr

y bes

t to 

recog

nize 

the c

onten

t of 

the i

nput 

image

 even

 if



     

     

     

 you 

remov

e all

 prom

pts. 

The `

guida

nce_s

cale`

 betw

een 3

.0 an

d 5.0

 is r

ecomm

ended

.





     

   Ex

ample

s:





     

   Re

turns

:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] o

r `tu

ple`:



     

     

  [`~

pipel

ines.

stabl

e_dif

fusio

n.Sta

bleDi

ffusi

onPip

eline

Outpu

t`] i

f `re

turn_

dict`

 is T

rue, 

other

wise 

a `tu

ple.



     

     

  Whe

n ret

urnin

g a t

uple,

 the 

first

 elem

ent i

s a l

ist w

ith t

he ge

nerat

ed im

ages,

 and 

the s

econd

 elem

ent i

s a



     

     

  lis

t of 

`bool

`s de

notin

g whe

ther 

the c

orres

pondi

ng ge

nerat

ed im

age l

ikely

 repr

esent

s "no

t-saf

e-for

-work

"



     

     

  (ns

fw) c

onten

t, ac

cordi

ng to

 the 

`safe

ty_ch

ecker

`.



     

   ""

"



     

   # 

0. De

fault

 heig

ht an

d wid

th to

 unet



     

   # 

BEV: 

we ca

nnot 

use t

he si

ze of

 imag

e



     

   # 

heigh

t, wi

dth =

 self

._def

ault_

heigh

t_wid

th(he

ight,

 widt

h, No

ne)





     

   # 

1. Ch

eck i

nputs

. Rai

se er

ror i

f not

 corr

ect



     

   # 

we do

 not 

need 

this,

 only

 some

 type

 asse

rtion



     

   # 

self.

check

_inpu

ts(



     

   # 

    p

rompt

,



     

   # 

    i

mage,



     

   # 

    h

eight

,



     

   # 

    w

idth,



     

   # 

    c

allba

ck_st

eps,



     

   # 

    n

egati

ve_pr

ompt,



     

   # 

    p

rompt

_embe

ds,



     

   # 

    n

egati

ve_pr

ompt_

embed

s,



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

   # 

)





     

   # 

2. De

fine 

call 

param

eters



     

   # 

NOTE:

 we g

et ba

tch_s

ize f

irst 

from 

promp

t, th

en al

ign w

ith i

t.



     

   if

 prom

pt is

 not 

None 

and i

sinst

ance(

promp

t, st

r):



     

     

  bat

ch_si

ze = 

1



     

   el

if pr

ompt 

is no

t Non

e and

 isin

stanc

e(pro

mpt, 

list)

:



     

     

  bat

ch_si

ze = 

len(p

rompt

)



     

   el

se:



     

     

  bat

ch_si

ze = 

promp

t_emb

eds.s

hape[

0]





     

   de

vice 

= sel

f._ex

ecuti

on_de

vice



     

   # 

here 

`guid

ance_

scale

` is 

defin

ed an

alog 

to th

e gui

dance

 weig

ht `w

` of 

equat

ion (

2)



     

   # 

of th

e Ima

gen p

aper:

 http

s://a

rxiv.

org/p

df/22

05.11

487.p

df . 

`guid

ance_

scale

 = 1`



     

   # 

corre

spond

s to 

doing

 no c

lassi

fier 

free 

guida

nce.



     

   do

_clas

sifie

r_fre

e_gui

dance

 = gu

idanc

e_sca

le > 

1.0





     

   ##

# BEV

, che

ck ca

mera_

param

 ###



     

   if

 came

ra_pa

ram i

s Non

e:



     

     

  # u

se un

cond_

cam a

nd di

sable

 clas

sifie

r fre

e gui

dance



     

     

  N_c

am = 

6  # 

TODO:

 hard

-code

d



     

     

  cam

era_p

aram 

= sel

f.con

troln

et.un

cond_

cam_p

aram(

(batc

h_siz

e, N_

cam))



     

     

  do_

class

ifier

_free

_guid

ance 

= Fal

se



     

   ##

# don

e ###





     

   # 

if is

insta

nce(s

elf.c

ontro

lnet,

 Mult

iCont

rolNe

tMode

l) an

d isi

nstan

ce(co

ntrol

net_c

ondit

ionin

g_sca

le, f

loat)

:



     

   # 

    c

ontro

lnet_

condi

tioni

ng_sc

ale =

 [con

troln

et_co

nditi

oning

_scal

e] * 

len(s

elf.c

ontro

lnet.

nets)





     

   # 

3. En

code 

input

 prom

pt



     

   # 

NOTE:

 here

 they

 use 

paddi

ng to

 77, 

is th

is ne

cessa

ry?



     

   pr

ompt_

embed

s = s

elf._

encod

e_pro

mpt(



     

     

  pro

mpt,



     

     

  dev

ice,



     

     

  num

_imag

es_pe

r_pro

mpt,



     

     

  do_

class

ifier

_free

_guid

ance,



     

     

  neg

ative

_prom

pt,



     

     

  pro

mpt_e

mbeds

=prom

pt_em

beds,



     

     

  neg

ative

_prom

pt_em

beds=

negat

ive_p

rompt

_embe

ds,



     

   ) 

 # (2

 * b,

 77 +

 1, 7

68)





     

   # 

4. Pr

epare

 imag

e



     

   # 

NOTE:

 if i

mage 

is no

t ten

sor, 

there

 will

 be s

evera

l pro

cess.



     

   as

sert 

not s

elf.c

ontro

l_ima

ge_pr

ocess

or.co

nfig.

do_no

rmali

ze, "

Your 

contr

olnet

 shou

ld no

t nor

maliz

e the

 cont

rol i

mage.

"



     

   im

age =

 self

.prep

are_i

mage(



     

     

  ima

ge=im

age,



     

     

  wid

th=wi

dth,



     

     

  hei

ght=h

eight

,



     

     

  bat

ch_si

ze=ba

tch_s

ize *

 num_

image

s_per

_prom

pt,



     

     

  num

_imag

es_pe

r_pro

mpt=n

um_im

ages_

per_p

rompt

,



     

     

  dev

ice=d

evice

,



     

     

  dty

pe=se

lf.co

ntrol

net.d

type,



     

     

  do_

class

ifier

_free

_guid

ance=

do_cl

assif

ier_f

ree_g

uidan

ce,



     

     

  gue

ss_mo

de=gu

ess_m

ode,



     

   ) 

 # (2

 * b,

 c_26

, 200

, 200

)



     

   if

 use_

zero_

map_a

s_unc

ondit

ional

 and 

do_cl

assif

ier_f

ree_g

uidan

ce:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  _im

ages[

0] = 

torch

.zero

s_lik

e(_im

ages[

0])



     

     

  ima

ge = 

torch

.cat(

_imag

es)





     

   # 

5. Pr

epare

 time

steps



     

   se

lf.sc

hedul

er.se

t_tim

estep

s(num

_infe

rence

_step

s, de

vice=

devic

e)



     

   ti

meste

ps = 

self.

sched

uler.

times

teps





     

   # 

6. Pr

epare

 late

nt va

riabl

es



     

   nu

m_cha

nnels

_late

nts =

 self

.unet

.conf

ig.in

_chan

nels



     

   la

tents

 = se

lf.pr

epare

_late

nts(



     

     

  bat

ch_si

ze * 

num_i

mages

_per_

promp

t,



     

     

  num

_chan

nels_

laten

ts,



     

     

  hei

ght,



     

     

  wid

th,



     

     

  pro

mpt_e

mbeds

.dtyp

e,



     

     

  dev

ice,



     

     

  gen

erato

r,



     

     

  lat

ents,

  # w

ill u

se if

 not 

None,

 othe

rwise

 will

 gene

rate



     

   ) 

 # (b

, c, 

h/8, 

w/8) 

-> (b

s, 4,

 28, 

50)





     

   # 

7. Pr

epare

 extr

a ste

p kwa

rgs.



     

   ex

tra_s

tep_k

wargs

 = se

lf.pr

epare

_extr

a_ste

p_kwa

rgs(g

enera

tor, 

eta)





     

   ##

#### 

BEV: 

here 

we re

const

ruct 

each 

input

 form

at ##

####



     

   as

sert 

camer

a_par

am.sh

ape[0

] == 

batch

_size

, \



     

     

  f"E

xcept

 {bat

ch_si

ze} c

amera

 para

ms, b

ut yo

u hav

e bs=

{len(

camer

a_par

am)}"



     

   N_

cam =

 came

ra_pa

ram.s

hape[

1]



     

   la

tents

 = to

rch.s

tack(

[late

nts] 

* N_c

am, d

im=1)

  # b

s, 6,

 4, 2

8, 50



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ca

mera_

param

 = ca

mera_

param

.to(s

elf.d

evice

)



     

   if

 do_c

lassi

fier_

free_

guida

nce a

nd no

t gue

ss_mo

de:



     

     

  # u

ncond

 in t

he fr

ont, 

cond 

in th

e tai

l



     

     

  _im

ages 

= lis

t(tor

ch.ch

unk(i

mage,

 2))



     

     

  kwa

rgs_w

ith_u

ncond

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_kw

args(



     

     

     

 came

ra_pa

ram=c

amera

_para

m,



     

     

     

 imag

e=_im

ages[

0],  

# 0 i

s for

 unco

nditi

onal



     

     

     

 max_

len=b

box_m

ax_le

ngth,



     

     

     

 **be

v_con

troln

et_kw

args,



     

     

  )



     

     

  kwa

rgs_w

ith_u

ncond

.pop(

"max_

len",

 None

)  # 

some 

do no

t tak

e thi

s.



     

     

  cam

era_p

aram 

= kwa

rgs_w

ith_u

ncond

.pop(

"came

ra_pa

ram")



     

     

  _im

ages[

0] = 

kwarg

s_wit

h_unc

ond.p

op("i

mage"

)



     

     

  ima

ge = 

torch

.cat(

_imag

es)



     

     

  bev

_cont

rolne

t_kwa

rgs =

 move

_to(k

wargs

_with

_unco

nd, s

elf.d

evice

)



     

   ##

#### 

BEV e

nd ##

####





     

   # 

8. De

noisi

ng lo

op



     

   nu

m_war

mup_s

teps 

= len

(time

steps

) - n

um_in

feren

ce_st

eps *

 self

.sche

duler

.orde

r



     

   wi

th se

lf.pr

ogres

s_bar

(tota

l=num

_infe

rence

_step

s) as

 prog

ress_

bar:



     

     

  for

 i, t

 in e

numer

ate(t

imest

eps):



     

     

     

 # ex

pand 

the l

atent

s if 

we ar

e doi

ng cl

assif

ier f

ree g

uidan

ce



     

     

     

 # bs

*2, 6

, 4, 

28, 5

0



     

     

     

 late

nt_mo

del_i

nput 

= (



     

     

     

     

torch

.cat(

[late

nts] 

* 2) 

if do

_clas

sifie

r_fre

e_gui

dance

 else

 late

nts



     

     

     

 )



     

     

     

 late

nt_mo

del_i

nput 

= sel

f.sch

edule

r.sca

le_mo

del_i

nput(



     

     

     

     

laten

t_mod

el_in

put, 

t



     

     

     

 )





     

     

     

 # co

ntrol

net(s

) inf

erenc

e



     

     

     

 cont

rolne

t_t =

 t.un

squee

ze(0)



     

     

     

 # gu

ess_m

ode &

 clas

sifie

r_fre

e_gui

dance

 -> o

nly g

uidan

ce us

e con

troln

et



     

     

     

 # no

t gue

ss_mo

de & 

class

ifier

_free

_guid

ance 

-> al

l use

 cont

rolne

t



     

     

     

 # gu

ess_m

ode -

> nor

mal i

nput,

 take

 effe

ct in

 cont

rolne

t



     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

er Co

ntrol

Net o

nly f

or th

e con

ditio

nal b

atch.



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ents



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds

.chun

k(2)[

1]



     

     

     

 else

:



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput 

= lat

ent_m

odel_

input



     

     

     

     

contr

olnet

_prom

pt_em

beds 

= pro

mpt_e

mbeds



     

     

     

 cont

rolne

t_t =

 cont

rolne

t_t.r

epeat

(len(

contr

olnet

_late

nt_mo

del_i

nput)

)





     

     

     

 # fm

t: of

f



     

     

     

 down

_bloc

k_res

_samp

les, 

mid_b

lock_

res_s

ample

, \



     

     

     

 enco

der_h

idden

_stat

es_wi

th_ca

m = s

elf.c

ontro

lnet(



     

     

     

     

contr

olnet

_late

nt_mo

del_i

nput,



     

     

     

     

contr

olnet

_t,



     

     

     

     

camer

a_par

am,  

# for

 BEV



     

     

     

     

encod

er_hi

dden_

state

s=con

troln

et_pr

ompt_

embed

s,



     

     

     

     

contr

olnet

_cond

=imag

e,



     

     

     

     

condi

tioni

ng_sc

ale=c

ontro

lnet_

condi

tioni

ng_sc

ale,



     

     

     

     

guess

_mode

=gues

s_mod

e,



     

     

     

     

retur

n_dic

t=Fal

se,



     

     

     

     

**bev

_cont

rolne

t_kwa

rgs, 

# for

 BEV



     

     

     

 )



     

     

     

 # fm

t: on





     

     

     

 if g

uess_

mode 

and d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# Inf

ered 

Contr

olNet

 only

 for 

the c

ondit

ional

 batc

h.



     

     

     

     

# To 

apply

 the 

outpu

t of 

Contr

olNet

 to b

oth t

he un

condi

tiona

l and

 cond

ition

al ba

tches

,



     

     

     

     

# add

 0 to

 the 

uncon

ditio

nal b

atch 

to ke

ep it

 unch

anged

.



     

     

     

     

down_

block

_res_

sampl

es = 

[



     

     

     

     

    t

orch.

cat([

torch

.zero

s_lik

e(d),

 d])



     

     

     

     

    f

or d 

in do

wn_bl

ock_r

es_sa

mples



     

     

     

     

]



     

     

     

     

mid_b

lock_

res_s

ample

 = to

rch.c

at(



     

     

     

     

    [

torch

.zero

s_lik

e(mid

_bloc

k_res

_samp

le), 

mid_b

lock_

res_s

ample

]



     

     

     

     

)



     

     

     

     

# add

 unco

nd en

coder

_hidd

en_st

ates_

with_

cam h

ere



     

     

     

     

encod

er_hi

dden_

state

s_wit

h_cam

 = se

lf.co

ntrol

net.a

dd_un

cond_

to_em

b(



     

     

     

     

    p

rompt

_embe

ds.ch

unk(2

)[0],

 N_ca

m,



     

     

     

     

    e

ncode

r_hid

den_s

tates

_with

_cam,



     

     

     

     

)





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # St

ratin

g fro

m her

e, we

 use 

4-dim

 data

.



     

     

     

 # en

coder

_hidd

en_st

ates_

with_

cam: 

(2b x

 N), 

78, 7

68



     

     

     

 # la

tent_

model

_inpu

t: 2b

, N, 

4, 28

, 50 

-> 2b

 x N,

 4, 2

8, 50



     

     

     

 late

nt_mo

del_i

nput 

= rea

rrang

e(



     

     

     

     

laten

t_mod

el_in

put, 

'b n 

... -

> (b 

n) ..

.')



     

     

     

 late

nts =

 rear

range

(late

nts, 

'b n 

... -

> (b 

n) ..

.')





     

     

     

 # pr

edict

 the 

noise

 resi

dual:

 2bxN

, 4, 

28, 5

0



     

     

     

 addi

tiona

l_par

am = 

{}



     

     

     

 nois

e_pre

d = s

elf.u

net(



     

     

     

     

laten

t_mod

el_in

put, 

 # ma

y wit

h unc

ondit

ional



     

     

     

     

t,



     

     

     

     

encod

er_hi

dden_

state

s=enc

oder_

hidde

n_sta

tes_w

ith_c

am,



     

     

     

     

**add

ition

al_pa

ram, 

 # if

 use 

origi

nal u

net, 

it ca

nnot 

take 

kwarg

s



     

     

     

     

cross

_atte

ntion

_kwar

gs=cr

oss_a

ttent

ion_k

wargs

,



     

     

     

     

down_

block

_addi

tiona

l_res

idual

s=dow

n_blo

ck_re

s_sam

ples,



     

     

     

     

mid_b

lock_

addit

ional

_resi

dual=

mid_b

lock_

res_s

ample

,



     

     

     

 ).sa

mple





     

     

     

 # pe

rform

 guid

ance



     

     

     

 if d

o_cla

ssifi

er_fr

ee_gu

idanc

e:



     

     

     

     

# for

 each

: bxN

, 4, 

28, 5

0



     

     

     

     

noise

_pred

_unco

nd, n

oise_

pred_

text 

= noi

se_pr

ed.ch

unk(2

)



     

     

     

     

noise

_pred

 = no

ise_p

red_u

ncond

 + gu

idanc

e_sca

le * 

(



     

     

     

     

    n

oise_

pred_

text 

- noi

se_pr

ed_un

cond



     

     

     

     

)





     

     

     

 # co

mpute

 the 

previ

ous n

oisy 

sampl

e x_t

 -> x

_t-1



     

     

     

 # NO

TE: i

s the

 sche

duler

 use 

rando

mness

, ple

ase h

andle

 the 

logic



     

     

     

 # fo

r gen

erato

r.



     

     

     

 late

nts =

 self

.sche

duler

.step

(



     

     

     

     

noise

_pred

, t, 

laten

ts, *

*extr

a_ste

p_kwa

rgs



     

     

     

 ).pr

ev_sa

mple





     

     

     

 # ==

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

=====

====



     

     

     

 # no

w we 

add d

imens

ion b

ack, 

use 5

-dim 

data.



     

     

     

 # NO

TE: o

nly `

laten

ts` i

s upd

ated 

throu

gh th

e loo

p



     

     

     

 late

nts =

 rear

range

(late

nts, 

'(b n

) ...

 -> b

 n ..

.', n

=N_ca

m)





     

     

     

 # ca

ll th

e cal

lback

, if 

provi

ded



     

     

     

 if i

 == l

en(ti

meste

ps) -

 1 or

 (



     

     

     

     

(i + 

1) > 

num_w

armup

_step

s and

 (i +

 1) %

 self

.sche

duler

.orde

r == 

0



     

     

     

 ):



     

     

     

     

progr

ess_b

ar.up

date(

)



     

     

     

     

if ca

llbac

k is 

not N

one a

nd i 

% cal

lback

_step

s == 

0:



     

     

     

     

    c

allba

ck(i,

 t, l

atent

s)





     

   ##

#### 

BEV: 

here 

rebui

ld th

e sha

pes b

ack. 

post-

proce

ss st

ill a

ssume



     

   # 

laten

ts, n

o nee

d for

 b, n

, 4, 

28, 5

0



     

   # 

promp

t_emb

eds, 

no ne

ed fo

r b, 

len, 

768



     

   # 

image

, no 

need 

for b

, c, 

200, 

200



     

   ##

### B

EV en

d





     

   # 

If we

 do s

equen

tial 

model

 offl

oadin

g, le

t's o

ffloa

d une

t and

 cont

rolne

t



     

   # 

manua

lly f

or ma

x mem

ory s

aving

s



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.une

t.to(

"cpu"

)



     

     

  sel

f.con

troln

et.to

("cpu

")



     

     

  tor

ch.cu

da.em

pty_c

ache(

)





     

   if

 outp

ut_ty

pe ==

 "lat

ent":



     

     

  ima

ge = 

laten

ts



     

     

  has

_nsfw

_conc

ept =

 None



     

   el

if ou

tput_

type 

== "p

il":



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

     

  # 1

0. Co

nvert

 to P

IL



     

     

  ima

ge = 

self.

numpy

_to_p

il_do

uble(

image

)



     

   el

se:



     

     

  # 8

. Pos

t-pro

cessi

ng



     

     

  ima

ge = 

self.

decod

e_lat

ents(

laten

ts)





     

     

  # 9

. Run

 safe

ty ch

ecker



     

     

  ima

ge, h

as_ns

fw_co

ncept

 = se

lf.ru

n_saf

ety_c

hecke

r(



     

     

     

 imag

e, de

vice,

 prom

pt_em

beds.

dtype



     

     

  )





     

   # 

Offlo

ad la

st mo

del t

o CPU



     

   if

 hasa

ttr(s

elf, 

"fina

l_off

load_

hook"

) and

 self

.fina

l_off

load_

hook 

is no

t Non

e:



     

     

  sel

f.fin

al_of

fload

_hook

.offl

oad()





     

   if

 not 

retur

n_dic

t:



     

     

  ret

urn (

image

, has

_nsfw

_conc

ept)





     

   re

turn 

BEVSt

ableD

iffus

ionPi

pelin

eOutp

ut(



     

     

  ima

ges=i

mage,

 nsfw

_cont

ent_d

etect

ed=ha

s_nsf

w_con

cept



     

   )



