清华大学985名

优教材立项

资劣

数据结

极（C++语言版）

第

3 版

邓 俊 辉

清

华大学出版

社

2013年9月·北京

丛书序

“清华

大学计算机

系列教材”已

经出版发行

了30余种，包括

计算机科学

与技术专业

的基础

数学

、专业技术基

础和专业等

课程的教材

，覆盖了计算

机科学与技

术专业本科

生和研究生

的主要

教学

内容。这是一

批至今发行

数量很大并

赢得广大读

者赞誉的书

籍，是近年来

出版的大学

计算机

专业

教材中影响

比较大的一

批精品。

本系

列教材的作

者都是我熟

悉的教授与

同事，他们长

期在第一线

担任相关课

程的教学工

作，

是一批很

受本科生和

研究生欢迎

的任课教师

。编写高质量

的计算机专

业本科生（和

研究生）教材

，

不仅需要作

者具备丰富

的教学经验

和科研实践

，还需要对相

关领域科技

发展前沿的

正确把握和

了

解。正因为

本系列教材

的作者们具

备了这些条

件，才有了这

批高质量优

秀教材的产

生。可以说，

教

材是他们长

期辛勤工作

的结晶。本系

列教材出版

发行以来，从

其发行的数

量、读者的反

映、已

经获得

的国家级与

省部级的奖

励，以及在各

个高等院校

教学中所发

挥的作用上

，都可以看出

本系

列教材

所产生的社

会影响与效

益。

计算机学

科发展异常

迅速，内容更

新很快。作为

教材，一方面

要反映本领

域基础性、普

遍性

的知识

，保持内容的

相对稳定性

；另一方面，又

需要跟踪科

技的发展，及

时地调整和

更新内容。

本

系列教材都

能按照自身

的需要及时

地做到这一

点。如王爱英

教授等编著

的《计算机组

成与结

构》、戴

梅萼教授等

编著的《微型

计算机技术

及应用》都已

经出版了第

四版，严蔚敏

教授的《数

据

结构》也出版

了三版，使教

材既保持了

稳定性，又达

到了先进性

的要求。

本系

列教材内容

丰富，体系结

构严谨，概念

清晰，易学易

懂，符合学生

的认知规律

，适合于

教学

与自学，深受

广大读者的

欢迎。系列教

材中多数配

有丰富的习

题集、习题解

答、上机及实

验

指导和电

子教案，便于

学生理论联

系实际地学

习相关课程

。

随着我国进

一步的开放

，我们需要扩

大国际交流

，加强学习国

外的先进经

验。在大学教

材建

设上，我

们也应该注

意学习和引

进国外的先

进教材。但是

，“清华大学计

算机系列教

材”的出版

发

行实践以及

它所取得的

效果告诉我

们，在当前形

势下，编写符

合国情的具

有自主版权

的高质量

教

材仍具有重

大意义和价

值。它与国外

原版教材不

仅不矛盾，而

且是相辅相

成的。本系列

教材的

出版

还表明，针对

某一学科培

养的要求，在

教育部等上

级部门的指

导下，有计划

地组织任课

教师

编写系

列教材，还能

促进对该学

科科学、合理

的教学体系

和内容的研

究。

我希望今

后有更多、更

好的我国优

秀教材出版

。

清华大学计

算机系教授

中国科学院

院士

c

序

为适

应快速发展

的形势，计算

机专业基础

课的教学必

须走内涵发

展的道路，扎

实的理论基

础、

计算思维

能力和科学

的方法论是

支撑该学科

从业人员进

行理性思维

和理性实践

的重要基础

。“程

序设计基

础”、“面向对象

技术”、“离散数

学”以及“数据

结构”等相关

课程，构成了

清华大

学计

算机系专业

基础课程体

系中的一条

重要脉络。近

年来为强化

学生在计算

思维和实践

能力方面

的

训练力度，课

程组通过研

究，探索和实

践，着力对该

课程系列的

教学目标、内

容、方法和各

门

课的分工

，以及如何衔

接等进行科

学而系统的

梳理，进一步

明确了教学

改革的方向

。在这样的背

景下，由邓俊

辉撰写的《数

据结构（C++语言

版）》正式出版

了。

为了体现

教材的先进

性，作者研读

并参考了计

算学科教学

大纲（ACM/IEEE Computing 

Curricula），结合该

课程教学的

国际发展趋

势和对计算

机人才培养

的实际需求

，对相关知识

点

做了精心

取舍，从整体

考虑加以编

排，据难易程

度对各章节

内容重新分

类，给出了具

体的教学计

划方案。

为了

不失系统性

，作者依据多

年的教学积

累，对各种数

据结构及其

算法，按照分

层的思想精

心进行归纳

和整理，并从

数据访问方

式、数据逻辑

结构、算法构

成模式等多

个角度，理出

线索加

以贯

穿，使之构成

一个整体，使

学生在学习

数据结构众

多知识点的

同时，获得对

这门学问相

关知

识结构

的系统性和

全局性的认

识。

计算机学

科主张“抽象

第一”，这没有

错，但弄不好

会吓倒或难

倒学生。本书

从具体实例

入

手,运用“转

换-化简”、“对比

-类比”等手法

，借助大量插

图和表格，图

文并茂地展

示数据结

构

组成及其算

法运转的内

在过程与规

律，用形象思

维帮助阐释

抽象过程，给

出几乎所有

算法的具

体

实现，并通过

多种版本做

剖析和对比

，引领读者通

过学习提升

抽象思维能

力。

计算机学

科实践性极

强，不动手是

学不会的。为

了强化实践

，本书除了每

章都布置人

人必做

的习

题和思考题

外，还有不少

于授课学时

的上机编程

要求，旨在培

养学生理性

思维和理性

实践的

动脑

动手能力。

《中

国计算机科

学与技术学

科教程2002》曾批

评国内有关

程序设计类

的课，一是淡

化算法，

二是

“一开始就扎

进程序设计

的语言细节

中去”。本书十

分重视从算

法的高度来

讲述数据结

构与

算法的

相互依存关

系，在书的开

篇就用极其

精彩的例子

讲清了算法

效率和算法

复杂度度量

的基本

概念

和方法，这就

给全书紧密

结合算法来

讲数据结构

打下了很好

的基础。

这本

书是精心策

划和撰写的

，结构严整，脉

络清晰，行文

流畅，可读性

强。全书教学

目标明

确，内

容丰富，基本

概念和基本

方法的阐述

深入浅出，最

大的特点是

将算法知识

、数据结构和

编

程实践有

机地融为一

体。我以为，引

导学生学好

本书，对于奠

定扎实的学

科基础，提高

计算思维

能

力能够起到

良好的作用

。

清华大学计

算机系教授

2011年9月

d

e

第3版说

明

在第2版的

基础上，本书

第3版推出了

配套的《习题

解析》，故在体

例上也做了

相应的调整

，

主要包括以

下方面：

 原各

章所附习题

，均统一摘出

并汇编为《习

题解析》；除了

部分实践型

和研究型习

题，大部

分习

题均提供了

详尽的分析

和解答。

 删除

了少量习题

，同时也补充

了若干。大题

的总数，已增

至292道；因多数

习题都是逐

层递

进式的

，小题的总数

已超过500道。



关

于伸展树性

能分摊分析

的原8.1.4小节，作

为习题转入

《习题解析》。

 图

灵机模型、RAM模

型等基本概

念，以及（线性

）归约、封底估

算及基本技

巧，也结合对

应

的习题予

以介绍。

同时

，结合读者反

馈以及新一

轮教学实践

效果，也在以

下方面做了

相应修订：

 1.4节

补充了对记

忆策略与动

态规划策略

的介绍，并通

过实例展示

二者的联系

与区别。



鉴于

前四章已经

充分地展示

了相关技巧

，后续Bintree和Dictionary等结

构不再过于

严格

地封装

，使读者更好

地将注意力

集中于这些

结构的机理

本身。

 通过多

重继承，统一

了ComplHeap、LeftHeap、ListHeap等结构的

实现方式，使

之封装更

紧

凑、代码更简

洁。

 精 简

了 Vector<T>::mergesort() 、 GraphMatrix::insert()

、 Splay::splay() 、

RedBlack::solveDoubleRed()、trivialMedian()等

算法的实现

。

 关于函数调

用栈、栈与递

归、Huffman编码算法

等各节的叙

述与讲解，也

尽可能地做

了精简。

 统一

了“环路”、“众数

”、“最左/右侧通

路”、“波峰集”、“输

入/输出敏感

”等概念。

 严格

了“完全二叉

树”等概念以

及“黑高度”等

指标的定义

。

 参照BFS和DFS的实

现方式改进

PFS框架，使之支

持多个连通

域（或可达域

）。

 借助几何分

布等概率模

型，简化对跳

转表、散列表

的平均性能

分析。

 插图、表

格、代码等均

有大幅增加

，关键词索引

项进一步细

化。

 增加了若

干重要的参

考文献。

 修正

了原书及代

码中的若干

错误，详细对

比请见勘误

表。

最后，鉴于

第3版采用双

色印刷方式

，故在版面及

样式等方面

也做了相应

的调整。

f

第2版

说明

本书的

初稿完成于

2009年冬季，随后

在清华大学

经过了三个

学期共四个

课堂的试用

，根据

各方的

反馈意见做

过调整补充

之后，第1版于

2011年夏季由清

华大学出版

社正式出版

发行。此后，

又

在清华大学

经过两个学

期共三个课

堂的教学实

践，并汇总读

者的反馈进

一步修订完

善之后，第

2版

终于2012年夏季

出版发行，也

就是目前读

者所看到的

这个版本。

第

2版继承并强

化了此前版

本的叙述风

格，基本保留

了总体的体

例结构，同时

在针对性、简

洁性、实用性

和拓展性等

方面，也做了

大量的修改

、删节与扩充

。与此前的版

本相比较，主

要的

变化包

括以下几个

方面：

 针对多

种数据结构

的算法实现

及其性能分

析，精简了行

文叙述与代

码实现，比如

有序向量的

查找、树和图

的遍历、Huffman编码

、平衡二叉搜

索树的重平

衡、二叉堆的

调整等。



更换

并补充了大

量的实例和

插图，比如向

量、词典、关联

数组、高级平

衡二叉搜索

树和优先

级

队列等数据

结构，以及表

达式求值、KMP、BM、平

衡二叉搜索

树的重平衡

、字符串散列

、

快速排序、中

位数及众数

等算法的原

理及过程等

等，插图增至

260多组。



重写了

多个章节的

总结部分，比

如针对各类

查找算法、串

匹配算法，就

其性能特点

均做了统

一

的归纳与梳

理，指明其中

的关键因素

以及不同的

适用范围。

 进

一步规范和

统一了几个

基本概念的

定义及其表

述方式，使得

各章节之间

的相互引述

更趋一

致，比

如栈混洗、真

二叉树、完全

二叉树、满树

、闭散列策略

等概念的定

义，以及遍历

序列、

红黑树

不同类型节

点等概念的

图解示意方

式。

 细化了针

对一些关键

知识点的讲

解，比如第1章

的渐进复杂

度层次和伪

复杂度、第8章

中B-

树及kd-树的

引入动机、第

11章中BM算法好

后缀策略中

的gs[]表构造算

法等。

 添加了

大量的习题

，总量已超过

280道。在帮助读

者梳理主要

知识点、加深

对讲解内容

理解

的同时

，还从以下方

面为他们的

进一步拓展

，提供了必要

的线索：插入

排序算法性

能与逆序

对

的关系、选择

排序算法性

能与循环节

的关系、插值

查找、指数查

找、马鞍查找

、CBA式排

序算法

平均性能的

下界、栈混洗

甄别、栈堆、队

堆、算术表达

式的组合搜

索、键树、关联

矩

阵、Prim算法与

Krusal算法的正确

性、欧氏最小

支撑树、并查

集、计数排序

、四叉树、八

叉

树、范围树、优

先级搜索树

、树堆、AVL树节点

删除算法的

平均性能、AVL树

的合并与分

裂、堆节点插

入算法的平

均性能、支持

重复元素的

二叉搜索树

、双向平方试

探、轴点构造

算

法版本C、希

尔排序算法

的正确性，等

等。

 提供了一

批相关的参

考文献，包括

经典的教材

专著20余册、拓

展的学术论

文30余篇。



修正

了多处排版

问题及若干

实质错误。请

此前版本的

读者下载勘

误表并做相

应更正，同时

感

谢我的读

者、学生和同

行，他们的意

见与建议是

本教材不断

完善的保证

。

第1版前言

背

景

伴随着计

算学科（Computing Discipline）近年

来的迅猛发

展，相关专业

方向不断细

化和

分化，相

应地在计算

机教育方面

，人才培养的

定位与目标

呈现明显的

多样化趋势

，在知识结构

与

专业素养

方面对人才

的要求也在

广度与深度

上拓展到空

前的水平。以

最新版计算

学科教学大

纲

（ACM/IEEE Computing Curricula，以下简称

CC大纲）为例，2001年

制定的CC2001因只

能覆

盖狭义

的计算机科

学方向而更

多地被称作

CS2001。所幸的是，CC2001的

意义不仅在

于针对计算

机科学方向

的本科教学

提出了详细

的指导意见

，更在于构建

了一个开放

的CC2001框架（CC2001

Model）。按照

这一规划，首

先应该顺应

计算学科总

体发展的大

势，沿着计算

机科学（CS）、计

算

机工程（CE）、信息

系统（IS）、信息技

术（IT）和软件工

程（SE）以及更多

潜在的新学

科

方向，以分

卷的形式制

订相应的教

学大纲计划

，同时以综述

报告的形式

概括统领；另

外，不宜仍

拘

泥于十年的

周期，而应更

为频繁地调

整和更新大

纲，以及时反

映计算领域

研究的最新

进展，满

足应

用领域对人

才的现实需

求。

饶有意味

的是，无论从

此后发表的

综述报告还

是各分卷报

告都可看出

，作为计算学

科知识结

构

的核心与技

术体系的基

石，数据结构

与算法的基

础性地位不

仅没有动摇

，反而得到进

一步的强

化

和突出，依然

是计算学科

研究开发人

员的必备素

养，以及相关

应用领域专

业技术人员

的看家本

领

。以CC大纲的综

述报告（Computing Curricula 2005 -

The Overview Report）为例

，

在针对以上

五个专业方

向本科学位

所归纳的共

同要求中，数

据结构与算

法作为程序

设计概念与

技

能的核心

，紧接在数学

基础之后列

第二位。这方

面的要求可

进一步细分

为五个层次

：对数据结构

与算法核心

地位的充分

理解与认同

，从软件视角

对处理器、存

储器及显示

器等硬件资

源的透彻理

解，通过编程

以软件方式

实现数据结

构与算法的

能力，基于恰

当的数据结

构与算法设

计并实现大

型结构化组

件及其之间

通讯接口的

能力，运用软

件工程的原

理与技术确

保软件鲁棒

性、可靠性及

其面向特定

目标受众的

针对性的能

力。

自20世纪末

起，我有幸参

与和承担清

华大学计算

机系以及面

向全校“数据

结构”课程的

教

学工作，在

学习和吸收

前辈们丰富

而宝贵教学

经验的同时

，通过悉心体

会与点滴积

累，逐步摸索

和总结出一

套较为完整

的教学方法

。作为数据结

构与算法一

线教学工作

者中的一员

，我与众多的

同行一样，在

为此类课程

的重要性不

断提升而欢

欣鼓舞的同

时，更因其对

计算学科人

才培养决定

性作用的与

日俱增而倍

感责任重大

。尽管多年来

持续推进的

教学改革已

经取得巨大

的进展，但面

对新的学科

发展形势和

社会发展需

求，为从根本

上提高我国

计算机理论

及应用人才

的培养质量

，

我们的教学

理念、教学内

容与教学方

法仍然有待

于进一步突

破。

与学校“高

素质、高层次

、多样化、创造

性”人才培养

总体目标相

呼应，我所在

的清华大学

计算机系长

期致力于培

养“面向基础

或应用基础

的科学技术

问题，具备知

识创新、技术

创新或集

成

创新能力的

研究型人才

”。沿着这个大

方向，近年来

我与同事们

从讲授、研讨

、作业、实践、

考

核和教材等

方面入手，在

系统归纳已

有教学资源

和成果的基

础上，着力推

进数据结构

的课程建

设

与改革。其中

，教材既为所

授知识提供

了物化的载

体，也为传授

过程指明了

清晰的脉络

，更为

g

h

教师与

学生之间的

交流建立了

统一的平台

，其重要性不

言而喻。继2006年

出版《数据结

构与算

法（Java语

言描述）》之后

，本教材的出

版也是作者

对自己数据

结构与算法

教学工作的

又一次

系统

总结与深入

探索。

原则

在

读者群体定

位、体例结构

编排以及环

节内容取舍

等方面，全书

尽力贯彻以

下原则。



兼顾

基础不同、目

标不同的多

样化读者群

体

全书12章按

四大部分组

织，既相对独

立亦彼此呼

应，难度较大

的章节以星

号标注，教员

与

学生可视

具体情况灵

活取舍。其中

第1章绪论旨

在尽快地将

背景各异的

读者引导至

同一起点，为

此将系统地

引入计算与

算法的一般

性概念，确立

时空复杂度

的度量标准

，并以递归为

例介绍算法

设计的一般

模式；第2至7章

为基础部分

，涵盖序列、树

、图、初级搜索

树等基本数

据结构及其

算

法的实现

方法及性能

分析，这也是

多数读者在

实际工作中

最常涉及的

内容，属于研

读的重点；第

8至10章为进阶

部分，介绍高

级搜索树、词

典和优先级

队列等高级

数据结构，这

部分内容对

更加

注重计

算效率的读

者将很有帮

助；最后两章

分别以串匹

配和高级排

序算法为例

，着重介绍算

法性

能优化

以及针对不

同应用需求

的调校方法

与技巧，这部

分内容可以

帮助读者深

入理解各类

数据结

构与

算法在不同

实际环境中

适用性的微

妙差异。



注重

整体认识，着

眼系统思维

全书体例参

照现代数据

结构普遍采

用的分类规

范进行编排

，其间贯穿以

具体而本质

的线索，

帮助

读者在了解

各种具体数

据结构之后

，通过概括与

提升形成对

数据结构家

族的整体性

认识。行

文从

多个侧面体

现“转换-化简

”的技巧，引导

读者逐步形

成和强化计

算思维（computational

thinking）的意

识与习惯，从

方法论的高

度掌握利用

计算机求解

问题的一般

性规律与方

法。

比如从逻

辑结构的角

度，按照线性

、半线性和非

线性三个层

次对数据结

构进行分类

，并以遍

历算

法为线索，点

明不同层次

之间相互转

换的技巧。又

如，通过介绍

动态规划、减

而治之、分而

治之等算法

策略，展示如

何将人所擅

长的概括化

简思维方式

与计算机强

大的枚举迭

代能力相结

合，高效地求

解实际应用

问题。再如，从

数据元素访

问形式的角

度，按照循秩

访问、循位置

访问

或循链

接访问、循关

键码访问、循

值访问、循优

先级访问等

方式，对各种

数据结构做

了归类，并

指

明它们之间

的联系与区

别。

通过引入

代数判定树

模型以及对

应的下界等

概念，并讲解

如何针对具

体计算模型

确定特定问

题的复杂度

下界，破除了

部分读者对

计算机计算

能力的盲目

迷信。按照CC大

纲综述报告

的归纳结

论

，这也是对计

算学科所有

专业本科毕

业生共同要

求中的第三

点不仅需要

了解计算机

技术可

以做

什么（possibilities）以及如

何做，更需要

了解不能做

什么（limitations）以及为

什

么不能做

。

 尊重认知规

律，放眼拓展

提升

在相关

学科众多的

专业基础课

程中，数据结

构与算法给

学生留下的

印象多是内

容深、难度大

，

而如何让学

生打消畏难

情绪从而学

有所乐、学有

所获，则是摆

在每位任课

教师面前的

课题。计算

机

教学有其独

特的认知规

律，整个过程

大致可以分

为记忆（remember）、理解

（understand）、

应用（apply）、分析（analyze）、评

估（evaluate）和创造（create）等

若干阶段，本

书

也按照这

一脉络，在叙

述方式上做

了一些粗浅

的尝试。

为加

深记忆与理

解，凡重要的

知识点均配

有插图。全书

共计230多组300余

幅插图，借助

视

觉通道，从

原理、过程、实

例等角度使

晦涩抽象的

知识点得以

具体化、形象

化，也就是鲁

迅先生

“五到

”读书法中的

第一条“眼到

”。

为加深对类

似概念或系

列概念的综

合理解，完成

认识上的提

升，还普遍采

用“对比”的手

法。

例如，优先

级队列接口

不同实现方

式之间的性

能对比、快速

排序算法不

同版本在适

用范围上的

对

比，等等。又

如，通过Dijkstra算法

和Prim算法的横

向对比，提炼

和抽象出更

具一般性的

优先

级搜索

框架，并反过

来基于这一

认识实现统

一的搜索算

法模板。

为强

化实践能力

的培养，多从

具体的应用

问题入手，经

逐步分析导

出具体的解

决方法。所列

230余段代码，均

根据讲述的

侧重按模块

划分，在力求

简洁的同时

也配有详实

的备注解说

。读者

可以下

载代码，边阅

读边编译执

行，真正做到

“手到”和“心到

”。几乎所有实

现的数据结

构均

符合对

应的抽象数

据类型接口

标准，在强化

接口规范的

同时，从习惯

与方式上为

读者日后的

团队

协作做

铺垫与准备

。

在分析与评

估方面，介绍

了算法复杂

度的典型层

次及分析技

巧，包括常规

的最坏情况

和平均

情况

分析，以及分

摊分析。针对

递归算法，还

着重介绍了

递归跟踪法

与递推方程

法。另外从实

用

的角度，还

引入了稳定

性、就地性等

更为精细的

性能评估尺

度，并结合部

分算法做了

相关的分析

对比。

数据结

构与算法这

二者之间相

辅相成的关

系，也是本书

着重体现的

一条重要线

索。为此，本

书

的体例与多

数同类教材

不尽相同。以

排序算法为

例，除最后一

章外，大部分

排序算法都

作为对

应数

据结构的应

用实例，分散

编入相应的

章节：其中起

泡排序、归并

排序、插入排

序、选择排序

等算法以排

序器的形式

归入序列部

分；桶排序和

基数排序归

入散列部分

；而堆排序则

归入优先级

队列部分。再

如，图算法及

其基本实现

均前置到第

6章，待到后续

章节引入高

级数据结构

时再介

绍其

优化方法，如

此前后呼应

。行文讲述中

也着力突出

数据结构对

高效算法的

支撑作用，以

及源

自应用

的算法问题

对数据结构

发展的反向

推动作用，优

先级队列之

于Huffman编码算法

、完全二

叉堆

之于就地堆

排序、伸展树

之于基于局

部性原理的

缓存算法、散

列表之于数

值空间与样

本空间

规模

差异的弥合

算法等，均属

于这方面的

实例。

与许多

课程的规律

类似，习题对

于数据结构

与算法而言

也是强化和

提升学习效

果的必由之

途，否则无异

于“入宝山而

空返”。本书各

章均针对性

地附有大量

习题，累计逾

270道。当然，

好的

习题不应仅

限于对讲授

内容的重复

与堆砌，而应

更多地侧重

于拓展与反

思。其中，拓展

型习

题既包

括对书中数

据结构接口

的扩充、算法

性能的改进

，也包括通过

查阅文献资

料补充相关

的知

识点。另

外，一些难度

极大或者难

度不大但过

程繁琐的内

容，在这里也

以习题的形

式留待课后

进

一步探讨

。在求知求真

的过程中，质

疑与批判是

难能可贵的

精神，反诘与

反思更是创

造创新的起

点。从吸收到

反思，在某种

意义上也就

是学习（learning）与反

学习（unlearning）反复迭

代、

不断上升

的过程。为此

，部分习题的

答案并非简

单地重复正

文的结论，甚

至并不具有

固定的答案

，

以给读者日

后灵活的运

用与创新留

下足够的空

间。

说明

书中

凡重要的专

业词汇均注

有原文，插图

中的标注也

多以英文给

出，因为作者

认为这都是

进

一步钻研

以及与国际

同行交流的

基础。公式多

采用接近代

码的风格，而

非严格的数

学格式，以利

i

于按照代码

注释的方式

描述和理解

算法。

书中涉

及的所有代

码以及大量

尚未在书中

列出的辅助

代码，均按Visual Studio工

程形式

分成

50多组，并统一

到名为DSACPP的解

决方案之下

，完整的代码

包可从本书

主页下载后

直接编

译执

行。

为精简篇

幅、突出重点

，在一定程度

上牺牲了软

件规范性甚

至计算效率

，读者不必盲

目效仿。

比如

，为尽量利用

页面宽度和

便于投影式

播放，全文源

代码统一采

用Java风格编排

，但代码的

层

次感却因此

有所削弱，代

码片段的切

分也有过度

之嫌。同样出

于简化的考

虑，代码中一

些本可

优化

但可能影响

总体思路的

细节也被忽

略。另外，对错

误与意外的

处理也采用

了简化的处

理方式。

限于

本人的水平

与经验，书中

一定不乏纰

漏与谬误之

处，恳请读者

及专家批评

指正。

2011年夏末

于清华园

j

k

教

学计划编排

方案建议

采

用本书作为

教材时，视学

生基础、专业

方向、教学目

标及允许课

时总量的不

同，授课教师

可参照以下

典型方案分

配课内学时

，通常还需另

外设置约50%的

课外编程实

验学时。

教学

斱案不诼内

学时分配

教

学内容

斱案

A

斱案

B

斱案

C

斱

案

D

斱案

E

斱案

F

斱案

G

部分 章

节（规学时可

省带*小节） 64 48

64 64 48 32

48

一

基础知识

第

1章 绪讳

1.1~1.3 + 1.5 2.5

2.5 3.5 4.5 3.5

2.5 3

1.4*

1.5

1.5 2 2.5 2.5

0 2

二

基

本数据

结极

第2章 向量

2.1 ~

2.6 3 3 3

4 3 2.5 3

2.7*

1 0 1.5

2 1 0 0

2.8 2 2 2

3 2 2 2

第

3章 列表

3.1 ~

3.4 2 2 3

4 3 2 3

3.5 2 2 3

4 3 2 3

第4章

栈不队列

4.1 ~ 4.3

2 2 2 3

2 2 2

4.4*

3 3 3 3

3 0 3

4.5

~ 4.6 1 1

1 2 1 2

1

第

5章 二叉树

5.1

+ 5.3 2 2

2 2 2 2

2

5.4 2 2

3 3 3 2

2

5.2 + 5.5

2 2 3 3

3 0 3

第

6章

图

6.1 ~ 6.4

1.5 1.5 2 2

2 2 2

6.5

~ 6.8 2.5 2.5

2 4 3 3

3

6.9*

1 1

2 2 0 0

0

6.10 ~ 6.12

2 2 2 4

3 2 2

第7章

搜

索树

7.1 ~ 7.2

2 2 3 6

4 3 3

7.3

~ 7.4 2 2

3 6 4 3

3

三

高级

数据

结极

第

8章 高级搜索

树

8.1 ~

8.2 2 2 3

0 0 0 0

8.3*

~ 8.4*

3

0 3 0 0

0 0

第9章 词典

9.1

+ 9.3 2 2

2 0 0 0

0

9.2*

+ 9.4*

4 0 4 0

0 0 0

第10章

优先级

队列

10.1 ~ 10.2

4 4 4 0

0 0 0

10.3*

2 0 2 0

0 0 0

四

算法

第11章 串

11.1 ~

11.3 2 2 0

0 0 0 2

11.4*

~ 11.5*

2

0 0 0 0

0 2

第12章

排序

12.1

2 2 0 0

0 0 2

12.2*

~ 12.3*

4 0

0 0 0 0

0

本书所

有相关教学

资料均向公

众开放，包括

勘误表、插图

、代码以及配

套讲义等。欢

迎访问

教材

主页：http://dsa.cs.tsinghua.edu.cn/~deng/dsacpp/

l

致 谢

感

谢严蔚敏教

授，廿多年前

是她引领我

进入数据结

构的殿堂；感

谢吴文虎教

授，在追随他

参

与信息学

相关竞赛组

织工作的过

程中，我更加

切实地感受

到了算法之

宏之美。感谢

殷人昆、王宏

、

朱仲涛、徐明

星、尹霞等老

师，在与他们

的教学合作

过程中我获

益良多。感谢

众多的同行

，与他

们的交

流和探讨每

每令我思路

顿开。感谢数

以千计的学

生，他们是我

写作的最终

动机与不竭

动力，

无论是

在课堂或是

课后，与他们

相处的时光

都属于我在

清华园最美

好的记忆。

历

年的助教研

究生不仅出

色地完成了

繁重的课外

辅导与资源

建设工作，他

们丰富的想

象力和

创造

力更是我重

要的灵感来

源，在此我要

感谢他们对

我的帮助！

截

至2012年秋季，按

担任助教时

间先后，他们

分别是：

王智

、李云翀、赵乐

、肖晶、刘汝佳

、高岳、沈超慧

、李锐喆

于泽

、白彦冰、夏龙

、向阳、姚姜源

、刘雨辰、姜禹

、方宇剑

在本

书各版次的

使用过程中

，收到了学生

及读者的大

量反馈，其中

杨凯峪、李雨

田、许婷婷、

郑

斯陶、石梦凯

、陈逸翀、王紫

、朱剑男、李仁

杰、许建林、吴

育昕、刘苏齐

、陈键飞、唐骞

璘、

徐霜晴等

同学，分别指

出了多处纰

漏及错误。王

笑尘同学作

为第3版的试

验读者，杨凯

峪、李雨

田同

学作为配套

《习题解析》的

试验读者，均

提出了许多

很好的修改

建议。清华美

院的郭清华

同

学，对第3版

的版式和色

调设计提出

了极具价值

的建议。在此

也谨向他们

表示感谢！

感

谢清华大学

出版社的各

位编辑，正是

依靠他们的

鼎力支持，本

书才得以顺

利出版。特别

感

谢龙启铭

先生，他出色

而高效的协

调工作，使我

得以将更多

精力集中于

书稿本身；在

体例编排及

编写风格等

方面，他的许

多建议都极

具价值。

本教

材第3版的撰

写工作，得到

了“清华大学

985名优教材”立

项资助，在此

谨向清华大

学，

特别是校

、系教务部门

的大力支持

表示感谢！

m

简

要目录

第1章

绪讳

1

§1.1 计算机

不算法________________ 2

§1.2 复杂

度度量 _________________ 8

§1.3 复杂

度分枂 ________________ 11

§1.4 *递归

______________________ 16

§1.5

抽象数据类

型_______________ 26

第2章 向量

27

§2.1 仍数组刡向

量_______________ 28

§2.2

接口 ______________________ 29

§2.3

极造

不枂极 ________________ 32

§2.4

劢态

空间管理_______________ 33

§2.5 常

觃向量

__________________ 37

§2.6 有序

向量

__________________ 44

§2.7 *排序不

下界

________________ 57

§2.8 排序器

____________________

59

第3章 列表 65

§3.1 仍

向量刡列表

_______________ 66

§3.2

接口 ______________________ 67

§3.3

列表 ______________________ 71

§3.4

有

序列表 __________________ 77

§3.5

排序

器 ____________________ 78

第4章

栈不

队列 85

§4.1 栈________________________

86

§4.2 栈不

递归 __________________

88

§4.3 栈癿典

型应用_______________ 90

§4.4 *试探

回溯法 ________________ 99

§4.5 队列

_____________________ 104

§4.6

队列应用 _________________ 107

第

5章

事叉树 109

§5.1 事

叉树及其表

示____________

110

§5.2 编码树 ___________________

114

§5.3 事

叉树癿实现

______________ 117

§5.4 遍历 _____________________ 123

§5.5 Huffman编码______________ 136

第

6章

图 149

§6.1 概述

_____________________ 150

§6.2 抽

象数据类型

______________

153

§6.3 邻接矩阵 _________________

155

§6.4 邻

接表 ___________________

158

§6.5 图遍历

算法概述____________ 159

§6.6 广

度优先搜索

______________ 159

§6.7

深度优先搜

索______________ 162

§6.8 拓扑排序

_________________

165

§6.9 *双还通域分

解 _____________

168

§6.10 优先级搜

索 ______________

172

§6.11 最小支撑

树 ______________

174

§6.12 最短路径

________________ 178

第7章 搜索树

181

§7.1 查找

_____________________ 183

§7.2 事叉搜

索树

_______________ 184

n

§7.3

平衡事

叉搜索树____________ 191

§7.4 AVL树

____________________

194

第8章 高级搜

索树 203

§8.1 伸展树

___________________ 204

§8.2

B-树_____________________ 212

§8.3 *红黑树___________________

227

§8.4 *

kd-树

___________________

239

第9章 词典 245

§9.1 词

典ADT __________________ 247

§9.2 *跳转表___________________ 249

§9.3

散

列表 ___________________ 259

§9.4

*散列应

用 _________________ 277

第10章

优先

级队列 281

§10.1 优先

级队列ADT

___________ 282

§10.2 堆______________________

286

§10.3 *左

式堆__________________ 297

第11章 串

305

§11.1 串及串匹配

______________

306

§11.2 蛮力算法 ________________

309

§11.3 KMP算

法_________________ 311

§11.4 *

BM算法 _________________

317

§11.5 *

Karp-Rabin算法

_________

327

第12章 排序 333

§12.1 快

速排序 ________________ 334

§12.2 *选叏

不中位数 ____________ 341

§12.3 *希

尔排序 ________________ 350

附彔

357

参考文献 ______________________ 358

揑

图索引 ______________________ 362

表栺

索引

______________________ 369

算法索

引 ______________________

370

代码索引

______________________ 371

关键词索引

____________________

377

o

详细目录

第

1章

绪讳 1

§1.1 计算

机不算法________________

2

1.1.1 古

埃及人癿绳

索 ........2

1.1.2 欧几里得

癿尺觃 ........3

1.1.3

起泡

排序 ..............4

1.1.4 算法..................5

1.1.5 算

法效率 ..............7

§1.2

复杂

度度量 _________________ 8

1.2.1

时间

复杂度 ............8

1.2.2 渐迕

复杂度

............9

1.2.3 空间

复杂度 ...........11

§1.3 复杂

度分枂 ________________ 11

1.3.1 常数

O(1) ............12

1.3.2

对数O(logn) .........12

1.3.3 线性O(n)

............13

1.3.4 夗

项式O(polynomial(n))

..........................14

1.3.5 指数O(2n

) ............14

1.3.6 复

杂度局次 ...........15

1.3.7

输

入觃模 .............16

§1.4 *递归

______________________

16

1.4.1 线性逑弻 .............17

1.4.2 逑

弻分枂 .............17

1.4.3

逑弻

模式 .............19

1.4.4 逑弻消

除

.............21

1.4.5 二分逑弻

.............22

§1.5

抽象数据类

型_______________ 26

第2章 向量

27

§2.1 仍数组刡向

量_______________ 28

2.1.1

数组.................28

2.1.2 向量

.................29

§2.2

接口 ______________________ 29

2.2.1

ADT接口 .............29

2.2.2 操

作实例

.............30

2.2.3 Vector模板

类.........30

§2.3

极造不枂

极 ________________ 32

2.3.1

默讣极造

斱法 .........32

2.3.2 基亍复

刢癿极造斱

法....32

2.3.3 枂极斱法

.............33

§2.4 劢态空间管

理_______________

33

2.4.1 静态空间

管理 .........33

2.4.2 可扩充

向量 ...........34

2.4.3

扩容.................34

2.4.4 分

摊分枂 .............35

2.4.5 缩容

.................36

§2.5 常觃向量

__________________ 37

2.5.1 直

接引用元素

.........37

2.5.2 置乱器...............37

2.5.3 刞等

器不比较器

.......38

2.5.4 无序查找 .............39

2.5.5

揑

入.................40

2.5.6 初除.................40

2.5.7

唯一

化...............42

2.5.8 遍历.................43

§2.6

有序

向量 __________________ 44

2.6.1

比较器

...............44

2.6.2 有序性甄删

...........44

2.6.3

唯一化...............45

2.6.4 查找

.................47

2.6.5

二分查找（版

本A）.....48

2.6.6 Fibonacci查找 .......51

2.6.7 二分

查找（版本B）.....54

2.6.8 二

分查找（版本

C）.....55

p

§2.7 *排序不下界

________________ 57

2.7.1 有序性...............57

2.7.2 排序

及其分类

.........57

2.7.3 下

界.................57

2.7.4

比较树...............58

2.7.5 估

计下界 .............59

§2.8 排序

器 ____________________ 59

2.8.1 统一入口

.............59

2.8.2 起泡排序

.............60

2.8.3 弻

幵排序 .............61

第3章

列表 65

§3.1 仍向量

刡列表_______________

66

3.1.1 从静

态刡劢态 .........66

3.1.2 由

秩刡位置 ...........67

3.1.3

列

表.................67

§3.2 接口 ______________________

67

3.2.1 列表

节点 .............67

3.2.2 列表.................68

§3.3 列

表

______________________ 71

3.3.1 头、尾节点

...........71

3.3.2 默讣极造斱

法 .........71

3.3.3

由秩刡位

置癿转换......72

3.3.4 查

找.................72

3.3.5

揑入.................72

3.3.6 基亍

复刢癿极造

.......74

3.3.7

初除.................75

3.3.8 枂极.................76

3.3.9

唯

一化...............76

3.3.10 遍历................77

§3.4

有

序列表 __________________ 77

3.4.1

唯一

化...............77

3.4.2 查找.................78

§3.5

排序

器 ____________________ 78

3.5.1

统一入口

.............78

3.5.2 揑入排序 .............79

3.5.3 选

择排序 .............80

3.5.4

弻幵

排序 .............82

第4章 栈

不队列

85

§4.1 栈________________________ 86

4.1.1 ADT接

口 .............86

4.1.2

操作实例

.............87

4.1.3 Stack模板类..........88

§4.2

栈不

递归 __________________ 88

4.2.1

函数调

用栈 ...........88

4.2.2 避免逑

弻

.............89

§4.3 栈癿典型

应用_______________ 90

4.3.1 逆序输

出 .............90

4.3.2

逑弻嵌套

.............91

4.3.3 延迟缓冲 .............94

4.3.4 逆

波兰表达式

.........96

§4.4 *试探回溯法

________________

99

4.4.1 试探不回溯

...........99

4.4.2

八皁后..............100

4.4.3 迷宫

寺径 ............102

§4.5 队列 _____________________ 104

4.5.1 概

述................104

4.5.2 ADT接口

............105

4.5.3 操作

实例 ............105

4.5.4 Queue模板类

.........106

§4.6 队列应用

_________________ 107

4.6.1 循

环分配器

..........107

4.6.2 银

行服务模拟

........107

第5章

事叉树

109

§5.1 事叉树及其

表示____________ 110

5.1.1 树 .................110

5.1.2

二叉

树..............111

5.1.3 夗叉树..............112

q

§5.2 编

码树 ___________________ 114

5.2.1 二迕刢

编码 ..........114

5.2.2

二叉编

码树 ..........116

§5.3 事叉树

癿实现______________

117

5.3.1 二叉

树节点 ..........117

5.3.2 二叉

树节点操作

接口...119

5.3.3 二叉树

..............120

§5.4 遍历 _____________________ 123

5.4.1 逑弻式

遍历 ..........124

5.4.2

*迭代版

先序遍历 ......126

5.4.3 *迭

代版中序遍

历

......128

5.4.4 *迭代版后

序遍历 ......131

5.4.5 局次

遍历 ............133

§5.5

Huffman编码______________ 136

5.5.1 PFC编

码及解码

.......136

5.5.2 最

优编码树 ..........139

5.5.3 Huffman编

码树.......141

5.5.4 Huffman编码算

法

.....142

第6章 图 149

§6.1 概

述 _____________________ 150

§6.2 抽象数据

类型______________ 153

6.2.1

操作接

口 ............153

6.2.2 Graph模板类.........153

§6.3 邻

接矩阵 _________________ 155

6.3.1 原理

................155

6.3.2 实现................155

6.3.3 时间性

能 ............157

6.3.4

空间性能

............157

§6.4 邻接表 ___________________

158

6.4.1 原理

................158

6.4.2

复杂度..............158

§6.5 图遍

历算法概述

____________ 159

§6.6 广度优先搜

索______________ 159

6.6.1

策略................159

6.6.2 实现

................160

6.6.3

实例................161

6.6.4 复杂度

..............161

6.6.5

应用................161

§6.7 深度优

先搜索______________ 162

6.7.1 策略

................162

6.7.2 实现................162

6.7.3 实例................163

6.7.4 复

杂度..............164

6.7.5 应用................165

§6.8 拓

扑排序

_________________ 165

6.8.1 应用

................165

6.8.2 有向无环图

..........166

6.8.3 算法................166

6.8.4 实现................167

6.8.5 实

例................168

6.8.6 复杂度..............168

§6.9 *双

还通域分解

_____________

168

6.9.1 兲节点不双

连通域.....168

6.9.2

蛮力

算法 ............169

6.9.3 可行算

法

............169

6.9.4 实现................170

6.9.5

实例

................171

6.9.6 复杂度..............172

§6.10

优先

级搜索 ______________ 172

6.10.1

优先

级不优先级

数....172

6.10.2 基本框架

...........173

6.10.3

复杂度.............174

§6.11 最小

支撑树 ______________

174

6.11.1 支撑

树.............174

6.11.2

最小支撑

树 .........174

6.11.3 歧丿性.............175

6.11.4 蛮

力算法 ...........175

6.11.5

Prim算法

..........175

§6.12 最短路径 ________________

178

6.12.1 最

短路径树 .........178

r

6.12.2 Dijkstra算

法 ......178

第7章 搜索

树 181

§7.1

查找 _____________________ 183

7.1.1

循兲

键码讵问 ........183

7.1.2 词

条................183

7.1.3 序不比较

器 ..........183

§7.2

事叉搜索

树 _______________ 184

7.2.1

顺序性..............184

7.2.2 中

序遍历序列

........184

7.2.3

BST模板类...........185

7.2.4 查找

算法及其实

现.....185

7.2.5

揑入算法

及其实现.....188

7.2.6 初

除算法及其

实现.....189

§7.3

平衡事

叉搜索树____________ 191

7.3.1 树

高不性能

..........191

7.3.2 理

想平衡不适

度平衡...192

7.3.3

等价

发换 ............192

7.3.4 旋转调

整

............193

§7.4 AVL树____________________ 194

7.4.1 定丿及

性质 ..........194

7.4.2

节点揑

入 ............196

7.4.3 节点初除

............198

7.4.4 统一重平衡

算法 ......200

第8章

高

级搜索树 203

§8.1 伸

展树

___________________ 204

8.1.1 尿部性

..............204

8.1.2 逐局伸展 ............205

8.1.3

双

局伸展 ............206

8.1.4 伸展

树癿实现

........208

§8.2 B-树

_____________________ 212

8.2.1 夗路平衡查

找 ........212

8.2.2

ADT接口及其

实现 .....215

8.2.3 兲键码

查找

..........216

8.2.4 性能分

枂 ............218

8.2.5 兲键码揑

入 ..........219

8.2.6

上溢不分

裂 ..........219

8.2.7 兲键码初

除

..........222

8.2.8 下溢不合

幵 ..........223

§8.3 *红黑树___________________ 227

8.3.1

概

述................228

8.3.2 红黑树接

口定丿 ......230

8.3.3 节点

揑入算法 ........231

8.3.4

节

点初除算法

........234

§8.4 *

kd-树

___________________ 239

8.4.1 范围查诟

............239

8.4.2 kd-树 ..............242

8.4.3

基亍2d-树癿

范围查诟..243

第

9章 词典 245

§9.1 词典

ADT __________________ 247

9.1.1 操作接口 ............247

9.1.2

操

作实例 ............247

9.1.3 接口

定丿

............248

9.1.4 实现斱

法 ............248

§9.2 *跳转表___________________ 249

9.2.1

Skiplist模

板类......249

9.2.2 总体逡

辑结极 ........250

9.2.3 四联

表..............250

9.2.4 查找................252

9.2.5 空间

复杂度 ..........253

9.2.6

时间

复杂度 ..........254

9.2.7 揑入

................255

9.2.8 初除................258

§9.3 散列表

___________________

259

9.3.1 完美散列 ............259

9.3.2 装

填因子不空

间刟用率 .260

9.3.3

散

列函数 ............261

9.3.4 散列

表..............264

9.3.5 冲突及其

排解 ........266

s

9.3.6 闭散列

策略 ..........268

9.3.7

查找不

初除 ..........271

9.3.8 揑入................272

9.3.9 更

夗闭散列策

略 ......273

9.3.10

散列码转

换 .........275

§9.4 *散列应用

_________________

277

9.4.1 桶排序..............277

9.4.2

最大

间隒 ............278

9.4.3 基数排

序

............279

第10章 优先

级队列 281

§10.1 优先

级队列ADT ___________ 282

10.1.1 优先

级不优先级

队列..282

10.1.2 兲键码

、比较器不偏

序兲系

.........................283

10.1.3 操作

接口 ...........283

10.1.4 操作实

例：选择排序

..283

10.1.5 接口定丿

...........284

10.1.6 应

用实例：Huffman编码

树

.........................284

§10.2 堆______________________ 286

10.2.1

完全二

叉堆 .........286

10.2.2 元素揑

入

...........289

10.2.3 元素初除

...........291

10.2.4

建堆...............292

10.2.5 就地堆

排序 .........295

§10.3 *左式堆

__________________ 297

10.3.1

堆合幵.............297

10.3.2 单侧

倾斜 ...........298

10.3.3 PQ_LeftHeap模板类

..298

10.3.4 空节点路径

长度

.....299

10.3.5 左倾性

不左式堆 .....299

10.3.6 最

右侧通路 .........300

10.3.7

合

幵算法 ...........300

10.3.8 实例

...............301

10.3.9 合幵操作癿

实现 .....302

10.3.10

复杂度

............302

10.3.11 基亍合幵癿

揑入和初除

302

第11章

串 305

§11.1 串及

串匹配

______________ 306

11.1.1 串

................306

11.1.2 串

匘配.............307

11.1.3

测评标

准不策略 .....308

§11.2 蛮

力算法

________________ 309

11.2.1 算法

描述

...........309

11.2.2 算法实

现 ...........309

11.2.3 时间复杂

度 .........310

§11.3

KMP算法_________________ 311

11.3.1 极思

...............311

11.3.2 next表 ............312

11.3.3

KMP算法 ...........312

11.3.4 next[0]

= -1 ......313

11.3.5

next[j + 1] .......313

11.3.6 极造

next表.........314

11.3.7 性能分枂

...........315

11.3.8 继续改迕 ...........315

§11.4

*

BM算

法 _________________ 317

11.4.1 思路不框

架 .........317

11.4.2

坏字符策

略 .........318

11.4.3 好后缀策

略

.........321

11.4.4 gs[]表极造算

法 .....323

11.4.5 算法纵觅

...........326

§11.5 *

Karp-Rabin算法 _________ 327

11.5.1

极思...............327

11.5.2 算

法不实现 .........328

第

12章 排序 333

§12.1

快速

排序 ________________ 334

12.1.1

分治策

略 ...........334

12.1.2 轴点...............334

t

12.1.3 快速

排序算法 .......335

12.1.4 快

速划分算法

.......335

12.1.5 复杂度.............338

12.1.6 应对

退化 ...........339

§12.2

*选叏不

中位数 ____________ 341

12.2.1

概述

...............341

12.2.2 众数...............342

12.2.3

弻幵向

量癿中位数

....343

12.2.4 基亍优先级

队列癿选叏

346

12.2.5

基亍快速划

分癿选叏..347

12.2.6 k-选

叏算法 .........348

§12.3 *希尔

排序 ________________ 350

12.3.1 逑减增

量策略 .......350

12.3.2

增量

序列 ...........353

附彔 357

参

考文献 ______________________ 358

揑图

索引

______________________ 362

表栺索

引 ______________________

369

算法索引

______________________ 370

代码索引

______________________ 371

关

键词索引 ____________________

377

第

1章

绪论

§1.1

计算

机不算法 第

1章 绪讳

2

作为

万物之灵的

人，与动物的

根本区别在

于理性，而计

算则是理性

的一种重要

而具体的表

现

形式。计算

机是人类从

事计算的工

具，是抽象计

算模型的具

体物化。基于

图灵模型的

现代计算机

，

既是人类现

代文明的标

志与基础，更

是人脑思维

的拓展与延

伸。

尽管计算

机的性能日

益提高，但这

种能力在解

决实际应用

问题时能否

真正得以发

挥，决定性

的

关键因素仍

在于人类自

身。具体地，通

过深入思考

与分析获得

对问题本质

的透彻理解

，按照长

期积

淀而成的框

架与模式设

计出合乎问

题内在规律

的算法，选用

、改进或定制

足以支撑算

法高效

实现

的数据结构

，并在真实的

应用环境中

充分测试、调

校和改进，构

成了应用计

算机高效求

解实

际问题

的典型流程

与不二法门

。任何一位有

志于驾驭计

算机的学生

，都应该从这

些方面入手

，不

断学习，反

复练习，勤于

总结。

本章将

介绍与计算

相关的基本

概念，包括算

法构成的基

本要素、算法

效率的衡量

尺度、计算

复

杂度的分析

方法与界定

技巧、算法设

计的基本框

架与典型模

式，这些也构

成了全书所

讨论的各

类

数据结构及

相关算法的

基础与出发

点。

§1.1 计算机与

算法

1946年问世

的ENIAC开启了现

代电子数字

计算机的时

代，计算机科

学（computer science）

也在随后

应运而生。计

算机科学的

核心在于研

究计算方法

与过程的规

律，而不仅仅

是作为计算

工

具的计算

机本身，因此

E. Dijkstra及其追随者

更倾向于将

这门科学称

作计算科学

（computing

science）。

实际上，人类

使用不同工

具从事计算

的历史可以

追溯到更为

久远的时代

，计算以及计

算工具

始终

与我们如影

相随地穿越

漫长的时光

岁月，不断推

动人类及人

类社会的进

化发展。从最

初颜色

各异

的贝壳、长短

不一的刻痕

、周载轮回的

日影、粗细有

别的绳结，以

至后来的直

尺、圆规和算

盘，都曾经甚

至依然是人

类有力的计

算工具。

1.1.1 古埃

及人的绳索

古埃及人以

其复杂而浩

大的建

筑工

程而著称于

世，在长期规

划与

实施此

类工程的过

程中，他们逐

渐

归纳并掌

握了基本的

几何度量和

测

绘方法。考

古研究发现

，公元前2000

年的

古埃及人已

经知道如何

解决如

下实

际工程问题

：通过直线l上

给定

的点P，作

该直线的垂

线。

图1.1 古埃及

人使用癿绳

索计算机及

其算法

他们

所采用的方

法，原理及过

程如图1.1所示

，翻译成现代

的算法语言

可描述如下

。

第1章 绪讳 §1.1 计

算机不算法

3

perpendicular(l, P)

输入：直线l及

其上一点P

输

出：经过P且垂

直亍l癿直线

1.

叏12殌等长绳

索，依次首尾

联结成环 //联

结处称作“结

”，按顺时针斱

向编号为0..11

2. 奴

隶A看管0号结

，将其固定亍

点P处

3. 奴隶B牵

劢4号结，将绳

索沿直线l斱

向尽可能地

拉直

4. 奴隶C牵

劢9号结，将绳

索尽可能地

拉直

5. 经过0号

和9号结，绘刢

一条直线

算

法1.1 过直线上

给定点作直

角

以上由古

埃及人发明

、由奴隶与绳

索组成的这

套计算工具

，乍看起来与

现代的电子

计算机相

去

甚远。但就本

质而言，二者

之间的相似

之处远多于

差异，它们同

样都是用于

支持和实现

计算过

程的

物理机制，亦

即广义的计

算机。因此就

这一意义而

言，将其称作

“绳索计算机

”毫不过分。

1.1.2

欧

几里得的尺

规

欧几里得

几何是现代

公理系统的

鼻祖。从计算

的角度来看

，针对不同的

几何问题，欧

氏几何

都分

别给出了一

套几何作图

流程，也就是

具体的算法

。比如，经典的

线段三等分

过程可描述

为如

算法1.2所

示。该算法的

一个典型的

执行实例如

图1.2所示。

tripartition(AB)

输入

：线殌AB

输出：将

AB三等分癿两

个点C和D

1.

从A収

出一条不AB丌

重合癿射线



2. 仸叏上三点

C'、D'和B'，使|AC'| =

|C'D'| = |D'B'|

3.

联接B'B

4. 过

D'做B'B癿平行线

，交AB亍D

5.

过C'做B'B癿

平行线，交AB亍

C

算法1.2 三等分

给定线段

图

1.2

古希腊人癿

尺觃计算机

在以上算法

中，输入为所

给的直线段

AB，输出为将其

三等分的C和

D点。我们知道

，欧氏几

何还

给出了大量

过程与功能

更为复杂的

几何作图算

法，为将这些

算法变成可

行的实际操

作序列，

欧氏

几何使用了

两种相互配

合的基本工

具：不带刻度

的直尺，以及

半径跨度不

受限制的圆

规。同

样地，从

计算的角度

来看，由直尺

和圆规构成

的这一物理

机制也不妨

可以称作“尺

规计算机”。

在

尺规计算机

中，可行的基

本操作不外

乎以下五类

：

1 过两个点作

一直线

2

确定

两条直线癿

交点

3 以仸一

点为囿心，以

仸意半径作

一个囿

4

确定

仸一直线和

仸一囿癿交

点（若二者癿

确相交）

5 确定

两个囿癿交

点（若二者癿

确相交）

每一

欧氏作图算

法均可分解

为一系列上

述操作的组

合，故称之为

基本操作恰

如其分。

§1.1 计算

机不算法 第

1章 绪讳

4

1.1.3 起泡

排序

D.

Knuth[3]曾指出

，四分之一以

上的CPU时间都

用于执行同

一类型的计

算：按照某种

约定

的次序

，将给定的一

组元素顺序

排列，比如将

n个整数按通

常的大小次

序排成一个

非降序列。这

类操作统称

排序（sorting）。

就广义

而言，我们今

天借助计算

机所完成的

计算任务中

，有更高的比

例都可归入

此类。例如，

从

浩如烟海的

万维网中找

出与特定关

键词最相关

的前100个页面

，就是此类计

算的一种典

型形式。

排序

问题在算法

设计与分析

中扮演着重

要的角色，以

下不妨首先

就此做一讨

论。为简化起

见，这

里暂且

只讨论对整

数的排序。

 局

部有序与整

体有序

在由

一组整数组

成的序列A[0, n - 1]中

，满足A[i

- 1]  A[i]的相邻

元素称作顺

序的；

否则是

逆序的。不难

看出，有序序

列中每一对

相邻元素都

是顺序的，亦

即,对任意1  i <

n都

有A[i - 1] 

A[i]；反之，所有

相邻元素均

顺序的序列

，也必然整体

有序。

 扫描交

换

由有序序

列的上述特

征，我们可以

通过不断改

善局部的有

序性实现整

体的有序：从

前向后依

次

检查每一对

相邻元素，一

旦发现逆序

即交换二者

的位置。对于

长度为n的序

列，共需做n - 1

次

比较和不超

过n

- 1次交换，这

一过程称作

一趟扫描交

换。

图1.3 通过6趟

扫描交换对

七个整数排

序（其中已就

位癿元素以

深色示意）

以

图1.3(a)中由7个整

数组成的序

列A[0, 6] = {

5, 2, 7, 4,

6, 3, 1 }为例。

在第

一趟扫描交

换过程中，{ 5, 2 }交

换位置，{

7, 4, 6, 3,

1 }循环

交换位置，扫

描

交换后的

结果如图(b)所

示。



起泡排序

可见，经过这

样的一趟扫

描，序列未必

达到整体有

序。果真如此

，则可对该序

列再做一趟

扫

描交换，比

如，图(b)再经一

趟扫描交换

的结果如图

(c)。事实上，很有

可能如图(c~f)所

示，需

要反复

进行多次扫

描交换，直到

如图(g)所示，在

序列中不再

含有任何逆

序的相邻元

素。多数的

这

类交换操作

，都会使得越

小（大）的元素

朝上（下）方移

动（习题[1-3]），直至

它们抵达各

自应处的位

置。

排序过程

中，所有元素

朝各自最终

位置亦步亦

趋的移动过

程，犹如气泡

在水中的上

下沉浮，

起泡

排序（bubblesort）算法也

因此得名。

第

1章 绪讳

§1.1 计算

机不算法

5



实

现

上述起泡

排序的思路

，可准确描述

和实现为如

代码1.1所示的

函数bubblesort1A()。

1 void

bubblesort1A ( int A[],

int n ) {

//起泡排

序算法（版本

1A）：0 <= n

2

bool sorted = false;

//整体排序标

志，首先假定

尚未排序

3 while (

!sorted ) { //在

尚未确讣已

全尿排序乀

前，逐趟迕行

扫描交换

4 sorted = true;

//假

定已经排序

5 for ( int

i = 1; i

< n; i++ )

{ //自左向右逐

对检查弼前

范围A[0, n)内癿各

相邻元素

6

if ( A[i -

1] > A[i] )

{ //一

旦A[i - 1]不A[i]逆序，则

7

swap ( A[i -

1], A[i] ); //交换乀，幵

8 sorted = false;

//因

整体排序丌

能保证，需要

清除排序标

志

9 }

10

}

11 n--; //至此末元

素必然就位

，故可以缩短

待排序序列

癿有效长度

12

}

13 } //倚劣布尔型

标志位sorted，可及

时提前退出

，而丌致总是

蛮力地做n

- 1趟

扫描交换

代

码1.1 整数数组

癿起泡排序

1.1.4

算法

以上三

例都可称作

算法。那么，究

竟什么是算

法呢？所谓算

法，是指基于

特定的计算

模型，

旨在解

决某一信息

处理问题而

设计的一个

指令序列。比

如，针对“过直

线上一点作

垂直线”这一

问题，基于由

绳索和奴隶

构成的计算

模型，由古埃

及人设计的

算法1.1；针对“三

等分线段”这

一问题，基于

由直尺和圆

规构成的计

算模型，由欧

几里得设计

的算法1.2；以及

针对“将若干

元

素按大小

排序”这一问

题，基于图灵

机模型而设

计的bubblesort1A()算法，等

等。

一般地，本

书所说的算

法还应必须

具备以下要

素。

 输入与输

出

待计算问

题的任一实

例，都需要以

某种方式交

给对应的算

法，对所求解

问题特定实

例的这种

描

述统称为输

入（input）。对于上述

三个例子而

言，输入分别

是“某条直线

及其上一点

”、“某

条线段”以

及“由n个整数

组成的某一

序列”。其中，第

三个实例的

输入具体地

由A[]与n共同描

述和定义，前

者为存放待

排序整数的

数组，后者为

整数的总数

。

经计算和处

理之后得到

的信息，即针

对输入问题

实例的答案

，称作输出（output）。比

如，

对于上述

三个例子而

言，输出分别

是“垂直线”、“三

等分点”以及

“有序序列”。在

物理上，

输出

有可能存放

于单独的存

储空间中，也

可能直接存

放于原输入

所占的存储

空间中。比如

，第三

个实例

即属于后一

情形，经排序

的整数将按

非降次序存

放在数组A[]中

。

 基本操作、确

定性与可行

性

所谓确定

性和可行性

是指，算法应

可描述为由

若干语义明

确的基本操

作组成的指

令序列，且

每

一基本操作

在对应的计

算模型中均

可兑现。以上

述算法1.1为例

，整个求解过

程可以明白

无误

地描述

为一系列借

助绳索可以

兑现的基本

操作，比如“取

等长绳索”、“联

结绳索”、“将绳

结

固定于指

定点”以及“拉

直绳索”等。再

如算法1.2中，“从

一点任意发

出一条射线

”、“在直

线上任

取三个等距

点”、“联接指定

两点”等，也都

属于借助尺

规可以兑现

的基本操作

。

§1.1 计算机不算

法 第1章

绪讳

6

细心的读者

可能会注意

到，算法1.2所涉

及的操作并

不都是基本

的，比如，最后

两句都要求

“过直线外一

点作其平行

线”，这本身就

是另一几何

作图问题。幸

运的是，借助

基本操作的

适当

组合，这

一子问题也

可圆满解决

，对应的算法

则不妨称作

是算法1.2的“子

算法”。

从现代

程序设计语

言的角度，可

以更加便捷

而准确地理

解算法的确

定性与可行

性。具体地，

一

个算法满足

确定性与可

行性，当且仅

当它可以通

过程序设计

语言精确地

描述，比如，起

泡排序

算法

可以具体地

描述和实现

为代码1.1中的

函数bubblesort1A()，其中“读

取某一元素

的内

容”、“修改

某一元素的

内容”、“比较两

个元素的大

小”、“逻辑表达

式求值”以及

“根据逻

辑判

断确定分支

转向”等等，都

属于现代电

子计算机所

支持的基本

操作。

 有穷性

与正确性

不

难理解，任意

算法都应在

执行有限次

基本操作之

后终止并给

出输出，此即

所谓算法的

有穷

性（finiteness）。进一

步地，算法不

仅应该迟早

会终止，而且

所给的输出

还应该能够

符合由

问题

本身在事先

确定的条件

，此即所谓算

法的正确性

（correctness）。

对以上前两

个算法实例

而言，在针对

任一输入实

例的计算过

程中，每条基

本操作语句

仅执行

一次

，故其有穷性

不证自明。另

外，根据勾股

定理以及平

行等比原理

，其正确性也

一目了然。然

而对于更为

复杂的算法

，这两条性质

的证明往往

颇需费些周

折（习题[1-27]和[1-28]），有

些

问题甚至

尚无定论（习

题[1-29]）。即便是简

单的起泡排

序，bubblesort1A()算法的有

穷性和

正确

性也不是由

代码1.1自身的

结构直接保

证的。以下就

以此为例做

一分析。

 起泡

排序

图1.3给出

了bubblesort1A()的一次具

体执行过程

和排序结果

，然而严格地

说，这远不足

以证明起泡

排序就是一

个名副其实

的算法。比如

，对于任意一

组整数，经过

若干趟的起

泡交换之

后

该算法是否

总能完成排

序？事实上，即

便是其有穷

性也值得怀

疑。就代码结

构而言，只有

在前

一趟扫

描交换中未

做任何元素

交换的情况

下，外层循环

才会因条件

“!sorted”不再满足而

退

出。但是，这

一情况对任

何输入实例

都总能出现

吗？反过来，是

否存在某一

（某些）输入序

列，

无论做多

少趟起泡交

换也无济于

事？这种担心

并非毫无道

理。细心的读

者或许已注

意到，在起泡

交换的过程

中，尽管多数

时候元素会

朝着各自的

最终位置不

断靠近，但有

的时候某些

元素也的确

会暂时朝着

远离自己应

处位置的方

向移动（习题

[1-3]）。

证明算法有

穷性和正确

性的一个重

要技巧，就是

从适当的角

度审视整个

计算过程，并

找出其

所具

有的某种不

变性和单调

性。其中的单

调性通常是

指，问题的有

效规模会随

着算法的推

进不断

递减

。不变性则不

仅应在算法

初始状态下

自然满足，而

且应与最终

的正确性相

呼应当问题

的

有效规模

缩减到0时，不

变性应随即

等价于正确

性。

那么，具体

到bubblesort1A()算法，其单

调性和不变

性应如何定

义和体现呢

？

反观图1.3不难

看出，每经过

一趟扫描交

换，尽管并不

能保证序列

立即达到整

体有序，但从

“待求解问题

的规模”这一

角度来看，整

体的有序性

必然有所改

善。以全局最

大的元素（图

1.3

中的整数7）为

例，在第一趟

扫描交换的

过程中，一旦

触及该元素

，它必将与后

续的所有元

素依

次交换

。于是如图1.3(b)所

示，经过第一

趟扫描之后

，该最大元素

必然就位；而

且在此后的

各

趟扫描交

换中，该元素

将绝不会参

与任何交换

。这就意味着

，经过一趟扫

描交换之后

，我们只需

要

关注前面更

小的那n - 1个元

素。实际上，这

一结论对后

续的各趟扫

描交换也都

成立考查

图

1.3(c~g)中的元素6~2，不

难验证这一

点。

第1章 绪讳

§1.1 计算机不算

法

7

于是，起泡

排序算法的

不变性和单

调性可分别

概括为：经过

k趟扫描交换

之后，最大的

前k

个元素必

然就位；经过

k趟扫描交换

之后，待求解

问题的有效

规模将缩减

至n -

k。

反观如代

码1.1所示的bubblesort1A()算

法，外层while循环

会不断缩减

待排序序列

的有

效长度

n。现在我们已

经可以理解

，该算法之所

以能够如此

处理，正是基

于以上不变

性和单调性

。

特别地，初始

状态下k

= 0，这两

条性质都自

然满足。另一

方面，由以上

单调性可知

，无论

如何，至

多经n -

1趟扫描

交换后，问题

的有效规模

必将缩减至

1。此时，仅含单

个元素的序

列，

有序性不

言而喻；而由

该算法的不

变性，其余n - 1个

元素在此前

的n

- 1步迭代中

业已相继就

位。因此，算法

不仅必然终

止，而且输出

序列必然整

体有序，其有

穷性与正确

性由此得证

。

 退化与鲁棒

性

同一问题

往往不限于

一种算法，而

同一算法也

常常会有多

种实现方式

，因此除了以

上必须具

备

的基本属性

，在应用环境

中还需从实

用的角度对

不同算法及

其不同版本

做更为细致

考量和取

舍

。这些细致的

要求尽管应

纳入软件工

程的范畴，但

也不失为成

熟算法的重

要标志。

比如

其中之一就

是，除一般性

情况外，实用

的算法还应

能够处理各

种极端的输

入实例。仍以

排序问题为

例，极端情况

下待排序序

列的长度可

能不是正数

（参数n

= 0甚至n < 0），或

者反

过来长

度达到或者

超过系统支

持的最大值

（n = INT_MAX），或者A[]中的元

素不见得互

异甚至

全体

相等，以上种

种都属于所

谓的退化（degeneracy）情

况。算法所谓

的鲁棒性（robustness），

就

是要求能够

尽可能充分

地应对此类

情况。请读者

自行验证，对

于以上退化

情况，代码1.1中

bubblesort1A()算法依然可

以正确返回

而不致出现

异常。

 重用性

从实用角度

评判不同算

法及其不同

实现方式时

，可采用的另

一标准是：算

法的总体框

架能否

便捷

地推广至其

它场合。仍以

起泡排序为

例。实际上，起

泡算法的正

确性与所处

理序列中元

素的

类型关

系不大，无论

是对于float、char或其

它类型，只要

元素之间可

以比较大小

，算法的整体

框架就依然

可以沿用。算

法模式可推

广并适用于

不同类型基

本元素的这

种特性，即是

重用性的一

种典型形式

。很遗憾，代码

1.1所实现的bubblesort1A()算

法尚不满足

这一要求；而

稍后的第2

章

和第3章，将使

包括起泡排

序在内的各

种排序算法

具有这一特

性。

1.1.5 算法效率



可计算性

相

信本书的读

者已经学习

并掌握了至

少一种高级

程序设计语

言，如C、C++或Java等。学

习

程序设计

语言的目的

，在于学会如

何编写合法

（即合乎特定

程序语言的

语法）的程序

，从而保证

编

写的程序或

者能够经过

编译和链接

生成执行代

码，或者能够

由解释器解

释执行。然而

从通过计

算

有效解决实

际问题的角

度来看，这只

是第一个层

次，仅仅做到

语法正确还

远远不够。很

遗憾，

算法所

应具备的更

多基本性质

，合法的程序

并非总是自

然具备。

以前

面提到的有

穷性为例，完

全合乎语法

的程序却往

往未必能够

满足。相信每

一位编写过

程

序的读者

都有过这样

的体验：很多

合法的程序

可以顺利编

译链接，但在

实际运行的

过程中却因

无

穷循环或

递归溢出导

致异常。更糟

糕的是，就大

量的应用问

题而言，根本

就不可能设

计出必然终

止的算法。从

这个意义讲

，它们都属于

不可解的问

题。当然，关于

此类问题的

界定和研究

，应归

入可计

算性（computability）理论的

范畴，本书将

不予过多涉

及。

§1.2 复杂度度

量

第1章 绪讳

8

 难解性

实际

上我们不仅

需要确定，算

法对任何输

入都能够在

有穷次操作

之后终止，而

且更加关注

该

过程所需

的时间。很遗

憾，很多算法

即便满足有

穷性，但在终

止之前所花

费的时间成

本却太高。

比

如，理论研究

的成果显示

，大量问题的

最低求解时

间成本，都远

远超出目前

实际系统所

能提供

的计

算能力。同样

地，此类难解

性（intractability）问题，在本

书中也不予

过多讨论。

 计

算效率

在“编

写合法程序

”这一基础之

上，本书将更

多地关注于

非“不可解和

难解”的一般

性问

题，并讨

论如何高效

率地解决这

一层面的计

算问题。为此

，首先需要确

立一种尺度

，用以从时间

和空间等方

面度量算法

的计算成本

，进而依此尺

度对不同算

法进行比较

和评判。当然

，更重要的

是

研究和归纳

算法设计与

实现过程中

的一般性规

律与技巧，以

编写出效率

更高、能够处

理更大规

模

数据的程序

。这两点既是

本书的基本

主题，也是贯

穿始终的主

体脉络。

 数据

结构

由上可

知，无论是算

法的初始输

入、中间结果

还是最终输

出，在计算机

中都可以数

据的形式

表

示。对于数据

的存储、组织

、转移及变换

等操作，不同

计算模型和

平台环境所

支持的具体

形式

不尽相

同，其执行效

率将直接影

响和决定算

法的整体效

率。数据结构

这一学科正

是以“数据”这

一信息的表

现形式为研

究对象，旨在

建立支持高

效算法的数

据信息处理

策略、技巧与

方法。要做

到

根据实际应

用需求自如

地设计、实现

和选用适当

的数据结构

，必须首先对

算法设计的

技巧以及

相

应数据结构

的特性了然

于心，这些也

是本书的重

点与难点。

§1.2 复

杂度度量

算

法的计算成

本涵盖诸多

方面，为确定

计算成本的

度量标准，我

们不妨先从

计算速度这

一主

要因素

入手。具体地

，如何度量一

个算法所需

的计算时间

呢？

1.2.1 时间复杂

度

上述问题

并不容易直

接回答，原因

在于，运行时

间是由多种

因素综合作

用而决定的

。首先，

即使是

同一算法，对

于不同的输

入所需的运

行时间并不

相同。以排序

问题为例，输

入序列的规

模、

其中各元

素的数值以

及次序均不

确定，这些因

素都将影响

到排序算法

最终的运行

时间。为针对

运

行时间建

立起一种可

行、可信的评

估标准，我们

不得不首先

考虑其中最

为关键的因

素。其中，问

题

实例的规模

往往是决定

计算成本的

主要因素。一

般地，问题规

模越接近，相

应的计算成

本也越

接近

；而随着问题

规模的扩大

，计算成本通

常也呈上升

趋势。

如此，本

节开头所提

的问题即可

转化为：随着

输入规模的

扩大，算法的

执行时间将

如何增长？

执

行时间的这

一变化趋势

可表示为输

入规模的一

个函数，称作

该算法的时

间复杂度（time

complexity）。具

体地，特定算

法处理规模

为n的问题所

需的时间可

记作T(n)。

细心的

读者可能注

意到，根据规

模并不能唯

一确定具体

的输入，规模

相同的输入

通常都有多

个，而算法对

其进行处理

所需时间也

不尽相同。仍

以排序问题

为例，由n个元

素组成的输

入序列

有n!种

，有时所有元

素都需交换

，有时却无需

任何交换（习

题[1-3]）。故严格说

来，以上定义

的T(n)并不明确

。为此需要再

做一次简化

，即从保守估

计的角度出

发，在规模为

n的所有输入

中

选择执行

时间最长者

作为T(n)，并以T(n)度

量该算法的

时间复杂度

。

第1章 绪讳 §1.2 复

杂度度量

9

1.2.2 渐

进复杂度

至

此，对于同一

问题的两个

算法A和B，通过

比较其时间

复杂度TA(n)和TB(n)，即

可评价二

者

对于同一输

入规模n的计

算效率高低

。然而，藉此还

不足以就其

性能优劣做

出总体性的

评判，

比如对

于某些问题

，一些算法更

适用于小规

模输入，而另

一些则相反

（习题[1-5]）。

幸运的

是，在评价算

法运行效率

时，我们往往

可以忽略其

处理小规模

问题时的能

力差异，转

而

关注其在处

理更大规模

问题时的表

现。其中的原

因不难理解

，小规模问题

所需的处理

时间本来

就

相对更少，故

此时不同算

法的实际效

率差异并不

明显；而在处

理更大规模

的问题时，效

率的些

许差

异都将对实

际执行效果

产生巨大的

影响。这种着

眼长远、更为

注重时间复

杂度的总体

变化趋

势和

增长速度的

策略与方法

，即所谓的渐

进分析（asymptotic analysis）。

那么

，针对足够大

的输入规模

n，算法执行时

间T(n)的渐进增

长速度，应如

何度量和评

价呢？

 大O记号

同样地出于

保守的估计

，我们首先关

注T(n)的渐进上

界。为此可引

入所谓“大O记

号”

（big-O

notation）。具体地，若

存在正的常

数c和函数f(n)，使

得对任何n >> 2都

有

T(n)

 c∙f(n)

则可认为

在n足够大之

后，f(n)给出了T(n)增

长速度的一

个渐进上界

。此时，记之为

：

T(n)

= O(f(n))

由这一定义

，可导出大O记

号的以下性

质：

(1)

对于任一

常数c > 0，有O(f(n)) =

O(c∙f(n))

(2) 对于

任意常数a >

b > 0，有

O(na

+

nb

) = O(na

)

前一性质意

味着，在大O记

号的意义下

，函数各项正

的常系数可

以忽略并等

同于1。后一性

质则意味着

，多项式中的

低次项均可

忽略，只需保

留最高次项

。可以看出，大

O记号的这些

性质

的确体

现了对函数

总体渐进增

长趋势的关

注和刻画。



环

境差异

在实

际环境中直

接测得的执

行时间T(n)，虽不

失为衡量算

法性能的一

种指标，但作

为评判

不同

算法性能优

劣的标准，其

可信度值得

推敲。事实上

，即便是同一

算法、同一输

入，在不同的

硬件平台上

、不同的操作

系统中甚至

不同的时间

，所需要的计

算时间都不

尽相同。因此

，有必要

按照

超脱于具体

硬件平台和

软件环境的

某一客观标

准，来度量算

法的时间复

杂度，并进而

评价不

同算

法的效率差

异。

 基本操作

一种自然且

可行的解决

办法是，将时

间复杂度理

解为算法中

各条指令的

执行时间之

和。在图

灵机

（Turing

Machine, TM）和随机存储

机（Random Access Machine,

RAM）等计算模

型[4]

中，指令语

句均可分解

为若干次基

本操作，比如

算术运算、比

较、分支、子程

序调用与返

回等；

而在大

多数实际的

计算环境中

，每一次这类

基本操作都

可在常数时

间内完成。

如

此，不妨将T(n)定

义为算法所

执行基本操

作的总次数

。也就是说，T(n)决

定于组成算

法

的所有语

句各自的执

行次数，以及

其中所含基

本操作的数

目。以代码1.1中

起泡排序

bubblesort1A()算

法为例，若将

该算法处理

长度为n的序

列所需的时

间记作T(n)，则按

照上述

分析

，只需统计出

该算法所执

行基本操作

的总次数，即

可确定T(n)的上

界。

§1.2

复杂度度

量 第1章 绪讳

10



起泡排序

bubblesort1A()算

法由内、外两

层循环组成

。内循环从前

向后，依次比

较各对相邻

元素，

如有必

要则将其交

换。故在每一

轮内循环中

，需要扫描和

比较n -

1对元素

，至多需要交

换n - 1

对元素。元

素的比较和

交换，都属于

基本操作，故

每一轮内循

环至多需要

执行2(n

- 1)次基本

操作。另外，根

据1.1.4节对该算

法正确性的

分析结论，外

循环至多执

行n - 1轮。因此，总

共

需要执行

的基本操作

不会超过2(n - 1)2次

。若以此来度

量该算法的

时间复杂度

，则有

T(n)

= O(2(n-1)2

)

根据大

O记号的性质

，可进一步简

化和整理为

：

T(n) = O(2n2

-

4n + 2) =

O(2n2

) = O(n2

)

 最坏、最好与

平均情况

由

上可见，以大

O记号形式表

示的时间复

杂度，实质上

是对算法执

行时间的一

种保守估计

对于规模为

n的任意输入

，算法的运行

时间都不会

超过O(f(n))。比如，“起

泡排序算法

复

杂度T(n) = O(n2

)”意味

着，该算法处

理任何序列

所需的时间

绝不会超过

O(n2

)。的确需要这

么长计算时

间的输入实

例，称作最坏

实例或最坏

情况（worst case）。

需强调

的是，这种保

守估计并不

排斥更好情

况甚至最好

情况（best case）的存在

和出现。

比如

，对于某些输

入序列，起泡

排序算法的

内循环的执

行轮数可能

少于n-1，甚至只

需执行一轮

（习题[1-3]）。当然，有

时也需要考

查所谓的平

均情况（average case），也就

是按照某种

约定的概率

分布，将规模

为n的所有输

入对应的计

算时间加权

平均。

比较而

言，“最坏情况

复杂度”是人

们最为关注

且使用最多

的，在一些特

殊的场合甚

至成为

唯一

的指标。比如

控制核电站

运转、管理神

经外科手术

室现场的系

统而言，从最

好或平均角

度评

判算法

的响应速度

都不具有任

何意义，在最

坏情况下的

响应速度才

是唯一的指

标。

 大记号

为

了对算法的

复杂度最好

情况做出估

计，需要借助

另一个记号

。如果存在正

的常数c和函

数

g(n)，使得对于

任何n >> 2都有

T(n)

 c∙g(n)

就

可以认为，在

n足够大之后

，g(n)给出了T(n)的一

个渐进下界

。此时，我们记

之为：

T(n)

= (g(n))

这里的

称作“大记号

”（big-omega notation）。与大O记号恰

好相反，大记

号是对算法

执行效率的

乐观估计对

于规模为n的

任意输入，算

法的运行时

间都不低于

(g(n))。比如，

即便在

最好情况下

，起泡排序也

至少需要T(n) = (n)的

计算时间（习

题[1-4]）。



大记号

借

助大O记号、大

记号，可以对

算法的时间

复杂度作出

定量的界定

，亦即，从渐进

的趋势

看，T(n)介

于(g(n))与O(f(n))之间。若

恰巧出现g(n) =

f(n)的

情况，则可以

使用另一记

号来表示。

如

果存在正的

常数c1 < c2和函数

h(n)，使得对于任

何n

>> 2都有

c1∙h(n) 

T(n)  c2∙h(n)

就可

以认为在n足

够大之后，h(n)给

出了T(n)的一个

确界。此时，我

们记之为：

T(n) = (h(n))

第

1章

绪讳 §1.3 复杂

度分枂

11

这里

的称作“大记

号”（big-theta notation），它是对算

法复杂度的

准确估计

对

于规模为n的

任何输入，算

法的运行时

间T(n)都与(h(n))同阶

。

图1.4

大O记号、大

记号和大记

号

以上主要

的这三种渐

进复杂度记

号之间的联

系与区别，可

直观地由图

1.4示意。

1.2.3 空间复

杂度

除了执

行时间的长

短，算法所需

存储空间的

多少也是衡

量其性能的

一个重要方

面，此即所谓

的空间复杂

度（space complexity）。实际上，以

上针对时间

复杂度所引

入的几种渐

进记号，

也适

用于对空间

复杂度的度

量，其原理及

方法基本相

同，不再赘述

。

需要注意的

是，为了更为

客观地评价

算法性能的

优劣，除非特

别申明，空间

复杂度通常

并不

计入原

始输入本身

所占用的空

间对于同一

问题，这一指

标对任何算

法都是相同

的。反之，其

它

（如转储、中转

、索引、映射、缓

冲等）各个方

面所消耗的

空间，则都应

计入。

另外，很

多时候我们

都是更多地

甚至仅仅关

注于算法的

时间复杂度

，而不必对空

间复杂度做

专门的考查

。这种简便评

测方式的依

据，来自于以

下事实：就渐

进复杂度的

意义而言，在

任一算

法的

任何一次运

行过程中所

消耗的存储

空间，都不会

多于其间所

执行基本操

作的累计次

数。

实际上根

据定义，每次

基本操作所

涉及的存储

空间，都不会

超过常数规

模；纵然每次

基本操

作所

占用或访问

的存储空间

都是新开辟

的，整个算法

所需的空间

总量，也不过

与基本操作

的次数

同阶

。从这个意义

上说，时间复

杂度本身就

是空间复杂

度的一个天

然的上界。

当

然，对空间复

杂度的分析

也有其自身

的意义，尤其

在对空间效

率非常在乎

的应用场合

中，

或当问题

的输入规模

极为庞大时

，由时间复杂

度所确立的

平凡上界已

经难以令人

满意。这类情

况

下，人们将

更为精细地

考查不同算

法的空间效

率，并尽力在

此方面不断

优化。本书的

后续章节，

将

结合一些实

际问题介绍

相关的方法

与技巧。

§1.3

复杂

度分析

在明

确了算法复

杂度的度量

标准之后，如

何分析具体

算法的复杂

度呢？1.2.2节所引

入的三

种记

号中，大O记号

是最基本的

，也是最常用

到的。从渐进

分析的角度

，大O记号将各

算法的复杂

度由低到高

划分为若干

层次级别。以

下依次介绍

若干典型的

复杂度级别

，并介绍主要

的分析方法

与技巧。读者

可参照以下

介绍的方法

，做进一步的

练习（习题[1-30]和

[1-32]）。

§1.3

复杂度分枂

第1章 绪讳

12

1.3.1

常

数O(1)

 问题与算

法

考查如下

常规元素的

选取问题，该

问题一种解

法如算法1.3所

示。

ordinaryElement(S[], n) //从n 

3个互异

整数中，除最

大、最小者以

外，仸叏一个

“常觃元素”

 仸

叏癿三个元

素x, y,

z  S; //返三个元

素亦必互异



通过比较，对

它们做排序

; //讴经排序后

，依次重命名

为：a < b

< c

 输出b;

算法

1.3 叏非枀端元

素

该算法的

正确性不言

而喻，但它需

要运行多少

时间？与输入

的规模n有何

联系？



复杂度

既然S是有限

集，故其中的

最大、最小元

素各有且仅

有一个。因此

，无论S的规模

有多大，

在任

意三个元素

中至少都有

一个是非极

端元素。不妨

取前三个元

素x = S[0]、y

= S[1]和z =

S[2]，这一步

只需执行三

次（从特定单

元读取元素

的）基本操作

，耗费O(3)时间。接

下来，为

确定

这三个元素

的大小次序

，最多需要做

三次比较（习

题[2-37]），也需O(3)时间

。最后，输

出居

中的非极端

元素只需O(1)时

间。因此综合

起来，算法1.3的

运行时间为

：

T(n)

= O(3) + O(3)

+ O(1) = O(7)

= O(1)

运行时间可

表示和度量

为T(n) =

O(1)的这一类

算法，统称作

“常数时间复

杂度算法”

（constant-time algorithm）。此

类算法已是

最为理想的

，因为不可能

奢望“不劳而

获”。

一般地，仅

含一次或常

数次基本操

作的算法（如

算法1.1和算法

1.2）均属此类。此

类算法

通常

不含循环、分

支、子程序调

用等，但也不

能仅凭语法

结构的表面

形式一概而

论（习题[1-7]）。

采用

1.2.3节的分析方

法不难看出

，除了输入数

组等参数之

外，该算法仅

需常数规模

的辅助

空间

。此类仅需O(1)辅

助空间的算

法，亦称作就

地算法（in-place algorithm）。

1.3.2 对数

O(logn)

 问题与算法

考查如下问

题：对于任意

非负整数，统

计其二进制

展开中数位

1的总数。

该问

题的一个算

法可实现如

代码1.2所示。

该

算法使用一

个计数器ones记

录数位1的数

目，

其初始值

为0。随后进入

一个循环：通

过二进制

位

的与（and）运算，检

查n的二进制

展开的最

低

位，若该位为

1则累计至ones。由

于每次循环

都将n的二进

制展开右移

一位，故整体

效果等同

于

逐个检验所

有数位是否

为1，该算法的

正确性

也不

难由此得证

。

以n

= 441(10) = 110111001(2)为例，

采用

以上算法，变

量n与计数器

ones在计算过程

中的演变过

程如表1.1所示

。

表1.1 countOnes(441)癿执行过

秳

十

迕 刢 事

迕 刢

数位1计

数

441 110111001 0

220 11011100 1

110

1101110 1

55 110111

27 11011 2

13

1101 3

6 110

4

3 11 4

1 1 5

0

0 6

第1章 绪讳

§1.3

复杂度分枂

13

1 int countOnes

( unsigned int n

) { //统计整数二

迕刢展开中

数位1癿总数

：O(logn)

2

int ones = 0;

//计数器复位

3 while ( 0

< n ) {

//在n缩减至0乀

前，反复地

4 ones +=

( 1 & n

); //检

查最低位，若

为1则计数

5 n

>>= 1; //右

秱一位

6

}

7 return ones;

//迒回

计数

8 } //等效亍

glibc癿内置函数

int

__builtin_popcount (unsigned int n)

代码1.2 整数事

迕刢展开中

数位1总数癿

统计

 复杂度

根据右移运

算的性质，每

右移一位，n都

至少缩减一

半。也就是说

，至多经过1

+ log2n

次

循环，n必然缩

减至0，从而算

法终止。实际

上从另一角

度来看，1 +

log2n恰为

n二进制展开

的总位数，每

次循环都将

其右移一位

，总的循环次

数自然也应

是1 + log2n。后一解释

，也可

以从表

1.1中n的二进制

展开一列清

晰地看出。

无

论是该循环

体之前、之内

还是之后，均

只涉及常数

次（逻辑判断

、位与运算、加

法、右移

等）基

本操作。因此

，countOnes()算法的执行

时间主要由

循环的次数

决定，亦即：

O(1 +

log2n) = O(log2n) =

O(log2n)

由

大O记号定义

，在用函数logrn界

定渐进复杂

度时，常底数

r的具体取值

无所谓（习题

[1-8]），故通常不予

专门标出而

笼统地记作

logn。比如，尽管此

处底数为常

数2，却可直接

记

作O(logn)。此类算

法称作具有

“对数时间复

杂度”（logarithmic-time algorithm）。

实际上

，代码1.2中的countOnes()算

法仍有巨大

的改进余地

（习题[1-12]）。

 对数多

项式复杂度

更一般地，凡

运行时间可

以表示和度

量为T(n) =

O(logc

n)形式的

这一类算法

（其中常数c >

0），均

统称作“对数

多项式时间

复杂度的算

法”（polylogarithmic-time algorithm）。上

述O(logn)即c =

1的

特例。此类算

法的效率虽

不如常数复

杂度算法理

想，但从多项

式的角度看

仍能无限接

近于后者（习

题[1-9]），故也是极

为高效的一

类算法。

1.3.3 线性

O(n)



问题与算法

考查如下问

题：计算给定

n个整数的总

和。该问题可

由代码1.3中的

算法sumI()解决。

1 int sumI

( int A[], int

n ) { //数

组求和算法

（迭代版）

2 int sum =

0; //刜始

化累计器，O(1)

3 for

( int i =

0; i < n;

i++ ) //对

全部共O(n)个元

素，逐一

4

sum += A[i]; //累计

，O(1)

5 return sum; //迒回累计值

，O(1)

6 } //O(1) +

O(n)*O(1) + O(1) =

O(n+2) = O(n)

代码1.3

数组元

素求和算法

sumI()

§1.3 复杂度分枂

第1章 绪讳

14

 复

杂度

sumI()算法的

正确性一目

了然，它需要

运行多少时

间呢？

首先，对

s的初始化需

要O(1)时间。算法

的主体部分

是一个循环

，每一轮循环

中只需进行

一

次累加运

算，这属于基

本操作，可在

O(1)时间内完成

。每经过一轮

循环，都将一

个元素累加

至s，

故总共需

要做n轮循环

，于是该算法

的运行时间

应为：

O(1)

+ O(1)n = O(n

+ 1) = O(n)

凡运行

时间可以表

示和度量为

T(n) = O(n)形式的这一

类算法，均统

称作“线性时

间复杂

度算

法”（linear-time

algorithm）。比如，算法

1.2只需略加修

改，即可解决

“n等分给定

线

段”问题，这个

通用版本相

对于输入n就

是一个线性

时间复杂度

的算法。

也就

是说，对于输

入的每一单

元，此类算法

平均消耗常

数时间。就大

多数问题而

言，在对输

入

的每一单元

均至少访问

一次之前，不

可能得出解

答。以数组求

和为例，在尚

未得知每一

元素的

具体

数值之前，绝

不可能确定

其总和。故就

此意义而言

，此类算法的

效率亦足以

令人满意。

1.3.4 多

项式O(polynomial(n))

若运行

时间可以表

示和度量为

T(n)

= O(f(n))的形式，而且

f(x)为多项式，则

对应的算法

称作“多项式

时间复杂度

算法”（polynomial-time algorithm）。比如根

据1.2.2节的分析

，

1.1.3节所实现起

泡排序bubblesort1A()算法

的时间复杂

度应为T(n)

= O(n2

)，故该

算法即属

于

此类。当然，以

上所介绍的

线性时间复

杂度算法，也

属于多项式

时间复杂度

算法的特例

，其中

线性多

项式f(n) = n的次数

为1。

在算法复

杂度理论中

，多项式时间

复杂度被视

作一个具有

特殊意义的

复杂度级别

。多项式级

的

运行时间成

本，在实际应

用中一般被

认为是可接

受的或可忍

受的。某问题

若存在一个

复杂度在

此

范围以内的

算法，则称该

问题是可有

效求解的或

易解的（tractable）。

请注

意，这里仅要

求多项式的

次数为一个

正的常数，而

并未对其最

大取值范围

设置任何具

体

上限，故实

际上该复杂

度级别涵盖

了很大的一

类算法。比如

，从理论上讲

，复杂度分别

为O(n2

)

和O(n2012

)算法都

同属此类，尽

管二者实际

的计算效率

有天壤之别

。之所以如此

，是因为相对

于

以下的指

数级复杂度

，二者之间不

超过多项式

规模的差异

只是小巫见

大巫。

1.3.5 指数O(2n

)



问

题与算法

考

查如下问题

：在禁止超过

1位的移位运

算的前提下

，对任意非负

整数n，计算幂

2

n。

1

__int64 power2BF_I ( int

n ) { //幂函数2^n算法

（蛮力迭代版

），n

>= 0

2 __int64

pow = 1; //O(1)：累积器刜始

化为2^0

3 while ( 0

< n -- )

//O(n)：迭代n轮

，殏轮都

4 pow <<=

1; //O(1)：将累

积器翻倍

5 return

pow; //O(1)：迒

回累积器

6 }

//O(n) = O(2^r)，r为

输入指数n癿

比特位数

代

码1.4

幂函数算

法（蛮力迭代

版）

第1章 绪讳

§1.3 复杂度分枂

15

 复杂度

如代

码1.4所示的算

法power2BF_I()由n轮迭代

组成，各需做

一次累乘和

一次递减，均

属于

基本操

作，故整个算

法共需O(n)时间

。若以输入指

数n的二进制

位数r

= 1 + log2n作为输

入

规模，则运

行时间为O(2r

)。稍

后在1.4.3节我们

将看到，该算

法仍有巨大

的改进余地

。

一般地，凡运

行时间可以

表示和度量

为T(n) =

O(an

)形式的算

法（a > 1），均属于“指

数时间复杂

度算法”（exponential-time

algorithm）。

 从多

项式到指数

从常数、对数

、线性、平方到

多项式时间

复杂度，算法

效率的差异

还在可接受

的范围。然而

，

在多项式与

指数时间复

杂度之间，却

有着一道巨

大的鸿沟。当

问题规模较

大后，指数复

杂度算法

的

实际效率将

急剧下降，计

算时间之长

很快就会达

到令人难以

忍受的地步

。因此通常认

为，指数

复杂

度算法无法

真正应用于

实际问题中

，它们不是有

效算法，甚至

不能称作算

法。相应地，不

存

在多项式

复杂度算法

的问题，也称

作难解的（intractable）问

题。

需注意的

是，在问题规

模不大时，指

数复杂度反

而可能在较

长一段区间

内均低于多

项式复杂

度

。比如，在1  n 

116,690以内

，指数复杂度

1.0001n反而低于多

项式复杂度

n

1.0001；但前

者迟早

必然超越后

者，且随着n的

进一步增大

，二者的差距

无法保持在

多项式倍的

范围。因此，

从

渐进复杂度

的角度看，多

项式与指数

是无法等量

齐观的两个

截然不同的

量级。

实际上

很遗憾，绝大

多数计算问

题并不存在

多项式时间

的算法（习题

[1-16]、[1-23]和

[1-27]），也就是说

，试图求解此

类问题的任

一算法，都至

少需要运行

指数量级的

时间。特别

地

，很多问题甚

至需要无穷

的时间，由于

有穷性不能

满足或者尚

未得到证明

（习题[1-29]），

也可以

说不存在解

决这些问题

的算法。不过

，这类问题均

不属于本书

的讨论范围

。

1.3.6 复杂度层次

图1.5 复杂度癿

典型局次：(1)~(7)依

次为O(logn)、O( n)、O(n)、O(nlogn)、O(n2

)、O(n3

)和O(2n

)

利用

大O记号，不仅

可以定量地

把握算法复

杂度的主要

部分，而且可

以定性地由

低至高将复

杂度划分为

若干层次。典

型的复杂度

层次包括O(1)、O(log*

n)、O(loglogn)、O(logn)、

O(sqrt(n))、O(n)、O(nlog*

n)、O(nloglogn)、O(nlogn)、O(n2

)、O(n3

)、O(nc

)、O(2n

)

等

，图1.5绘出了其

中七个层次

复杂度函数

对应的渐进

增长趋势。

§1.4 *逑

弻 第1章 绪讳

16

请注意，在图

1.5的左图中，层

次(7)的2

n显得比

层次(6)的n

3更低

，但这只是在

问题规模n

较

小时的暂时

现象。从覆盖

更大范围的

右图可以看

出，当问题规

模不小于10之

后，层次(7)的复

杂度将远远

高于层次(6)。另

外，右图还采

用了双对数

坐标，将层次

(6)、(5)、(3)和(2)表示

为直

线，从而更为

清晰地显示

出各层次之

间的高低关

系。

1.3.7 输入规模

对算法复杂

度的界定，都

是相对于问

题的输入规

模而言的。然

而，细心的读

者可能已经

注意

到，不同

的人在不同

场合下关于

“输入规模”的

理解、定义和

度量可能不

尽相同，因此

也可能导

致

复杂度分析

的结论有所

差异。比如，1.3.2节

中关于“countOnes()算法

的复杂度为

O(logn)”

的结论，是相

对于输入整

数本身的数

值n而言；而若

以n二进制展

开的宽度r = 1

+ log2n

作

为输入规模

，则应为线性

复杂度O(r)。再如

，1.3.5节中关于“power2BF_I()算

法的复杂度

为O(2r

)”的结论，是

相对于输入

指数n的二进

制数位r而言

；而若以n本身

的数值作为

输入规模，

却

应为线性复

杂度O(n)。

严格地

说，所谓待计

算问题的输

入规模，应严

格定义为“用

以描述输入

所需的空间

规模”。

因此就

上述两个例

子而言，将输

入参数n二进

制展开的宽

度r作为输入

规模更为合

理。也就是说

，

将这两个算

法的复杂度

界定为O(r)和O(2

r

)更

妥。对应地，以

输入参数n本

身的数值作

为基准而

得

出的O(logn)和O(n)复杂

度，则应分别

称作伪对数

的（pseudo-logarithmic）和伪线性

的

（pseudo-linear）复杂度。

§1.4 

*递

归

分支转向

是算法的灵

魂；函数和过

程及其之间

的相互调用

，是在经过抽

象和封装之

后，实现

分支

转向的一种

重要机制；而

递归则是函

数和过程调

用的一种特

殊形式，即允

许函数和过

程进行

自我

调用。因其高

度的抽象性

和简洁性，递

归已成为多

数高级程序

语言普遍支

持的一项重

要特性。

比如

在C++语言中，递

归调用（recursive call）就是

某一方法调

用自身。这种

自我调用通

常

是直接的

，即在函数体

中包含一条

或多条调用

自身的语句

。递归也可能

以间接的形

式出现，即某

个方法首先

调用其它方

法，再辗转通

过其它方法

的相互调用

，最终调用起

始的方法自

身。

递归的价

值在于，许多

应用问题都

可简洁而准

确地描述为

递归形式。以

操作系统为

例，多数

文件

系统的目录

结构都是递

归定义的。具

体地，每个文

件系统都有

一个最顶层

的目录，其中

可以

包含若

干文件和下

一层的子目

录；而在每一

子目录中，也

同样可能包

含若干文件

和再下一层

的子

目录；如

此递推，直至

不含任何下

层的子目录

。通过如此的

递归定义，文

件系统中的

目录就可以

根据实际应

用的需要嵌

套任意多层

（只要系统的

存储资源足

以支持）。

递归

也是一种基

本而典型的

算法设计模

式。这一模式

可以对实际

问题中反复

出现的结构

和形

式做高

度概括，并从

本质层面加

以描述与刻

画，进而导出

高效的算法

。从程序结构

的角度看，递

归模式能够

统筹纷繁多

变的具体情

况，避免复杂

的分支以及

嵌套的循环

，从而更为简

明地描述和

实现算法，减

少代码量，提

高算法的可

读性，保证算

法的整体效

率。

以下将从

递归的基本

模式入手，循

序渐进地介

绍如何选择

和应用（线性

递归、二分递

归和多

分支

递归等）不同

的递归形式

，以实现（遍历

、分治等）算法

策略，以及如

何利用递归

跟踪和递

推

方程等方法

分析递归算

法的复杂度

。

第1章 绪讳

§1.4 *逑

弻

17

1.4.1

线性递归

 数组求和

仍

以1.3.3节的数组

求和问题为

例。易见，若n =

0则

总和必为0，这

也是最终的

平凡情况；

否

则一般地，总

和可理解为

前n - 1个整数（A[0,

n - 1)）之

和，再加上末

元素（A[n -

1]）。

按这一

思路，可基于

线性递归模

式，设计出另

一sum()算法如代

码1.5所示。

1 int

sum ( int A[],

int n ) {

//数组

求和算法（线

性逑弻版）

2 if (

1 > n )

//平

凡情冴，逑弻

基

3 return 0;

//直接（非逑

弻式）计算

4 else //一

般情冴

5 return sum (

A, n - 1

) + A[n -

1]; //逑弻

：前n - 1项乀和，再

累计第n

- 1项

6 }

//O(1)*逑

弻深度 = O(1)*(n +

1) = O(n)

代码

1.5

数组求和算

法（线性递归

版）

由此实例

，可以看出保

证递归算法

有穷性的基

本技巧：首先

判断并处理

n = 0之类的平凡

情

况，以免因

无限递归而

导致系统溢

出。这类平凡

情况统称“递

归基”（base case of recursion）。

平凡情

况可能有多

种，但至少要

有一种（比如

此处），且迟早

必然会出现

。

 线性递归

算

法sum()可能朝着

更深一层进

行自我调用

，且每一递归

实例对自身

的调用至多

一次。于是，

每

一层次上至

多只有一个

实例，且它们

构成一个线

性的次序关

系。此类递归

模式因而称

作“线性

递归

”（linear recursion），它也是递归

的最基本形

式。

这种形式

中，应用问题

总可分解为

两个独立的

子问题：其一

对应于单独

的某个元素

，故可直

接求

解（比如A[n - 1]）；另一

个对应于剩

余部分，且其

结构与原问

题相同（比如

A[0, n

- 1)）。

另外，子问题

的解经简单

的合并（比如

整数相加）之

后，即可得到

原问题的解

。



减而治之

线

性递归的模

式，往往对应

于所谓减而

治之（decrease-and-conquer）的算法

策略：递归

每

深入一层，待

求解问题的

规模都缩减

一个常数，直

至最终蜕化

为平凡的小

（简单）问题。

按

照减而治之

策略，此处随

着递归的深

入，调用参数

将单调地线

性递减。因此

无论最初输

入

的n有多大

，递归调用的

总次数都是

有限的，故算

法的执行迟

早会终止，即

满足有穷性

。当抵达

递归

基时，算法将

执行非递归

的计算（这里

是返回0）。

1.4.2 递归

分析

递归算

法时间和空

间复杂度的

分析与常规

算法很不一

样，有其自身

的规律和特

定的技巧，以

下介绍递归

跟踪与递推

方程这两种

主要的方法

。

 递归跟踪

作

为一种直观

且可视的方

法，递归跟踪

（recursion

trace）可用以分析

递归算法的

总体

运行时

间与空间。具

体地，就是按

照以下原则

，将递归算法

的执行过程

整理为图的

形式：

 算法的

每一递归实

例都表示为

一个方框，其

中注明了该

实例调用的

参数

 若实例

M调用实例N，则

在M与N对应的

方框之间添

加一条有向

联线

§1.4 *逑弻

第

1章 绪讳

18

按上

述约定，代码

1.5中sum()算法的递

归跟踪如图

1.6所示。其中，sum()算

法的每一递

归

实例分别

对应于一个

方框，并标有

相应的调用

参数。每发生

一次递归调

用，就从当前

实例向下引

出一条有向

边，指向下层

对应于新实

例的方框。

图

1.6 对sum(A, 5)癿递归跟

踪分枂

该图

清晰地给出

了算法执行

的整个过程

：首先对参数

n进行调用，再

转向对参数

n - 1的调

用，再转

向对参数n

- 2的

调用，...，直至最

终的参数0。在

抵达递归基

后不再递归

，而是将平

凡

的解（长度为

0数组的总和

0）返回给对参

数1的调用；累

加上A[0]之后，再

返回给对参

数2的

调用；累

加上A[1]之后，继

续返回给对

参数3的调用

；...；如此依次返

回，直到最终

返回给对

参

数n的调用，此

时，只需累加

A[n - 1]即得到整个

数组的总和

。

从图1.6可清楚

地看出，整个

算法所需的

计算时间，应

该等于所有

递归实例的

创建、执行和

销毁所需的

时间总和。其

中，递归实例

的创建、销毁

均由操作系

统负责完成

，其对应的时

间成本

通常

可以近似为

常数，不会超

过递归实例

中实质计算

步骤所需的

时间成本，故

往往均予忽

略。为

便于估

算，启动各实

例的每一条

递归调用语

句所需的时

间，也可以计

入被创建的

递归实例的

账上，

如此我

们只需统计

各递归实例

中非递归调

用部分所需

的时间。

具体

地，就以上的

sum()算法而言，每

一递归实例

中非递归部

分所涉及的

计算无非三

类（判

断n是否

为0、累加sum(n - 1)与A[n -

1]、返

回当前总和

），且至多各执

行一次。鉴于

它们均

属于

基本操作，每

个递归实例

实际所需的

计算时间都

应为常数O(3)。由

图1.6还可以看

出，对于

长度

为n的输入数

组，递归深度

应为n +

1，故整个

sum()算法的运行

时间为：

(n + 1)

 O(3) = O(n)

那么

，sum()算法的空间

复杂度又是

多少呢？由图

1.6不难看出，在

创建了最后

一个递归实

例（即到达递

归基）时，占用

的空间量达

到最大准确

地说，等于所

有递归实例

各自所占空

间

量的总和

。这里每一递

归实例所需

存放的数据

，无非是调用

参数（数组A的

起始地址和

长度n）以

及用

于累加总和

的临时变量

。这些数据各

自只需常数

规模的空间

，其总量也应

为常数。故此

可知，

sum()算法的

空间复杂度

线性正比于

其递归的深

度，亦即O(n)。

第1章

绪讳 §1.4 *逑弻

19

 递

推方程

递归

算法的另一

常用分析方

法，即递推方

程（recurrence equation）法。与递归

跟踪分

析相

反，该方法无

需绘出具体

的调用过程

，而是通过对

递归模式的

数学归纳，导

出复杂度定

界函

数的递

推方程（组）及

其边界条件

，从而将复杂

度的分析，转

化为递归方

程（组）的求解

。

在总体思路

上，该方法与

微分方程法

颇为相似：很

多复杂函数

的显式表示

通常不易直

接获得，

但是

它们的微分

形式却往往

遵循某些相

对简洁的规

律，通过求解

描述这些规

律的一组微

分方程，

即可

最终导出原

函数的显式

表示。微分方

程的解通常

并不唯一，除

非给定足够

多的边界条

件。类

似地，为

使复杂度定

界函数的递

推方程能够

给出确定的

解，也需要给

定某些边界

条件。以下我

们

将看到，这

类边界条件

往往可以通

过对递归基

的分析而获

得。

仍以代码

1.5

中线性递归

版sum()算法为例

，将该算法处

理长度为n的

数组所需的

时间成本

记

作T(n)。我们将该

算法的思路

重新表述如

下：为解决问

题sum(A, n)，需递归地

解决问题sum(A,

n - 1)，然

后累加上A[n -

1]。按

照这一新的

理解，求解sum(A, n)所

需的时间，应

该等于求

解

sum(A, n

- 1)所需的时间

，另加一次整

数加法运算

所需的时间

。

根据以上分

析，可以得到

关于T(n)的如下

一般性的递

推关系：

T(n)

= T(n - 1)

+ O(1) = T(n

- 1) + c1，

其中

c1为常数

另一

方面，当递归

过程抵达递

归基时，求解

平凡问题sum(A, 0)只

需（用于直接

返回0的）

常数

时间。如此，即

可获得如下

边界条件：

T(0) = O(1) =

c2， 其

中c2为常数

联

立以上两个

方程，最终可

以解得：

T(n)

= c1n + c2

= O(n)

这一

结论与递归

跟踪分析殊

途同归。

另外

，运用以上方

法，同样也可

以界定sum()算法

的空间复杂

度（习题[1-18]）。

1.4.3 递归

模式

 多递归

基

为保证有

穷性，递归算

法都必须设

置递归基，且

确保总能执

行到。为此，针

对每一类可

能出

现的平

凡情况，都需

设置对应的

递归基，故同

一算法的递

归基可能（显

式或隐式地

）不止一个。

以

下考查数组

倒置问题，也

就是将数组

中各元素的

次序前后翻

转。比如，若输

入数组为：

A[]

= { 3, 1,

4, 1, 5, 9,

2, 6 }

则

倒置后为：

A[] = { 6,

2, 9, 5, 1,

4, 1, 3 }

这

里先介绍该

问题的一个

递归版算法

，1.4.4节还将介绍

另一等效的

迭代版算法

。无论何种

实

现，均由如下

reverse()函数作为统

一的启动入

口。

1 void

reverse ( int*, int,

int ); //重载癿倒

置算法原型

2 void

reverse ( int* A,

int n ) //数组倒置（算

法癿刜始入

口，调用癿可

能是reverse()癿逑弻

版戒迭代版

）

3 { reverse (

A, 0, n -

1 ); } //由重载癿入

口启劢逑弻

戒迭代算法

代码1.6

数组倒

置算法癿统

一入口

§1.4 *逑弻

第1章 绪讳

20

借

助线性递归

不难解决这

一问题，为此

只需注意到

并利用如下

事实：为得到

整个数组的

倒置，

可以先

对换其首、末

元素，然后递

归地倒置除

这两个元素

以外的部分

。按照这一思

路，可实现如

代码1.7所示的

算法。通过递

归跟踪可以

证明（习题[1-31]），其

时间复杂度

为O(n)。

1

void reverse ( int*

A, int lo, int

hi ) { //数组倒置

（夗逑弻基逑

弻版）

2 if ( lo

< hi ) {

3 swap ( A[lo],

A[hi] ); //交换A[lo]和

A[hi]

4

reverse ( A, lo

+ 1, hi -

1 ); //逑弻倒置A(lo, hi)

5 } //else隐

含了两种逑

弻基

6

} //O(hi - lo

+ 1)

代码1.7 数

组倒置癿递

归算法

 实现

递归

在设计

递归算法时

，往往需要从

多个角度反

复尝试，方能

确定对问题

的输入及其

规模的最佳

划分方式。有

时，还可能需

要从不同的

角度重新定

义和描述原

问题，使得经

分解所得的

子问题与

原

问题具有相

同的语义形

式。

例如，在代

码1.7线性递归

版reverse()算法中，通

过引入参数

lo和hi，使得对全

数组以及

其

后各子数组

的递归调用

都统一为相

同的语法形

式。另外，还利

用C++的函数重

载（overload）

机制定义

了名称相同

、参数表有别

的另一函数

reverse(A, n)，作为统一的

初始入口。

 多

向递归

递归

算法中，不仅

递归基可能

有多个，递归

调用也可能

有多种可供

选择的分支

。以下的简单

实例中，每一

递归实例虽

有多个可能

的递归方向

，但只能从中

选择其一，故

各层次上的

递归实例

依

然构成一个

线性次序关

系，这种情况

依然属于线

性递归。至于

一个递归实

例可能执行

多次递归

调

用的情况，稍

后将于1.4.5节再

做介绍。

再次

讨论1.3.5节中，计

算幂函数power(2, n) =

2^n的

问题。按照线

性递归的构

思，该

函数可

以重新定义

和表述如下

：

power2(n) =





1 （若n

= 0）

2∙power2(n-1) （否则）

由此

不难直接导

出一个线性

递归的算法

，其复杂度与

代码1.4中蛮力

的power2BF_I()算法

完全

一样，总共需

要做O(n)次递归

调用（习题[1-13]）。但

实际上，若能

从其它角度

分析该函

数

并给出新的

递归定义，完

全可以更为

快速地完成

幂函数的计

算。以下就是

一例：

power2(n)

=









1 （若n =

0）

power2(n/2)

2



2 （若n > 0且

为奇数）

power2(n/2)

2 （若n >

0且

为偶数）

按照

这一新的表

述和理解，可

按二进制展

开n之后的各

比特位，通过

反复的平方

运算和加倍

运算得到power2(n)。比

如：

2^1 =

2^001(2) = (2^2^2)0



(2^2)0

 2

1

= (((1  2

0

)^2  2

0

)^2  2

1

)

2^2 =

2^010(2) = (2^2^2)0



(2^2)1

 2

0

= (((1  2

0

)^2  2

1

)^2  2

0

)

2^3 =

2^011(2) = (2^2^2)0



(2^2)1

 2

1

= (((1  2

0

)^2  2

1

)^2  2

1

)

第1章 绪讳

§1.4

*逑弻

21

2^4 =

2^100(2) = (2^2^2)1



(2^2)0

 2

0

= (((1  2

1

)^2  2

0

)^2  2

0

)

2^5 =

2^101(2) = (2^2^2)1



(2^2)0

 2

1

= (((1  2

1

)^2  2

0

)^2  2

1

)

2^6 =

2^110(2) = (2^2^2)1



(2^2)1

 2

0

= (((1  2

1

)^2  2

1

)^2  2

0

)

2^7 =

2^111(2) = (2^2^2)1



(2^2)1

 2

1

= (((1  2

1

)^2  2

1

)^2  2

1

)

...

一般地

，若n的二进制

展开式为b1b2b3...bk，则

有

2^n = (...(((1 

2

b1)^2  2

b2)^2  2

b3)^2

...  2

bk

)

若nk-1和nk的二

进制展开式

分别为b1b2...bk-1和b1b2...bk-1bk，则

有

2^nk =

(2^nk-1)^2  2

bk

由此可以

归纳得出如

下递推式：

power2(nk) =





power2(nk-1)^2  2

（若

bk = 1）

power2(nk-1)^2

（若bk = 0）

基于这一

递推式，即可

如代码1.8所示

，实现幂函数

的多向递归

版本power2()：

1 inline __int64 sqr

( __int64 a )

{ return a *

a; }

2 __int64

power2 ( int n

) { //幂函数

2^n算法（优化逑

弻版），n >=

0

3 if (

0 == n )

return 1; //逑弻基

；否则，规n癿奇

偶分删逑弻

4 return

( n & 1

) ? sqr (

power2 ( n >>

1 ) ) <<

1 : sqr (

power2 ( n >>

1 ) );

5

} //O(logn) = O(r)，r为输入指数

n癿比特位数

代码1.8

优化癿

幂函数算法

（线性递归版

）

针对输入参

数n为奇数或

偶数的两种

可能，这里分

别设有不同

的递归方向

。尽管如此，每

个

递归实例

都只能沿其

中的一个方

向深入到下

层递归，整个

算法的递归

跟踪分析图

的拓扑结构

仍然

与图1.6类

似，故依然属

于线性递归

。可以证明（习

题[1-31]），该算法的

时间复杂度

为：

O(logn)  O(1) =

O(r)

与此前代

码1.4中蛮力版

本的O(n) = O(2r

)相比，计

算效率得到

了极大提高

。

1.4.4 递归消除

由

上可见，按照

递归的思想

可使我们得

以从宏观上

理解和把握

应用问题的

实质，深入挖

掘和

洞悉算

法过程的主

要矛盾和一

般性模式，并

最终设计和

编写出简洁

优美且精确

紧凑的算法

。然而，

递归模

式并非十全

十美，其众多

优点的背后

也隐含着某

些代价。

 空间

成本

首先，从

递归跟踪分

析的角度不

难看出，递归

算法所消耗

的空间量主

要取决于递

归深度（习

题

[1-17]），故较之同一

算法的迭代

版，递归版往

往需耗费更

多空间，并进

而影响实际

的运行

速度

。另外，就操作

系统而言，为

实现递归调

用需要花费

大量额外的

时间以创建

、维护和销毁

各

递归实例

，这些也会令

计算的负担

雪上加霜。有

鉴于此，在对

运行速度要

求极高、存储

空间需精

打

细算的场合

，往往应将递

归算法改写

成等价的非

递归版本。

一

般的转换思

路，无非是利

用栈结构（第

4章）模拟操作

系统的工作

过程。这类的

通用方法

已

超出本书的

范围，以下仅

针对一种简

单而常见的

情况，略作介

绍。

§1.4

*逑弻 第1章

绪讳

22



尾递归

及其消除

在

线性递归算

法中，若递归

调用在递归

实例中恰好

以最后一步

操作的形式

出现，则称作

尾递

归（tail recursion）。比如

代码1.7中reverse(A,

lo, hi)算法

的最后一步

操作，是对去

除了首、末元

素之后总长

缩减两个单

元的子数组

进行递归倒

置，即属于典

型的尾递归

。实际上，

属于

尾递归形式

的算法，均可

以简捷地转

换为等效的

迭代版本。

仍

以代码1.7中reverse(A,

lo, hi)算

法为例。如代

码1.9所示，首先

在起始位置

插入一

个跳

转标志next，然后

将尾递归语

句调用替换

为一条指向

next标志的跳转

语句。

1

void reverse ( int*

A, int lo, int

hi ) { //数组倒

置（直接改造

而得癿迭代

版）

2 next: //算法起始

位置添加跳

转标志

3

if ( lo <

hi ) {

4

swap ( A[lo], A[hi]

); //交换

A[lo]和A[hi]

5 lo++;

hi--; //收缩待倒

置匙间

6 goto

next; //跳转

至算法体癿

起始位置，迭

代地倒置A(lo, hi)

7

} //else隐

含了迭代癿

终止

8 }

//O(hi - lo +

1)

代码1.9 由

递归版改造

而得癿数组

倒置算法（迭

代版）

新的迭

代版与原递

归版功能等

效，但其中使

用的goto语句有

悖于结构化

程序设计的

原则。

这一语

句虽仍不得

不被C++等高级

语言保留，但

最好还是尽

力回避。为此

可如代码1.10所

示，将

next标志与

if判断综合考

查，并代之以

一条逻辑条

件等价的while语

句。

1 void

reverse ( int* A,

int lo, int hi

) { //数组倒置

（觃范整理乀

后癿迭代版

）

2

while ( lo <

hi ) //用while替换跳转

标志和if，完全

等效

3

swap ( A[lo++], A[hi--]

); //交换A[lo]和

A[hi]，收缩待倒置

匙间

4 }

//O(hi - lo +

1)

代码1.10 迕

一步调整代

码1.9癿结极，消

除goto语句

请注

意，尾递归的

判断应依据

对算法实际

执行过程的

分析，而不仅

仅是算法外

在的语法形

式。

比如，递归

语句出现在

代码体的最

后一行，并不

见得就是尾

递归；严格地

说，只有当该

算法（除

平凡

递归基外）任

一实例都终

止于这一递

归调用时，才

属于尾递归

。以代码1.5中线

性递归版sum()

算

法为例，尽管

从表面看似

乎最后一行

是递归调用

，但实际上却

并非尾递归

实质的最后

一次

操作是

加法运算。有

趣的是，此类

算法的非递

归化转换方

法仍与尾递

归如出一辙

，相信读者不

难

将其改写

为类似于代

码1.3中sumI()算法的

迭代版本。

1.4.5 二

分递归



分而

治之

面对输

入规模庞大

的应用问题

，每每感慨于

头绪纷杂而

无从下手的

你，不妨从先

哲孙子的名

言中获取灵

感“凡治众如

治寡，分数是

也”。是的，解决

此类问题的

有效方法之

一，就是将

其

分解为若干

规模更小的

子问题，再通

过递归机制

分别求解。这

种分解持续

进行，直到子

问题规

模缩

减至平凡情

况。这也就是

所谓的分而

治之（divide-and-conquer）策略。

第

1章 绪讳 §1.4 *逑弻

23

与减而治之

策略一样，这

里也要求对

原问题重新

表述，以保证

子问题与原

问题在接口

形式上

的一

致。既然每一

递归实例都

可能做多次

递归，故称作

“多路递归”（multi-way recursion）。

通

常都是将原

问题一分为

二，故称作“二

分递归”（binary

recursion）。需强

调的是，无论

是分解为两

个还是更大

常数个子问

题，对算法总

体的渐进复

杂度并无实

质影响。

 数组

求和

以下就

采用分而治

之的策略，按

照二分递归

的模式再次

解决数组求

和问题。新算

法的思路是

：

以居中的元

素为界将数

组一分为二

；递归地对子

数组分别求

和；最后，子数

组之和相加

即为原数

组

的总和。具体

过程可描述

如代码1.11，算法

入口的调用

形式为sum(A, 0, n)。

1 int sum (

int A[], int lo,

int hi ) {

//数组

求和算法（二

分逑弻版，入

口为sum(A, 0, n -

1)）

2 if (

lo == hi )

//如遇逑

弻基（匙间长

度已降至1），则

3 return A[lo]; //直接迒回诠

元素

4 else { //否则（一

般情冴下lo

< hi），则

5 int mi

= ( lo +

hi ) >> 1;

//以屁中单元

为界，将原匙

间一分为二

6 return sum (

A, lo, mi )

+ sum ( A,

mi + 1, hi

); //逑弻对各子

数组求和，然

后合计

7 }

8 } //O(hi -

lo + 1)，线性

正比亍匙间

癿长度

代码

1.11

通过事分递

归计算数组

元素乊和

该

算法的正确

性无需解释

。为分析其复

杂度，不妨只

考查n = 2^m形式的

长度。

图1.7 对sum(A, 0, 7)癿

递归跟踪分

枂

图1.7针对n = 8的

情况给出了

sum(A, 0,

7)执行过程的

递归跟踪。其

中各方框都

标注有对

应

的lo和hi值，即子

数组区间的

起、止单元。可

见，按照调用

的关系及次

序，该方法的

所有实

例构

成一个层次

结构（即第5章

将介绍的二

叉树）。沿着这

个层次结构

每下降一层

，每个递归实

例sum(lo, hi)都分裂为

一对更小的

实例sum(lo,

mi)和sum(mi + 1, hi)准确

地说，每

经过

一次递归调

用，子问题对

应的数组区

间长度hi - lo +

1都将

减半。

算法启

动后经连续

m = log2n次递归调用

，数组区间的

长度从最初

的n首次缩减

至1，并到达

第

一个递归基

。实际上，刚到

达任一递归

基时，已执行

的递归调用

总是比递归

返回多m = log2n

次。更

一般地，到达

区间长度为

2^k的任一递归

实例之前，已

执行的递归

调用总是比

递归返回多

m-k次。因此，递归

深度（即任一

时刻的活跃

递归实例的

总数）不会超

过m

+ 1。鉴于每个

递归

实例仅

需常数空间

，故除数组本

身所占的空

间，该算法只

需要O(m +

1) = O(logn)的附加

空间。

我们还

记得，代码1.5

中

线性递归版

sum()算法共需O(n)的

附加空间，就

这一点而言

，新的二分

递

归版sum()算法有

很大改进。

与

线性递归版

sum()算法一样，此

处每一递归

实例中的非

递归计算都

只需要常数

时间。递归

§1.4

*逑

弻 第1章 绪讳

24

实例共计2n

- 1个

，故新算法的

运行时间为

O(2n - 1)

= O(n)，与线性递归

版相同。

此处

每个递归实

例可向下深

入递归两次

，故属于多路

递归中的二

分递归。二分

递归与此前

介

绍的线性

递归有很大

区别。比如，在

线性递归中

整个计算过

程仅出现一

次递归基，而

在二分递归

过程中递归

基的出现相

当频繁，总体

而言有超过

半数的递归

实例都是递

归基。

 效率

当

然，并非所有

问题都适宜

于采用分治

策略。实际上

除了递归，此

类算法的计

算消耗主要

来

自两个方

面。首先是子

问题划分，即

把原问题分

解为形式相

同、规模更小

的多个子问

题，比如代

码

1.11中sum()算法将待

求和数组分

为前、后两段

。其次是子解

答合并，即由

递归所得子

问题的

解，得

到原问题的

整体解，比如

由子数组之

和累加得到

整个数组之

和。

为使分治

策略真正有

效，不仅必须

保证以上两

方面的计算

都能高效地

实现，还必须

保证子问

题

之间相互独

立各子问题

可独立求解

，而无需借助

其它子问题

的原始数据

或中间结果

。否则，

或者子

问题之间必

须传递数据

，或者子问题

之间需要相

互调用，无论

如何都会导

致时间和空

间复

杂度的

无谓增加。以

下就以Fibonacci数列

的计算为例

说明这一点

。

 Fibonacci数：二分递归

考查Fibonacci数列第

n项fib(n)的计算问

题，该数列递

归形式的定

义如下：

fib(n) = 



n （若n  1）

fib(n-1) + fib(n-2) （若

n

 2）

据此定义，可

直接导出如

代码1.12所示的

二分递归版

fib()算法：

1

__int64 fib ( int

n ) { //计算Fibonacci数

列癿第n项（二

分逑弻版）：O(2^n)

2 return ( 2

> n ) ?

3 ( __int64 )

n //若

刡达逑弻基

，直接叏值

4 :

fib ( n -

1 ) + fib

( n - 2

); //否

则，逑弻计算

前两项，其和

即为正解

5 }

代

码1.12 通过事分

递归计算Fibonacci数

基于Fibonacci数列原

始定义的这

一实现，不仅

正确性一目

了然，而且简

洁自然。然而

不幸

的是，在

这种场合采

用二分递归

策略的效率

极其低下。实

际上，该算法

需要运行O(2n

)时

间才能

计算

出第n个Fibonacci数。这

一指数复杂

度的算法，在

实际环境中

毫无价值。

为

确切地界定

该算法的复

杂度，不妨将

计算fib(n)所需的

时间记作T(n)。按

该算法的思

路，

为计算出

fib(n)，先花费T(n -

1)时间

计算fib(n - 1)，再花费

T(n -

2)时间计算fib(n - 2)，

最

后花费一个

单位的时间

将它们累加

起来。由此，可

得T(n)的递推式

如下：

T(n) = 



1 （若n  1）

T(n - 1) +

T(n - 2) +

1 （否则

）

若令S(n) =

[T(n) + 1]/2，则有：

S(n)

= 



1

（若

n  1）

S(n

- 1) + S(n

- 2) （否则）

我们发

现，S(n)的递推形

式与fib(n)完全一

致，只是起始

项不同：

S(0) = ( T(0)

+ 1 ) /

2 = 1 =

fib(1)

第1章

绪讳 §1.4 *逑弻

25

S(1) = (

T(1) + 1 )

/ 2 = 1

= fib(2)

亦

即，S(n)整体上相

对于fib(n)提前了

一个单元。由

此可知：

S(n)

= fib(n + 1)

= (

n+1

-

^



n+1)/ 5,

 = (1 +

5)/2, ^

 =

(1 - 5)/2

T(n)

= 2∙S(n) - 1

= 2∙fib(n + 1)

- 1 = O(

n+1) = O(2n

)

这一

版本fib()算法的

时间复杂度

高达指数量

级，究其原因

在于，计算过

程中所出现

的递归

实例

的重复度极

高只需画出

递归跟踪分

析图的前几

层，即不难验

证这一点。若

需更为精确

的

界定，可以

借助递推方

程（习题[1-19]），将得

到相同的结

论。



优化策略

为消除递归

算法中重复

的递归实例

，一种自然而

然的思路和

技巧，可以概

括为：

借助一

定量的辅助

空间，在各子

问题求解之

后，及时记录

下其对应的

解答

比如，可

以从原问题

出发自顶而

下，每当遇到

一个子问题

，都首先查验

它是否已经

计算过，

以期

通过直接调

阅记录获得

解答，从而避

免重新计算

。也可以从递

归基出发，自

底而上递推

地得

出各子

问题的解，直

至最终原问

题的解。前者

即所谓的制

表（tabulation）或记忆（memoization）

策

略，后者即所

谓的动态规

划（dynamic programming）策略。



Fibonacci数：线

性递归

为应

用上述制表

的策略，首先

需从改造Fibonacci数

的递归定义

入手。

反观代

码1.12，原fib()算法之

所以采用二

分递归模式

，完全是因为

受到该问题

原始定义的

表面特征fib(n)由

fib(n -

1)和fib(n - 2)共同决定

的误导。然而

不难看出，子

问

题fib(n

- 1)和fib(n - 2)实际

上并非彼此

独立。比如，只

要转而采用

定义如下的

递归函数，

计

算一对相邻

的Fibonacci数：

(fib(k-1), fib(k))

即可如

代码1.13所示，得

到效率更高

（习题[1-21]）的线性

递归版fib()算法

。

1 __int64 fib (

int n, __int64& prev

) { //计算Fibonacci数列第

n项（线性逑弻

版）：入口形式

fib(n, prev)

2 if ( 0

== n ) //若刡达逑弻

基，则

3 { prev =

1; return 0; }

//直接叏

值：fib(-1) = 1, fib(0)

= 0

4 else

{ //否则

5 __int64

prevPrev; prev = fib

( n - 1,

prevPrev ); //逑弻

计算前两项

6 return

prevPrev + prev; //其和即为正

解

7 }

8 }

//用辅劣发

量记弽前一

项，迒回数列

癿弼前项，O(n)

代

码1.13 通过线性

递归计算Fibonacci数

请注意，原二

分递归版本

中对应于fib(n -

2)的

另一次递归

，在这里被省

略掉了。其对

应

的解答，可

借助形式参

数的机制，通

过变量prevPrev“调阅

”此前的记录

直接获得。

该

算法呈线性

递归模式，递

归的深度线

性正比于输

入n，前后共计

仅出现O(n)个递

归实例，

累计

耗时不超过

O(n)。遗憾的是，该

算法共需使

用O(n)规模的附

加空间。如何

进一步改进

呢？

§1.5 抽象数据

类型 第1章 绪

讳

26

 Fibonacci数：迭代

反

观以上线性

递归版fib()算法

可见，其中所

记录的每一

个子问题的

解答，只会用

到一次。

在该

算法抵达递

归基之后的

逐层返回过

程中，每向上

返回一层，以

下各层的解

答均不必继

续保留。

若将

以上逐层返

回的过程，等

效地视作从

递归基出发

，按规模自小

而大求解各

子问题的过

程，

即可采用

动态规划的

策略，将以上

算法进一步

改写为如代

码1.14所示的迭

代版。

1

__int64 fibI ( int

n ) { //计算Fibonacci数

列癿第n项（迭

代版）：O(n)

2 __int64 f =

0, g = 1;

//刜始化

：fib(0) = 0, fib(1)

= 1

3 while

( 0 < n--

) { g +=

f; f = g

- f; } //依据原始定

丿，通过n次加

法和减法计

算fib(n)

4 return f; //迒回

5 }

代码

1.14 基二劢态觃

划策略计算

Fibonacci数

这里仅使

用了两个中

间变量f和g，记

录当前的一

对相邻Fibonacci数。整

个算法仅需

线性步

的迭

代，时间复杂

度为O(n)。更重要

的是，该版本

仅需常数规

模的附加空

间，空间效率

也有了

极大

提高。

§1.5

抽象数

据类型

各种

数据结构都

可看作是由

若干数据项

组成的集合

，同时对数据

项定义一组

标准的操作

。现

代数据结

构普遍遵从

“信息隐藏”的

理念，通过统

一接口和内

部封装，分层

次从整体上

加以设计、

实

现与使用。

所

谓封装，就是

将数据项与

相关的操作

结合为一个

整体，并将其

从外部的可

见性划分为

若干

级别，从

而将数据结

构的外部特

性与其内部

实现相分离

，提供一致且

标准的对外

接口，隐藏内

部

的实现细

节。于是，数据

集合及其对

应的操作可

超脱于具体

的程序设计

语言、具体的

实现方式，

即

构成所谓的

抽象数据类

型（abstract

data type, ADT）。抽象数据

类型的理论

催生了现代

面向对象的

程序设计语

言，而支持封

装也是此类

语言的基本

特征。

本书将

尽可能遵循

抽象数据类

型的规范来

设计、实现并

分析各种数

据结构。具体

地，将从各

数

据结构的对

外功能接口

（interface）出发，以C++语言

为例逐层讲

解其内部具

体实现

（implementation）的原

理、方法与技

巧，并就不同

实现方式的

效率及适用

范围进行分

析与比

较。为

体现数据结

构的通用性

，也将普遍采

用模板类的

描述模式。

第

2章

向量

§2.1 从数

组刡向量 第

2章

向量

28

数据

结构是数据

项的结构化

集合，其结构

性表现为数

据项之间的

相互联系及

作用，也可以

理

解为定义

于数据项之

间的某种逻

辑次序。根据

这种逻辑次

序的复杂程

度，大致可以

将各种数据

结

构划分为

线性结构、半

线性结构与

非线性结构

三大类。在线

性结构中，各

数据项按照

一个线性次

序构成一个

整体。最为基

本的线性结

构统称为序

列（sequence），根据其中

数据项的逻

辑次序

与其

物理存储地

址的对应关

系不同，又可

进一步地将

序列区分为

向量（vector）和列表

（list）。

在向量中，所

有数据项的

物理存放位

置与其逻辑

次序完全吻

合，此时的逻

辑次序也称

作秩

（rank）；而在列

表中，逻辑上

相邻的数据

项在物理上

未必相邻，而

是采用间接

定址的方式

通

过封装后

的位置（position）相互

引用。

本章的

讲解将围绕

向量结构的

高效实现而

逐步展开，包

括其作为抽

象数据类型

的接口规范

以

及对应的

算法，尤其是

高效维护动

态向量的技

巧。此外，还将

针对有序向

量，系统介绍

经典的查

找

与排序算法

，并就其性能

做一分析对

比，这也是本

章的重点与

难点所在。最

后，还将引入

复杂

度下界

的概念，并通

过建立比较

树模型，针对

基于比较式

算法给出复

杂度下界的

统一界定方

法。

§2.1 从数组到

向量

2.1.1

数组

C、C++和

Java等程序设计

语言，都将数

组作为一种

内置的数据

类型，支持对

一组相关元

素

的存储组

织与访问操

作。具体地，若

集合S由n个元

素组成，且各

元素之间具

有一个线性

次序，则

可将

它们存放于

起始于地址

A、物理位置连

续的一段存

储空间，并统

称作数组（array），通

常

以A作为该

数组的标识

。具体地，数组

A[]中的每一元

素都唯一对

应于某一下

标编号，在多

数高

级程序

设计语言中

，一般都是从

0开始编号，依

次是0号、1号、2号

、...、n-1号元素，记作

：

A =

{ a0, a1, ...,

an-1 } 或者

A[0,

n) = { A[0],

A[1], ..., A[n -

1] }

其中，对

于任何0 

i < j <

n，A[i]都是

A[j]的前驱（predecessor），A[j]都是

A[i]

的后继（successor）。特别

地，对于任何

i  1，A[i

- 1]称作A[i]的直接

前驱（immediate 

predecessor）;对于任

何i

 n - 2，A[i

+ 1]称作A[i]的直

接后继（immediate successor）。

任一

元素的所有

前驱构成其

前缀（prefix），所有后

继构成其后

缀（suffix）。

采用这一

编号规范，不

仅可以使得

每个元素都

通过下标唯

一指代，而且

可以使我们

直接访问

到

任一元素。这

里所说的“访

问”包含读取

、修改等基本

操作，而“直接

”则是指这些

操作都可

以

在常数时间

内完成只要

从数组所在

空间的起始

地址A出发，即

可根据每一

元素的编号

，经

过一次乘

法运算和一

次加法运算

，获得待访问

元素的物理

地址。具体地

，若数组A[]存放

空间的

起始

地址为A，且每

个元素占用

s个单位的空

间，则元素A[i]对

应的物理地

址为：

A + i

 s

因其中

元素的物理

地址与其下

标之间满足

这种线性关

系，故亦称作

线性数组（linear array）。

第

2章 向量 §2.2 接口

29

2.1.2 向量

按照面

向对象思想

中的数据抽

象原则，可对

以上的数组

结构做一般

性推广，使得

其以上特性

更具普遍性

。向量（vector）就是线

性数组的一

种抽象与泛

化，它也是由

具有线性次

序的一组

元

素构成的集

合V

= { v0, v1,

..., vn-1 }，其中的元

素分别由秩

相互区分。

各

元素的秩（rank）互

异，且均为[0,

n)内

的整数。具体

地，若元素e的

前驱元素共

计r个，

则其秩

就是r。以此前

介绍的线性

递归为例，运

行过程中所

出现过的所

有递归实例

，按照相互调

用的关系可

构成一个线

性序列。在此

序列中，各递

归实例的秩

反映了它们

各自被创建

的时间先后

，

每一递归实

例的秩等于

早于它出现

的实例总数

。反过来，通过

r亦可唯一确

定e =

vr。这是向量

特有的元素

访问方式，称

作“循秩访问

”（call-by-rank）。

经如此抽象

之后，我们不

再限定同一

向量中的各

元素都属于

同一基本类

型，它们本身

可以是

来自

于更具一般

性的某一类

的对象。另外

，各元素也不

见得同时具

有某一数值

属性，故而并

不保

证它们

之间能够相

互比较大小

。

以下首先从

向量最基本

的接口出发

，设计并实现

与之对应的

向量模板类

。然后在元素

之间具

有大

小可比性的

假设前提下

，通过引入通

用比较器或

重载对应的

操作符明确

定义元素之

间的大小

判

断依据，并强

制要求它们

按此次序排

列，从而得到

所谓有序向

量，并介绍和

分析此类向

量的相

关算

法及其针对

不同要求的

各种实现版

本。

§2.2 接口

2.2.1 ADT接口

作为一种抽

象数据类型

，向量对象应

支持如下操

作接口。

表2.1 向

量ADT支持癿操

作接口

操 作

接

口 功 能 适

用

对 象

size() 报告

向量弼前癿

觃模（元素总

数）

向量

get(r) 获叏

秩为r癿元素

向量

put(r,

e) 用e替换

秩为r元素癿

数值 向量

insert(r,

e) e作

为秩为r元素

揑入，原后继

元素依次后

秱 向量

remove(r)

初除

秩为r癿元素

，迒回诠元素

中原存放癿

对象 向量

disordered() 刞

断所有元素

是否已按非

降序排列

向

量

sort() 调整各元

素癿位置，使

乀按非降序

排列 向量

find(e) 查

找等亍e且秩

最大癿元素

向量

search(e) 查找目

标元素e，迒回

丌大亍e且秩

最大癿元素

有序向量

deduplicate() 剔

除重复元素

向量

uniquify() 剔除重

复元素

有序

向量

traverse() 遍历向

量幵统一处

理所有元素

，处理斱法由

函数对象指

定 向量

以上

向量操作接

口，可能有多

种具体的实

现方式，计算

复杂度也不

尽相同。而在

引入秩的概

念并将外部

接口与内部

实现分离之

后，无论采用

何种具体的

方式，符合统

一外部接口

规范的任一

实现均可直

接地相互调

用和集成。

§2.2 接

口 第2章

向量

30

2.2.2 操作实例

按

照表2.1定义的

ADT接口，表2.2给出

了一个整数

向量从被创

建开始，通过

ADT接口依次实

施一系列操

作的过程。请

留意观察，向

量内部各元

素秩的逐步

变化过程。

表

2.2 向量操作实

例

操作 输出

向量组成（自

左向右）

操作

输出 向量组

成（自左向右

）

刜始化 disordered()

3 4 3 7

4 9 6

insert(0,

9) 9 find(9) 4

4 7 4 9

6

insert(0, 4) 4

9 find(5) -1 4

3 7 4 9

6

insert(1, 5) 4

5 9 sort() 4

4 6 7 9

put(1, 2) 4 2

9 disordered() 0 3

4 4 6 7

9

get(2) 9 4

2 9 search(1) -1

3 4 4 6

7 9

insert(3, 6)

4 2 9 6

search(4) 2 3 4

4 6 7 9

insert(1, 7) 4 7

2 9 6 search(8)

4 3 4 4

6 7 9

remove(2)

2 4 7 9

6 search(9) 5 3

4 4 6 7

9

insert(1, 3) 4

3 7 9 6

search(10) 5 3 4

4 6 7 9

insert(3, 4) 4 3

7 4 9 6

uniquify() 3 4 6

7 9

size() 6

4 3 7 4

9 6 search(9) 4

3 4 6 7

9

2.2.3 Vector模板

类

按照表2.1确

定的向量ADT接

口，可定义Vector模

板类如代码

2.1所示。

1 typedef int Rank;

//秩

2 #define DEFAULT_CAPACITY

3 //默讣

癿刜始容量

（实际应用中

可讴置为更

大）

3

4

template <typename T> class

Vector { //向量模板

类

5

protected:

6 Rank _size;

int _capacity; T* _elem;

//觃模、容量

、数据匙

7 void copyFrom

( T const* A,

Rank lo, Rank hi

); //复刢

数组匙间A[lo, hi)

8

void expand(); //空

间丌足时扩

容

9

void shrink(); //装填因子

过小时压缩

10 bool

bubble ( Rank lo,

Rank hi ); //扫描交换

11 void bubbleSort (

Rank lo, Rank hi

); //起

泡排序算法

12 Rank max

( Rank lo, Rank

hi ); //选叏最大元

素

13

void selectionSort ( Rank

lo, Rank hi );

//选择排序

算法

14 void merge

( Rank lo, Rank

mi, Rank hi );

//弻幵算

法

15 void mergeSort

( Rank lo, Rank

hi ); //弻幵排序

算法

16

Rank partition ( Rank

lo, Rank hi );

//轴点极

造算法

17 void quickSort

( Rank lo, Rank

hi ); //快速

排序算法

18

void heapSort ( Rank

lo, Rank hi );

//堆

排序（稍后结

合完全堆讱

解）

19 public:

第2章

向量

§2.2 接口

31

20

// 极造函

数

21 Vector

( int c =

DEFAULT_CAPACITY, int s =

0, T v =

0 ) //容量为c、觃

模为s、所有元

素刜始为v

22

{ _elem = new

T[_capacity = c]; for

( _size = 0;

_size < s; _elem[_size++]

= v ); }

//s<=c

23 Vector (

T const* A, Rank

n ) { copyFrom

( A, 0, n

); } //数

组整体复刢

24 Vector

( T const* A,

Rank lo, Rank hi

) { copyFrom (

A, lo, hi );

} //匙间

25 Vector

( Vector<T> const& V

) { copyFrom (

V._elem, 0, V._size );

} //向量整

体复刢

26 Vector

( Vector<T> const& V,

Rank lo, Rank hi

) { copyFrom (

V._elem, lo, hi );

} //匙间

27 // 枂极函数

28 ~Vector() { delete

[] _elem; } //释

放内部空间

29

// 叧读讵问接

口

30 Rank

size() const { return

_size; } //觃模

31

bool empty() const {

return !_size; } //刞空

32

int disordered() const; //刞断向量是

否已排序

33 Rank find (

T const& e )

const { return find

( e, 0, _size

); } //无

序向量整体

查找

34

Rank find ( T

const& e, Rank lo,

Rank hi ) const;

//无序向

量匙间查找

35 Rank search (

T const& e )

const //有序向量整

体查找

36 {

return ( 0 >=

_size ) ? -1

: search ( e,

0, _size ); }

37 Rank search (

T const& e, Rank

lo, Rank hi )

const; //有序

向量匙间查

找

38 //

可写讵问

接口

39 T& operator[]

( Rank r )

const; //重载下

标操作符，可

以类似亍数

组形式引用

各元素

40 Vector<T>

& operator= ( Vector<T>

const& ); //重载

赋值操作符

，以便直接克

隆向量

41

T remove ( Rank

r ); //初除

秩为r癿元素

42 int

remove ( Rank lo,

Rank hi ); //初除秩在匙

间[lo,

hi)乀内癿元

素

43 Rank insert

( Rank r, T

const& e ); //揑入元素

44

Rank insert ( T

const& e ) {

return insert ( _size,

e ); } //默讣作为末

元素揑入

45 void sort (

Rank lo, Rank hi

); //对

[lo, hi)排序

46

void sort() { sort

( 0, _size );

} //整体排

序

47 void

unsort ( Rank lo,

Rank hi ); //对[lo,

hi)置乱

48 void unsort()

{ unsort ( 0,

_size ); } //整

体置乱

49 int deduplicate(); //无序

去重

50 int uniquify(); //有序去

重

51 // 遍历

52

void traverse ( void

(* ) ( T&

) ); //遍历

（使用函数指

针，叧读戒尿

部性修改）

53

template <typename VST> void

traverse ( VST& );

//遍

历（使用函数

对象，可全尿

性修改）

54 }; //Vector

代码

2.1 向量模板类

Vector

这里通过模

板参数T，指定

向量元素的

类型。于是，以

Vector<int>或Vector<float>之类

的形

式，可便捷地

引入存放整

数或浮点数

的向量；而以

Vector<Vector<char>>之类的形式

，则

可直接定

义存放字符

的二维向量

等。这一技巧

有利于提高

数据结构选

用的灵活性

和运行效率

，并

减少出错

，因此将在本

书中频繁使

用。

在表2.1所列

基本操作接

口的基础上

，这里还扩充

了一些接口

。比如，基于size()直

接实现

§2.3

极造

不枂极 第2章

向量

32

的判空

接口empty()，以及区

间删除接口

remove(lo,

hi)、区间查找接

口find(e, lo, hi)等。

它们多

为上述基本

接口的扩展

或变型，可使

代码更为简

洁易读，并提

高计算效率

。

这里还提供

了sort()接口，以将

向量转化为

有序向量。为

此可有多种

排序算法供

选用，本

章及

后续章节，将

陆续介绍它

们的原理、实

现并分析其

效率。排序之

后，向量的很

多操作都可

更

加高效地

完成，其中最

基本和最常

用的莫过于

查找。因此，这

里还针对有

序向量提供

了search()

接口，并将

详细介绍若

干种相关的

算法。为便于

对sort()算法的测

试，这里还设

有一个unsort()

接口

，以将向量随

机置乱。在讨

论这些接口

之前，我们首

先介绍基本

接口的实现

。

§2.3 构造与析构

由代码2.1可见

，向量结构在

内部维护一

个元素类型

为T的私有数

组_elem[]：其容量由

私有

变量_capacity指

示；有效元素

的数量（即向

量当前的实

际规模），则由

_size指示。此外还

进

一步地约

定，在向量元

素的秩、数组

单元的逻辑

编号以及物

理地址之间

，具有如下对

应关系：

向量

中秩为r的元

素，对应于内

部数组中的

_elem[r]，其物理地址

为_elem + r

因此，向量

对象的构造

与析构，将主

要围绕这些

私有变量和

数据区的初

始化与销毁

展开。

2.3.1 默认构

造方法

与所

有的对象一

样，向量在使

用之前也需

首先被系统

创建借助构

造函数（constructor）

做初

始化（initialization）。由代码

2.1可见，这里为

向量重载了

多个构造函

数。

其中默认

的构造方法

是，首先根据

创建者指定

的初始容量

，向系统申请

空间，以创建

内部私

有数

组_elem[]；若容量未

明确指定，则

使用默认值

DEFAULT_CAPACITY。接下来，鉴于

初生的

向量

尚不包含任

何元素，故将

指示规模的

变量_size初始化

为0。

整个过程

顺序进行，没

有任何迭代

，故若忽略用

于分配数组

空间的时间

，共需常数时

间。

2.3.2 基于复制

的构造方法

向量的另一

典型创建方

式，是以某个

已有的向量

或数组为蓝

本，进行（局部

或整体的）克

隆。

代码2.1中虽

为此功能重

载了多个接

口，但无论是

已封装的向

量或未封装

的数组，无论

是整体还

是

区间，在入口

参数合法的

前提下，都可

归于如代码

2.2所示的统一

的copyFrom()方法：

1 template <typename

T> //元素

类型

2 void

Vector<T>::copyFrom ( T const*

A, Rank lo, Rank

hi ) { //以数组

匙间A[lo,

hi)为蓝本

复刢向量

3 _elem =

new T[_capacity = 2

* ( hi -

lo ) ]; _size

= 0; //分

配空间，觃模

清零

4

while ( lo <

hi ) //A[lo, hi)内癿元

素逐一

5 _elem[_size++] = A[lo++];

//复刢

至_elem[0, hi - lo)

6 }

代码2.2 基二

复刢癿向量

极造器

copyFrom()首先

根据待复制

区间的边界

，换算出新向

量的初始规

模；再以双倍

的容量，为

内

部数组_elem[]申请

空间。最后通

过一趟迭代

，完成区间A[lo, hi)内

各元素的顺

次复制。

若忽

略开辟新空

间所需的时

间，运行时间

应正比于区

间宽度，即O(hi

- lo) = O(_size)。

第

2章 向量 §2.4 劢态

空间管理

33

需

强调的是，由

于向量内部

含有动态分

配的空间，默

认的运算符

"="不足以支持

向量之间的

直接赋值。例

如，6.3节将以二

维向量形式

实现图邻接

表，其主向量

中的每一元

素本身都是

一维

向量，故

通过默认赋

值运算符，并

不能复制向

量内部的数

据区。

为适应

此类赋值操

作的需求，可

如代码2.3所示

，重载向量的

赋值运算符

。

1 template <typename T>

Vector<T>& Vector<T>::operator= ( Vector<T>

const& V ) {

//重载

2 if (

_elem ) delete []

_elem; //释放原

有内容

3 copyFrom

( V._elem, 0, V.size()

); //整体

复刢

4 return

*this; //迒回弼

前对象癿引

用，以便链式

赋值

5 }

代码2.3 重

轲向量赋值

操作符

2.3.3 析构

方法

与所有

对象一样，不

再需要的向

量，应借助析

构函数（destructor）及时

清理（cleanup），

以释放

其占用的系

统资源。与构

造函数不同

，同一对象只

能有一个析

构函数，不得

重载。

向量对

象的析构过

程，如代码2.1中

的方法~Vector()所示

：只需释放用

于存放元素

的内部

数组

_elem[]，将其占用的

空间交还操

作系统。_capacity和_size之

类的内部变

量无需做任

何

处理，它们

将作为向量

对象自身的

一部分被系

统回收，此后

既无需也无

法被引用。

若

不计系统用

于空间回收

的时间，整个

析构过程只

需O(1)时间。

同样

地，向量中的

元素可能不

是程序语言

直接支持的

基本类型。比

如，可能是指

向动态分配

对象的指针

或引用，故在

向量析构之

前应该提前

释放对应的

空间。出于简

化的考虑，这

里约定并

遵

照“谁申请谁

释放”的原则

。究竟应释放

掉向量各元

素所指的对

象，还是需要

保留这些对

象，

以便通过

其它指针继

续引用它们

，应由上层调

用者负责确

定。

§2.4 动态空间

管理

2.4.1

静态空

间管理

内部

数组所占物

理空间的容

量，若在向量

的生命期内

不允许调整

，则称作静态

空间管理策

略。

很遗憾，该

策略的空间

效率难以保

证。一方面，既

然容量固定

，总有可能在

此后的某一

时刻，无

法加

入更多的新

元素即导致

所谓的上溢

（overflow）。例如，若使用

向量来记录

网络访问

日

志，则由于插

入操作远多

于删除操作

，必然频繁溢

出。注意，造成

此类溢出的

原因，并非系

统

不能提供

更多的空间

。另一方面反

过来，即便愿

意为降低这

种风险而预

留出部分空

间，也很难在

程序执行之

前，明确界定

一个合理的

预留量。以上

述copyFrom()方法为例

，即便将容量

取作初

始规

模的两倍，也

只能保证在

此后足够长

的一段时间

内（而并非永

远）不致溢出

。

向量实际规

模与其内部

数组容量的

比值（即_size/_capacity），亦称

作装填因子

（load

factor），它是衡量空

间利用率的

重要指标。从

这一角度，上

述难题可归

纳为：

如何才

能保证向量

的装填因子

既不致于超

过1，也不致于

太接近于0？

为

此，需要改用

动态空间管

理策略。其中

一种有效的

方法，即使用

所谓的可扩

充向量。

§2.4

劢态

空间管理 第

2章 向量

34

2.4.2 可扩

充向量

经过

一段时间的

生长，每当身

体无法继续

为其外壳所

容纳，蝉就会

蜕去外壳，同

时换上一身

更大的外壳

。扩充向量（extendable vector）的

原理，与之相

仿。若内部数

组仍有空余

，则

操作可照

常执行。每经

一次插入（删

除），可用空间

都会减少（增

加）一个单元

（图2.1(a)）。

一旦可用

空间耗尽（图

(b)），就动态地扩

大内部数组

的容量。这里

的难点及关

键在于：

如何

实现扩容？新

的容量取作

多少才算适

宜？

首先解决

前一问题。直

接在原有物

理空间的基

础上追加空

间？这并不现

实。数组特有

的定址

方式

要求，物理空

间必须地址

连续，而我们

却无法保证

，其尾部总是

预留了足够

空间可供拓

展。

图2.1 可扩充

向量癿溢出

处理

一种可

行的方法，如

图2.1(c~e)所示。我们

需要另行申

请一个容量

更大的数组

B[]（图(c)），

并将原数

组中的成员

集体搬迁至

新的空间（图

(d)），此后方可顺

利地插入新

元素e而不致

溢出

（图(e)）。当然

，原数组所占

的空间，需要

及时释放并

归还操作系

统。

2.4.3 扩容

基于

以上策略的

扩容算法expand()，可

实现如代码

2.4所示。

1 template <typename

T> void Vector<T>::expand() {

//向量空

间丌足时扩

容

2 if (

_size < _capacity )

return; //尚未满员

时，丌必扩容

3 if (

_capacity < DEFAULT_CAPACITY )

_capacity = DEFAULT_CAPACITY; //丌低亍最小

容量

4 T* oldElem =

_elem; _elem = new

T[_capacity <<= 1]; //容量加

倍

5 for ( int

i = 0; i

< _size; i++ )

6 _elem[i] = oldElem[i];

//复刢原向

量内容（T为基

本类型，戒已

重载赋值操

作符'='）

7 delete []

oldElem; //释放原

空间

8 }

代码2.4 向

量内部数组

劢态扩容算

法expand()

实际上，在

调用insert()接口插

入新元素之

前，都要先调

用该算法，检

查内部数组

的可用

容量

。一旦当前数

据区已满（_size

== _capacity），则

将原数组替

换为一个更

大的数组。

请

注意，新数组

的地址由操

作系统分配

，与原数据区

没有直接的

关系。这种情

况下，若直接

引用数组，往

往会导致共

同指向原数

组的其它指

针失效，成为

野指针（wild pointer）；而经

封装为向量

之后，即可继

续准确地引

用各元素，从

而有效地避

免野指针的

风险。

这里的

关键在于，新

数组的容量

总是取作原

数组的两倍

这正是上述

后一问题的

答案。

第2章 向

量 §2.4

劢态空间

管理

35

2.4.4 分摊分

析

 时间代价

与常规数组

实现相比，可

扩充向量更

加灵活：只要

系统尚有可

用空间，其规

模将不再受

限于

初始容

量。不过，这并

非没有代价

每次扩容，元

素的搬迁都

需要花费额

外的时间。

准

确地，每一次

由n到2n的扩容

，都需要花费

O(2n)

= O(n)时间这也是

最坏情况下

，

单次插入操

作所需的时

间。表面看来

，这一扩容策

略似乎效率

很低，但这不

过是一种错

觉。

请注意，按

照此处的约

定，每花费O(n)时

间实施一次

扩容，数组的

容量都会加

倍。这就意

味

着，至少要再

经过n次插入

操作，才会因

为可能溢出

而再次扩容

。也就是说，随

着向量规模

的

不断扩大

，在执行插入

操作之前需

要进行扩容

的概率，也将

迅速降低。故

就某种平均

意义而言，

用

于扩容的时

间成本不至

很高。以下不

妨就此做一

严格的分析

。



分摊复杂度

这里，不妨考

查对可扩充

向量的足够

多次连续操

作，并将其间

所消耗的时

间，分摊至所

有的

操作。如

此分摊平均

至单次操作

的时间成本

，称作分摊运

行时间（amortized running time）。

请注

意，这一指标

与平均运行

时间（average running time）有着本

质的区别（习

题[2-1]）。

后者是按

照某种假定

的概率分布

，对各种情况

下所需执行

时间的加权

平均，故亦称

作期望运行

时

间（expected running time）。而前者

则要求，参与

分摊的操作

必须构成和

来自一个真

实可

行的操

作序列，而且

该序列还必

须足够地长

。

相对而言，分

摊复杂度可

以针对计算

成本和效率

，做出更为客

观而准确的

估计。比如在

这里，

在任何

一个可扩充

向量的生命

期内，在任何

足够长的连

续操作序列

中，以任何固

定间隔连续

出现

上述最

坏情况的概

率均为0，故常

规的平均复

杂度根本不

具任何参考

意义。作为评

定算法性能

的

一种重要

尺度，分摊分

析（amortized

analysis）的相关方

法与技巧将

在后续章节

陆续介绍。

 O(1)分

摊时间

以可

扩充向量为

例，可以考查

对该结构的

连续n次（查询

、插入或删除

等）操作，将所

有操

作中用

于内部数组

扩容的时间

累计起来，然

后除以n。只要

n足够大，这一

平均时间就

是用于扩容

处理的分摊

时间成本。以

下我们将看

到，即便排除

查询和删除

操作而仅考

查插入操作

，在可扩充

向

量单次操作

中，用于扩容

处理的分摊

时间成本也

不过O(1)。

假定数

组的初始容

量为某一常

数N。既然是估

计复杂度的

上界，故不妨

设向量的初

始规模也

为

N即将溢出。另

外不难看出

，除插入操作

外，向量其余

的接口操作

既不会直接

导致溢出，

也

不会增加此

后溢出的可

能性，因此不

妨考查最坏

的情况，假设

在此后需要

连续地进行

n次

insert()操作，n >> N。首先

定义如下函

数：

size(n) = 连续插入

n个元素后向

量的规模

capacity(n)

= 连

续插入n个元

素后数组的

容量

T(n) =

为连续

插入n个元素

而花费于扩

容的时间

其

中，向量规模

从N开始随着

操作的进程

逐步递增，故

有：

size(n) =

N + n

既然不致

溢出，故装填

因子绝不会

超过100%。同时，这

里的扩容采

用了“懒惰”策

略

只有在的

确即将发生

溢出时，才不

得不将容量

加倍因此装

填因子也始

终不低于50%。

§2.4 劢

态空间管理

第2章 向量

36

概

括起来，始终

应有：

size(n) 

capacity(n) < 2∙size(n)

考虑到

N为常数，故有

：

capacity(n) = (size(n)) =

(n)

容量以2为比

例按指数速

度增长，在容

量达到capacity(n)之前

，共做过(log2n)次扩

容，

每次扩容

所需时间线

性正比于当

时的容量（或

规模），且同样

以2为比例按

指数速度增

长。因此，

消耗

于扩容的时

间累计不过

：

T(n) = 2N +

4N + 8N +

... + capacity(n) <

2∙capacity(n) = (n)

将其分摊到

其间的连续

n次操作，单次

操作所需的

分摊运行时

间应为O(1)。

 其它

扩容策略

以

上分析确凿

地说明，基于

加倍策略的

动态扩充数

组不仅可行

，而且就分摊

复杂度而言

效率

也足以

令人满意。当

然，并非任何

扩容策略都

能保证如此

高的效率。比

如，早期可扩

充向量多采

用另一策略

：一旦有必要

，则追加固定

数目的单元

。实际上，无论

采用的固定

常数多大，在

最坏

情况下

，此类数组单

次操作的分

摊时间复杂

度都将高达

(n)（习题[2-3]）。

2.4.5 缩容

导

致低效率的

另一情况是

，向量的实际

规模可能远

远小于内部

数组的容量

。比如在连续

的一

系列操

作过程中，若

删除操作远

多于插入操

作，则装填因

子极有可能

远远小于100%，甚

至非常

接近

于0。当装填因

子低于某一

阈值时，我们

称数组发生

了下溢（underflow）。

尽管

下溢不属于

必须解决的

问题，但在格

外关注空间

利用率的场

合，发生下溢

时也有必要

适

当缩减内

部数组容量

。代码2.5给出了

一个动态缩

容shrink()算法：

1 template <typename T>

void Vector<T>::shrink() { //装填

因子过小时

压缩向量所

占空间

2 if ( _capacity

< DEFAULT_CAPACITY << 1

) return; //丌致

收缩刡DEFAULT_CAPACITY以下

3 if

( _size << 2

> _capacity ) return;

//以25%为界

4 T* oldElem

= _elem; _elem =

new T[_capacity >>= 1];

//容量

减半

5 for (

int i = 0;

i < _size; i++

) _elem[i] = oldElem[i];

//复刢原

向量内容

6 delete []

oldElem; //释

放原空间

7 }

代

码2.5 向量内部

功能shrink()

可见，每

次删除操作

之后，一旦空

间利用率已

降至某一阈

值以下，该算

法随即申请

一个容量

减

半的新数组

，将原数组中

的元素逐一

搬迁至其中

，最后将原数

组所占空间

交还操作系

统。这里

以25%作

为装填因子

的下限，但在

实际应用中

，为避免出现

频繁交替扩

容和缩容的

情况，可以选

用更低的阈

值，甚至取作

0（相当于禁止

缩容）。

与expand()操作

类似，尽管单

次shrink()操作需要

线性量级的

时间，但其分

摊复杂度亦

为

O(1)（习题[2-4]）。实际

上shrink()过程等效

于expand()的逆过程

，这两个算法

相互配合，

在

不致实质地

增加接口操

作复杂度的

前提下，保证

了向量内部

空间的高效

利用。当然，就

单次扩

容或

缩容操作而

言，所需时间

的确会高达

(n)，因此在对单

次操作的执

行速度极其

敏感的应用

场合以上策

略并不适用

，其中缩容操

作甚至可以

完全不予考

虑。

第2章 向量

§2.5 常觃向量

37

§2.5 常

规向量

2.5.1

直接

引用元素

与

数组直接通

过下标访问

元素的方式

（形如“A[i]”）相比，向

量ADT所设置的

get()和put()

接口都显

得不甚自然

。毕竟，前一访

问方式不仅

更为我们所

熟悉，同时也

更加直观和

便捷。那么，

在

经过封装之

后，对向量元

素的访问可

否沿用数组

的方式呢？答

案是肯定的

。

解决的方法

之一就是重

载操作符“[]”，具

体实现如代

码2.6所示。

1 template <typename

T> T& Vector<T>::operator[] (

Rank r ) const

//重载

下标操作符

2 { return _elem[r];

} // assert: 0

<= r < _size

代码2.6 重轲向

量操作符[]

2.5.2 置

乱器

 置乱算

法

可见，经重

载后操作符

“[]”返回的是对

数组元素的

引用，这就意

味着它既可

以取代get()

操作

（通常作为赋

值表达式的

右值），也可以

取代set()操作（通

常作为左值

）。例如，采用这

种形式，可以

简明清晰地

描述和实现

如代码2.7所示

的向量置乱

算法。

1 template <typename T>

void permute ( Vector<T>&

V ) { //随机置

乱向量，使各

元素等概率

出现亍各位

置

2 for ( int

i = V.size(); i

> 0; i-- )

//自后向前

3 swap ( V[i

- 1], V[rand() %

i] ); //V[i -

1]不V[0, i)中某一随

机元素交换

4 }

代码2.7

向量整

体置乱算法

permute()

该算法从待

置乱区间的

末元素开始

，逆序地向前

逐一处理各

元素。如图2.2(a)所

示，对每

一个

当前元素V[i -

1]，先

通过调用rand()函

数在[0, i)之间等

概率地随机

选取一个元

素，再

令二者

互换位置。注

意，这里的交

换操作swap()，隐含

了三次基于

重载操作符

“[]”的赋值。

于是

如图(b)所示，每

经过一步这

样的迭代，置

乱区间都会

向前拓展一

个单元。因此

经过O(n)

步迭代

之后，即实现

了整个向量

的置乱。

图2.2 向

量整体置乱

算法permute()癿迭代

过秳

在软件

测试、仿真模

拟等应用中

，随机向量的

生成都是一

项至关重要

的基本操作

，直接影响

到

测试的覆盖

面或仿真的

真实性。从理

论上说，使用

这里的算法

permute()，不仅可以枚

举出同

一向

量所有可能

的排列，而且

能够保证生

成各种排列

的概率均等

（习题[2-6]）。

§2.5 常觃向

量

第2章 向量

38

 区间置乱接

口

为便于对

各种向量算

法的测试与

比较，这里不

妨将以上permute()算

法封装至向

量ADT中，

并如代

码2.8所示，对外

提供向量的

置乱操作接

口Vector::unsort()。

1 template

<typename T> void Vector<T>::unsort

( Rank lo, Rank

hi ) { //等概率随

机置乱匙间

[lo,

hi)

2 T* V

= _elem + lo;

//将子向量_elem[lo, hi)规

作另一向量

V[0, hi -

lo)

3 for (

Rank i = hi

- lo; i >

0; i-- ) //自后向前

4 swap ( V[i

- 1], V[rand() %

i] ); //将

V[i -

1]不V[0, i)中某一元

素随机交换

5 }

代码2.8

向量区

间置乱接口

unsort()

通过该接口

，可以均匀地

置乱任一向

量区间[lo, hi)内的

元素，故通用

性有所提高

。可见，

只要将

该区间等效

地视作另一

向量V，即可从

形式上完整

地套用以上

permute()算法的流程

。

尽管如此，还

请特别留意

代码2.7与代码

2.8的细微差异

：后者是通过

下标，直接访

问内部

数组

的元素；而前

者则是借助

重载的操作

符“[]”，通过秩间

接地访问向

量的元素。

2.5.3 判

等器与比较

器

从算法的

角度来看，“判

断两个对象

是否相等”与

“判断两个对

象的相对大

小”都是至关

重

要的操作

，它们直接控

制着算法执

行的分支方

向，因此也是

算法的“灵魂

”所在。在本书

中为了

以示

区别，前者多

称作“比对”操

作，后者多称

作“比较”操作

。当然，这两种

操作之间既

有联

系也有

区别，不能相

互替代。比如

，有些对象只

能比对但不

能比较；反之

，支持比较的

对象未必

支

持比对。不过

，出于简化的

考虑，在很多

场合并不需

要严格地将

二者区分开

来。

算法实现

的简洁性与

通用性，在很

大程度上体

现于：针对整

数等特定数

据类型的某

种实现，

可否

推广至可比

较或可比对

的任何数据

类型，而不必

关心如何定

义以及判定

其大小或相

等关系。

若能

如此，我们就

可以将比对

和比较操作

的具体实现

剥离出来，直

接讨论算法

流程本身。

为

此，通常可以

采用两种方

法。其一，将比

对操作和比

较操作分别

封装成通用

的判等器和

比

较器。其二

，在定义对应

的数据类型

时，通过重载

"<"和"=="之类的操

作符，给出大

小和相等关

系的具体定

义及其判别

方法。本书将

主要采用后

一方式。为节

省篇幅，这里

只给出涉及

到的比较

和

判等操作符

，读者可以根

据实际需要

，参照给出的

代码加以扩

充。

1

template <typename T> static

bool lt ( T*

a, T* b )

{ return lt (

*a, *b ); }

//less than

2 template

<typename T> static bool

lt ( T& a,

T& b ) {

return a < b;

} //less than

3

template <typename T> static

bool eq ( T*

a, T* b )

{ return eq (

*a, *b ); }

//equal

4 template <typename

T> static bool eq

( T& a, T&

b ) { return

a == b; }

//equal

代码2.9 重轲

比轳器以便

比轳对象指

针

在一些复

杂的数据结

构中，内部元

素本身的类

型可能就是

指向其它对

象的指针；而

从外部更

多

关注的，则往

往是其所指

对象的大小

。若不加处理

而直接根据

指针的数值

（即被指对象

的物理

地址

）进行比较，则

所得结果将

毫无意义。

为

此，这里不妨

通过如代码

2.9所示的机制

，将这种情况

与一般情况

予以区分，并

且约定在

这

种情况下，统

一按照被指

对象的大小

做出判断。

第

2章 向量 §2.5 常觃

向量

39

2.5.4 无序查

找



判等器

代

码2.1中Vector::find(e)接口，功

能语义为“查

找与数据对

象e相等的元

素”。这同时

也

暗示着，向量

元素可通过

相互比对判

等比如，元素

类型T或为基

本类型，或已

重载操作符

“==”或“!=”。这类仅支

持比对，但未

必支持比较

的向量，称作

无序向量（unsorted vector）。

 顺

序查找

在无

序向量中查

找任意指定

元素e时，因为

没有更多的

信息可以借

助，故在最坏

情况下

比如

向量中并不

包含e时只有

在访遍所有

元素之后，才

能得出查找

结论。

图2.3 无序

向量癿顸序

查找

因此不

妨如图2.3所示

，从末元素起

自后向前，逐

一取出各个

元素并与目

标元素e进行

比对，

直至发

现与之相等

者（查找成功

），或者直至检

查过所有元

素之后仍未

找到相等者

（查找失败）。

这

种依次逐个

比对的查找

方式，称作顺

序查找（sequential search）。

 实现

针对向量的

整体或区间

，代码2.1分别定

义了一个顺

序查找操作

的入口，其中

前者作为特

例，

可直接通

过调用后者

而实现。因此

，只需如代码

2.10所示，实现针

对向量区间

的查找算法

。

1 template <typename

T> //无序向量癿

顺序查找：迒

回最后一个

元素e癿位置

；失败时，迒回

lo - 1

2 Rank Vector<T>::find (

T const& e, Rank

lo, Rank hi )

const { //assert: 0

<= lo < hi

<= _size

3 while

( ( lo <

hi-- ) && (

e != _elem[hi] )

); //从后向前，顺

序查找

4 return

hi; //若hi < lo，则

意味着失败

；否则hi即命中

元素癿秩

5 }

代

码2.10 无序向量

元素查找接

口find()

其中若干

细微之处，需

要体会。比如

，当同时有多

个命中元素

时，本书统一

约定返回其

中秩

最大者

稍后介绍的

查找接口find()亦

是如此故这

里采用了自

后向前的查

找次序。如此

，

一旦命中即

可立即返回

，从而省略掉

不必要的比

对。另外，查找

失败时约定

统一返回-1。这

不仅

简化了

对查找失败

情况的判别

，同时也使此

时的返回结

果更加易于

理解只要假

想着在秩为

-1

处植入一个

与任何对象

都相等的哨

兵元素，则返

回该元素的

秩当且仅当

查找失败。

最

后还有一处

需要留意。while循

环的控制逻

辑由两部分

组成，首先判

断是否已抵

达通配符，

再

判断当前元

素与目标元

素是否相等

。得益于C/C++语言

中逻辑表达

式的短路求

值特性，在前

一

判断非真

后循环会立

即终止，而不

致因试图引

用已越界的

秩（-1）而出错。

 复

杂度

最坏情

况下，查找终

止于首元素

_elem[lo]，运行时间为

O(hi -

lo) = O(n)。最好情况

下

，查找命中于

末元素_elem[hi

- 1]，仅需

O(1)时间。对于规

模相同、内部

组成不同的

输入，

渐进运

行时间却有

本质区别，故

此类算法也

称作输入敏

感的（input sensitive）算法。

§2.5 常

觃向量 第2章

向量

40

2.5.5 插入

 实

现

按照代码

2.1的ADT定义，插入

操作insert(r, e)负责将

任意给定的

元素e插到任

意指定的

秩

为r的单元。整

个操作的过

程，可具体实

现如代码2.11所

示。

1

template <typename T> //将e作为秩

为r元素揑入

2

Rank Vector<T>::insert ( Rank

r, T const& e

) { //assert: 0

<= r <= size

3 expand(); //若有必要，扩

容

4

for ( int i

= _size; i >

r; i-- ) _elem[i]

= _elem[i-1]; //自后向前

，后继元素顺

次后秱一个

单元

5

_elem[r] = e; _size++;

//置入新

元素幵更新

容量

6 return r;

//迒回秩

7 }

代码2.11 向量元

素揑入接口

insert()

如前所述，插

入之前必须

首先调用expand()算

法，核对是否

即将溢出；若

有必要（图

2.4(a)），则

加倍扩容（图

2.4(b)）。

图2.4 向量元素

揑入操作insert(r,

e)癿

过秳

为保证

数组元素物

理地址连续

的特性，随后

需要将后缀

_elem[r, _size)（如果非空）整

体后移一个

单元（图(c)）。这些

后继元素自

后向前的搬

迁次序不能

颠倒，否则会

因元素被覆

盖

而造成数

据丢失。在单

元_elem[r]腾出之后

，方可将待插

入对象e置入

其中（图(d)）。

 复杂

度

时间主要

消耗于后继

元素的后移

，线性正比于

后缀的长度

，故总体为O(_size -

r + 1)。

可

见，新插入元

素越靠后（前

）所需时间越

短（长）。特别地

，r取最大值_size时

为最好

情况

，只需O(1)时间；r取

最小值0时为

最坏情况，需

要O(_size)时间。一般

地，若插入位

置等

概率分

布，则平均运

行时间为O(_size) = O(n)（习

题[2-9]），线性正比

于向量的实

际规模。

2.5.6 删除

删除操作重

载有两个接

口，remove(lo, hi)用以删除

区间[lo, hi)内的元

素，而remove(r)

用以删

除秩为r的单

个元素。乍看

起来，利用后

者即可实现

前者：令r从hi - 1到

lo递减，反复

调

用remove(r)。不幸的是

，这一思路似

是而非。

因数

组中元素的

地址必须连

续，故每删除

一个元素，所

有后继元素

都需向前移

动一个单元

。

若后继元素

共有m = _size

- hi个，则对

remove(r)的每次调用

都需移动m次

；对于整个区

间，

元素移动

的次数累计

将达到m*(hi -

lo)，为后

缀长度和待

删除区间宽

度的乘积。

实

际可行的思

路恰好相反

，应将单元素

删除视作区

间删除的特

例，并基于后

者来实现前

者。

第2章 向量

§2.5

常觃向量

41

稍

后就会看到

，如此可将移

动操作的总

次数控制在

O(m)以内，而与待

删除区间的

宽度无关。



区

间删除：remove(lo, hi)

向量

区间删除接

口remove(lo, hi)，可实现如

代码2.12所示。

1 template <typename T>

int Vector<T>::remove ( Rank

lo, Rank hi )

{ //初

除匙间[lo, hi)

2

if ( lo ==

hi ) return 0;

//出亍

效率考虑，单

独处理退化

情冴，比如remove(0, 0)

3 while

( hi < _size

) _elem[lo++] = _elem[hi++];

//[hi, _size)顺

次前秱hi - lo个单

元

4 _size = lo;

//更新觃模

，直接丢弃尾

部[lo, _size = hi)匙间

5 shrink(); //若有

必要，则缩容

6 return

hi - lo; //迒回被初除

元素癿数目

7

}

代码2.12 向量区

间初除接口

remove(lo, hi)

设[lo, hi)为向量（图

2.5(a)）的合法区间

（图(b)），则其后缀

[hi, n)需整体前移

hi -

lo

个单元（图(c)）。与

插入算法同

理，这里后继

元素自前向

后的移动次

序也不能颠

倒（习题[2-10]）。

图2.5 向

量区间初除

操作remove(lo,

hi)癿过秳

向量规模更

新为_size - hi +

lo后，还要

调用shrink()，若有必

要则做缩容

处理（图(d)）。

 单元

素删除remove(r)

利用

以上remove(lo,

hi)通用接

口，通过重载

即可实现如

下另一同名

接口remove(r)。

1 template <typename

T> T Vector<T>::remove (

Rank r ) {

//初除向

量中秩为r癿

元素，0 <= r <

size

2 T e

= _elem[r]; //备仹被

初除元素

3

remove ( r, r

+ 1 ); //调

用匙间初除

算法，等效亍

对匙间[r,

r + 1)癿初

除

4

return e; //迒回被初

除元素

5

}

代码

2.13 向量单元素

初除接口remove()



复

杂度

remove(lo, hi)的计算

成本，主要消

耗于后续元

素的前移，线

性正比于后

缀的长度，总

体

不过O(m

+ 1) = O(_size

- hi + 1)。

这与

此前的预期

完全吻合：区

间删除操作

所需的时间

，应该仅取决

于后继元素

的数目，而与

被删除区间

本身的宽度

无关。特别地

，基于该接口

实现的单元

素删除接口

remove(r)需耗时

O(_size - r)。也就

是说，被删除

元素在向量

中的位置越

靠后（前）所需

时间越短（长

），最

好为O(1)，最坏

为O(n) = O(_size)。



错误及意

外处理

请注

意，上述操作

接口对输入

都有一定的

限制和约定

。其中指定的

待删除区间

，必须落在合

§2.5 常觃向量 第

2章

向量

42

法范

围[0, _size)之内，为此

输入参数必

须满足0

 lo  hi

 _size。

一般

地，输入参数

超出接口所

约定合法范

围的此类问

题，都属于典

型的错误（error）或

意

外（exception）。除了以

注释的形式

加以说明，还

应该尽可能

对此类情况

做更为周全

的处理。

尽管

如此，本书还

是沿用了相

对简化的处

置方式，将入

口参数合法

性检查的责

任统一交由

上

层调用例

程，这也是出

于对本书的

重点算法效

率、讲解重点

以及叙述简

洁的优先考

虑。

当然，在充

分掌握了本

书的内容之

后，读者不妨

再按照软件

工程的规范

，就此做进一

步的完善。

2.5.7

唯

一化

很多应

用中，在进一

步处理之前

都要求数据

元素互异。以

网络搜索引

擎为例，多个

计算节点

各

自获得的局

部搜索结果

，需首先剔除

其中重复的

项目，方可合

并为一份完

整的报告。类

似地，

所谓向

量的唯一化

处理，就是剔

除其中的重

复元素，即表

2.1所列deduplicate()接口的

功能。

 实现

视

向量是否有

序，该功能有

两种实现方

式，以下首先

介绍针对无

序向量的唯

一化算法。

1

template <typename T> int

Vector<T>::deduplicate() { //初

除无序向量

中重复元素

（高效版）

2

int oldSize = _size;

//记弽

原觃模

3 Rank i

= 1; //从_elem[1]开

始

4

while ( i <

_size ) //自前向后

逐一考查各

元素_elem[i]

5

( find ( _elem[i],

0, i ) <

0 ) ? //在其前

缀中寺找不

乀雷同者（至

夗一个）

6 i++ : remove

( i ); //若无

雷同则继续

考查其后继

，否则初除雷

同者

7 return oldSize -

_size; //向量觃

模发化量，即

被初除元素

总数

8 }

代码2.14 无

序向量清除

重复元素接

口deduplicate()

如代码2.14所

示，该算法自

前向后逐一

考查各元素

_elem[i]，并通过调用

find()接口，在

其前

缀中寻找与

之雷同者。若

找到，则随即

删除；否则，转

而考查当前

元素的后继

。

 正确性

算法

的正确性由

以下不变性

保证：

在while循环

中，在当前元

素的前缀_elem[0,

i)内

，所有元素彼

此互异

初次

进入循环时

i = 1，只有唯一的

前驱_elem[0]，故不变

性自然满足

。

图2.6 无序向量

deduplicate()算法原理

一

般地如图2.6(a)所

示，假设在转

至元素e =

_elem[i]之前

不变性一直

成立。于是，经

过

针对该元

素的一步迭

代之后，无非

两种结果：

1）若

元素e的前缀

_elem[0, i)中不含与之

雷同的元素

，则如图(b)，在做

过i++之后，新

的

前缀_elem[0, i)将继续

满足不变性

，而且其规模

增加一个单

位。

第2章 向量

§2.5

常觃向量

43

2）反

之，若含存在

与e雷同的元

素，则由此前

一直满足的

不变性可知

，这样的雷同

元素不

超过

一个。因此如

图(c)，在删除e之

后，前缀_elem[0,

i)依然

保持不变性

。

 复杂度

由图

2.6(a)和(b)也可看出

该算法过程

所具有的单

调性：

随着循

环的不断进

行，当前元素

的后继持续

地严格减少

因此，经过n - 2步

迭代之后该

算法必然终

止。

这里所需

的时间，主要

消耗于find()和remove()两

个接口。根据

2.5.4节的结论，前

一部

分时间

应线性正比

于查找区间

的宽度，即前

驱的总数；根

据2.5.6节的结论

，后一部分时

间应线

性正

比于后继的

总数。因此，每

步迭代所需

时间为O(n)，总体

复杂度应为

O(n2

)。

经预排序转

换之后，借助

2.6.3节将要介绍

的相关算法

，还可以进一

步提高向量

唯一化处理

的效率（习题

[2-12]）。

2.5.8 遍历

 功能

在

很多算法中

，往往需要将

向量作为一

个整体，对其

中所有元素

实施某种统

一的操作，比

如

输出向量

中的所有元

素，或者按照

某种运算流

程统一修改

所有元素的

数值（习题[2-13]）。针

对此类操作

，可为向量专

门设置一个

遍历接口traverse()。

 实

现

向量的遍

历操作接口

，可实现如代

码2.15所示。

1 template <typename

T> void Vector<T>::traverse (

void ( *visit )

( T& ) )

//倚劣

函数指针机

刢

2 { for

( int i =

0; i < _size;

i++ ) visit (

_elem[i] ); } //遍历向量

3

4 template <typename T>

template <typename VST> //元素类型、操

作器

5 void Vector<T>::traverse (

VST& visit ) //倚劣函

数对象机刢

6

{ for ( int

i = 0; i

< _size; i++ )

visit ( _elem[i] );

} //遍历向量

代

码2.15 向量遍历

接口traverse()

可见，traverse()遍

历的过程，实

质上就是自

前向后地逐

一对各元素

实施同一基

本操作。

而具

体采用何种

操作，可通过

两种方式指

定。前一种方

式借助函数

指针*visit()指定某

一函数，

该函

数只有一个

参数，其类型

为对向量元

素的引用，故

通过该函数

即可直接访

问或修改向

量元素。

另外

，也可以函数

对象的形式

，指定具体的

遍历操作。这

类对象的操

作符“()”经重载

之后，在

形式

上等效于一

个函数接口

，故此得名。

相

比较而言，后

一形式的功

能更强，适用

范围更广。比

如，函数对象

的形式支持

对向量元素

的关联修改

。也就是说，对

各元素的修

改不仅可以

相互独立地

进行，也可以

根据某个（些

）元素

的数值

相应地修改

另一元素。前

一形式虽也

可实现这类

功能，但要繁

琐很多。



实例

在代码2.16中，Increase<T>()即

是按函数对

象形式指定

的基本操作

，其功能是将

作为参

数的

引用对象的

数值加一（假

定元素类型

T可直接递增

或已重载操

作符"++"）。于是可

如

§2.6 有序向量

第2章

向量

44

increase()函

数那样，以此

基本操作做

遍历即可使

向量内所有

元素的数值

同步加一。

1

template <typename T> struct

Increase //函

数对象：逑增

一个T类对象

2 { virtual

void operator() ( T&

e ) { e++;

} }; //假讴T可直接

逑增戒已重

载++

3

4 template <typename T>

void increase ( Vector<T>

& V ) //统一逑增

向量中癿各

元素

5 { V.traverse (

Increase<T>() ); } //以Increase<T>()为基

本操作迕行

遍历

代码2.16 基

二遍历实现

increase()功能

 复杂度

遍历操作本

身只包含一

层线性的循

环迭代，故除

了向量规模

的因素之外

，遍历所需时

间应线

性正

比于所统一

指定的基本

操作所需的

时间。比如在

上例中，统一

的基本操作

Increase<T>()

只需常数时

间，故这一遍

历的总体时

间复杂度为

O(n)。

§2.6 有序向量

若

向量S[0, n)中的所

有元素不仅

按线性次序

存放，而且其

数值大小也

按此次序单

调分布，

则称

作有序向量

（sorted vector）。例如，所有学

生的学籍记

录可按学号

构成一个有

序向量（学

生

名单），使用同

一跑道的所

有航班可按

起飞时间构

成一个有序

向量（航班时

刻表），第二十

九

届奥运会

男子跳高决

赛中各选手

的记录可按

最终跳过的

高度构成一

个（非增）序列

（名次表）。

与通

常的向量一

样，有序向量

依然不要求

元素互异，故

通常约定其

中的元素自

前（左）向后（右

）

构成一个非

降序列，即对

任意0

 i < j

< n都有S[i]  S[j]。

2.6.1 比

较器

当然，除

了与无序向

量一样需要

支持元素之

间的“判等”操

作，有序向量

的定义中实

际上还

隐含

了另一更强

的先决条件

：各元素之间

必须能够比

较大小。这一

条件构成了

有序向量中

“次

序”概念的

基础，否则所

谓的“有序”将

无从谈起。

多

数高级程序

语言所提供

的基本数据

类型都满足

上述条件，比

如C++语言中的

整型、浮点型

和字符型等

，然而字符串

、复数、矢量以

及更为复杂

的类型，则未

必直接提供

了某种自然

的大小

比较

规则。采用很

多方法，都可

以使得大小

比较操作对

这些复杂数

据对象可以

明确定义并

且可行，

比如

最常见的就

是在内部指

定某一（些）可

比较的数据

项，并由此确

立比较的规

则。这里沿用

2.5.3节的约定，假

设复杂数据

对象已经重

载了"<"和"<="等操

作符。

2.6.2 有序性

甄别

作为无

序向量的特

例，有序向量

自然可以沿

用无序向量

的查找算法

。然而，得益于

元素之间

的

有序性，有序

向量的查找

、唯一化等操

作都可更快

地完成。因此

在实施此类

操作之前，都

有必

要先判

断当前向量

是否已经有

序，以便确定

是否可采用

更为高效的

接口。

1 template <typename

T> int Vector<T>::disordered() const

{ //迒回向

量中逆序相

邻元素对癿

总数

2 int

n = 0; //计数器

3

for ( int i

= 1; i <

_size; i++ ) //逐一检查_size

- 1对

相邻元素

第

2章 向量

§2.6 有序

向量

45

4

if ( _elem[i -

1] > _elem[i] )

n++; //逆序则

计数

5 return

n; //向量有

序弼且仅弼

n = 0

6 }

代码2.17 有序向

量甄删算法

disordered()

代码2.17即为有

序向量的一

个甄别算法

，其原理与1.1.3节

起泡排序算

法相同：顺序

扫描整

个向

量，逐一比较

每一对相邻

元素向量已

经有序，当且

仅当它们都

是顺序的。

2.6.3 唯

一化

相对于

无序向量，有

序向量中清

除重复元素

的操作更为

重要。正如2.5.7节

所指出的，出

于

效率的考

虑，为清除无

序向量中的

重复元素，一

般做法往往

是首先将其

转化为有序

向量。

 低效版

1

template <typename T> int

Vector<T>::uniquify() { //有序向量重

复元素剔除

算法（低效版

）

2

int oldSize = _size;

int i = 1;

//弼前比对元

素癿秩，起始

亍首元素

3 while (

i < _size )

//从

前向后，逐一

比对各对相

邻元素

4 _elem[i -

1] == _elem[i] ?

remove ( i )

: i++; //若雷

同，则初除后

者；否则，转至

后一元素

5

return oldSize - _size;

//向

量觃模发化

量，即被初除

元素总数

6 }

代

码2.18

有序向量

uniquify()接口癿平凡

实现

唯一化

算法可实现

如代码2.18所示

，其正确性基

于如下事实

：有序向量中

的重复元素

必然

前后紧

邻。于是，可以

自前向后地

逐一检查各

对相邻元素

：若二者雷同

则调用remove()接口

删

除靠后者

，否则转向下

一对相邻元

素。如此，扫描

结束后向量

中将不再含

有重复元素

。

这里的运行

时间，主要消

耗于

while循环，共

需迭代_size - 1

= 

n -

1步。此

外，在最坏情

况下，

每次循

环都需执行

一次remove()

操作，由

2.3节的分析结

论，其复

杂度

线性正比于

被删除元素

的后

继元素

总数。因此如

图2.7所示，

当大

量甚至所有

元素均雷同

时，用

于所有

这些remove()操作的

时间

总量将

高达：

图2.7 低效

版uniquify()算法癿最

坏情冴

 (n

- 2) + (n

- 3) + ...

+ 2 + 1

= O(n2

)

这一

效率竟与向

量未排序时

相同，说明该

方法未能充

分利用此时

向量的有序

性。

 改进思路

稍加分析即

不难看出，以

上唯一化过

程复杂度过

高的根源是

，在对remove()接口的

各次调

用中

，同一元素可

能作为后继

元素向前移

动多次，且每

次仅移动一

个单元。

§2.6

有序

向量 第2章 向

量

46

图2.8 有序向

量中癿重复

元素可批量

初除

如上所

言，此时的每

一组重复元

素，都必然前

后紧邻地集

中分布。因此

如图2.8所示，可

以

区间为单

位成批地删

除前后紧邻

的各组重复

元素，并将其

后继元素（若

存在）统一地

大跨度前移

。

具体地，若V[lo, hi)为

一组紧邻的

重复元素，则

所有的后继

元素V[hi, _size)可统一

地整体

前移

hi

- lo - 1个单元。

 高效

版

按照上述

思路，可如代

码2.19所示得到

唯一化算法

的新版本。

1

template <typename T> int

Vector<T>::uniquify() { //有

序向量重复

元素剔除算

法（高效版）

2

Rank i = 0,

j = 0; //各

对互异“相邻

”元素癿秩

3 while ( ++j

< _size ) //逐

一扫描，直至

末元素

4 if ( _elem[i]

!= _elem[j] ) //跳过

雷同者

5 _elem[++i] = _elem[j];

//収现

丌同元素时

，向前秱至紧

邻亍前者右

侧

6 _size =

++i; shrink(); //直接截除

尾部夗余元

素

7

return j - i;

//向量觃模

发化量，即被

初除元素总

数

8 }

代码2.19

有序

向量uniquify()接口癿

高效实现

图

2.9针对一个有

序向量的实

例，完整地给

出了该算法

对应的执行

过程。

图2.9 在有

序向量中查

找互异癿相

邻元素

同样

地，既然各组

重复元素必

然彼此相邻

地构成一个

子区间，故只

需依次保留

各区间的起

始

元素。于是

，这里引入了

变量i和j。每经

过若干次移

动，i和j都将分

别指向下一

对相邻子区

间

的首元素

；在将后者转

移至前者的

后继位置之

后，即可重复

上述过程。具

体地如图(a)所

示，初

始时i

= 0和

j = 1分别指向最

靠前两个元

素。

第2章 向量

§2.6 有序向量

47

接

下来，逐位后

移j，直至指向

A[j=4] = 5 

A[i=0]。如图(b)，此时可

见，i和j的确分

别指向3和5所

在分组的首

元素。接下来

，令i = 1，并将A[j=4] =

5前移

至A[i=1]处。此时的

i指向刚被前

移的A[1] = 5；令j =

j + 1 =

5指向

待扫描的下

一元素A[5] = 5，并继

续比较。

如图

(c)，此轮比较终

止于

A[j=9] = 8 

A[i=1] = 5。

于是，令

i

= i + 1

= 2，并将A[j=9] = 8前移至

A[i=2]处。此时的i指

向刚被前移

的A[2]

= 8；令j = j

+ 1 = 10指向待

扫描的下一

元素A[10]

= 8，并继续

比较。如图(d)，此

轮比较

终止

于A[12] =

13  A[i=2] =

8。于是，令i = i +

1 = 3，并

将A[j=12] =

13前移至A[i=3]

处

。此时的i指向

刚被前移的

A[3] = 13；令j

= j + 1

= 13指向待扫

描的下一元

素A[13] = 13，

并继续比

较。如图(e)，至j = 16 

_size时

，循环结束。最

后如图(f)，只需

将向量规模

更新

为_size = i

+ 1 = 4，算法

随即结束。鉴

于在删除重

复元素之后

内部数组的

空间利用率

可能

下降很

多，故需调用

shrink()，如有必要则

做缩容处理

。

 复杂度

while循环

的每一步迭

代，仅需对元

素数值做一

次比较，向后

移动一到两

个位置指针

，并至

多向前

复制一个元

素，故只需常

数时间。而在

整个算法过

程中，每经过

一步迭代秩

j都必然加一

，

鉴于j不能超

过向量的规

模n，故共需迭

代n次。由此可

知，uniquify()算法的时

间复杂度应

为

O(n)，较之uniquifySlow()的O(n2

)，效

率整整提高

了一个线性

因子。

反过来

，在遍历所有

元素之前不

可能确定是

否有重复元

素，故就渐进

复杂度而言

，能在O(n)

时间内

完成向量的

唯一化已属

最优。当然，之

所以能够做

到这一点，关

键在于向量

已经排序。

2.6.4 查

找

有序向量

S中的元素不

再随机分布

，秩r是S[r]在S中按

大小的相对

位次，位于S[r]前

（后）

方的元素

均不致于更

大（小）。当所有

元素互异时

，r即是S中小于

S[r]的元素数目

。一般地，

若小

于、等于S[r]的元

素各有i、k个，则

该元素及其

雷同元素应

集中分布于

S[i, i

+ k)。

利用上述性

质，有序向量

的查找操作

可以更加高

效地完成。尽

管在最坏情

况下，无序向

量的

查找操

作需要线性

时间，但我们

很快就会看

到，有序向量

的这一效率

可以提升至

O(logn)。

为区别于无

序向量的查

找接口find()，有序

向量的查找

接口将统一

命名为search()。与

find()一

样，代码2.1也针

对有序向量

的整体或区

间查找重载

了两个search()接口

，且前者作

为

特例可直接

调用后者。因

此，只需如代

码2.20所示实现

其中的区间

查找接口。

1

template <typename T> //在

有序向量癿

匙间[lo,

hi)内，确定

丌大亍e癿最

后一个节点

癿秩

2 Rank Vector<T>::search

( T const& e,

Rank lo, Rank hi

) const { //assert:

0 <= lo <

hi <= _size

3

return ( rand() %

2 ) ? //按各50%癿

概率随机使

用二分查找

戒Fibonacci查找

4 binSearch ( _elem,

e, lo, hi )

: fibSearch ( _elem,

e, lo, hi );

5 }

代码

2.20 有序向量各

种查找算法

癿统一search()接口

鉴于有序查

找的算法多

样且各具特

点，为便于测

试，这里的接

口不妨随机

选择查找算

法。实

际应用

中可根据问

题的特点具

体确定，并做

适当微调。以

下将介绍两

类典型的查

找算法。

§2.6 有序

向量 第2章

向

量

48

2.6.5 二分查找

（版本A）

 减而治

之

循秩访问

的特点加上

有序性，使得

我们可将“减

而治之” 策略

运用于有序

向量的查找

。具

体地如图

2.10所示，假设在

区间S[lo, hi)中查找

目标元素e。

图

2.10 基二减治策

略癿有序向

量事分查找

算法（版本A）

以

任一元素S[mi] = x为

界，都可将区

间分为三部

分，且根据此

时的有序性

必有：

S[lo,

mi)  S[mi] 

S(mi, hi)

于是，只

需将目标元

素e与x做一比

较，即可视比

较结果分三

种情况做进

一步处理：1）若

e <

x，则目标元素

如果存在，必

属于左侧子

区间S[lo, mi)，故可深

入其中继续

查找；2）若x < e，

则目

标元素如果

存在，必属于

右侧子区间

S(mi, hi)，故也可深入

其中继续查

找；3）若e = x，

则意味

着已经在此

处命中，故查

找随即终止

。

也就是说，每

经过至多两

次比较操作

，我们或者已

经找到目标

元素，或者可

以将查找问

题简

化为一

个规模更小

的新问题。如

此，借助递归

机制即可便

捷地描述和

实现此类算

法。实际上，以

下将要介绍

的各种查找

算法都可归

入这一模式

，不同点仅在

于其对切分

点mi的选取策

略，以及每

次

深入递归之

前所做比较

操作的次数

。

 实现

按上述

思路实现的

第一个算法

如代码2.21所示

。为区别于稍

后将要介绍

的同类算法

的其它

版本

，不妨将其记

作版本A。

1 // 二分

查找算法（版

本A）：在有序向

量癿匙间[lo, hi)内

查找元素e，0

<= lo <= hi

<= _size

2 template

<typename T> static Rank

binSearch ( T* A,

T const& e, Rank

lo, Rank hi )

{

3 while (

lo < hi )

{ //殏

步迭代可能

要做两次比

较刞断，有三

个分支

4 Rank

mi = ( lo

+ hi ) >>

1; //以中

点为轴点

5 if

( e < A[mi]

) hi = mi;

//深

入前半殌[lo, mi)继

续查找

6 else

if ( A[mi] <

e ) lo =

mi + 1; //深入

后半殌(mi,

hi)继续

查找

7 else return

mi; //在mi处命

中

8 }

//成功查找

可以提前终

止

9 return -1;

//查找失败

10 } //有夗个命中

元素时，丌能

保证迒回秩

最大者；查找

失败时，简单

地迒回-1，而丌

能指示失败

癿位置

代码

2.21

事分查找算

法（版本A）

为在

有序向量区

间[lo, hi)内查找元

素e，该算法以

中点mi =

(lo + hi) /

2为界，将

其

大致平均

地分为前、后

两个子向量

。随后通过一

至两次比较

操作，确定问

题转化的方

向。通过快

捷

的整数移位

操作回避了

相对更加耗

时的除法运

算。另外，通过

引入lo、hi和mi等变

量，将减

第2章

向量

§2.6 有序向

量

49

治算法通

常的递归模

式改成了迭

代模式。

 实例

如图2.11左侧所

示，设通过调

用search(8, 0, 7)，在有序向

量区间S[0,

7)内查

找目标

元素

8。第一步迭代

如图(a1)所示，取

mi = (0

+ 7)/2 = 3，经过1次失败

的比较另加

1次成功

的比

较后确认S[mi = 3] =

7 < 8，故

深入后半段

S[4, 7)。第二步迭代

如图(a2)所示，取

mi

= 

(4 +

7)/2 = 5，经过1次成功

的比较后确

认8 <

S[mi = 5] =

9，故深入前

半段S[4, 5)。最

后一

步迭代如图

(a3)所示，取mi =

(4 + 5)/2 =

4，经过

2次失败的比

较后确认8 = S[mi =

4]。

前

后总共经过

3步迭代和5次

比较操作，最

终通过返回

合法的秩mi = 4，指

示对目标元

素8的查找

在

元素S[4]处成功

命中。

图2.11 事分

查找算法（版

本A）实例：search(8, 0,

7)成功

，search(3, 0, 7)失败

再如图

2.11右侧所示，设

通过调用search(3,

0, 7)，在

同一向量区

间内查找目

标元素3。

第一

步迭代如图

(b1)所示，取mi =

(0 + 7) /

2 = 3，经过

1次成功的比

较后确认3 <

S[mi = 

3]

= 7，故

深入前半段

S[0, 3)。第二步迭代

如图(b2)所示，取

mi =

(0 + 3) /

2 = 1，经

过1次成功

的比较后确

认3

< S[mi = 1]

= 4，故深入前

半段S[0, 1)。第三步

迭代如图(b3)所

示，取mi =

(0 + 1) /

2 = 0，经过1次

失败的比较

另加1次成功

的比较后确

认S[mi =

0] = 2

< 3，故深入“后

半段”S[1, 1)。此时因

为lo =

1 = hi，故最后一

步迭代实际

上并不会执

行；

while循环退出

后，算法通过

返回非法的

秩-1指示查找

失败。纵观整

个查找过程

，前后总共经

过

4步迭代和

4次比较操作

。

 复杂度

以上

算法采取的

策略可概括

为，以“当前区

间内居中的

元素”作为目

标元素的试

探对象。从

应

对最坏情况

的保守角度

来看，这一策

略是最优的

每一步迭代

之后无论沿

着哪个方向

深入，

新问题

的规模都将

缩小一半。因

此，这一策略

亦称作二分

查找（binary search）。

也就是

说，随着迭代

的不断深入

，有效的查找

区间宽度将

按1/2的比例以

几何级数的

速度递

减。于

是，经过至多

log2(hi - lo)步迭代后，算

法必然终止

。鉴于每步迭

代仅需常数

时间，故

总体

时间复杂度

不超过：

O(log2(hi - lo)) =

O(logn)

与代

码2.10中顺序查

找算法的O(n)复

杂度相比，O(logn)几

乎改进了一

个线性因子

。

 查找长度

以

上迭代过程

所涉及的计

算，主要分为

两类：元素的

大小比较、秩

的算术运算

及其赋值。虽

然二者均属

于O(1)复杂度的

基本操作，但

元素的秩无

非是（无符号

）整数，而向量

元素的类型

§2.6 有序向量 第

2章 向量

50

则通

常更为复杂

，甚至复杂到

未必能够保

证在常数时

间内完成（习

题[2-17]）。因此就时

间复

杂度的

常系数而言

，前一类计算

的权重远远

高于后者，而

查找算法的

整体效率也

更主要地取

决于

其中所

执行的元素

大小比较操

作的次数，即

所谓查找长

度（search

length）。

通常，可针

对查找成功

或失败等情

况，从最好、最

坏和平均情

况等角度，分

别测算查找

长度，

并凭此

对查找算法

的总体性能

做一评估。



成

功查找长度

对于长度为

n的有序向量

，共有n种可能

的成功查找

，分别对应于

某一元素。实

际上，每一

种

成功查找所

对应的查找

长度，仅取决

于n以及目标

元素所对应

的秩，而与元

素的具体数

值无关。

比如

，回顾图2.11中的

实例不难看

出，无论怎样

修改那7个元

素的数值，只

要它们依然

顺序排列，

则

针对S[4]的查找

过程（包括各

步迭代的比

较次数以及

随后的深入

方向）必然与

在原例中执

行

search(8, 0, 7)的过程完

全一致。

图2.12

事

分查找算法

（版本A）癿查找

长度（成功、失

败查找分删

以实线、虚线

白色斱框示

意）

当n = 7时由图

2.12不难验证，各

元素所对应

的成功查找

长度分别应

为：

{ 4, 3, 5,

2, 5, 4, 6

}

若假定查

找的目标元

素按等概率

分布，则平均

查找长度即

为：

(4 +

3 + 5 +

2 + 5 +

4 + 6) /

7 = 29 /

7 = 4.14

为了估计

出一般情况

下的成功查

找长度，不失

一般性地，仍

在等概率条

件下考查长

度为n

= 

2

k

- 1的有序

向量，并将其

对应的平均

成功查找长

度记作caverage(k)，将所

有元素对应

的查找长

度

总和记作C(k) =

caverage(k)∙(2k

- 1)。

特

别地，当k

= 1时向

量长度n = 1，成功

查找仅有一

种情况，故有

边界条件：

caverage(1) = C(1) =

2

以

下采用递推

分析法。对于

长度为n = 2k

- 1的有

序向量，每步

迭代都有三

种可能的分

支：

经过1次成

功的比较后

，转化为一个

规模为2

k-1

- 1的新

问题（图2.12中的

左侧分支）；经

2次失

败的比

较后，终止于

向量中的某

一元素，并确

认在此处成

功命中；经1次

失败的比较

另加1次成功

的比较后，转

化为另一个

规模为2

k-1

- 1的新

问题（图2.12中的

右侧分支）。

根

据以上递推

分析的结论

，可得递推式

如下：

C(k)

= [C(k - 1)

+ (2k-1

- 1)]

+ 2 + [C(k

- 1) + 2(2k-1

- 1)]（式2-1）

 =

2∙C(k - 1) +

3∙2k-1

- 1

若令

：

第2章 向量 §2.6 有

序向量

51

F(k) = C(k)

- 3k∙2

k-1

-

1

则有

：

F(1) =

-2

F(k) = 2∙F(k

- 1) = 22

∙F(k - 2) =

23

∙F(k - 3)

= ...

 =

2k-1

∙F(1) = -2

k

于是：

C(k) =

F(k) + 3k 

2

k-1

+ 1

= -2

k

+

3k  2

k-1

+ 1

 =

(3k/2 - 1)∙(2k

-

1) + 3k/2

进而：

caverage(k) = C(k) /

(2

k

- 1)

= 3k/2 - 1

+ 3k/2/(2k

- 1)

= 3k/2 - 1

+ O()

也

就是说，若忽

略末尾趋于

收敛的波动

项，平均查找

长度应为：

O(1.5k)

= O(1.5∙log2n)

 失

败查找长度

按照代码2.21，失

败查找的终

止条件必然

是“lo

 hi”，也就是说

，只有在有效

区间宽度

缩

减至0时，查找

方以失败告

终。因此，失败

查找的时间

复杂度应为

确定的(logn)。

不难

发现，就各步

迭代后分支

方向的组合

而言，失败查

找可能的情

况，恰好比成

功查找可能

的情况多出

一种。例如在

图2.12中，失败查

找共有7

+ 1 = 8种可

能。由图2.12不难

验证，各

种可

能所对应的

查找长度分

别为：

{ 3, 4,

4, 5, 4, 5,

5, 6 }

其中，最

好情况下需

要做3次元素

比较，最坏情

况下需要做

6次元素比较

。若同样地假

定待

查找目

标元素按等

概率分布，则

平均查找长

度应为：

(3 + 4

+ 4 + 5

+ 4 + 5

+ 5 + 6)

/ 8 = 36

/ 8 = 4.50

仿照

以上对平均

成功查找长

度的递推分

析方法，不难

证明（习题[2-20]），一

般情况下的

平均失败查

找长度亦为

O(1.5∙log2n)。

 不足

尽管二

分查找算法

（版本A）即便在

最坏情况下

也可保证O(logn)的

渐进时间复

杂度，但就

其

常系数1.5而言

仍有改进余

地。以成功查

找为例，即便

是迭代次数

相同的情况

，对应的查找

长

度也不尽

相等。究其根

源在于，在每

一步迭代中

为确定左、右

分支方向，分

别需要做1次

或2次元

素比

较，从而造成

不同情况所

对应查找长

度的不均衡

。尽管该版本

从表面上看

完全均衡，但

我们

通过以

上细致的分

析已经看出

，最短和最长

分支所对应

的查找长度

相差约两倍

。

那么，能否实

现更好的均

衡呢？具体又

应如何实现

呢？

2.6.6 Fibonacci查找



递推

方程

递推方

程法既是复

杂度分析的

重要方法，也

是我们优化

算法时确定

突破口的有

力武器。为改

§2.6 有序向量 第

2章

向量

52

进以

上二分查找

算法的版本

A，不妨从刻画

查找长度随

向量长度递

推变化的式

2-1入手。

实际上

，最终求解所

得到的平均

复杂度，在很

大程度上取

决于这一等

式。更准确地

讲，主要

取决

于(2k-1

- 1)和2 

(2k-1

- 1)两项，其

中的(2k-1

-

1)为子向

量的宽度，而

系数1和2则是

算法为深入

前、后子向量

，所需做的比

较操作次数

。以此前的二

分查找算法

版本A为例，之

所以

存在均

衡性方面的

缺陷，根源正

在于这两项

的大小不相

匹配。

基于这

一理解，不难

找到解决问

题的思路，具

体地不外乎

两种：

其一，调

整前、后区域

的宽度，适当

地加长（缩短

）前（后）子向量

其二，统一沿

两个方向深

入所需要执

行的比较次

数，比如都统

一为一次

后

一思路的实

现将在稍后

介绍，以下首

先介绍前一

思路的具体

实现。

 黄金分

割

实际上，减

治策略本身

并不要求子

向量切分点

mi必须居中，故

按上述改进

思路，不妨按

黄

金分割比

来确定mi。为简

化起见，不妨

设向量长度

n = fib(k) -

1。

图2.13 Fibonacci查找算法

原理

于是如

图2.13所示，fibSearch(e,

0, n)查找

可以mi = fib(k

- 1) - 1作为前

、后子

向量的

切分点。如此

，前、后子向量

的长度将分

别是：

fib(k - 1)

- 1

fib(k -

2) - 1 =

(fib(k) - 1) -

(fib(k - 1) -

1) - 1

于是，无

论朝哪个方

向深入，新向

量的长度从

形式上都依

然是某个Fibonacci数

减一，故这

一

处理手法可

以反复套用

，直至因在S[mi]处

命中或向量

长度收缩至

零而终止。这

种查找算法

，

亦称作Fibonacci查找

（Fibonaccian search）。



实现

按照以

上思路，可实

现Fibonacci查找算法

如代码2.22所示

。

1 #include

"..\fibonacci\Fib.h" //引入Fib数列类

2 // Fibonacci查找算法（版

本A）：在有序向

量癿匙间[lo,

hi)内

查找元素e，0 <= lo <=

hi <= _size

3

template <typename T> static

Rank fibSearch ( T*

A, T const& e,

Rank lo, Rank hi

) {

4 Fib

fib ( hi -

lo ); //用

O(log_phi(n =

hi - lo)时间创建Fib数

列

5

while ( lo <

hi ) { //殏步迭代

可能要做两

次比较刞断

，有三个分支

6

while ( hi -

lo < fib.get() )

fib.prev(); //通过向前顺

序查找（分摊

O(1)）——至夗迭代几

次？

7 Rank

mi = lo +

fib.get() - 1; //确定形如

Fib(k)

- 1癿轴点

8 if

( e < A[mi]

) hi = mi;

//深入

前半殌[lo, mi)继续

查找

9 else

if ( A[mi] <

e ) lo =

mi + 1; //深入后

半殌(mi,

hi)继续查

找

10 else return

mi; //在mi处命中

11 } //成功查找可

以提前终止

第2章

向量 §2.6 有

序向量

53

12 return -1; //查找

失败

13 } //有夗个

命中元素时

，丌能保证迒

回秩最大者

；失败时，简单

地迒回-1，而丌

能指示失败

癿位置

代码

2.22

Fibonacci查找算法

算

法主体框架

与二分查找

大致相同，主

要区别在于

以黄金分割

点取代中点

作为切分点

。为此，

需要借

助Fib对象（习题

[1-22]），实现对Fibonacci数的

高效设置与

获取。

尽管以

下的分析多

以长度为fib(k)

- 1的

向量为例，但

这一实现完

全可适用于

长度任意的

向量中的任

意子向量。为

此，只需在进

入循环之前

调用构造器

Fib(n = hi

- lo)，将初始长度

设置为“不小

于n的最小Fibonacci项

”。这一步所需

花费的O(logn)时间

，分摊到后续

的

O(logn)步迭代中

，并不影响算

法整体的渐

进复杂度。



定

性比较

可见

，Fibonacci查找倾向于

适当加长（缩

短）需1次（2次）比

较方可确定

的前端（后端

）

子向量。故定

性地粗略估

计，应可（在常

系数的意义

上）进一步提

高查找的效

率。

图2.14

Fibonacci查找算

法癿查找长

度（成功、失败

查找分删以

实线、虚线白

色斱框示意

）

作为验证，不

妨仍以n = fib(6)

- 1 = 7为例

，就平均查找

长度与二分

查找做一对

比。

如图2.14所示

，7种成功情况

、8种失败情况

的查找长度

分别为：

{ 5, 4,

3, 5, 2, 5,

4 }

{ 4,

5, 4, 4, 5,

4, 5, 4 }

若依

然假定各种

情况出现的

概率相等，则

平均成功查

找长度和平

均失败查找

长度应分别

为：

(5 + 4

+ 3 + 5

+ 2 + 5

+ 4) / 7

= 28 / 7

= 4.00

(4 +

5 + 4 +

4 + 5 +

4 + 5 +

4) / 8 =

35 / 8 =

4.38

相对于二

分查找算法

版本A实例（图

2.12）的4.14和4.50，的确有

所改进。

 定量

分析

参照2.6.5节

的方法，也可

对Fibonacci查找算法

的成功查找

长度做出最

更为精确的

分析。

其中关

于最好、最坏

情况的结论

完全一致，故

以下仅讨论

等概率条件

下的平均情

况。

依然将长

度为n =

fib(k) - 1的有序

向量的平均

成功查找长

度记作caverage(k)，将所

有元

素对应

的查找长度

总和记作C(k)

= caverage(k)∙(fib(k) - 1)。

§2.6 有

序向量 第2章

向量

54

同理，可

得边界条件

及递推式如

下：

caverage(2) = C(2)

= 0

caverage(3) =

C(3) = 2

C(k)

= [C(k-1) + (fib(k-1)

- 1)] + 2

+ [C(k-2) + 2(fib(k-2)

- 1)]

 =

C(k - 2) +

C(k - 1) +

fib(k - 2) +

fib(k) - 1

结合以上

边界条件，可

以解得：

C(k) =

①

k∙fib(k)

- fib(k + 2)

+ 1 = (k

- 

2

)∙fib(k)

+ 1 + O()

其中

， = ( 5

+ 1) / 2

= 1.618

于是

caverage(k)

= C(k)/(fib(k) - 1)

= k - 

2

+ 1 +

(k - 

2

)/(fib(k) - 1) +

O()

= k -



2

+ 1

+ O()

也就是

说，忽略末尾

趋于收敛的

波动项，平均

查找长度的

增长趋势为

：

O(k)

= O(logn) = O(log2

∙ log2n) = O(1.44∙log2n)

较之2.6.5节二分

查找算法（版

本A）的O(1.50∙log2n)，效率略

有提高。

2.6.7 二分

查找（版本B）



从

三分支到两

分支

2.6.6节开篇

曾指出，二分

查找算法版

本A的不均衡

性体现为复

杂度递推式

中(2k-1

- 1)和

2(2k-1

- 1)两项的

不均衡。为此

，Fibonacci查找算法已

通过采用黄

金分割点，在

一定程度上

降低了时间

复杂度的常

系数。实际上

还有另一更

为直接的方

法，即令以上

两项的常系

数同时等于

1。也就是说，无

论朝哪个方

向深入，都只

需做1次元素

的大小比较

。相应地，算法

在每步迭代

中

（或递归层

次上）都只有

两个分支方

向，而不再是

三个。

图2.15 基二

减治策略癿

有序向量事

分查找算法

（版本B）

具体过

程如图2.15所示

，与二分查找

算法的版本

A基本类似。不

同之处是，在

每个切分点

A[mi]

处，仅做一次

元素比较。具

体地，若目标

元素小于A[mi]，则

深入前端子

向量A[lo,

mi)继续查

找；否则，深入

后端子向量

A[mi, hi)继续查找。

 实

现

按照上述

思路，可将二

分查找算法

改进为如代

码2.23所示的版

本B。

 

①

令F(k) = -C(k) +

k∙fib(k) + 1，则有F(0) =

1，F(1) = 2，F(k) =

F(k-1) + F(k-2) =

fib(k+2)

第

2章 向量 §2.6

有序

向量

55

1 //

二分查

找算法（版本

B）：在有序向量

癿匙间[lo, hi)内查

找元素e，0 <= lo

<= hi <= _size

2 template <typename T>

static Rank binSearch (

T* A, T const&

e, Rank lo, Rank

hi ) {

3

while ( 1 <

hi - lo )

{ //殏步

迭代仅需做

一次比较刞

断，有两个分

支；成功查找

丌能提前终

止

4 Rank

mi = ( lo

+ hi ) >>

1; //以中点为

轴点

5 (

e < A[mi] )

? hi = mi

: lo = mi;

//经比较

后确定深入

[lo, mi)戒[mi, hi)

6

} //出口时hi = lo

+ 1，查

找匙间仅含

一个元素A[lo]

7 return

( e == A[lo]

) ? lo :

-1 ; //查

找成功时迒

回对应癿秩

；否则统一迒

回-1

8

} //有夗个命

中元素时，丌

能保证迒回

秩最大者；查

找失败时，简

单地迒回-1，而

丌能指示失

败癿位置

代

码2.23 事分查找

算法（版本B）

请

再次留意与

代码2.21中版本

A的差异。首先

，每一步迭代

只需判断是

否e < A[mi]，即可

相应

地更新有效

查找区间的

右边界（hi

= mi）或左

边界（lo = mi）。另外，只

有等到区间

的

宽度已不

足2个单元时

迭代才会终

止，最后再通

过一次比对

判断查找是

否成功。

 性能

尽管版本B中

的后端子向

量需要加入

A[mi]，但得益于mi总

是位于中央

位置，整个算

法

O(logn)的渐进复

杂度不受任

何影响。

在这

一版本中，只

有在向量有

效区间宽度

缩短至1个单

元时算法才

会终止，而不

能如版本A

那

样，一旦命中

就能及时返

回。因此，最好

情况下的效

率有所倒退

。当然，作为补

偿，最坏情况

下的效率相

应地有所提

高。实际上无

论是成功查

找或失败查

找，版本B各分

支的查找长

度更加接

近

，故整体性能

更趋稳定。



进

一步的要求

在更多细微

之处，此前实

现的二分查

找算法（版本

A和B）及Fibonacci查找算

法仍有改进

的

余地。比如

，当目标元素

在向量中重

复出现时，它

们只能“随机

”地报告其一

，具体选取何

者取

决于算

法的分支策

略以及当时

向量的组成

。而在很多场

合中，重复元

素之间往往

会隐含地定

义有

某种优

先级次序，而

且算法调用

者的确可能

希望得到其

中优先级最

高者。比如按

照表2.1的定义

，

在有多个命

中元素时，向

量的search()接口应

以它们的秩

为优先级，并

返回其中最

靠后者。

这种

进一步的要

求并非多余

。以有序向量

的插入操作

为例，若通过

查找操作不

仅能够确定

可

行的插入

位置，而且能

够在同时存

在多个可行

位置时保证

返回其中的

秩最大者，则

不仅可以尽

可

能低减少

需移动的后

继元素，更可

保证重复的

元素按其插

入的相对次

序排列。对于

向量的插入

排

序等算法

（习题[3-8]）的稳定

性而言，这一

性质更是至

关重要。

另外

，对失败查找

的处理方式

也可以改进

。查找失败时

，以上算法都

是简单地统

一返回一个

标识“-1”。同样地

，若在插入新

元素e之前通

过查找确定

适当的插入

位置，则希望

在查找失败

时返回不大

（小）于e的最后

（前）一个元素

，以便将e作为

其后继（前驱

）插入向量。同

样地，

此类约

定也使得插

入排序等算

法的实现更

为便捷和自

然。

2.6.8

二分查找

（版本C）

 实现

在

版本B的基础

上略作修改

，即可得到如

代码2.24所示二

分查找算法

的版本C。

§2.6 有序

向量 第2章 向

量

56

1 // 二分查找

算法（版本C）：在

有序向量癿

匙间[lo,

hi)内查找

元素e，0 <= lo <=

hi <= _size

2

template <typename T> static

Rank binSearch ( T*

A, T const& e,

Rank lo, Rank hi

) {

3 while

( lo < hi

) { //殏步迭

代仅需做一

次比较刞断

，有两个分支

4 Rank

mi = ( lo

+ hi ) >>

1; //以中点为轴

点

5 (

e < A[mi] )

? hi = mi

: lo = mi

+ 1; //经比较后

确定深入[lo, mi)戒

(mi,

hi)

6 } //成功查找丌

能提前终止

7

return --lo; //循环结束时

，lo为大亍e癿元

素癿最小秩

，故lo -

1即丌大亍

e癿元素癿最

大秩

8 } //有夗个

命中元素时

，总能保证迒

回秩最大者

；查找失败时

，能够迒回失

败癿位置

代

码2.24 事分查找

算法（版本C）

该

版本的主体

结构与版本

B一致，故不难

理解，二者的

时间复杂度

相同。



正确性

版本C与版本

B的差异，主要

有三点。首先

，只有当有效

区间的宽度

缩短至0（而不

是1）时，

查找方

告终止。另外

，在每次转入

后端分支时

，子向量的左

边界取作mi + 1而

不是mi。

表面上

看，后一调整

存在风险此

时只能确定

切分点A[mi]  e，“贸然

”地将A[mi]排

除在

进一步的查

找范围之外

，似乎可能因

遗漏这些元

素，而导致本

应成功的查

找以失败告

终。

然而这种

担心大可不

必。通过数学

归纳可以证

明，版本C中的

循环体，具有

如下不变性

：

A[0, lo)中的元素皆

不大于e；A[hi, n)中的

元素皆大于

e

首次迭代时

，lo = 0且hi =

n，A[0, lo)和A[hi, n)均空，不

变性自然成

立。

如图2.16(a)所示

，设在某次进

入循环时以

上不变性成

立，以下无非

两种情况。若

e

< A[mi]，

则如图(b)，在令

hi =

mi并使A[hi, n)向左扩

展之后，该区

间内的元素

皆不小于A[mi]，当

然

也仍然大

于e。反之，若A[mi] 

e，则

如图(c)，在令lo = mi +

1并

使A[0, lo)向右拓展

之

后，该区间

内的元素皆

不大于A[mi]，当然

也仍然不大

于e。总之，上述

不变性必然

得以延续。

图

2.16

基二减治策

略癿有序向

量事分查找

算法（版本C）

循

环终止时，lo = hi。考

查此时的元

素A[lo

- 1]和A[lo]：作为A[0, lo)内

的最后一个

元素，A[lo -

1]必不大

于e；作为A[lo, n) = A[hi,

n)内的

第一个元素

，A[lo]必大于e。

也就

是说，A[lo - 1]即是原

向量中不大

于e的最后一

个元素。因此

在循环结束

之后，无论成

功

与否，只需

返回lo - 1即可这

也是版本C与

版本B的第三

点差异。

第2章

向量

§2.7 *排序不

下界

57

§2.7

*排序与

下界

2.7.1 有序性

从数据处理

的角度看，有

序性在很多

场合都能够

极大地提高

计算的效率

。以查找算法

为例，

对于无

序向量，正如

此前的分析

结论，代码2.10中

Vector::find()算法O(n)的复杂

度已属最优

。

而对于有序

向量，代码2.20中

Vector::search()接口的效率

，则可优化到

O(logn)。我们知道，

为

此需要借助

二分查找策

略，而之所以

这一策略可

行，正是因为

所有元素已

按次序排列

。

2.7.2 排序及其分

类

由以上介

绍可见，有序

向量的诸如

查找等操作

，效率远高于

一般向量。因

此在解决许

多应用

问题

时我们普遍

采用的一种

策略就是，首

先将向量转

换为有序向

量，再调用有

序向量支持

的各种

高效

算法。这一过

程的本质就

是向量的排

序。为此，正如

2.6.1节所指出的

，向量元素之

间必须

能够

定义某种全

序关系，以保

证它们可相

互比较大小

。

排序算法是

个庞大的家

族，可从多个

角度对其中

的成员进行

分类。比如，根

据其处理数

据的

规模与

存储的特点

不同，可分为

内部排序算

法和外部排

序算法：前者

处理的数据

规模相对不

大，

内存足以

容纳；后者处

理的数据规

模很大，必须

将借助外部

甚至分布式

存储器，在排

序计算过程

的任一时刻

，内存中只能

容纳其中一

小部分数据

。

又如，根据输

入形式的不

同，排序算法

也可分为离

线算法（offline

algorithm）和在

线

算法（online algorithm）。前一

情况下，待排

序的数据以

批处理的形

式整体给出

；而在网络

计

算之类的环

境中，待排序

的数据通常

需要实时生

成，在排序算

法启动后数

据才陆续到

达。再如，

针对

所依赖的体

系结构不同

，又可分为串

行和并行两

大类排序算

法。另外，根据

排序算法是

否采

用随机

策略，还有确

定式和随机

式之分。

本书

讨论的范围

，主要集中于

确定式串行

脱机的内部

排序算法。

2.7.3

下

界

根据1.2.2节的

分析，1.1.3节起泡

排序算法的

复杂度为O(n2

)。那

么，这一效率

是否已经

足

够高？能否以

更快的速度

完成排序？实

际上，在着手

优化算法之

前，这都是首

先必须回答

的问

题。以下

结合具体实

例，从复杂度

下界的角度

介绍回答此

类问题的一

般性方法。

 苹

果鉴别

考虑

如下问题：三

只苹果外观

一样，其

中两

只重量相同

另一只不同

，利用一架天

平

如何从中

找出重量不

同的那只？一

种直观的

方

法可以描述

为算法2.1。

该算

法的可行性

、正确性毋庸

置疑。该

算法

在最好情况

下仅需执行

一次比对操

作，

最坏情况

下两次。那么

，是否存在其

它算法，

即便

在最坏情况

下也至多只

需一次比对

呢？

identifyApple(A,

B, C)

输入：三叧

苹枅A、B和C，其中

两叧重量相

同，另一叧丌

同

输出：找出

重量丌同癿

那叧苹枅

{

 称

量A和B; 若A和B重

量相等，则迒

回C;

称量A和C; 若

A和C重量相等

，则迒回B;

 否则

，迒回A;

}

算法2.1 仍

三个苹枅中

选出重量丌

同者

§2.7

*排序不

下界 第2章 向

量

58

 复杂度下

界

尽管很多

算法都可以

优化，但有一

个简单的事

实却往往为

人所忽略：对

任一特定的

应用问题，

随

着算法的不

断改进，其效

率的提高必

然存在某一

极限。毕竟，我

们不能奢望

不劳而获。这

一极

限不仅

必然存在，而

且其具体的

数值，应取决

于应用问题

本身以及所

采用的计算

模型。

一般地

，任一问题在

最坏情况下

的最低计算

成本，即为该

问题的复杂

度下界（lower bound）。

一旦

某一算法的

性能达到这

一下界，即意

味着它已是

最坏情况下

最优的（worst-case

optimal）。

可见

，尽早确定一

个问题的复

杂度下界，对

相关算法的

优化无疑会

有巨大的裨

益。比如上例

所提

出的问

题，就是从最

坏情况的角

度，质疑“2次比

对操作”是否

为解决这一

问题的最低

复杂度。

以下

结合比较树

模型，介绍界

定问题复杂

度下界的一

种重要方法

。

2.7.4 比较树

 基于

比较的分支

如果用节点

（圆圈）表示算

法过程中的

不同状态，用

有方向的边

（直线段或弧

线段）表示不

同状态之间

的相互转换

，就可以将以

上算法2.1转化

为图2.17的树形

结构（第5章）。

图

2.17 仍三叧苹枅

中挑出重量

丌同者

这一

转化方法也

可以推广并

应用于其它

算法。

一般地

，树根节点对

应于算法入

口处的起始

状态（如

此处

三个苹果已

做好标记）；内

部节点（即非

末端

节点，图

中以白色大

圈示意）对应

于过程中的

某步

计算，通

常属于基本

操作；叶节点

（即末端节点

，

图中以黑色

小圈示意）则

对应于经一

系列计算后

某

次运行的

终止状态。如

此借助这一

树形结构，可

以

涵盖对应

算法所有可

能的执行流

程。

仍以图2.17为

例，从根节点

到叶节点C的

路径对应于

，在经过一次

称量比较并

确定A与B等重

后，即可断定

C是所要查找

的苹果。再如

，从根节点到

叶节点B的路

径对应于，在

经过两次称

量比

较并确

定A与B不等重

、A与C等重之后

，即可判定B是

所要查找的

苹果。

 比较树

算法所有可

能的执行过

程，都可涵盖

于这一树形

结构中。具体

地，该树具有

以下性质：

 每

一内部节点

各对应于一

次比对（称量

）操作；

 内部节

点的左、右分

支，分别对应

于在两种比

对结果（是否

等重）下的执

行方向；

 叶节

点（或等效地

，根到叶节点

的路径）对应

于算法某次

执行的完整

过程及输出

；

 反过来，算法

的每一运行

过程都对应

于从根到某

一叶节点的

路径。

按上述

规则与算法

相对应的树

，称作比较树

（comparison tree）。

不难理解，无

论什么算法

，只要其中的

分支都如算

法2.1那样，完全

取决于不同

变量或常量

的比对或比

较结果，则该

算法所有可

能的执行过

程都可表示

和概括为一

棵比较树。反

之，凡可如

此

描述的算法

，都称作基于

比较式算法

（comparison-based algorithm），简称CBA式算法

。

比如在本书

中，除散列之

外的算法大

多属于此类

。

以下我们将

看到，CBA式算法

在最坏情况

下的最低执

行成本，可由

对应的比较

树界定。

第2章

向量 §2.8 排序器

59

2.7.5 估计下界

 最

小树高

考查

任一CBA式算法

A，设CT(A)为与之对

应的一棵比

较树。

根据比

较树的性质

，算法A每一次

运行所需的

时间，将取决

于其对应叶

节点到根节

点的距离

（称

作叶节点的

深度）；而算法

A在最坏情况

下的运行时

间，将取决于

比较树中所

有叶节点的

最

大深度（称

作该树的高

度，记作h(CT(A))）。因此

就渐进的意

义而言，算法

A的时间复杂

度应不

低于

(h(CT(A)))。

对于存在CBA式

算法的计算

问题，既然其

任一CBA式算法

均对应于某

棵比较树，该

问题的复

杂

度下界就应

等于这些比

较树的最小

高度。问题在

于，如何估计

这些比较树

的最小高度

呢？

为此，只需

考查树中所

含叶节点（可

能的输出结

果）的数目。具

体地，在一棵

高度为h的二

叉树中，叶节

点的数目不

可能多于2

h。因

此反过来，若

某一问题的

输出结果不

少于N种，则比

较

树中叶节

点也不可能

少于N个，树高

h不可能低于

log2N（习题[7-3]）。

 苹果鉴

别

仍以算法

2.1为例。就该问

题而言，可能

的输出结果

共计N = 3种（不同

的苹果分别

为A、B

或C），故解决

该问题的任

一CBA式算法所

对应比较树

的高度为：

h  log23 =

2

因

此，只要是采

用CBA式算法来

求解该问题

，则无论如何

优化，在最坏

情况下都至

少需要2

次称

量尽管最好

情况下的确

仍可能仅需

1次。这也意味

着，算法2.1虽平

淡无奇，却已

是解

决苹果

鉴别问题的

最佳CBA式算法

。

 排序

再以CBA式

排序算法为

例。就n个元素

的排序问题

而言，可能的

输出共有N =

n!种

。与上例

略有

不同之处在

于，元素之间

不仅可以判

等而且可以

比较大小，故

此时的比较

树应属于三

叉树，

即每个

内部节点都

有三个分支

（分别对应小

于、相等和大

于的情况）。不

过，这并不影

响上述分

析

方法的运用

。按照以上思

路，任一CBA式排

序算法所对

应比较树的

高度应为：

h  log3(n!) =

log3e∙ln(n!) =

② (nlogn)

可

见，最坏情况

下CBA式排序算

法至少需要

(nlogn)时间，其中n为

待排序元素

数目。

需强调

的是，这一(nlogn)下

界是针对比

较树模型而

言的。事实上

，还有很多不

属此类的

排

序算法（比如

9.4.1节的桶排序

算法和9.4.3节的

基数排序算

法），而且其中

一些算法在

最坏

情况下

的运行时间

，有可能低于

这一下界，但

与上述结论

并不矛盾。

§2.8 排

序器

2.8.1 统一入

口

鉴于排序

在算法设计

与实际应用

中的重要地

位和作用，排

序操作自然

应当纳入向

量基本接口

的范围。这类

接口也是将

无序向量转

换为有序向

量的基本方

法和主要途

径。

 

②

由Stirling逢近公

式，n! ~ 2n ∙

(n/e)n

§2.8 排序器 第

2章

向量

60

1 template

<typename T> void Vector<T>::sort

( Rank lo, Rank

hi ) { //向量

匙间[lo,

hi)排序

2 switch (

rand() % 5 )

{ //随

机选叏排序

算法。可根据

具体问题癿

特点灵活选

叏戒扩充

3 case

1: bubbleSort ( lo,

hi ); break; //起

泡排序

4 case 2: selectionSort

( lo, hi );

break; //选择

排序（习题）

5 case

3: mergeSort ( lo,

hi ); break; //弻

幵排序

6 case 4: heapSort

( lo, hi );

break; //堆排

序（稍后介绍

）

7 default:

quickSort ( lo, hi

); break; //快速排序（稍

后介绍）

8

}

9 }

代码

2.25

向量排序器

接口

针对任

意合法向量

区间的排序

需求，代码2.25定

义了统一的

入口，并提供

起泡排序、选

择

排序（习题

[3-9]）、归并排序、堆

排序（10.2.5节）和快

速排序（12.1节）等

多种算法。为

便于测试和

对比，这里暂

以随机方式

确定每次调

用的具体算

法。在了解这

些算法各自

所长之后，

读

者可结合各

自具体的应

用，根据实际

需求灵活地

加以选用。

以

下先将起泡

排序算法集

成至向量ADT中

，然后讲解归

并排序算法

的原理、实现

。

2.8.2 起泡排序

起

泡排序算法

已在1.1.3节讲解

并实现，这里

只需将其集

成至向量ADT中

。

 起泡排序

1 template

<typename T> //向

量癿起泡排

序

2

void Vector<T>::bubbleSort ( Rank

lo, Rank hi )

//assert: 0 <= lo

< hi <= size

3 { while (

!bubble ( lo, hi--

) ); } //逐趟做扫

描交换，直至

全序

代码2.26 向

量癿起泡排

序

代码2.26给出

了起泡排序

算法的主体

框架，其功能

等效于代码

1.1中的外层循

环：反复调用

单趟扫描交

换算法，直至

逆序现象完

全消除。



扫描

交换

单趟扫

描交换算法

，可实现如代

码2.27所示。

1 template

<typename T> bool Vector<T>::bubble

( Rank lo, Rank

hi ) { //一趟

扫描交换

2 bool sorted =

true; //整

体有序标志

3 while (

++lo < hi )

//自左向右，逐

一检查各对

相邻元素

4 if (

_elem[lo - 1] >

_elem[lo] ) { //若

逆序，则

5 sorted = false;

//意味

着尚未整体

有序，幵需要

6 swap ( _elem[lo

- 1], _elem[lo] );

//通过交换使

尿部有序

7 }

8

return sorted; //迒

回有序标志

9 }

代码2.27 单趟扫

描交换

第2章

向量 §2.8

排序器

61

该算法的功

能等效于第

5页代码1.1中bubblesort1A()的

内层循环：依

次比较各对

相邻元

素，每

当发现逆序

即令二者彼

此交换；一旦

经过某趟扫

描之后未发

现任何逆序

的相邻元素

，即意

味着排

序任务已经

完成，则通过

返回标志“sorted”，以

便主算法及

时终止。

 重复

元素与稳定

性

稳定性（stability）是

对排序算法

更为细致的

要求，重在考

查算法对重

复元素的处

理效果。

具体

地，在将向量

A转换为有序

向量S之后，设

A[i]对应于S[ki]。若对

于A中每一对

重复元素A[i]

= A[j]（相

应地S[ki] = S[kj]），都有i

< j当

且仅当ki < kj，则称

该排序算法

是稳定算法

（stable

algorithm）。简而言之，稳

定算法的特

征是，重复元

素之间的相

对次序在排

序前后

保持

一致。反之，不

具有这一特

征的排序算

法都是不稳

定算法（unstable algorithm）。

比如

，依此标准反

观起泡排序

可以发现，该

算法过程中

元素相对位

置有所调整

的唯一可能

是，

某元素_elem[i - 1]严

格大于其后

继_elem[i]。也就是说

，在这种亦步

亦趋的交换

过程中，重

复

元素虽可能

相互靠拢，但

绝对不会相

互跨越。由此

可知，起泡排

序属于稳定

算法。

稳定的

排序算法，可

用以实现同

时对多个关

键码按照字

典序的排序

。比如，后面9.4.3节

基

数排序算

法的正确性

，就完全建立

在桶排序稳

定性的基础

之上。

若需兼

顾其它方面

的性能，以上

起泡排序仍

有改进的余

地（习题[2-25]）。

2.8.3

归并

排序

 历史与

发展

归并排

序③（mergesort）的构思朴

实却亦深刻

，作为一个算

法既古老又

仍不失生命

力。在

排序算

法发展的历

史上，归并排

序具有特殊

的地位，它是

第一个可以

在最坏情况

下依然保持

O(nlogn)运行时间的

确定性排序

算法。

时至今

日，在计算机

早期发展过

程中曾经出

现的一些难

题在更大尺

度上再次呈

现，归并排序

因此重新焕

发青春。比如

，早期计算机

的存储能力

有限，以至于

高速存储器

不能容纳所

有的数据，

或

者只能使用

磁带机或卡

片之类的顺

序存储设备

，这些既促进

了归并排序

的诞生，也为

该算法提

供

了施展的舞

台。信息化无

处不在的今

天，我们再次

发现，人类所

拥有信息之

庞大，不仅迫

使我

们更多

地将它们存

放和组织于

分布式平台

之上，而且对

海量信息的

处理也必须

首先考虑，如

何在

跨节点

的环境中高

效地协同计

算。因此在许

多新算法和

技术的背后

，都可以看到

归并排序的

影子。

 有序向

量的二路归

并

与起泡排

序通过反复

调用单趟扫

描交换类似

，归并排序也

可以理解为

是通过反复

调用所谓二

路归并（2-way merge）算法

而实现的。所

谓二路归并

，就是将两个

有序序列合

并成为一个

有序

序列。这

里的序列既

可以是向量

，也可以是第

3章将要介绍

的列表，这里

首先考虑有

序向量。归

并

排序所需的

时间，也主要

决定于各趟

二路归并所

需时间的总

和。

二路归并

属于迭代式

算法。每步迭

代中，只需比

较两个待归

并向量的首

元素，将小者

取出并

追加

到输出向量

的末尾，该元

素在原向量

中的后继则

成为新的首

元素。如此往

复，直到某一

向量

为空。最

后，将另一非

空的向量整

体接至输出

向量的末尾

。

③ 由冯•诺依曼

亍1945年在EDVAC上首

次编程实现

§2.8 排序器 第2章

向量

62

如图2.18(a)所

示，设拟归并

的有序向量

为{ 5, 8,

13, 21 }和{ 2,

4, 10, 29 }。

图2.18 有序

向量癿事路

归幵实例

（来

自两个向量

癿元素分删

以黑、白斱框

区分，其各自

癿当前首元

素则以灰色

长斱形示意

）

第一步迭代

经比较，取出

右侧向量首

元素2并归入

输出向量，同

时其首元素

更新为4（图(b)）。

此

后各步迭代

均与此类似

，都需比较首

元素，将小者

取出，并更新

对应的首元

素（图(c~h)）。

如此，即

可最终实现

整体归并（图

(i)）。

可见，二路归

并算法在任

何时刻只需

载入两个向

量的首元素

，故除了归并

输出的向量

外，仅

需要常

数规模的辅

助空间。另外

，该算法始终

严格地按顺

序处理输入

和输出向量

，故特别适用

于

使用磁带

机等顺序存

储器的场合

。

 分治策略

归

并排序的主

体结构属典

型的分治策

略，可递归地

描述和实现

如代码2.28所示

。

1 template <typename T>

//向量弻幵排

序

2 void Vector<T>::mergeSort

( Rank lo, Rank

hi ) { //0

<= lo < hi

<= size

3 if

( hi - lo

< 2 ) return;

//单元素匙

间自然有序

，否则...

4 int mi

= ( lo +

hi ) >> 1;

mergeSort ( lo, mi

); mergeSort ( mi,

hi ); //以中点

为界分删排

序

5

merge ( lo, mi,

hi ); //弻幵

6

}

代码

2.28 向量癿归幵

排序

可见，为

将向量S[lo,

hi)转换

为有序向量

，可以均匀地

将其划分为

两个子向量

：

S[lo, mi)

S[mi,

hi)

以下，只要通

过递归调用

将二者分别

转换为有序

向量，即可借

助以上的二

路归并算法

，得到

与原向

量S对应的整

个有序向量

。

请注意，这里

的递归终止

条件是当前

向量长度：

n = hi -

lo = 1

既

然仅含单个

元素的向量

必然有序，这

一处理分支

自然也就可

以作为递归

基。

第2章 向量

§2.8 排序器

63

 实例

归并算法的

一个完整实

例，如图2.19所示

。从递归的角

度，也可将图

2.19看作对该算

法的

递归跟

踪，其中绘出

了所有的递

归实例，并按

照递归调用

关系将其排

列成一个层

次化结构。

图

2.19

归幵排序实

例：S = { 6,

3, 2, 7, 1,

5, 8, 4 }

可以看出

，上半部分对

应于递归的

不断深入过

程：不断地均

匀划分（子）向

量，直到其规

模

缩减至1从

而抵达递归

基。此后如图

中下半部分

所示，开始递

归返回。通过

反复调用二

路归并算

法

，相邻且等长

的子向量不

断地捉对合

并为规模更

大的有序向

量，直至最终

得到整个有

序向量。

由此

可见，归并排

序可否实现

、可否高效实

现，关键在于

二路归并算

法。

 二路归并

接口的实现

针对有序向

量结构，代码

2.29给出了二路

归并算法的

一种实现。

1 template

<typename T> //有

序向量癿弻

幵

2

void Vector<T>::merge ( Rank

lo, Rank mi, Rank

hi ) { //各自有序

癿子向量[lo,

mi)和

[mi, hi)

3 T*

A = _elem +

lo; //合幵后癿向

量A[0, hi -

lo) = _elem[lo, hi)

4 int lb =

mi - lo; T*

B = new T[lb];

//前子向量

B[0, lb) = _elem[lo,

mi)

5 for (

Rank i = 0;

i < lb; B[i]

= A[i++] ); //复刢前子向

量

6 int lc =

hi - mi; T*

C = _elem +

mi; //后子向量

C[0, lc) =

_elem[mi, hi)

7 for

( Rank i =

0, j = 0,

k = 0; (

j < lb )

|| ( k <

lc ); ) {

//B[j]和C[k]中癿小者

续至A末尾

8 if (

( j < lb

) && ( !

( k < lc

) || ( B[j]

<= C[k] ) )

) A[i++] = B[j++];

9 if ( (

k < lc )

&& ( ! (

j < lb )

|| ( C[k] <

B[j] ) ) )

A[i++] = C[k++];

10

}

11 delete []

B; //释

放临时空间

B

12 }

//弻幵后得刡

完整癿有序

向量[lo, hi)

代码2.29 有

序向量癿事

路归幵

这里

约定，参与归

并的子向量

在原向量中

总是前、后相

邻的，故借助

三个入口参

数即可界定

其范围[lo, mi)和[mi, hi)。另

外，为保证归

并所得的子

向量能够原

地保存以便

继续参与更

高

层的归并

，这里使用了

临时数组B[]存

放前一向量

[lo,

mi)的副本（习题

[2-28]）。

§2.8 排序器 第2章

向量

64

 归并时

间

不难看出

，以上二路归

并算法merge()的渐

进时间成本

，取决于其中

循环迭代的

总次数。

实际

上，每经过一

次迭代，B[j]和C[k]之

间的小者都

会被移出并

接至A的末尾

（习题[2-29]

和[2-30]）。这意

味着，每经过

一次迭代，总

和s = j

+ k都会加一

。

考查这一总

和s在迭代过

程中的变化

。初始时，有s =

0 + 0 =

0；而

在迭代期间

，始终有：

s < lb

+ lc = (mi

- lo) + (hi

- mi) = hi

- lo

因此

，迭代次数及

所需时间均

不超过O(hi -

mi) = O(n)。

反之

，按照算法的

流程控制逻

辑，无论子向

量的内部元

素组成及其

相对大小如

何，只有待到

s

= hi - lo时迭代方能

终止。因此，该

算法在最好

情况下仍需

(n)时间，概括而

言应为(n)。

请注

意，借助二路

归并算法可

在严格少于

(nlogn)时间内完成

排序的这一

事实，与此前

2.7.3节关于排序

算法下界的

结论并不矛

盾毕竟，这里

的输入并非

一组完全随

机的元素，而

是已经划分

为各自有序

的两组，故就

总体而言已

具有相当程

度的有序性

。

 推广

二路归

并只需线性

时间的结论

，并不限于相

邻且等长的

子向量。实际

上，即便子向

量在物理

空

间上并非前

后衔接，且长

度相差悬殊

，该算法也依

然可行且仅

需线性时间

。

更重要地，正

如我们在后

面（82页代码3.22）将

要看到的，这

一算法框架

也可应用于

另一

类典型

的序列结构

列表而且同

样可以达到

线性的时间

效率。



排序时

间

那么，基于

以上二路归

并的线性算

法，归并排序

算法的时间

复杂度又是

多少呢？

不妨

采用递推方

程分析法，为

此首先将归

并排序算法

处理长度为

n的向量所需

的时间记作

T(n)。根据算法构

思与流程，为

对长度为n的

向量归并排

序，需递归地

对长度各为

n/2的两个子

向

量做归并排

序，再花费线

性时间做一

次二路归并

。如此，可得以

下递推关系

：

T(n) = 2T(n/2) +

O(n)

另外，当子向

量长度缩短

到1时，递归即

可终止并直

接返回该向

量。故有边界

条件

T(1) =

O(1)

联立以

上递推式，可

以解得（习题

[2-26]）：

T(n) =

O(nlogn)

也就是说，归

并排序算法

可在O(nlogn)时间内

对长度为n的

向量完成排

序。因二路归

并算法

的效

率稳定在(n)，故

更准确地讲

，归并排序算

法的时间复

杂度应为(nlogn)。

实

际上，利用图

2.19中算法整个

执行过程的

递归跟踪图

，也可殊途同

归。为此只需

如该图

所示

，按照规模大

小将各递归

实例分层排

列。既然每次

二路归并均

只需线性时

间，故同层的

所有

二路归

并累计也只

需线性时间

（当然，这两个

“线性”的含义

不同：前者是

指线性正比

于一对待

归

并子向量长

度之和，后者

则是指线性

正比于所有

参与归并的

子向量长度

之和）。由图不

难看出，

原向

量中每个元

素在同一层

次恰好出现

一次，故同层

递归实例所

消耗时间之

和应为(n)。另外

，

递归实例的

规模以2为倍

数按几何级

数逐层变化

，故共有(log2n)层，共

计(nlogn)时间。

第3章

列表

§3.1 从向量

刡列表

第3章

列表

66

上一章

介绍的向量

结构中，各数

据项的物理

存放位置与

逻辑次序完

全对应，故可

通过秩直接

访问对应的

元素，此即所

谓“循秩访问

”（call-by-rank）。这种访问方

式，如同根据

具体的

城市

名、街道名和

门牌号，直接

找到某人。本

章将要介绍

的列表，与向

量同属序列

结构的范畴

，

其中的元素

也构成一个

线性逻辑次

序；但与向量

极为不同的

是，元素的物

理地址可以

任意。

为保证

对列表元素

访问的可行

性，逻辑上互

为前驱和后

继的元素之

间，应维护某

种索引关系

。

这种索引关

系，可抽象地

理解为被索

引元素的位

置（position），故列表元

素是“循位置

访问”

（call-by-position）的；也可

形象地理解

为通往被索

引元素的链

接（link），故亦称作

“循

链接访问

”（call-by-link）。这种访问方

式，如同通过

你的某位亲

朋，找到他/她

的亲朋、亲

朋

的亲朋、...。注意

，向量中的秩

同时对应于

逻辑和物理

次序，而位置

仅对应于逻

辑次序。

本章

的讲解，将围

绕列表结构

的高效实现

逐步展开，包

括其ADT接口规

范以及对应

的算法。

此外

还将针对有

序列表，系统

地介绍排序

等经典算法

，并就其性能

做一分析和

对比。

§3.1 从向量

到列表

不同

数据结构内

部的存储与

组织方式各

异，其操作接

口的使用方

式及时空性

能也不尽相

同。

在设计或

选用数据结

构时，应从实

际应用的需

求出发，先确

定功能规范

及性能指标

。比如，引入

列

表结构的目

的，就在于弥

补向量结构

在解决某些

应用问题时

，在功能及性

能方面的不

足。二者

之间

的差异，表面

上体现于对

外的操作方

式，但根源则

在于其内部

存储方式的

不同。

3.1.1 从静态

到动态

数据

结构支持的

操作，通常无

非静态和动

态两类：前者

仅从中获取

信息，后者则

会修改数据

结构的局部

甚至整体。以

第2章基于数

组实现的向

量结构为例

，其size()和get()等静态

操作均

可在

常数时间内

完成，而insert()和remove()等

动态操作却

都可能需要

线性时间。究

其原因，

在于

“各元素物理

地址连续”的

约定此即所

谓的“静态存

储”策略。

得益

于这种策略

，可在O(1)时间内

由秩确定向

量元素的物

理地址；但反

过来，在添加

（删

除）元素之

前（之后），又不

得不移动O(n)个

后继元素。可

见，尽管如此

可使静态操

作的效率

达

到极致，但就

动态操作而

言，局部的修

改可能引起

大范围甚至

整个数据结

构的调整。

列

表（list）结构尽管

也要求各元

素在逻辑上

具有线性次

序，但对其物

理地址却未

作任何

限制

此即所谓“动

态存储”策略

。具体地，在其

生命期内，此

类数据结构

将随着内部

数据的

需要

，相应地分配

或回收局部

的数据空间

。如此，元素之

间的逻辑关

系得以延续

，却不必与其

物

理次序相

关。作为补偿

，此类结构将

通过指针或

引用等机制

，来确定各元

素的实际物

理地址。

例如

，链表（linked list）就是一

种典型的动

态存储结构

。其中的数据

，分散为一系

列称

作节点

（node）的单位，节点

之间通过指

针相互索引

和访问。为了

引入新节点

或删除原有

节点，

只需在

局部，调整少

量相关节点

之间的指针

。这就意味着

，采用动态存

储策略，至少

可以大大降

低动态操作

的成本。

第3章

列表 §3.2

接口

67

3.1.2 由

秩到位置

改

用以上动态

存储策略之

后，在提高动

态操作效率

的同时，却又

不得不舍弃

原静态存储

策略

中循秩

访问的方式

，从而造成静

态操作性能

的下降。

以采

用动态存储

策略的线性

结构（比如链

表）为例。尽管

按照逻辑次

序，每个数据

元素依然

具

有秩这一指

标，但为了访

问秩为r的元

素，我们只能

顺着相邻元

素之间的指

针，从某一端

出发

逐个扫

描各元素，经

过r步迭代后

才能确定该

元素的物理

存储位置。这

意味着，原先

只需O(1)时

间的

静态操作，此

时的复杂度

也将线性正

比于被访问

元素的秩，在

最坏情况下

等于元素总

数n；

即便在各

元素被访问

概率相等的

情况下，平均

而言也需要

O(n)时间。

对数据

结构的访问

方式，应与其

存储策略相

一致。此时，既

然继续延用

循秩访问的

方式已非

上

策，就应更多

地习惯于通

过位置，来指

代并访问动

态存储结构

中的数据元

素。与向量中

秩的地

位与

功能类似，列

表中的位置

也是指代各

数据元素的

一个标识性

指标，借助它

可以便捷地

（比如

在常数

时间内）得到

元素的物理

存储地址。各

元素的位置

，通常可表示

和实现为联

接于元素之

间

的指针或

引用。因此，基

于此类结构

设计算法时

，应更多地借

助逻辑上相

邻元素之间

的位置索引

，

以实现对目

标元素的快

速定位和访

问，并进而提

高算法的整

体效率。

3.1.3 列表

与向量一样

，列表也是由

具有线性逻

辑次序的一

组元素构成

的集合：

L

= { a0, a1,

..., an-1 }

列表

是链表结构

的一般化推

广，其中的元

素称作节点

（node），分别由特定

的位置或链

接

指代。与向

量一样，在元

素之间，也可

定义前驱、直

接前驱，以及

后继、直接后

继等关系；相

对

于任意元

素，也有定义

对应的前缀

、后缀等子集

。

§3.2 接口

如上所

述，作为列表

的基本组成

单位，列表节

点除需保存

对应的数据

项，还应记录

其前驱和

后

继的位置，故

需将这些信

息及相关操

作组成列表

节点对象，然

后参与列表

的构建。

本节

将给出列表

节点类与列

表类的接口

模板类描述

，稍后逐一讲

解各接口的

具体实现。

3.2.1

列

表节点

 ADT接口

作为一种抽

象数据类型

，列表节点对

象应支持以

下操作接口

。

表3.1

列表节点

ADT支持癿操作

接口

操 作 接

口

功 能

data() 弼前

节点所存数

据对象

pred() 弼前

节点前驱节

点癿位置

succ() 弼

前节点后继

节点癿位置

insertAsPred(e)

揑入前驱节

点，存入被引

用对象e，迒回

新节点位置

insertAsSucc(e) 揑入后继节

点，存入被引

用对象e，迒回

新节点位置

§3.2 接口 第3章

列

表

68

 ListNode模板类

按

照表3.1所定义

的ADT接口，可定

义列表节点

模板类如代

码3.1所示。出于

简洁与效率

的考

虑，这里

并未对ListNode对象

做封装处理

。列表节点数

据项的类型

，通过模板参

数T指定。

1 typedef

int Rank; //秩

2

#define ListNodePosi(T) ListNode<T>* //列

表节点位置

3

4 template <typename T>

struct ListNode { //列表节点模

板类（以双向

链表形式实

现）

5 // 成员

6

T data; ListNodePosi(T) pred;

ListNodePosi(T) succ; //数值

、前驱、后继

7

// 极

造函数

8 ListNode()

{} //针对

header和trailer癿极造

9 ListNode

( T e, ListNodePosi(T)

p = NULL, ListNodePosi(T)

s = NULL )

10 : data (

e ), pred (

p ), succ (

s ) {} //默

讣极造器

11 // 操

作接口

12

ListNodePosi(T) insertAsPred ( T

const& e ); //紧靠

弼前节点乀

前揑入新节

点

13 ListNodePosi(T) insertAsSucc (

T const& e );

//紧随弼前

节点乀后揑

入新节点

14 };

代

码3.1

列表节点

模板类①

每个

节点都存有

数据对象data。为

保证叙述简

洁，在不致歧

义的前提下

，本书将不再

区分

节点及

其对应的data对

象。此外，每个

节点还设有

指针pred和succ，分别

指向其前驱

和后继。

为了

创建一个列

表节点对象

，只需根据所

提供的参数

，分别设置节

点内部的各

个变量。其中

前驱、后继节

点的位置指

针若未予指

定，则默认取

作NULL。

3.2.2 列表

 ADT接口

作为一种抽

象数据类型

，列表对象应

支持以下操

作接口。

表3.2 列

表ADT支持癿操

作接口

操 作

接

口 功 能 适

用

对 象

size() 报告

列表弼前癿

觃模（节点总

数）

列表

first()、last() 迒回

首、末节点癿

位置 列表

insertAsFirst(e)

insertAsLast(e) 将

e弼作首、末节

点揑入 列表

insertA(p,

e)

insertB(p, e) 将e弼作节点

p癿直接后继

、前驱揑入

列

表

 

①

请注意，返

里所“定丿”癿

ListNodePosi(T)幵非真正意

丿上“列表节

点位置”类型

。

巧合癿是，就

在本书第1版

即将付印乀

际，C++.0x标准终亍

被ISO接纳。

新标

准所拓展癿

特性乀一，就

是对模板删

名（template alias）等语法形

式癿支持。因

此可以期望

在丌丽癿将

来，

C++编译器将

能够支持如

下更为直接

和简明癿描

述和实现：

template <typename T>

typedef ListNode<T>* ListNodePosi;

第

3章

列表 §3.2 接口

69

操

作 接 口 功

能

适 用 对 象

remove(p)

初除位置p处

癿节点，迒回

其数值 列表

disordered() 刞断所有节

点是否已按

非降序排列

列表

sort()

调整各

节点癿位置

，使乀按非降

序排列 列表

find(e) 查找目标元

素e，失败时迒

回NULL 列表

search(e) 查找

目标元素e，迒

回丌大亍e且

秩最大癿节

点 有序列表

deduplicate() 剔除重复节

点

列表

uniquify() 剔除

重复节点 有

序列表

traverse() 遍历

幵统一处理

所有节点，处

理斱法由函

数对象指定

列表

请留意

用以指示插

入和删除操

作位置的节

点p。这里约定

，它或者在此

前经查找已

经确定，

或者

从此前的其

它操作返回

或沿用。这些

也是列表类

结构的典型

操作方式。

这

里也设置一

个disordered()接口，以判

断列表是否

已经有序。同

时，也分别针

对有序和

无

序列表，提供

了去重操作

的两个版本

（deduplicate()和uniquify()），以及查找

操作的两

个

版本（find()和search()）。与向

量一样，有序

列表的唯一

化，比无序列

表效率更高

。然而

正如我

们将要看到

的，由于只能

通过位置指

针以局部移

动的方式访

问节点，尽管

有序列表中

节点

在逻辑

上始终按照

大小次序排

列，其查找操

作的效率并

没有实质改

进（习题[3-1]）。

 List模板

类

按照表3.2定

义的ADT接口，可

定义List模板类

如下。

1 #include "listNode.h" //引入列

表节点类

2

3 template <typename

T> class List {

//列

表模板类

4

5 private:

6 int _size; ListNodePosi(T)

header; ListNodePosi(T) trailer; //觃

模、头哨兵、尾

哨兵

7

8 protected:

9

void init(); //列表创

建时癿刜始

化

10

int clear(); //清除所有

节点

11

void copyNodes ( ListNodePosi(T),

int ); //复刢列

表中自位置

p起癿n项

12

void merge ( ListNodePosi(T)&,

int, List<T>&, ListNodePosi(T), int

); //弻幵

13 void mergeSort

( ListNodePosi(T)&, int );

//对从p开始连

续癿n个节点

弻幵排序

14 void selectionSort

( ListNodePosi(T), int );

//对

从p开始连续

癿n个节点选

择排序

15 void insertionSort

( ListNodePosi(T), int );

//对从

p开始连续癿

n个节点揑入

排序

16

17 public:

18 // 极造函

数

19

List() { init(); }

//默讣

20 List (

List<T> const& L );

//整体

复刢列表L

21 List (

List<T> const& L, Rank

r, int n );

//复

刢列表L中自

第r项起癿n项

22 List ( ListNodePosi(T)

p, int n );

//复刢列表中

自位置p起癿

n项

§3.2 接口 第3章

列表

70

23 // 枂极函

数

24 ~List(); //释放（包含

头、尾哨兵在

内癿）所有节

点

25

// 叧读讵问

接口

26 Rank

size() const { return

_size; } //觃模

27

bool empty() const {

return _size <= 0;

} //刞

空

28 T&

operator[] ( Rank r

) const; //重载，支持

循秩讵问（效

率低）

29

ListNodePosi(T) first() const {

return header->succ; } //首节点

位置

30 ListNodePosi(T) last() const

{ return trailer->pred; }

//末节点

位置

31 bool valid

( ListNodePosi(T) p )

//刞断位

置p是否对外

合法

32 { return

p && ( trailer

!= p ) &&

( header != p

); } //将头、尾

节点等同亍

NULL

33

int disordered() const; //刞断列表是

否已排序

34 ListNodePosi(T) find (

T const& e )

const //无

序列表查找

35 { return

find ( e, _size,

trailer ); }

36

ListNodePosi(T) find ( T

const& e, int n,

ListNodePosi(T) p ) const;

//无序匙间查

找

37 ListNodePosi(T) search

( T const& e

) const //有序列表

查找

38

{ return search (

e, _size, trailer );

}

39 ListNodePosi(T) search

( T const& e,

int n, ListNodePosi(T) p

) const; //有序匙

间查找

40

ListNodePosi(T) selectMax ( ListNodePosi(T)

p, int n );

//在p及

其n-1个后继中

选出最大者

41 ListNodePosi(T) selectMax() {

return selectMax ( header->succ,

_size ); } //整体最大者

42

// 可写讵问接

口

43 ListNodePosi(T)

insertAsFirst ( T const&

e ); //将e弼作首

节点揑入

44

ListNodePosi(T) insertAsLast ( T

const& e ); //将

e弼作末节点

揑入

45 ListNodePosi(T) insertA (

ListNodePosi(T) p, T const&

e ); //将e弼作

p癿后继揑入

46 ListNodePosi(T)

insertB ( ListNodePosi(T) p,

T const& e );

//将e弼作p癿前

驱揑入

47 T remove

( ListNodePosi(T) p );

//初除

合法位置p处

癿节点,迒回

被初除节点

48 void merge (

List<T>& L ) {

merge ( first(), size,

L, L.first(), L._size );

} //全列表弻幵

49 void sort

( ListNodePosi(T) p, int

n ); //列表匙间排

序

50

void sort() { sort

( first(), _size );

} //列表整体

排序

51 int

deduplicate(); //无序去

重

52 int

uniquify(); //有序去重

53 void reverse();

//前后倒置（习

题）

54 // 遍历

55 void traverse (

void (* ) (

T& ) ); //遍历

，依次实斲visit操

作（函数指针

，叧读戒尿部

性修改）

56 template <typename VST>

//操作

器

57 void traverse

( VST& ); //遍历，依次

实斲visit操作（函

数对象，可全

尿性修改）

58 }; //List

代

码3.2

列表模板

类

由代码3.2可

见，列表结构

的实现方式

与第2章的向

量结构颇为

相似：通过模

板参数T指定

列

表元素的

类型（同时亦

为代码3.1中列

表节点数据

项的类型）；在

内部设置私

有变量以记

录当前

规模

等状态信息

；基于多种排

序算法提供

统一的sort()接口

，以将列表转

化为有序列

表。

以下，分别

介绍列表的

内部结构、基

本接口，以及

主要算法的

具体实现。

第

3章 列表 §3.3

列表

71

§3.3 列表

3.3.1

头、尾节

点

List对象的内

部组成及逻

辑结构如图

3.1所示，其中私

有的头节点

（header）和尾节点

（trailer）始

终存在，但对

外并不可见

。对外部可见

的数据节点

如果存在，则

其中的第一

个和

最后一

个节点分别

称作首节点

（first

node）和末节点（last node）。

图

3.1 首（末）节点是

头（尾）节点癿

直接后继（前

驱）

就内部结

构而言，头节

点紧邻于首

节点之前，尾

节点紧邻于

末节点之后

。这类经封装

之后从

外部

不可见的节

点，称作哨兵

节点（sentinel node）。由代码

3.2中List::valid()关于合法

节点位置的

判别准则可

见，此处的两

个哨兵节点

从外部被等

效地视作NULL。

设

置哨兵节点

之后，对于从

外部可见的

任一节点而

言，其前驱和

后继在列表

内部都必然

存在，

故可简

化算法的描

述与实现。比

如，在代码3.2中

为实现first()和last()操

作，只需直接

返回

header->succ或trailer->pred。此外

更重要地，哨

兵节点的引

入，也使得相

关算法不必

再对

各种边

界退化情况

做专门的处

理，从而避免

出错的可能

，我们稍后将

对此有更实

际的体会。

尽

管哨兵节点

也需占用一

定的空间，但

只不过是常

数规模，其成

本远远低于

由此带来的

便利。

3.3.2 默认构

造方法

创建

List对象时，默认

构造方法将

调用如代码

3.3所示的统一

初始化过程

init()，在列表

内部

创建一对头

、尾哨兵节点

，并适当地设

置其前驱、后

继指针构成

一个双向链

表。

1 template <typename T>

void List<T>::init() { //列表刜始

化，在创建列

表对象时统

一调用

2 header = new

ListNode<T>; //创建

头哨兵节点

3 trailer =

new ListNode<T>; //创建尾哨兵

节点

4

header->succ = trailer; header->pred

= NULL;

5 trailer->pred

= header; trailer->succ =

NULL;

6 _size =

0; //记弽觃

模

7 }

代码3.3 列表

类内部斱法

init()

如图3.2所示，该

链表对外的

有效部分初

始为空，哨兵

节点对外不

可见，此后引

入的新节点

都将陆续插

入于这一对

哨兵节点之

间。

图3.2

刚创建

癿List对象

在列

表的其它构

造方法中，内

部变量的初

始化过程与

此相同，因此

都可统一调

用init()过

程。该过

程仅涉及常

数次基本操

作，共需运行

常数时间。

§3.3

列

表 第3章 列表

72

3.3.3

由秩到位置

的转换

鉴于

偶尔可能需

要通过秩来

指定列表节

点，可通过重

载操作符“[]”,提

供一个转换

接口。

1 template

<typename T> //重载下

标操作符，以

通过秩直接

讵问列表节

点（虽斱便，效

率低，需慎用

）

2

T& List<T>::operator[] ( Rank

r ) const {

//assert: 0 <= r

< size

3 ListNodePosi(T)

p = first(); //从首节点出

収

4 while ( 0

< r-- ) p

= p->succ; //顺数第r个

节点即是

5

return p->data; //目

标节点，迒回

其中所存元

素

6

}

代码3.4 重轲

列表类癿下

标操作符

具

体地如代码

3.4所示，为将任

意指定的秩

r转换为列表

中对应的元

素，可从首节

点出发，

顺着

后继指针前

进r步。只要秩

r合法，该算法

的正确性即

一目了然。其

中每步迭代

仅需常数时

间，

故该算法

的总体运行

时间应为O(r + 1)，线

性正比于目

标节点的秩

。

相对于向量

同类接口的

O(1)复杂度，列表

的这一效率

十分低下其

根源在于，列

表元素

的存

储和访问方

式已与向量

截然不同。诚

然，当r大于n/2时

，从trailer出发沿pred指

针逆行

查找

，可以在一定

程度上减少

迭代次数，但

就总体的平

均效率而言

，这一改进并

无实质意义

。

3.3.4

查找

 实现

在

代码3.2中，列表

ADT针对整体和

区间查找，重

载了操作接

口find(e)和find(e,

p, n)。

其中，前

者作为特例

，可以直接调

用后者。因此

，只需如代码

3.5所示，实现后

一接口。

1

template <typename T> //在无

序列表内节

点p（可能是trailer）癿

n个（真）前驱中

，找刡等亍e癿

最后者

2 ListNodePosi(T) List<T>::find (

T const& e, int

n, ListNodePosi(T) p )

const {

3 while

( 0 < n--

) //（0 <= n

<= rank(p) < _size）对亍

p癿最近癿n个

前驱，从右向

左

4 if ( e

== ( p =

p->pred )->data ) return

p; //逐个比对

，直至命中戒

范围越界

5 return

NULL; //p越

出左边界意

味着匙间内

丌含e，查找失

败

6 }

//失败时，迒

回NULL

代码3.5 无序

列表元素查

找接口find()



复杂

度

以上算法

的思路及过

程，与无序向

量的顺序查

找算法Vector::find()（代码

2.10）相仿，

故时间

复杂度也应

是O(n)，线性正比

于查找区间

的宽度。

3.3.5

插入

 接口

为将节

点插至列表

，可视具体要

求的不同，在

代码3.6所提供

的多种接口

中灵活选用

。

1

template <typename T> ListNodePosi(T)

List<T>::insertAsFirst ( T const&

e )

2 {

_size++; return header->insertAsSucc (

e ); } //e弼作首节点

揑入

3

第3章 列

表 §3.3

列表

73

4 template

<typename T> ListNodePosi(T) List<T>::insertAsLast

( T const& e

)

5 { _size++;

return trailer->insertAsPred ( e

); } //e弼作

末节点揑入

6

7

template <typename T> ListNodePosi(T)

List<T>::insertA ( ListNodePosi(T) p,

T const& e )

8 { _size++; return

p->insertAsSucc ( e );

} //e弼作p癿后继

揑入（After）

9

10

template <typename T> ListNodePosi(T)

List<T>::insertB ( ListNodePosi(T) p,

T const& e )

11 { _size++; return

p->insertAsPred ( e );

} //e弼作p癿

前驱揑入（Before）

代

码3.6 列表节点

揑入接口

可

见，这些接口

的实现，都可

转化为列表

节点对象的

前插入或后

插入接口。

 前

插入

将新元

素e作为当前

节点的前驱

插至列表的

过程，可描述

和实现如代

码3.7所示。

1 template <typename T>

//将e紧

靠弼前节点

乀前揑入亍

弼前节点所

属列表（讴有

哨兵头节点

header）

2 ListNodePosi(T) ListNode<T>::insertAsPred

( T const& e

) {

3 ListNodePosi(T)

x = new ListNode

( e, pred, this

); //创建新节点

4 pred->succ =

x; pred = x;

//讴置正向链

接

5 return x;

//迒回新节

点癿位置

6 }

代

码3.7

ListNode::insertAsPred()算法

图3.3给

出了整个操

作的具体过

程。插入新节

点之前，列表

局部的当前

节点及其前

驱如图(a)

所示

。该算法首先

如图(b)所示创

建新节点new，构

造函数同时

将其数据项

置为e，并令其

后继链

接succ指

向当前节点

，令其前驱链

接pred指向当前

节点的前驱

节点。随后如

图(c)所示，使new

成

为当前节点

前驱节点的

后继，使new成为

当前节点的

前驱（次序不

能颠倒）。最终

如图(d)所

示，经

过如此调整

，新节点即被

顺利地插至

列表的这一

局部。

图3.3 ListNode::insertAsPred()算法

请注意，列表

规模记录的

更新由代码

3.6中的上层调

用者负责。另

外，得益于头

哨兵节点的

存在，即便当

前节点为列

表的首节点

，其前驱也如

图(a)所示必然

存在，故不必

另做特殊处

理。

当然，在当

前节点即首

节点时，前插

入接口等效

于List::insertAsFirst()。

 后插入

将

新元素e作为

当前节点的

后继插至列

表的过程，可

描述和实现

如代码3.8所示

。

§3.3 列表 第3章 列

表

74

1 template <typename

T> //将e紧随弼

前节点乀后

揑入亍弼前

节点所属列

表（讴有哨兵

尾节点trailer）

2 ListNodePosi(T)

ListNode<T>::insertAsSucc ( T const&

e ) {

3

ListNodePosi(T) x = new

ListNode ( e, this,

succ ); //创建

新节点

4

succ->pred = x; succ

= x; //讴置

逆向链接

5

return x; //迒

回新节点癿

位置

6

}

代码3.8 ListNode::insertAsSucc()算

法

后插入的

操作过程以

及最终效果

与前插入完

全对称，不再

赘述。

 复杂度

上述两种插

入操作过程

，仅涉及局部

的两个原有

节点和一个

新节点，且不

含任何迭代

或递归。

若假

设当前节点

已经定位，不

计入此前的

查找所消耗

的时间，则它

们都可在常

数时间内完

成。

3.3.6

基于复制

的构造

与向

量一样，列表

的内部结构

也是动态创

建的，故利用

默认的构造

方法并不能

真正地完成

新

列表的复

制创建。为此

，需要专门编

写相应的构

造方法，通过

复制某一已

有列表来构

造新列表。



copyNodes()

尽

管这里提供

了多种形式

，以允许对原

列表的整体

或局部复制

，但其实质过

程均大同小

异，

都可概括

和转化为如

代码3.9所示的

底层内部方

法copyNodes()。在输入参

数合法的前

提下，

copyNodes()首先调

用init()方法，创建

头、尾哨兵节

点并做相应

的初始化处

理，然后自p所

指

节点起，从

原列表中取

出n个相邻的

节点，并逐一

作为末节点

插至新列表

中。

1 template <typename

T> //列表内部

斱法：复刢列

表中自位置

p起癿n项

2 void

List<T>::copyNodes ( ListNodePosi(T) p,

int n ) {

//p合法

，且至少有n-1个

真后继节点

3 init(); //创建头、尾哨

兵节点幵做

刜始化

4

while ( n-- )

{ insertAsLast ( p->data

); p = p->succ;

} //将起

自p癿n项依次

作为末节点

揑入

5 }

代码3.9 列

表类内部斱

法copyNodes()

根据此前

的分析，init()操作

以及各步迭

代中的插入

操作均只需

常数时间，故

copyNodes()

过程总体的

运行时间应

为O(n

+ 1)，线性正比

于待复制列

表区间的长

度n。

 基于复制

的构造

如代

码3.10所示，基于

上述copyNodes()方法可

以实现多种

接口，通过复

制已有列表

的区

间或整

体，构造出新

列表。其中，为

了复制列表

L中自秩r起的

n个相邻节点

，List(L, r, n)需

借助重载

后的下标操

作符，找到待

复制区间起

始节点的位

置，然后再以

此节点作为

参数调用

copyNodes()。根

据3.3.3节的分析

结论，需要花

费O(r + 1)的时间才

能将r转换为

起始节点的

位置，故该复

制接口的总

体复杂度应

为O(r

+ n + 1)，线性正比

于被复制节

点的最高秩

。由此

也可再

次看出，在诸

如列表之类

采用动态存

储策略的结

构中，循秩访

问远非有效

的方式。

1 template <typename

T> //复刢

列表中自位

置p起癿n项（assert: p为

合法位置，且

至少有n-1个后

继节点）

2

List<T>::List ( ListNodePosi(T) p,

int n ) {

copyNodes ( p, n

); }

第3章

列表 §3.3

列表

75

3

4

template <typename T> //整

体复刢列表

L

5 List<T>::List ( List<T>

const& L ) {

copyNodes ( L.first(), L._size

); }

6

7

template <typename T> //复刢L中自第

r项起癿n项（assert:

r+n <= L._size）

8

List<T>::List ( List<T> const&

L, int r, int

n ) { copyNodes

( L[r], n );

}

代

码3.10 基二复刢

癿列表极造

斱法

3.3.7

删除

 实

现

在列表中

删除指定节

点p的算法，可

以描述并实

现如代码3.11所

示。

1 template <typename T>

T List<T>::remove ( ListNodePosi(T)

p ) { //初除合法

节点p，迒回其

数值

2 T e =

p->data; //备仹待

初除节点癿

数值（假定T类

型可直接赋

值）

3 p->pred->succ

= p->succ; p->succ->pred =

p->pred; //后继、前驱

4 delete p;

_size--; //释放节点，更

新觃模

5 return

e; //迒回

备仹癿数值

6 }

代码3.11

列表节

点初除接口

remove()

图3.4给出了整

个操作的具

体过程。删除

节点之前，列

表在位置p附

近的局部如

图(a)所示。

为了

删除位置p处

的节点，首先

如图(b)所示，令

其前驱节点

与后继节点

相互链接。然

后如图(c)

所示

，释放掉已经

孤立出来的

节点p，同时相

应地更新列

表规模计数

器_size。最终如图

(d)所示，

经过如

此调整之后

，原节点p即被

顺利地从列

表中摘除。

图

3.4 List::remove()算法

这里，可

以清晰地体

会到哨兵节

点的作用。不

难验证，即便

p所指的是列

表中唯一对

外有效

的节

点（其前驱和

后继都是哨

兵节点），remove()算法

依然可以正

常运转。

 复杂

度

以上过程

仅涉及常数

次基本操作

，故若不计入

此前为查找

并确定位置

p所消耗的时

间，列表

的节

点删除操作

可在常数时

间内完成。

§3.3 列

表 第3章

列表

76

3.3.8 析构



释放资

源及清除节

点

与所有对

象一样，列表

对象析构时

也需如代码

3.12所示，将其所

占用的资源

归还操作系

统。

1 template

<typename T> List<T>::~List() //列表枂极

器

2 { clear(); delete

header; delete trailer; }

//清空列表

，释放头、尾哨

兵节点

代码

3.12 列表枂极斱

法

可见，列表

的析构需首

先调用clear()接口

删除并释放

所有对外部

有效的节点

，然后释放内

部的头、尾哨

兵节点。而clear()过

程则可描述

和实现如代

码3.13所示。

1 template <typename T>

int List<T>::clear() { //清空

列表

2 int oldSize =

_size;

3 while (

0 < _size )

remove ( header->succ );

//反复初

除首节点，直

至列表发空

4 return oldSize;

5

}

代码3.13 列表清

空斱法clear()



复杂

度

这里的时

间消耗主要

来自clear()操作，该

操作通过remove()接

口反复删除

列表的首节

点。

因此，clear()方法

以及整个析

构方法的运

行时间应为

O(n)，线性正比于

列表原先的

规模。

3.3.9

唯一化

 实现

旨在剔

除无序列表

中重复元素

的接口deduplicate()，可实

现如代码3.14所

示。

1

template <typename T> int

List<T>::deduplicate() { //剔除无序

列表中癿重

复节点

2

if ( _size <

2 ) return 0;

//平凡

列表自然无

重复

3 int oldSize

= _size; //记弽原

觃模

4

ListNodePosi(T) p = header;

Rank r = 0;

//p从首节

点开始

5 while (

trailer != ( p

= p->succ ) )

{ //依次

直刡末节点

6 ListNodePosi(T) q

= find ( p->data,

r, p ); //在p癿r个（真）前

驱中查找雷

同者

7 q ? remove

( q ) :

r++; //若癿确

存在，则初除

乀；否则秩加

一

8 }

//assert: 循环过程

中癿仸意时

刻，p癿所有前

驱互丌相同

9 return oldSize

- _size; //列表觃模发

化量，即被初

除元素总数

10 }

代码3.14 无序列

表剔除重复

节点接口deduplicate()

与

算法Vector::deduplicate()（42页代码

2.14）类似，这里也

是自前向后

依次处理各

节

点p，一旦通

过find()接口在p的

前驱中查到

雷同者，则随

即调用remove()接口

将其删除。

 正

确性

向量与

列表中元素

的逻辑次序

一致，故二者

的deduplicate()算法亦具

有类似的不

变性和

单调

性（习题[3-4]），故正

确性均可保

证。

第3章 列表

§3.4 有序列表

77

 复

杂度

与无序

向量的去重

算法一样，该

算法总共需

做O(n)步迭代。由

3.3.4节的分析结

论，每一步

迭

代中find()操作所

需的时间线

性正比于查

找区间宽度

，即当前节点

的秩；由3.3.7节的

分析结

论，列

表节点每次

remove()操作仅需常

数时间。因此

，总体执行时

间应为：

1 + 2

+ 3 + ...

+ n = n∙(n

+ 1) / 2

= O(n2

)

相对

于无序向量

，尽管此处节

点删除操作

所需的时间

减少，但总体

渐进复杂度

并无改进。

3.3.10 遍

历

列表也提

供支持节点

批量式访问

（习题[3-5]）的遍历

接口，其实现

如代码3.15所示

。

1

template <typename T> void

List<T>::traverse ( void (

*visit ) ( T&

) ) //倚劣函数指

针机刢遍历

2 {

for ( ListNodePosi(T) p

= header->succ; p !=

trailer; p = p->succ

) visit ( p->data

); }

3

4

template <typename T> template

<typename VST> //元素类型、操

作器

5

void List<T>::traverse ( VST&

visit ) //倚劣函

数对象机刢

遍历

6

{ for ( ListNodePosi(T)

p = header->succ; p

!= trailer; p =

p->succ ) visit (

p->data ); }

代码3.15

列

表遍历接口

traverse()

该接口的设

计思路与实

现方式，与向

量的对应接

口（2.5.8节）如出一

辙，复杂度也

相同。

§3.4 有序列

表

若列表中

所有节点的

逻辑次序与

其大小次序

完全一致，则

称作有序列

表（sorted list）。

为保证节

点之间可以

定义次序，依

然假定元素

类型T直接支

持大小比较

，或已重载相

关操作符。

与

有序向量一

致地，这里依

然约定采用

非降次序。

3.4.1 唯

一化

与有序

向量同理，有

序列表中的

雷同节点也

必然（在逻辑

上）彼此紧邻

。利用这一特

性，可

实现重

复节点删除

算法如代码

3.16所示。位置指

针p和q分别指

向每一对相

邻的节点，若

二者雷

同则

删除q，否则转

向下一对相

邻节点。如此

反复迭代，直

至检查过所

有节点。

1 template <typename

T> int List<T>::uniquify() {

//成批

剔除重复元

素，效率更高

2 if ( _size

< 2 ) return

0; //平凡列表自

然无重复

3 int

oldSize = _size; //记

弽原觃模

4 ListNodePosi(T) p =

first(); ListNodePosi(T) q; //p为

各匙殌起点

，q为其后继

5 while ( trailer

!= ( q =

p->succ ) ) //反

复考查紧邻

癿节点对(p,

q)

6 if (

p->data != q->data )

p = q; //若

互异，则转向

下一匙殌

7 else remove (

q ); //否

则（雷同），初除

后者

8

return oldSize - _size;

//列表觃

模发化量，即

被初除元素

总数

9 }

代码3.16

有

序列表剔除

重复节点接

口uniquify()

整个过程

的运行时间

为O(_size) = O(n)，线性正比

于列表原先

的规模。

§3.5 排序

器 第3章 列表

78

3.4.2 查找

 实现

有

序列表的节

点查找算法

，可实现如代

码3.17所示。

1 template <typename

T> //在有

序列表内节

点p（可能是trailer）癿

n个（真）前驱中

，找刡丌大亍

e癿最后者

2 ListNodePosi(T)

List<T>::search ( T const&

e, int n, ListNodePosi(T)

p ) const {

3 // assert: 0

<= n <= rank(p)

< _size

4 while

( 0 <= n--

) //对

亍p癿最近癿

n个前驱，从右

向左逐个比

较

5 if

( ( ( p

= p->pred )->data )

<= e ) break;

//直至命中

、数值越界戒

范围越界

6 // assert:

至

此位置p必符

合输出语丿

约定——尽管此

前最后一次

兲键码比较

可能没有意

丿（等效亍不

-inf比较）

7 return p;

//迒回查

找终止癿位

置

8 } //失败时，迒

回匙间左边

界癿前驱（可

能是header）——调用者

可通过valid()刞断

成功不否

代

码3.17 有序列表

查找接口search()

与

有序向量类

似，无论查找

成功与否，返

回的位置都

应便于后续

（插入等）操作

的实施。



顺序

查找

与2.6.5节至

2.6.8节有序向量

的各种查找

算法相比，该

算法完全不

同；反过来，除

了循环

终止

条件的细微

差异，多数部

分反倒与3.3.4节

无序列表的

顺序查找算

法几乎一样

。

究其原因在

于，尽管有序

列表中的节

点已在逻辑

上按次序单

调排列，但在

动态存储策

略中，

节点的

物理地址与

逻辑次序毫

无关系，故无

法像有序向

量那样自如

地应用减治

策略，从而不

得不

继续沿

用无序列表

的顺序查找

策略。

 复杂度

与无序向量

的查找算法

同理：最好情

况下的运行

时间为O(1)，最坏

情况下为O(n)。在

等概

率的前

提下，平均运

行时间也是

O(n)，线性正比于

查找区间的

宽度。

§3.5 排序器

3.5.1 统一入口

与

无序向量一

样，针对无序

列表任意合

法区间的排

序需求，这里

也如代码3.18所

示，设置

了一

个统一的排

序操作接口

。

1 template

<typename T> void List<T>::sort

( ListNodePosi(T) p, int

n ) { //列表匙间排

序

2 switch ( rand()

% 3 ) {

//随机选叏

排序算法。可

根据具体问

题癿特点灵

活选叏戒扩

充

3 case 1:

insertionSort ( p, n

); break; //揑入排序

4 case

2: selectionSort ( p,

n ); break; //选择排序

5 default: mergeSort (

p, n ); break;

//弻

幵排序

6 }

7

}

代码

3.18 有序列表基

二排序癿极

造斱法

这里

提供了插入

排序、选择排

序和归并排

序三种算法

，并依然以随

机方式确定

每次调用的

具

体算法，以

便测试和对

比。以下，将依

次地讲解这

几种算法的

原理、实现，并

分析其复杂

度。

第3章 列表

§3.5 排序器

79

3.5.2 插入

排序



构思

插

入排序（insertionsort）算法

适用于包括

向量与列表

在内的任何

序列结构。

算

法的思路可

简要描述为

：始终将整个

序列视作并

切分为两部

分：有序的前

缀，无序的后

缀；

通过迭代

，反复地将后

缀的首元素

转移至前缀

中。由此亦可

看出插入排

序算法的不

变性：

在任何

时刻，相对于

当前节点e = S[r]，前

缀S[0, r)总是业已

有序

算法开

始时该前缀

为空，不变性

自然满足。

图

3.5 序列癿揑入

排序

假设如

图3.5(a)所示，前缀

S[0,

r)已经有序。接

下来，借助有

序序列的查

找算法，可在

该前缀中定

位到不大于

e的最大元素

。于是只需将

e从无序后缀

中取出，并紧

邻于查找返

回的位置

之

后插入，即可

如图(b)所示，使

得有序前缀

的范围扩大

至S[0, r]。

如此，该前

缀的范围可

不断拓展。当

其最终覆盖

整个序列时

，亦即整体有

序。

 实例

如表

3.3所示，即为序

列插入排序

算法的一个

实例。

表3.3

揑入

排序算法实

例

#迭代 前缀

有序子序列

后缀无序子

序列

0

^ 5 2 7

4 6 3 1

1 5_ 2 7

4 6 3 1

2 2 5_ 7

4 6 3 1

3 2 5 7_

4 6 3 1

4 2 4 5

7_ 6 3 1

5 2 4 5

6 7_ 3 1

6 2 3 4

5 6 7_ 1

7 1 2 3

4 5 6 7_

^

这里，前

后共经7步迭

代。输入序列

中的7个元素

以秩为序，先

后作为首元

素被取出，并

插

至有序前

缀子序列中

的适当位置

。新近插入的

元素均以方

框注明，为确

定其插入位

置而在查找

操

作过程中

接受过大小

比较的元素

以下划线示

意。

§3.5 排序器 第

3章 列表

80

 实现

依照以上思

路，可针对列

表实现插入

排序算法如

代码3.19所示。

1

template <typename T> //列

表癿揑入排

序算法：对起

始亍位置p癿

n个元素排序

2

void List<T>::insertionSort ( ListNodePosi(T)

p, int n )

{ //valid(p) && rank(p)

+ n <= size

3 for ( int

r = 0; r

< n; r++ )

{ //逐一为各节

点

4 insertA

( search ( p->data,

r, p ), p->data

); //查找适弼

癿位置幵揑

入

5 p

= p->succ; remove (

p->pred ); //转向下一

节点

6

}

7 }

代码3.19

列

表癿揑入排

序

按3.4.2节的约

定，有多个元

素命中时search()接

口将返回其

中最靠后者

，排序之后重

复

元素将保

持其原有次

序，故以上插

入排序算法

属于稳定算

法。



复杂度

插

入排序算法

共由n步迭代

组成，故其运

行时间应取

决于，各步迭

代中所执行

的查找、删除

及插入操作

的效率。根据

此前3.3.5节和3.3.7节

的结论，插入

操作insertAfter()和删除

操作

remove()均只需

O(1)时间；而由3.4.2节

的结论，查找

操作search()所需时

间可在O(1)至O(n)

之

间浮动（从如

表3.3所示的实

例，也可看出

这一点）。

不难

验证，当输入

序列已经有

序时，该算法

中的每次search()操

作均仅需O(1)时

间，总体

运行

时间为O(n)。但反

过来，若输出

序列完全逆

序，则各次search()操

作所需时间

将线性递增

，

累计共需O(n2

)时

间。在等概率

条件下，平均

仍需要O(n2

)时间

（习题[3-10]）。

3.5.3 选择排

序

选择排序

（selectionsort）也适用于向

量与列表之

类的序列结

构。

 构思

与插

入排序类似

，该算法也将

序列划分为

无序前缀和

有序后缀两

部分；此外，还

要求前缀不

大于后后缀

。如此，每次只

需从前缀中

选出最大者

，并作为最小

元素转移至

后缀中，即可

使有序

部分

的范围不断

扩张。

图3.6 序列

癿选择排序

同样地，上述

描述也给出

了选择排序

算法过程所

具有的不变

性：

第3章 列表

§3.5

排序器

81

在任

何时刻，后缀

S[r, n)已经有序，且

不小于前缀

S[0,

r)

在算法的初

始时刻，后缀

为空，不变性

自然满足。如

图3.6(a)所示，假设

不变性已满

足。

于是，可调

用无序序列

的查找算法

，从前缀中找

出最大者M。接

下来，只需将

M从前缀中取

出并作

为首

元素插入后

缀，即可如图

(b)所示，使得后

缀的范围扩

大，并继续保

持有序。

如此

，该后缀的范

围可不断拓

展。当其最终

覆盖整个序

列时，亦即整

体有序。

 实例

表3.4 选择排序

算法实例

#迭

代 前缀无序

子序列 后缀

有序子序列

0 5

2 7 4 6

3 1_ ^

1

5 2 4 6

3 1_ 7

2

5 2 4 3

1_ 6 7

3

2 4 3 1_

5 6 7

4

2 3 1_ 4

5 6 7

5

2 1_ 3 4

5 6 7

6

1_ 2 3 4

5 6 7

7

^_ 1 2 3

4 5 6 7

序列选择排

序算法的一

个实例如表

3.4所示。其中，前

后共经7步迭

代，输入序列

中的7个元

素

按由大到小

的次序，依次

被从无序前

缀子序列中

取出，并作为

首元素插至

初始为空的

有序后缀

序

列中。无序子

序列在各步

迭代中的最

大元素用方

框注明。



实现

依照以上思

路，可针对列

表实现选择

排序算法如

代码3.20所示。

1 template <typename

T> //列

表癿选择排

序算法：对起

始亍位置p癿

n个元素排序

2 void List<T>::selectionSort

( ListNodePosi(T) p, int

n ) { //valid(p)

&& rank(p) + n

<= size

3 ListNodePosi(T)

head = p->pred; ListNodePosi(T)

tail = p;

4

for ( int i

= 0; i <

n; i++ ) tail

= tail->succ; //待排序匙间

为(head, tail)

5 while ( 1

< n ) {

//在至少迓

剩两个节点

乀前，在待排

序匙间内

6 ListNodePosi(T) max

= selectMax ( head->succ,

n ); //找

出最大者（歧

丿时后者优

先）

7

insertB ( tail, remove

( max ) );

//将其秱至

无序匙间末

尾（作为有序

匙间新癿首

元素）

8 tail =

tail->pred; n--;

9 }

10 }

代码3.20 列

表癿选择排

序

其中的selectMax()接

口用于在无

序列表中定

位最大节点

，其实现如代

码3.21所示。

§3.5 排序

器 第3章

列表

82

1 template <typename

T> //从起始亍位

置p癿n个元素

中选出最大

者

2 ListNodePosi(T)

List<T>::selectMax ( ListNodePosi(T) p,

int n ) {

3 ListNodePosi(T) max =

p; //最大者暂

定为首节点

p

4 for

( ListNodePosi(T) cur =

p; 1 < n;

n-- ) //从首节点p出

収，将后续节

点逐一不max比

较

5

if ( !lt (

( cur = cur->succ

)->data, max->data ) )

//若弼前元

素丌小亍max，则

6 max = cur;

//更新最大元

素位置记弽

7 return max; //迒回最大节

点位置

8 }

代码

3.21 列表最大节

点癿定位

 复

杂度

与插入

排序类似地

，选择排序亦

由n步迭代组

成，故其运行

时间取决于

各步迭代中

查找及插

入

操作的效率

。根据3.3.5和3.3.7节的

结论，insertB()和remove()均只

需O(1)时间。

selectMax()每次

必须遍历整

个无序前缀

，耗时应线性

正比于前缀

长度；全程累

计耗时O(n2）。

实际

上进一步地

仔细观察之

后不难发现

，无论输入序

列中各元素

的大小次序

如何，以上n次

selectMax()调用的累计

耗时总是(n2）。因

此与插入排

序算法不同

，以上选择排

序算法的时

间复杂度为

固定的(n2

)。也就

是说，其最好

和最坏情况

下的渐进效

率相同。

选择

排序属于CBA式

算法，故相对

于2.7.5节所给出

的(nlogn)下界，(n2

)的效

率应有很

大

的改进空间

。正如我们将

在10.2.5节看到的

，借助更为高

级的数据结

构，可以令单

次

selectMax()操作的复

杂度降至O(logn)，从

而使选择排

序的整体效

率提高至O(nlogn)。

3.5.4

归

并排序

2.8.3节介

绍过基于二

路归并的向

量排序算法

，其构思也同

样适用于列

表结构。实际

上，有

序列表

的二路归并

不仅可以实

现，而且能够

达到与有序

向量二路归

并同样高的

效率。



二路归

并算法的实

现

代码3.22针对

有序列表结

构，给出了二

路归并算法

的一种实现

。

1 template

<typename T> //有序列表癿

弻幵：弼前列

表中自p起癿

n个元素，不列

表L中自q起癿

m个元素弻幵

2 void

List<T>::merge ( ListNodePosi(T) &

p, int n, List<T>&

L, ListNodePosi(T) q, int

m ) {

3

// assert: this.valid(p) &&

rank(p) + n <=

size && this.sorted(p, n)

4 // L.valid(q) &&

rank(q) + m <=

L._size && L.sorted(q, m)

5 // 注意：在弻幵

排序乀类癿

场合，有可能

this ==

L && rank(p) +

n = rank(q)

6

ListNodePosi(T) pp = p->pred;

//倚劣前驱（可

能是header），以便迒

回前 ...

7 while

( 0 < m

) //在q尚未

秱出匙间乀

前

8 if

( ( 0 <

n ) && (

p->data <= q->data )

) //若p仍在匙

间内且v(p) <= v(q)，则

9 { if (

q == ( p

= p->succ ) )

break; n--; } //p弻

入合幵癿列

表，幵替换为

其直接后继

10

else //若p已超出右

界戒v(q) < v(p)，则

11 { insertB (

p, L.remove ( (

q = q->succ )->pred

) ); m--; }

//将q转

秱至p乀前

12 p =

pp->succ; //确

定弻幵后匙

间癿（新）起点

13 }

代码3.22

有序列

表癿事路归

幵

第3章 列表

§3.5 排序器

83

作为

有序列表的

内部接口，List::merge()可

以将另一有

序列表L中起

始于节点q、长

度为m

的子列

表，与当前有

序列表中起

始于节点p、长

度为n的子列

表做二路归

并。

为便于递

归地实现上

层的归并排

序，在二路归

并的这一版

本中，归并所

得的有序列

表依然起

始

于节点p。在更

为通用的场

合，不见得需

要采用这一

约定。

 归并时

间

代码3.22中二

路归并算法

merge()的时间成本

主要消耗于

其中的迭代

。该迭代反复

地比较两

个

子列表的首

节点p和q，并视

其大小相应

地令p指向其

后继，或将节

点q取出并作

为p的前驱插

入

前一子列

表。当且仅当

后一子列表

中所有节点

均处理完毕

时，迭代才会

终止。因此，在

最好情况

下

，共需迭代m次

；而在最坏情

况下，则需迭

代n次。

总体而

言，共需O(n

+ m)时间

，线性正比于

两个子列表

的长度之和

。

 特例

在List模板

类（70页代码3.2）中

，作为以上二

路归并通用

接口的一个

特例，还重载

并开放

了另

一个接口List::merge(L)，用

以将有序列

表L完整地归

并到当前有

序列表中。

请

注意，以上二

路归并算法

的通用接口

，对列表L没有

过多的限定

，因此同样作

为一个特例

，

该算法也适

用于L同为当

前列表的情

形。此时，待归

并的列表实

际上是来自

同一列表的

两个子列

表

（当然，此时的

两个子列表

不得相互重

叠。也就是说

，在两个首节

点中，p应是q的

前驱，且二

者

的间距不得

小于n）。对以下

归并排序算

法的简捷实

现而言，这一

特性至关重

要。

 分治策略

仿照向量的

归并排序算

法mergesort()（62页代码2.28），采

用分治策略

并基于以上

有序

列表的

二路归并算

法，可如代码

3.23所示，递归地

描述和实现

列表的归并

排序算法。

1 template <typename

T> //列

表癿弻幵排

序算法：对起

始亍位置p癿

n个元素排序

2 void List<T>::mergeSort

( ListNodePosi(T) & p,

int n ) {

//valid(p) && rank(p) +

n <= size

3

if ( n <

2 ) return; //若待排序范

围已足够小

，则直接迒回

；否则...

4 int m =

n >> 1; //以中点

为界

5 ListNodePosi(T) q =

p; for ( int

i = 0; i

< m; i++ )

q = q->succ; //均分列

表

6 mergeSort ( p,

m ); mergeSort (

q, n - m

); //对前、后子

列表分删排

序

7 merge

( p, m, *this,

q, n - m

); //弻幵

8 }

//注意

：排序后，p依然

指向弻幵后

匙间癿（新）起

点

代码3.23 列表

癿归幵排序

 排序时间

根

据该算法的

流程，为对长

度为n的列表

做归并排序

，首先需要花

费线性时间

确定居中的

切

分节点，然

后递归地对

长度均为n/2的

两个子列表

做归并排序

，最后还需花

费线性的时

间做二路

归

并。因此，仿照

2.8.3节对向量归

并排序算法

的分析方法

，同样可知其

复杂度应为

O(nlogn)。

另外，以上列

表归并排序

算法的递归

跟踪过程，与

如图2.19所示的

向量版本别

无二致。故从

递

归跟踪的

角度，亦可得

出同样的结

论。

请注意，在

子序列的划

分阶段，向量

与列表归并

排序算法之

间存在细微

但本质的区

别。前者

支持

循秩访问的

方式，故可在

O(1)时间内确定

切分中点；后

者仅支持循

位置访问的

方式，故不

得

不为此花费

O(n)时间。幸好在

有序子序列

的合并阶段

二者均需O(n)时

间，故二者的

渐进时间

§3.5 排

序器 第3章 列

表

84

复杂度依

然相等。

最后

，尽管二路归

并算法并未

对子列表的

长度做出任

何限制，但这

里出于整体

效率的考虑

，

在划分子列

表时宁可花

费O(n)时间使得

二者尽可能

接近于等长

。反之，若为省

略这部分时

间而

不保证

划分的均衡

性，则反而可

能导致整体

效率的下降

（习题[3-16]）。

第4章

栈

与队列

§4.1

栈 第

4章 栈不队列

86

本章将定制

并实现更加

基本，且更为

常用的两类

数据结构栈

与队列。与此

前介绍的向

量

和列表一

样，它们也属

于线性序列

结构，故其中

存放的数据

对象之间也

具有线性次

序。相对于一

般的序列结

构，栈与队列

的数据操作

范围仅限于

逻辑上的特

定某端。然而

，得益于其简

洁性与规

范

性，它们既成

为构建更复

杂、更高级数

据结构的基

础，同时也是

算法设计的

基本出发点

，甚至

常常作

为标准配置

的基本数据

结构以硬件

形式直接实

现。因此无论

就工程或理

论而言，其基

础性

地位都

是其它结构

无法比拟的

。

在信息处理

领域，栈与队

列的身影随

处可见。许多

程序语言本

身就是建立

于栈结构之

上，无

论PostScript或者

Java，其实时运行

环境都是基

于栈结构的

虚拟机。再如

，网络浏览器

多会将

用户

最近访问过

的地址组织

为一个栈。这

样，用户每访

问一个新页

面，其地址就

会被存放至

栈顶；

而用户

每按下一次

“后退”按钮，即

可沿相反的

次序返回此

前刚访问过

的页面。类似

地，主流的

文

本编辑器也

大都支持编

辑操作的历

史记录功能

，用户的编辑

操作被依次

记录在一个

栈中。一旦

出

现误操作，用

户只需按下

“撤销”按钮，即

可取消最近

一次操作并

回到此前的

编辑状态。

在

需要公平且

经济地对各

种自然或社

会资源做管

理或分配的

场合，无论是

调度银行和

医院的

服务

窗口，还是管

理轮耕的田

地和轮伐的

森林，队列都

可大显身手

。甚至计算机

及其网络自

身内

部的各

种计算资源

，无论是多进

程共享的CPU时

间，还是多用

户共享的打

印机，也都需

要借助队

列

结构实现合

理和优化的

分配。

相对于

向量和列表

，栈与队列的

外部接口更

为简化和紧

凑，故亦可视

作向量与列

表的特例，

因

此C++的继承与

封装机制在

此可以大显

身手。得益于

此，本章的重

点将不再拘

泥于对数据

结构

内部实

现机制的展

示，并转而更

多地从其外

部特性出发

，结合若干典

型的实际问

题介绍栈与

队列

的具体

应用。

在栈的

应用方面，本

章将在1.4节的

基础上，结合

函数调用栈

的机制介绍

一般函数调

用的实

现方

式与过程，并

将其推广至

递归调用。然

后以降低空

间复杂度的

目标为线索

，介绍通过显

式地

维护栈

结构解决应

用问题的典

型方法和基

本技巧。此外

，还将着重介

绍如何利用

栈结构，实现

基

于试探回

溯策略的高

效搜索算法

。在队列的应

用方面，本章

将介绍如何

实现基于轮

值策略的通

用

循环分配

器，并以银行

窗口服务为

例实现基本

的调度算法

。

§4.1

栈

4.1.1 ADT接口



入栈

与出栈

栈（stack）是

存放数据对

象的一种特

殊容器，其中

的数据元素

按线性的逻

辑次序排列

，故

也可定义

首、末元素。不

过，尽管栈结

构也支持对

象的插入和

删除操作，但

其操作的范

围仅限于

栈

的某一特定

端。也就是说

，若约定新的

元素只能从

某一端插入

其中，则反过

来也只能从

这一端

删除

已有的元素

。禁止操作的

另一端，称作

盲端。

第4章 栈

不队列 §4.1

栈

87

图

4.1 一摞椅子即

是一个栈

图

4.2 栈操作

如图

4.1所示，数把椅

子叠成一摞

即可视作一

个栈。

为维持

这一放置形

式，对该栈可

行的操作只

能在其顶部

实施：新的椅

子只能叠放

到最顶端；反

过来，只有最

顶

端的椅子

才能被取走

。因此比照这

类实例，栈中

可操作

的一

端更多地称

作栈顶（stack top），而另

一无法直

接

操作的盲端

则更多地称

作栈底（stack

bottom）。

作为

抽象数据类

型，栈所支持

的操作接口

可归纳为

表

4.1。其中除了引

用栈顶的top()等

操作外，如图

4.2

所示，最常用

的插入与删

除操作分别

称作入栈（push）

和

出栈（pop）。

表4.1 栈ADT支

持癿操作接

口

操作接口

功

能

size() 报告栈

癿觃模

empty()

刞断

栈是否为空

push(e) 将e揑至栈顶

pop() 初除栈顶对

象

top()

引用栈顶

对象

 后进先

出

由以上关

于栈操作位

置的约定和

限制不难看

出，栈中元素

接受操作的

次序必然始

终遵循所谓

“后进先出”（last-in-first-out,

LIFO）的

规律：从栈结

构的整个生

命期来看，更

晚（早）

出栈的

元素，应为更

早（晚）入栈者

；反之，更晚（早

）入栈者应更

早（晚）出栈。

4.1.2 操

作实例

表4.2给

出了一个存

放整数的栈

从被创建开

始，按以上接

口实施一系

列操作的过

程。

表4.2 栈操作

实例

操

作 输

出 栈（左侧为

栈顶） 操

作 输

出 栈（左侧为

栈顶）

Stack()

push(11) 11 3 7

5

empty() true size()

4 11 3 7

5

push(5) 5 push(6)

6 11 3 7

5

push(3) 3 5

empty() false 6 11

7 5

pop() 3

5 push(7) 7 6

11 3 7 5

push(7) 7 5 pop()

7 6 11 3

7 5

push(3) 3

7 5 pop() 6

11 3 7 5

top() 3 3 7

5 top() 11 11

3 7 5

empty()

false 3 7 5

size() 4 11 3

7 5

§4.2 栈不逑

弻

第4章 栈不

队列

88

4.1.3

Stack模板类

既然栈可视

作序列的特

例，故只要将

栈作为向量

的派生类，即

可利用C++的继

承机制，基于

2.2.3节定义的向

量模板类实

现栈结构。当

然，这里需要

按照栈的习

惯，对各接口

重新命名。

按

照表4.1所列的

ADT接口，可描述

并实现Stack模板

类如代码4.1所

示。

1 #include

"../Vector/Vector.h" //以向量为

基类，派生出

栈模板类

2 template

<typename T> class Stack:

public Vector<T> { //将

向量癿首/末

端作为栈底

/顶

3 public: //size()、empty()以及其它

开放接口，均

可直接沿用

4 void

push ( T const&

e ) { insert

( size(), e );

} //入栈：等效亍

将新元素作

为向量癿末

元素揑入

5 T

pop() { return remove

( size() - 1

); } //出

栈：等效亍初

除向量癿末

元素

6

T& top() { return

( *this ) [size()

- 1]; } //叏顶：直

接迒回向量

癿末元素

7 };

代

码4.1 Stack模板类

既

然栈操作都

限制于向量

的末端，参与

操作的元素

没有任何后

继，故由2.5.5节和

2.5.6节

的分析结

论可知，以上

栈接口的时

间复杂度均

为常数。

套用

以上思路，也

可直接基于

3.2.2节的List模板类

派生出Stack类（习

题[4-1]）。

§4.2

栈与递归

习题[1-17]指出，递

归算法所需

的空间量，主

要决定于最

大递归深度

。在达到这一

深度的

时刻

，同时活跃的

递归实例达

到最多。那么

，操作系统具

体是如何实

现函数（递归

）调用的？如

何

记录调用与

被调用函数

（递归）实例之

间的关系？如

何实现函数

（递归）调用的

返回？又是如

何维护同时

活跃的所有

函数（递归）实

例的？所有这

些问题的答

案，都可归结

于栈。

4.2.1

函数调

用栈

图4.3 函数

调用栈实例

：主函数main()调用

funcA()，funcA()调用funcB()，funcB()再自我

调用

第4章

栈

不队列 §4.2 栈不

逑弻

89

在Windows等大

部分操作系

统中，每个运

行中的二进

制程序都配

有一个调用

栈（call 

stack）或执行栈

（execution stack）。借助调用栈

可以跟踪属

于同一程序

的所有函数

，记录

它们之

间的相互调

用关系，并保

证在每一调

用实例执行

完毕之后，可

以准确地返

回。

 函数调用

如图4.3所示，调

用栈的基本

单位是帧（frame）。每

次函数调用

时，都会相应

地创建一帧

，

记录该函数

实例在二进

制程序中的

返回地址（return

address），以

及局部变量

、传入参数等

，

并将该帧压

入调用栈。若

在该函数返

回之前又发

生新的调用

，则同样地要

将与新函数

对应的一帧

压入栈中，成

为新的栈顶

。函数一旦运

行完毕，对应

的帧随即弹

出，运行控制

权将被交还

给该函

数的

上层调用函

数，并按照该

帧中记录的

返回地址确

定在二进制

程序中继续

执行的位置

。

在任一时刻

，调用栈中的

各帧，依次对

应于那些尚

未返回的调

用实例，亦即

当时的活跃

函数

实例（active function instance）。特

别地，位于栈

底的那帧必

然对应于入

口主函数main()，

若

它从调用栈

中弹出，则意

味着整个程

序的运行结

束，此后控制

权将交还给

操作系统。

仿

照递归跟踪

法，程序执行

过程出现过

的函数实例

及其调用关

系，也可构成

一棵树，称作

该

程序的运

行树。任一时

刻的所有活

跃函数实例

，在调用栈中

自底到顶，对

应于运行树

中从根节点

到最新活跃

函数实例的

一条调用路

径。

此外，调用

栈中各帧还

需存放其它

内容。比如，因

各帧规模不

一，它们还需

记录前一帧

的起

始地址

，以保证其出

栈之后前一

帧能正确地

恢复。

 递归

作

为函数调用

的特殊形式

，递归也可借

助上述调用

栈得以实现

。比如在图4.3中

，对应于

funcB()的自

我调用，也会

新压入一帧

。可见，同一函

数可能同时

拥有多个实

例，并在调用

栈中

各自占

有一帧。这些

帧的结构完

全相同，但其

中同名的参

数或变量，都

是独立的副

本。比如在

funcB()的

两个实例中

，入口参数m和

内部变量i各

有一个副本

。

4.2.2 避免递归

今

天，包括C++在内

的各种高级

程序设计语

言几乎都允

许函数直接

或间接地自

我调用，通过

递归来提高

代码的简洁

度和可读性

。而Cobol和Fortran等早期

的程序语言

虽然一开始

并未采用

栈

来实现过程

调用，但在其

最新的版本

中也陆续引

入了栈结构

来支持过程

调用。

尽管如

此，系统在后

台隐式地维

护调用栈的

过程中，难以

区分哪些参

数和变量是

对计算过程

有实质作用

的，更无法以

通用的方式

对它们进行

优化，因此不

得不将描述

调用现场的

所有参数和

变量悉数入

栈。再加上每

一帧都必须

保存的执行

返回地址以

及前一帧起

始位置，往往

导致程序的

空间效率不

高甚至极低

；同时，隐式的

入栈和出栈

操作也会令

实际的运行

时间增加不

少。

因此在追

求更高效率

的场合，应尽

可能地避免

递归，尤其是

过度的递归

。实际上，我们

此前

已经介

绍过相应的

方法和技巧

。例如，在1.4.4节中

将尾递归转

换为等效的

迭代形式；在

1.4.5

节中采用动

态规划策略

，将Fibonacci数算法中

的二分递归

改为线性递

归，直至完全

消除递归。

既

然递归本身

就是操作系

统隐式地维

护一个调用

栈而实现的

，我们自然也

可以通过显

式地模

拟调

用栈的运转

过程，实现等

效的算法功

能。采用这一

方式，程序员

可以精细地

裁剪栈中各

帧的

内容，从

而尽可能降

低空间复杂

度的常系数

。尽管算法原

递归版本的

高度概括性

和简洁性将

大打

折扣，但

毕竟在空间

效率方面可

以获得足够

的补偿。

§4.3 栈癿

典型应用

第

4章 栈不队列

90

§4.3 栈的典型应

用

4.3.1 逆序输出

在栈所擅长

解决的典型

问题中，有一

类具有以下

共同特征：首

先，虽有明确

的算法，但其

解

答却以线

性序列的形

式给出；其次

，无论是递归

还是迭代实

现，该序列都

是依逆序计

算输出的；

最

后，输入和输

出规模不确

定，难以事先

确定盛放输

出数据的容

器大小。因其

特有的“后进

先出”

特性及

其在容量方

面的自适应

性，使用栈来

解决此类问

题可谓恰到

好处。

 进制转

换

考查如下

问题；任给十

进制整数n，将

其转换为进

制的表示形

式。比如

= 8时有

12345(10) = 30071(8)

一般地，设 n = (dm

... d2 d1 d0)()

= dm

m

+

... + d2

2

+ d1

1

+

d0

0

若

记 ni

= (dm ... di+1

di)()

则有 di =

ni %  和

ni+1 = ni /



这

一递推关系

对应的计算

流程如下。可

见，其输出的

确为长度不

定的逆序线

性序列。

图4.4 迕

刢转换算法

流秳

 递归实

现

根据如图

4.4所示的计算

流程，可得到

如代码4.2所示

递归式算法

。

1

void convert ( Stack<char>&

S, __int64 n, int

base ) { //十迕刢数n刡

base迕刢癿转换

（逑弻版）

2 static char digit[]

//0 < n, 1

< base <= 16，新迕

刢下癿数位

符号，可规base叏

值范围适弼

扩充

3 = { '0',

'1', '2', '3', '4',

'5', '6', '7', '8',

'9', 'A', 'B', 'C',

'D', 'E', 'F' };

4 if ( 0

< n ) {

//在尚有

余数乀前，丌

断

5 convert (

S, n / base,

base ); //通过逑弻

得刡所有更

高位

6

S.push ( digit[n %

base] ); //输出低

位

7

}

8 } //新迕刢下

由高刡低癿

各数位，自顶

而下保存亍

栈S中

代码4.2 迕

刢转换算法

（递归版）

尽管

新进制下的

各数位须按

由低到高次

序逐位算出

，但只要引入

一个栈并将

算得的数位

依次

入栈，则

在计算结束

后只需通过

反复的出栈

操作即可由

高到低地将

其顺序输出

。

 迭代实现

这

里的静态数

位符号表在

全局只需保

留一份，但与

一般的递归

函数一样，该

函数在递归

调用

栈中的

每一帧都仍

需记录参数

S、n和base。将它们改

为全局变量

固然可以节

省这部分空

间，但

依然不

能彻底地避

免因调用栈

操作而导致

的空间和时

间消耗。为此

，不妨考虑改

写为如代码

4.3

所示的迭代

版本，既能充

分发挥栈处

理此类问题

的特长，又可

将空间消耗

降至O(1)。

第4章 栈

不队列

§4.3 栈癿

典型应用

91

1

void convert ( Stack<char>&

S, __int64 n, int

base ) { //十

迕刢数n刡base迕

刢癿转换（迭

代版）

2 static char digit[]

//0 < n, 1

< base <= 16，新迕刢

下癿数位符

号，可规base叏值

范围适弼扩

充

3 = { '0',

'1', '2', '3', '4',

'5', '6', '7', '8',

'9', 'A', 'B', 'C',

'D', 'E', 'F' };

4 while ( n

> 0 ) {

//由低刡高

，逐一计算出

新迕刢下癿

各数位

5 int remainder

= ( int )

( n % base

); S.push ( digit[remainder]

); //余数

（弼前位）入栈

6 n /=

base; //n更新为其对

base癿除商

7 }

8 } //新迕

刢下由高刡

低癿各数位

，自顶而下保

存亍栈S中

代

码4.3

迕刢转换

算法（迭代版

）

4.3.2 递归嵌套

具

有自相似性

的问题多可

嵌套地递归

描述，但因分

支位置和嵌

套深度并不

固定，其递归

算法

的复杂

度不易控制

。栈结构及其

操作天然地

具有递归嵌

套性，故可用

以高效地解

决这类问题

。以

下先从混

洗的角度介

绍栈的递归

嵌套性，然后

再讲解其在

具体问题中

的应用。

 栈混

洗

考查三个

栈A、B和S。其中，B和

S初始为空；A含

有n个元素，自

顶而下构成

输入序列：

A = <

a1, a2, ..., an

]

这

里，分别用尖

括号、方括号

示意栈顶、栈

底，这也是本

小节将统一

采用的约定

。

以下，若只允

许通过S.push( A.pop()

)弹出

栈A的顶元素

并随即压入

栈S中，或通过

B.push( S.pop() )弹出S的顶元

素并随即压

入栈B中，则在

经过这两类

操作各n次之

后，栈A和S

有可

能均为空，原

A中的元素均

已转入栈B。此

时，若将B中元

素自底而上

构成的序列

记作：

B = [ ak1,

ak2, ..., akn >

则该序

列称作原输

入序列的一

个栈混洗（stack permutation）。

图

4.5 栈混洗实例

：仍<

1, 2, 3, 4

]刡[ 3, 2, 4,

1 >（上斱左

侧为栈A，右侧

为栈B；下斱为

栈S）

如图4.5所示

，设最初栈A =

< 1, 2, 3,

4 ]，栈

S和B均为空；经

过“随机的”8次

操作，

A中元素

全部转入栈

B中。此时，栈B中

元素所对应

的序列[ 3,

2, 4, 1 >，即是

原序列的一

个

栈混洗。除

了“实施出栈

操作时栈不

得为空”，以上

过程并无更

多限制，故栈

混洗并不唯

一。就

此例而

言，[ 1, 2,

3, 4 >、[ 4,

3, 2, 1 >以及[

3, 2, 1, 4

>等也

是栈混洗。

从

图4.5也可看出

，一般地对于

长度为n的输

入序列，每一

栈混洗都对

应于由栈S的

n次push

§4.3 栈癿典型

应用

第4章 栈

不队列

92

和n次

pop构成的某一

合法操作序

列，比如[

3, 2, 4, 1

>即对

应于操作序

列：

{

push,

push, 

push, pop,

pop, 

push, pop,

pop }

反之，由n次

push和n次pop构成的

任何操作序

列，只要满足

“任一前缀中

的push不少于

pop”这

一限制，则该

序列也必然

对应于某个

栈混洗（习题

[4-4]）。

 括号匹配

对

源程序的语

法检查是代

码编译过程

中重要而基

本的一个步

骤，而对表达

式括号匹配

的检查

则又

是语法检查

中必需的一

个环节。其任

务是，对任一

程序块，判断

其中的括号

是否在嵌套

的意

义下完

全匹配（简称

匹配）。比如在

以下两个表

达式中，前者

匹配，而后者

不匹配。

a / (

b [ i -

1 ] [ j

+ 1 ] +

c [ i +

1 ] [ j

- 1 ] )

* 2

a /

( b [ i

- 1 ] [

j + 1 ]

) + c [

i + 1 ]

[ j - 1

] ) * 2

 递归

实现

不妨先

只考虑圆括

号。用'+'表示表

达式的串接

。

不难理解，一

般地，若表达

式S可分解为

如下形式：

S = S0 +

"(" + S1 +

")" + S2 +

S3

其

中S0和S3不含括

号，且S1中左、右

括号数目相

等，则S匹配当

且仅当S1和S2均

匹配。

按照这

一理解，可采

用分治策略

设计算法如

下：将表达式

划分为子表

达式S0、S1和S2，分别

递归地判断

S1和S2是否匹配

。这一构思可

具体实现如

代码4.4所示。

1

void trim ( const

char exp[], int& lo,

int& hi ) {

//初

除exp[lo, hi]丌含括号

癿最长前缀

、后缀

2 while

( ( lo <=

hi ) && (

exp[lo] != '(' )

&& ( exp[lo] !=

')' ) ) lo++;

//查找第

一个和

3 while (

( lo <= hi

) && ( exp[hi]

!= '(' ) &&

( exp[hi] != ')'

) ) hi--; //最后

一个括号

4 }

5

6

int divide ( const

char exp[], int lo,

int hi ) {

//切

分exp[lo, hi]，使exp匘配仅

弼子表达式

匘配

7 int

mi = lo; int

crc = 1; //crc为[lo,

mi]范围

内左、右括号

数目乀差

8 while (

( 0 < crc

) && ( ++mi

< hi ) )

//逐

个检查各字

符，直刡左、右

括号数目相

等，戒者越界

9 { if (

exp[mi] == ')' )

crc--; if ( exp[mi]

== '(' ) crc++;

} //左、右括号分

删计数

10 return

mi; //若mi <= hi，则

为合法切分

点；否则，意味

着尿部丌可

能匘配

11 }

12

13

bool paren ( const

char exp[], int lo,

int hi ) {

//检查

表达式exp[lo, hi]是否

括号匘配（逑

弻版）

14 trim

( exp, lo, hi

); if ( lo

> hi ) return

true; //清除丌

含括号癿前

缀、后缀

15 if

( exp[lo] != '('

) return false; //首字

符非左括号

，则必丌匘配

16

if ( exp[hi] !=

')' ) return false;

//末字符非右

括号，则必丌

匘配

17 int mi

= divide ( exp,

lo, hi ); //确定适

弼癿切分点

18

if ( mi >

hi ) return false;

//切分点丌合

法，意味着尿

部以至整体

丌匘配

19 return paren

( exp, lo +

1, mi - 1

) && paren (

exp, mi + 1,

hi ); //分删

检查左、右子

表达式

20

}

代码

4.4 拪号匹配算

法（递归版）

其

中，trim()函数用于

截除表达式

中不含括号

的头部和尾

部，即前缀S0和

后缀S3。divide()

第4章 栈

不队列 §4.3 栈癿

典型应用

93

函

数对表达式

做线性扫描

，并动态地记

录已经扫描

的左、右括号

数目之差。如

此，当已扫过

同样

多的左

、右括号时，即

确定了一个

合适的切分

点mi，并得到子

表达式S1 =

exp(lo, mi)和S2 =

exp(mi, hi]。以

下，经递归地

检查S1和S2，即可

判断原表达

式是否匹配

。

在最坏情况

下divide()需要线性

时间，且递归

深度为O(n)，故以

上算法共需

O(n2

)时间。

此外，该

方法也难以

处理含有多

种括号的表

达式（习题[4-5]和

[4-15]），故有必要进

一步优化。

 迭

代实现

实际

上，只要将push、pop操

作分别与左

、右括号相对

应，则长度为

n的栈混洗，必

然与由n

对括

号组成的合

法表达式彼

此对应（习题

[4-4]）。比如，栈混洗

[ 3, 2, 4,

1 >对应于表达

式"( ( (

) ) ( )

)"。按照这一

理解，借助栈

结构，只需扫

描一趟表达

式，即可在线

性时间

内，判

定其中的括

号是否匹配

。这一新的算

法，可简明地

实现如代码

4.5所示。

1 bool

paren ( const char

exp[], int lo, int

hi ) { //表达式

括号匘配检

查，可兼顼三

种括号

2 Stack<char> S; //使用

栈记弽已収

现但尚未匘

配癿左括号

3

for ( int i

= lo; i <=

hi; i++ ) /*

逐一检查弼

前字符 */

4 switch

( exp[i] ) {

//左括

号直接迕栈

；右括号若不

栈顶失配，则

表达式必丌

匘配

5 case '(':

case '[': case '{':

S.push ( exp[i] );

break;

6 case ')':

if ( ( S.empty()

) || ( '('

!= S.pop() ) )

return false; break;

7

case ']': if (

( S.empty() ) ||

( '[' != S.pop()

) ) return false;

break;

8 case '}':

if ( ( S.empty()

) || ( '{'

!= S.pop() ) )

return false; break;

9

default: break; //非括号

字符一徇忽

略

10

}

11 return S.empty();

//整个表达

式扫描过后

，栈中若仍残

留（左）括号，则

丌匘配；否则

（栈空）匘配

12 }

代

码4.5

拪号匹配

算法（迭代版

）

新算法的流

程控制简单

，而且便于推

广至多类括

号并存的场

合。它自左向

右逐个考查

各字符，

忽略

所有非括号

字符。凡遇到

左括号，无论

属于哪类均

统一压入栈

S中。若遇右括

号，则弹出栈

顶的左括号

并与之比对

。若二者属于

同类，则继续

检查下一字

符；否则，即可

断定表达式

不匹配。

当然

，栈S提前变空

或者表达式

扫描过后栈

S非空，也意味

着不匹配。

图

4.6给出了一次

完整的计算

过程。表达式

扫描完毕时

，栈S恰好为空

，故知表达式

匹配。

图4.6 迭代

式拪号匹配

算法实例

（上

斱为输入表

达式；下斱为

轴劣栈癿演

发过秳；虚框

表示在（右）拪

号不栈顶（左

）拪号匹配时

对应癿出栈

操作）

§4.3 栈癿典

型应用 第4章

栈不队列

94

4.3.3 延

迟缓冲

在一

些应用问题

中，输入可分

解为多个单

元并通过迭

代依次扫描

处理，但过程

中的各步计

算

往往滞后

于扫描的进

度，需要待到

必要的信息

已完整到一

定程度之后

，才能作出判

断并实施计

算。

在这类场

合，栈结构则

可以扮演数

据缓冲区的

角色。

 表达式

求值

在编译

C++程序的预处

理阶段，源程

序中的所有

常量表达式

都需首先计

算并替换为

对应的具

体

数值。而在解

释型语言中

，算术表达式

的求值也需

随着脚本执

行过程中反

复进行。

比如

，在UNIX Shell、DOS Shell和PostScript交互窗

口中分别输

入：



$ echo $



(( 0 + (

1 + 23 )

/ 4 * 5

* 67 - 8

+ 9 ))

\>

set /a (( 0

+ ( 1 +

23 ) / 4

* 5 * 67

- 8 + 9

))

GS> 0 1

23 add 4 div

5 mul 67 mul

add 8 sub 9

add =

都将返回“2011”。

可

见，不能简单

地按照“先左

后右”的次序

执行表达式

中的运算符

。关于运算符

执行次序的

规则（即运算

优先级），一部

分决定于事

先约定的惯

例（比如乘除

优先于加减

），另一部分则

决

定于括号

。也就是说，仅

根据表达式

的某一前缀

，并不能完全

确定其中各

运算符可否

执行以及执

行的次序；只

有在已获得

足够多后续

信息之后，才

能确定其中

哪些运算符

可以执行。

 优

先级表

我们

首先如代码

4.6所示，将不同

运算符之间

的运算优先

级关系，描述

为一张二维

表格。

1 #define N_OPTR 9

//运算符

总数

2 typedef enum

{ ADD, SUB, MUL,

DIV, POW, FAC, L_P,

R_P, EOE } Operator;

//运算符

集合

3 //加、减、乘

、除、乘斱、阶乘

、左括号、右括

号、起始符不

终止符

4

5 const char pri[N_OPTR][N_OPTR]

= { //运算

符优先等级

[栈顶] [弼前]

6 /* |-------------------- 弼

前

运 算 符 --------------------|

*/

7 /* +

- * / ^

! ( ) \0

*/

8 /* --

+ */ '>', '>',

'<', '<', '<', '<',

'<', '>', '>',

9

/* | - */

'>', '>', '<', '<',

'<', '<', '<', '>',

'>',

10 /* 栈

*

*/ '>', '>', '>',

'>', '<', '<', '<',

'>', '>',

11 /*

顶 / */ '>',

'>', '>', '>', '<',

'<', '<', '>', '>',

12 /* 运 ^

*/ '>', '>', '>',

'>', '>', '<', '<',

'>', '>',

13 /*

算 ! */ '>',

'>', '>', '>', '>',

'>', ' ', '>',

'>',

14 /* 符

( */ '<', '<',

'<', '<', '<', '<',

'<', '=', ' ',

15 /* | )

*/ ' ', '

', ' ', '

', ' ', '

', ' ', '

', ' ',

16

/* -- \0 */

'<', '<', '<', '<',

'<', '<', '<', '

', '='

17 };

代

码4.6 运算符优

先级关系癿

定义

在常规

的四则运算

之外，这里还

引入了乘方

和阶乘运算

。其中阶乘属

于一元运算

，且优先级

最

高。为统一算

法的处理流

程，将左、右括

号以及标识

表达式尾部

的字符'\0'，也视

作运算符。

第

4章 栈不队列

§4.3 栈癿典型应

用

95

 求值算法

基于运算符

优先级如上

的定义和判

定规则，可实

现表达式求

值算法如代

码4.7所示。

1 float

evaluate ( char* S,

char*& RPN ) {

//对（已

剔除白空格

癿）表达式S求

值，幵转换为

逆波兰式RPN

2 Stack<float> opnd;

Stack<char> optr; //运

算数栈、运算

符栈

3

optr.push ( '\0' );

//尾哨兵

'\0'也作为头哨

兵首先入栈

4 while ( !optr.empty()

) { //在运算符栈

非空乀前，逐

个处理表达

式中各字符

5 if

( isdigit ( *S

) ) { //若弼前字符

为操作数，则

6

readNumber ( S, opnd

); append ( RPN,

opnd.top() ); //读入操作数

，幵将其接至

RPN末尾

7

} else //若弼前

字符为运算

符，则

8

switch ( orderBetween (

optr.top(), *S ) )

{ //规其不

栈顶运算符

乀间优先级

高低分删处

理

9 case

'<': //栈顶运算

符优先级更

低时

10 optr.push

( *S ); S++;

//计算推

迟，弼前运算

符迕栈

11 break;

12

case '=': //优先

级相等（弼前

运算符为右

括号戒者尾

部哨兵'\0'）时

13

optr.pop(); S++; //脱

括号幵接收

下一个字符

14 break;

15 case '>': {

//栈顶运算符

优先级更高

时，可实斲相

应癿计算，幵

将结枅重新

入栈

16 char op

= optr.pop(); append (

RPN, op ); //栈顶运

算符出栈幵

续接至RPN末尾

17

if ( '!' ==

op ) { //若属亍一元

运算符

18 float pOpnd =

opnd.pop(); //叧需

叏出一个操

作数，幵

19 opnd.push

( calcu ( op,

pOpnd ) ); //实斲

一元计算，结

枅入栈

20 } else {

//对亍

其它（二元）运

算符

21 float pOpnd2

= opnd.pop(), pOpnd1 =

opnd.pop(); //叏出后

、前操作数

22 opnd.push

( calcu ( pOpnd1,

op, pOpnd2 ) );

//实

斲二元计算

，结枅入栈

23 }

24

break;

25 }

26

default : exit (

-1 ); //逢

语法错误，丌

做处理直接

退出

27

}//switch

28 }//while

29

return opnd.pop(); //弹出幵

迒回最后癿

计算结枅

30

}

代

码4.7 表达式癿

求值及RPN转换

该算法自左

向右扫描表

达式，并对其

中字符逐一

做相应的处

理。那些已经

扫描过但（因

信息

不足）尚

不能处理的

操作数与运

算符，将分别

缓冲至栈opnd和

栈optr。一旦判定

已缓存的子

表

达式优先

级足够高，便

弹出相关的

操作数和运

算符，随即执

行运算，并将

结果压入栈

opnd。

请留意这里

区分操作数

和运算符的

技巧。一旦当

前字符由非

数字转为数

字，则意味着

开始进

入一

个对应于操

作数的子串

范围。由于这

里允许操作

数含有多个

数位，甚至可

能是小数，故

可调

用readNumber()函数

（习题[4-6]），根据当

前字符及其

后续的若干

字符，利用另

一个栈解析

出当前的操

作数。解析完

毕，当前字符

将再次聚焦

于一个非数

字字符。

§4.3 栈癿

典型应用 第

4章 栈不队列

96

 不同优先级

的处置

按照

代码4.7，若当前

字符为运算

符，则在调用

orderBetween()函数（习题[4-7]），将

其与栈optr的栈

顶操作符做

一比较之后

，即可视二者

的优先级高

低，分三种情

况相应地处

置。

1）若当前运

算符的优先

级更高，则optr中

的栈顶运算

符尚不能执

行

以表达式

" 1 + 2

* 3 ... "为例，在扫描

到运算符'*'时

，optr栈顶运算符

为此前的'+'，

由

于pri['+']['*'] = '<'，当前运算

符'*'优先级更

高，故栈顶运

算符'+'的执行

必须推迟。

请

注意，由代码

4.6定义的优先

级表，无论栈

顶元素如何

，当前操作符

为'('的所有情

况均

统一归

入这一处理

方式；另外，无

论当前操作

符如何，栈顶

操作符为'('的

所有情况也

统一按此

处

理。也就是说

，所有左括号

及其后紧随

的一个操作

符都会相继

地被直接压

入optr栈中，而此

前的运算符

则一律押后

执行这与左

括号应有的

功能完全吻

合。

2）反之，一旦

栈顶运算符

的优先级更

高，则可以立

即弹出并执

行对应的运

算

以表达式

"

1 + 2 *

3 - 4 ...

"为例，在扫描

到运算符'-'时

，optr栈顶运算符

为'*'，

由于pri['*']['-'] = '>'，意味

着当前运算

符的优先级

更低，故栈顶

运算符'*'可立

即执行。

类似

地，根据代码

4.6定义的优先

级表，无论栈

顶元素如何

，当前操作符

为')'的情况也

几

乎全部归

入这一处理

方式。也就是

说，一旦抵达

右括号，此前

在optr栈缓冲的

运算符大都

可以

逐一弹

出并执行这

与右括号应

有的功能也

完全吻合。

3）当

前运算符与

栈顶运算符

的优先级“相

等”

对右括号

的上述处理

方式，将在optr栈

顶出现操作

符'('时终止由

代码4.6可知，

pri['('][')'] = '='。此

时，将弹出栈

顶的'('，然后继

续处理')'之后

的字符。不难

看出，

这对左

、右括号在表

达式中必然

相互匹配，其

作用在于约

束介乎二者

之间的那段

子表达式的

优先

级关系

，故在其“历史

使命”完成之

后，算法做如

上处置理所

应当。

除左、右

括号外，还有

一种优先级

相等的合法

情况，即pri['\0']['\0'] =

'='。由于

在

算法启动

之初已经首

先将字符'\0'压

入optr栈，故在整

个表达式已

被正确解析

并抵达表达

式结

束标识

符'\0'时，即出现

这一情况。对

于合法的表

达式，这种情

况只在算法

终止前出现

一次。

既然同

是需要弹出

栈顶，算法不

妨将这种情

况按照优先

级相等的方

式处置。

 语法

检查及鲁棒

性

为简洁起

见，以上算法

假设输入表

达式的语法

完全正确；否

则，有可能会

导致荒诞的

结果。

读者可

在此基础上

，尝试扩充语

法检查以及

对各种非法

情况的处理

功能（习题[4-12]）。

4.3.4 逆

波兰表达式

 RPN

逆波兰表达

式（reverse

Polish notation, RPN）是数学表

达式的一种

，其语法规则

可

概括为：操

作符紧邻于

对应的（最后

一个）操作数

之后。比如“1

2 +”即

通常习惯的

“1 + 2”。

按此规则，可

递归地得到

更复杂的表

达式，比如RPN表

达式

1 2 +

3 4 ^ *

即对应

于常规的表

达式

( 1 +

2 ) * 3

^ 4

第4章 栈

不队列

§4.3 栈癿

典型应用

97

RPN表

达式亦称作

后缀表达式

（postfix），原表达式则

称作中缀表

达式（infix）。尽管

RPN表

达式不够直

观易读，但其

对运算符优

先级的表述

能力，却毫不

逊色于常规

的中缀表达

式；

而其在计

算效率方面

的优势，更是

常规表达式

无法比拟的

。RPN表达式中运

算符的执行

次序，可

更为

简捷地确定

，既不必在事

先做任何约

定，更无需借

助括号强制

改变优先级

。具体而言，各

运

算符被执

行的次序，与

其在RPN表达式

中出现的次

序完全吻合

。以上面的"

1 2 + 3

4 ^ * "

为

例，三次运算

的次序{ +, ^, *

}，与三

个运算符的

出现次序完

全一致。

 求值

算法

根据以

上分析，采用

算法4.1即可高

效地实现对

RPN表达式的求

值。

rpnEvaluation(expr)

输入：RPN表达

式expr（假定语法

正确）

输出：表

达式数值

{

引

入栈S，用以存

放操作数;

 while (expr尚

未扫描完毕

)

{

 从expr中读入下

一元素x;

if (x是操

作数) 将x压入

S;

else { //x是运算符

从

栈S中弹出运

算符x所需数

目癿操作数

;

 对弹出癿操

作数实斲x运

算，幵将运算

结枅重新压

入S;

} //else

 }

//while

 迒回栈顶

; //也是栈底

}

算

法4.1 RPN表达式求

值

可见，除了

一个辅助栈

外，该算法不

需要借助任

何更多的数

据结构。此外

，算法的控制

流程

也十分

简明，只需对

RPN表达式做单

向的顺序扫

描，既无需更

多判断，也不

含任何分支

或回溯。

算法

4.1的一次完整

运行过程，如

表4.3所示。

表4.3 RPN表

达式求值算

法实例（当前

字符以斱框

注明，操作数

栈癿底部靠

左）

操作数栈

表 达 式 注

解

0 ! 1 +

2 3 ! 4

+ ^ * 5

! 67 - 8

9 + - -

刜始化，引入

操作数栈

0 0 !

1 + 2 3

! 4 + ^

* 5 ! 67

- 8 9 +

- - 操

作数0入栈

1

0 ! 1 +

2 3 ! 4

+ ^ * 5

! 67 - 8

9 + - -

0出

栈，运算'!'结枅

入栈

1 1 0

! 1 + 2

3 ! 4 +

^ * 5 !

67 - 8 9

+ - - 操作数

1入栈

2 0 ! 1

+ 2 3 !

4 + ^ *

5 ! 67 -

8 9 + -

- 1和1出栈

，运算'+'结枅入

栈

2 2

0 ! 1 +

2 3 ! 4

+ ^ * 5

! 67 - 8

9 + - -

操作数2入

栈

2 2 3

0 ! 1 +

2 3 ! 4

+ ^ * 5

! 67 - 8

9 + - -

操作数3入

栈

2 2 6

0 ! 1 +

2 3 ! 4

+ ^ * 5

! 67 - 8

9 + - -

3出栈，运算

'!'结枅入栈

2 2 6

4 0 ! 1

+ 2 3 !

4 + ^ *

5 ! 67 -

8 9 + -

- 操

作数4入栈

§4.3 栈

癿典型应用

第4章

栈不队

列

98

操作数栈

表 达

式 注 解

2 2

10 0 ! 1

+ 2 3 !

4 + ^ *

5 ! 67 -

8 9 + -

- 6和4出栈，运算

'+'结枅入栈

2 1024

0 ! 1 +

2 3 ! 4

+ ^ * 5

! 67 - 8

9 + - -

2和

10出栈，运算'^'结

枅入栈

2048 0 !

1 + 2 3

! 4 + ^

* 5 ! 67

- 8 9 +

- - 2和1024出

栈，运算'*'结枅

入栈

2048

5 0 ! 1

+ 2 3 !

4 + ^ *

5 ! 67 -

8 9 + -

- 操作数

5入栈

2048 120

0 ! 1 +

2 3 ! 4

+ ^ * 5

! 67 - 8

9 + - -

5出栈，运

算'!'结枅入栈

2048 120 67 0

! 1 + 2

3 ! 4 +

^ * 5 !

67 - 8 9

+ - - 操作数67入栈

2048

53 0 ! 1

+ 2 3 !

4 + ^ *

5 ! 67 -

8 9 + -

- 120和67出栈，运算

'-'结枅入栈

2048 53

8 0 ! 1

+ 2 3 !

4 + ^ *

5 ! 67 -

8 9 + -

- 操

作数8入栈

2048 53

8 9 0 !

1 + 2 3

! 4 + ^

* 5 ! 67

- 8 9 +

- - 操

作数9入栈

2048

53 17 0 !

1 + 2 3

! 4 + ^

* 5 ! 67

- 8 9 +

- - 8和

9出栈，运算'+'结

枅入栈

2048

36 0 ! 1

+ 2 3 !

4 + ^ *

5 ! 67 -

8 9 + -

- 53和17出

栈，运算'-'结枅

入栈

2012 0

! 1 + 2

3 ! 4 +

^ * 5 !

67 - 8 9

+ - - 2048和36出栈

，运算'-'结枅入

栈

可见，只有

操作数可能

需要借助栈

S做缓存，运算

符则均可直

接执行而不

必保留。

另外

，只要RPN表达式

合法，在整个

求值计算的

过程中，当前

运算符所需

的操作数无

论多少，

都必

然恰好按次

序存放在当

前栈的顶部

。当上例处理

到运算符'^'时

，对应的操作

数2和10恰为

次

栈顶和栈顶

；当处理到运

算符'*'时，对应

的操作数2和

1024也恰为次栈

顶和栈顶。

 手

工转换

按照

以下步骤，即

可完成从中

缀表达式到

RPN的转换。以如

下中缀表达

式为例（习题

[4-9]）：

(

0 ! + 1

) * 2 ^

( 3 ! +

4 ) - (

5 ! - 67

- ( 8 +

9 ) )

首先，假设在

事先并未就

运算符之间

的优先级做

过任何约定

。于是，我们不

得不通过增

添足

够多的

括号，以如下

方式，显式地

指定该表达

式的运算次

序：

( ( (

( 0 ) !

+ 1 ) *

( 2 ^ (

( 3 ) !

+ 4 ) )

) - ( (

( 5 ) !

- 67 ) -

( 8 + 9

) ) )

然后，将各

运算符后移

，使之紧邻于

其对应的右

括号的右侧

：

( ( ( (

0 ) ! 1

) + ( 2

( ( 3 )

! 4 ) +

) ^ ) *

( ( ( 5

) ! 67 )

- ( 8 9

) + ) -

) -

最后抹去所

有括号：

0 ! 1 +

2 3 ! 4

+ ^ * 5

! 67 - 8

9 + - -

稍事

整理，即得到

对应的RPN表达

式：

0 ! 1

+ 2 3 !

4 + ^ *

5 ! 67 -

8 9 + -

-

可见，操作

数之间的相

对次序，在转

换前后保持

不变；而运算

符在RPN中所处

的位置，恰好

就是其对应

的操作数均

已就绪且该

运算可以执

行的位置。

 自

动转换

实际

上，95页代码4.7中

evaluate()算法在对表

达式求值的

同时，也顺便

完成了从常

规表

达式到

RPN表达式的转

换。在求值过

程中，该算法

借助append()函数（习

题[4-8]）将各操作

数

和运算符

适时地追加

至串rpn的末尾

，直至得到完

整的RPN表达式

（习题[4-9]）。

这里采

用的规则十

分简明：凡遇

到操作数，即

追加至rpn；而运

算符只有在

从栈中弹出

并执

行时，才

被追加。这一

过程，与上述

手工转换的

方法完全等

效，其正确性

也因此得以

确立。

将RPN自动

转换过程与

RPN求值过程做

一对照，即不

难看出，后者

只不过是前

者的忠实再

现。

第4章 栈不

队列

§4.4 *试探回

溯法

99

§4.4

*试探回

溯法

4.4.1 试探与

回溯



忒修斯

的法宝

古希

腊神话中半

人半牛的怪

物弥诺陶洛

斯（Minotaur），藏身于一

个精心设计

、结构极其

复

杂的迷宫之

中。因此，找到

并消灭它绝

非易事，而此

后如何顺利

返回而不致

困死更是一

个难题。

不过

，在公主阿里

阿德涅（Ariadne）的帮

助下，英雄忒

修斯（Theseus）还是想

出了个好办

法，

他最终消

灭了怪物，并

带着公主轻

松地走出迷

宫。

实际上，忒

修斯所使用

的法宝，只不

过是一团普

通的线绳。他

将线绳的一

端系在迷宫

的入口

处，而

在此后不断

检查各个角

落的过程中

，线团始终握

在他的手中

。线团或收或

放，跟随着忒

修

斯穿梭于

蜿蜒曲折的

迷宫之中，确

保他不致迷

路。

忒修斯的

高招，与现代

计算机中求

解很多问题

的算法异曲

同工。事实上

，很多应用问

题的解，

在形

式上都可看

作若干元素

按特定次序

构成的一个

序列。以经典

的旅行商问

题（traveling 

salesman

problem, TSP）为例，其目

标是计算出

由给定的n个

城市构成的

一个序列，使

得按此

序列

对这些城市

的环游成本

（比如机票价

格）最低。尽管

此类问题本

身的描述并

不复杂，但遗

憾

的是，由于

所涉及元素

（比如城市）的

每一排列都

是一个候选

解，它们往往

构成一个极

大的搜索

空

间。通常，其搜

索空间的规

模与全排列

总数大体相

当，为n! = O(nn

)。因此若

采用蛮力策

略，

逐一生成

可能的候选

解并检查其

是否合理，则

必然无法将

运行时间控

制在多项式

的范围以内

。

 剪枝

为此，必

须基于对应

用问题的深

刻理解，利用

问题本身具

有的某些规

律尽可能多

、尽可能早

地

排除搜索空

间中的候选

解。其中一种

重要的技巧

就是，根据候

选解的某些

局部特征，以

候选解

子集

为单位批量

地排除。通常

如图4.7所示，搜

索空间多呈

树状结构，而

被排除的候

选解往往隶

属于同一分

支，故这一技

巧也可以形

象地称作剪

枝（pruning）。

与之对应

的算法多呈

现为如下模

式。从零开始

，尝试

逐步增

加候选解的

长度。更准确

地，这一过程

是在成批地

考查具有特

定前缀的所

有候选解。这

种从长度上

逐步向目

标

解靠近的尝

试，称作试探

（probing）。作为解的局

部特

征，特征

前缀在试探

的过程中一

旦被发现与

目标解不合

，

则收缩到此

前一步的长

度，然后继续

试探下一可

能的组合。

特

征

前 缀 长 度

缩

减 的 这 类

操

作 ， 称 作

回

溯

（backtracking），其效果等

同于剪枝。如

此，只要目标

解的确存在

就迟早会被

发现，而且只

要剪枝所依

据的特征

设

计得当，计算

的效率就会

大大提高。

图

4.7

通过剪枆排

除候选解子

集

 线绳与粉

笔

回到开头

的传说故事

。不难看出，忒

修斯藉以探

索迷宫的正

是试探回溯

法。当然，这一

方法

的真正

兑现还依赖

于有形的物

质基础忒修

斯的线绳。忒

修斯之所以

能够在迷宫

中有条不紊

地

进行搜索

，首先是得益

于这团收放

自如的线绳

。这一点不难

理解，所有算

法的实现都

必须建立在

特定的数据

结构之上。

§4.4 *试

探回溯法

第

4章 栈不队列

100

以下两个实

例，将介绍如

何借助适当

的数据结构

以高效地实

现试探回溯

策略。我们将

看到，

栈结构

在此过程中

所扮演的正

是忒修斯手

中线绳的角

色。当然，这里

还需解决故

事中隐含的

另一

技术难

点：如何保证

搜索过的部

分不被重复

搜索。办法之

一就是，在剪

枝的位置留

下某种标记

。

同样地，这类

标记也需兑

现为具体的

数据结构。倘

若建议忒修

斯在回溯时

不妨用粉笔

就地做个记

号，那么我们

的算法也应

配有以数据

结构形式实

现的“粉笔”。

4.4.2 八

皇后

 问题描

述

图4.8 (a)皇后癿

控刢范围；(b)8皇

后问题癿一

个解

如图4.8(a)，国

际象棋中皇

后的势力范

围覆

盖其所

在的水平线

、垂直线以及

两条对角线

。现考

查如下

问题：在nn的棋

盘上放置n个

皇后，如何使

得她们彼此

互不攻击此

时称她们构

成一个可

行

的棋局。对于

任何整数n

 4，这

就是n皇后问

题。

由鸽巢原

理可知，在n行

n列的棋盘上

至多只能

放

置n个皇后。反

之，n个皇后在

nn棋盘上的可

行

棋局通常

也存在，比如

图4.8(b)即为在88棋

盘

上，由8个皇

后构成的一

个可行棋局

。

 皇后

皇后是

组成棋局和

最终解的基

本单元，故可

如代码4.8所示

实现对应的

Queen类。

1 struct Queen

{ //皁后类

2 int

x, y; //皁

后在棋盘上

癿位置坐标

3 Queen

( int xx =

0, int yy =

0 ) : x

( xx ), y

( yy ) {};

4 bool operator== (

Queen const& q )

const { //重载刞等操

作符，以检测

丌同皁后乀

间可能癿冲

突

5

return ( x ==

q.x ) //行冲突（返

一情冴其实

幵丌会収生

，可省略）

6

|| ( y ==

q.y ) //列冲

突

7

|| ( x +

y == q.x +

q.y ) //沿正对角

线冲突

8

|| ( x -

y == q.x -

q.y ); //沿反

对角线冲突

9 }

10 bool operator!= (

Queen const& q )

const { return !

( *this == q

); } //重载丌等操

作符

11

};

代码4.8 皇

后类

可见，每

个皇后对象

均由其在棋

盘上的位置

坐标确定。此

外，这里还通

过重载判等

操作符，

实现

了对皇后位

置是否相互

冲突的便捷

判断。具体地

，这里按照以

上棋规，将同

行、同列或同

对

角线的任

意两个皇后

视作“相等”，于

是两个皇后

相互冲突当

且仅当二者

被判作“相等

”。

 算法实现

基

于试探回溯

策略，可如代

码4.9所示，实现

通用的N皇后

算法。

既然每

行能且仅能

放置一个皇

后，故不妨首

先将各皇后

分配至每一

行。然后，从空

棋盘开始，

逐

个尝试着将

她们放置到

无冲突的某

列。每放置好

一个皇后，才

继续试探下

一个。若当前

皇后在

任何

列都会造成

冲突，则后续

皇后的试探

都必将是徒

劳的，故此时

应该回溯到

上一皇后。

第

4章 栈不队列

§4.4 *试探回溯法

101

1

void placeQueens ( int

N ) { //N皁后算法（迭

代版）：采用试

探/回溯癿策

略，倚劣栈记

弽查找癿结

枅

2 Stack<Queen> solu; //存放（部分

）解癿栈

3 Queen q (

0, 0 ); //从原

点位置出収

4

do { //反复试探、回

溯

5

if ( N <=

solu.size() || N <=

q.y ) { //若已出界

，则

6 q = solu.pop();

q.y++; //回溯一行

，幵继续试探

下一列

7 }

else { //否则

，试探下一行

8 while

( ( q.y <

N ) && (

0 <= solu.find (

q ) ) )

//通过不已有

皁后癿比对

9 { q.y++; nCheck++;

} //尝试找刡可

摆放下一皁

后癿列

10 if

( N > q.y

) { //若存

在可摆放癿

列，则

11

solu.push ( q );

//摆上弼

前皁后，幵

12 if (

N <= solu.size() )

nSolu++; //若

部分解已成

为全尿解，则

通过全尿发

量nSolu计数

13 q.x++;

q.y = 0; //转入

下一行，从第

0列开始，试探

下一皁后

14 }

15 }

16 } while (

( 0 < q.x

) || ( q.y

< N ) );

//所

有分支均已

戒穷丼戒剪

枆乀后，算法

结束

17 }

代码4.9

N皇

后算法

这里

借助栈solu来动

态地记录各

皇后的列号

。当该栈的规

模增至N时，即

得到全局解

。该栈

即可依

次给出各皇

后在可行棋

局中所处的

位置。



实例

图

4.9给出了利用

以上算法，得

到四皇后问

题第一个解

的完整过程

。

图4.9 四皇后问

题求解过秳

（棋盘右侧为

记彔解癿栈

solu）

首先试探第

一行皇后，如

图(a)所示将其

暂置于第0列

，同时列号入

栈。接下来试

探再第二

行

皇后，如图(b)所

示在排除前

两列后，将其

暂置于第2列

，同时列号入

栈。然而此后

试探第三

行

皇后时，如图

(c)所示发现所

有列均有冲

突。于是回溯

到第二行，并

如图(d)所示将

第二行皇

后

调整到第3列

，同时更新栈

顶列号。后续

各步原理相

同，直至图(l)栈

满时得到一

个全局解。

如

此不断地试

探和回溯，即

可得到所有

可行棋局。可

见，通过剪枝

我们对原规

模为4! = 24

的搜索

空间实现了

有效的筛选

。随着问题规

模的增加，这

一技巧的优

化效果将更

为明显。

§4.4 *试探

回溯法 第4章

栈不队列

102

4.4.3 迷

宫寻径

 问题

描述

路径规

划是人工智

能的基本问

题之一，要求

依照约定的

行进规则，在

具有特定几

何结构的空

间区域内，找

到从起点到

终点的一条

通路。以下考

查该问题的

一个简化版

本：空间区域

限定为由

n  n个

方格组成的

迷宫，除了四

周的围墙，还

有分布其间

的若干障碍

物；只能水平

或垂直移动

。

我们的任务

是，在任意指

定的起始格

点与目标格

点之间，找出

一条通路（如

果的确存在

）。

 迷宫格点

格

点是迷宫的

基本组成单

位，故首先需

要实现Cell类如

代码4.10所示。

1 typedef enum {

AVAILABLE, ROUTE, BACKTRACKED, WALL

} Status; //迷

宫单元状态

2 //原始可用癿

、在弼前路径

上癿、所有斱

向均尝试失

败后回溯过

癿、丌可使用

癿（墙）

3

4 typedef enum

{ UNKNOWN, EAST, SOUTH,

WEST, NORTH, NO_WAY }

ESWN; //单元癿

相对邻接斱

向

5 //未定、东、南

、西、北、无路可

通

6

7 inline ESWN

nextESWN ( ESWN eswn

) { return ESWN

( eswn + 1

); } //依次转至

下一邻接斱

向

8

9 struct Cell {

//迷宫格点

10 int x, y;

Status status; //x坐标、y坐标、类

型

11

ESWN incoming, outgoing; //迕入、走出

斱向

12 };

13

14

#define LABY_MAX 24 //最大迷

宫尺寸

15 Cell laby[LABY_MAX][LABY_MAX]; //迷宫

代码4.10

迷宫栺

点类

可见，除

了记录其位

置坐标外，格

点还需记录

其所处的状

态。共有四种

可能的状态

：原始可

用的

（AVAILABLE）、在当前路径

上的（ROUTE）、所有方

向均尝试失

败后回溯过

的（BACKTRACKED）、

不可穿越

的（WALL）。属于当前

路径的格点

，还需记录其

前驱和后继

格点的方向

。既然只有上

、

下、左、右四个

连通方向，故

以EAST、SOUTH、WEST和NORTH区分。特

别地，因尚未

搜索到而仍

处于初始AVAILABLE状

态的格点，邻

格的方向都

是未知的（UNKNOWN）；经

过回溯后处

于

BACKTRACKED状态的格

点，与邻格之

间的连通关

系均已关闭

，故标记为NO_WAY。

 邻

格查询

在路

径试探过程

中需反复确

定当前位置

的相邻格点

，可如代码4.11所

示实现查询

功能。

1 inline Cell*

neighbor ( Cell* cell

) { //查诟弼

前位置癿相

邻格点

2

switch ( cell->outgoing )

{

3 case EAST

: return cell +

LABY_MAX; //向东

4 case SOUTH

: return cell +

1; //向南

5 case

WEST : return cell

- LABY_MAX; //向西

6

case NORTH : return

cell - 1; //向

北

第4章 栈不

队列 §4.4 *试探回

溯法

103

7 default :

exit ( -1 );

8 }

9 }

代码4.11 查

询相邻栺点

 邻格转入

在

确认某一相

邻格点可用

之后，算法将

朝对应的方

向向前试探

一步，同时路

径延长一个

单元。

为此，需

如代码4.12所示

实现相应的

格点转入功

能。

1 inline Cell*

advance ( Cell* cell

) { //从弼前位

置转入相邻

格点

2

Cell* next;

3 switch

( cell->outgoing ) {

4 case EAST: next

= cell + LABY_MAX;

next->incoming = WEST; break;

//向东

5 case SOUTH:

next = cell +

1; next->incoming = NORTH;

break; //向

南

6 case

WEST: next = cell

- LABY_MAX; next->incoming =

EAST; break; //向西

7

case NORTH: next =

cell - 1; next->incoming

= SOUTH; break; //向北

8

default : exit (

-1 );

9 }

10 return next;

11

}

代码4.12 转入相

邻栺点



算法

实现

在以上

功能的基础

上，可基于试

探回溯策略

实现寻径算

法如代码4.13所

示。

1 //

迷宫寺径

算法：在格单

元s至t乀间觃

划一条通路

（如枅癿确存

在）

2 bool labyrinth

( Cell Laby[LABY_MAX][LABY_MAX], Cell*

s, Cell* t )

{

3 if (

( AVAILABLE != s->status

) || ( AVAILABLE

!= t->status ) )

return false; //退化情冴

4 Stack<Cell*>

path; //用栈记弽通

路（Theseus癿线绳）

5 s->incoming

= UNKNOWN; s->status =

ROUTE; path.push ( s

); //起

点

6 do

{ //从起点出

収丌断试探

、回溯，直刡抵

达终点，戒者

穷尽所有可

能

7 Cell*

c = path.top(); //检查弼前

位置（栈顶）

8 if ( c

== t ) return

true; //若

已抵达终点

，则找刡了一

条通路；否则

，沿尚未试探

癿斱向继续

试探

9 while

( NO_WAY > (

c->outgoing = nextESWN (

c->outgoing ) ) )

//逐一检

查所有斱向

10 if ( AVAILABLE

== neighbor ( c

)->status ) break; //试图找刡尚

未试探癿斱

向

11 if ( NO_WAY

<= c->outgoing ) //若所有斱

向都已尝试

过

12 { c->status =

BACKTRACKED; c = path.pop();

}//则向后回

溯一步

13 else //否则

，向前试探一

步

14 { path.push (

c = advance (

c ) ); c->outgoing

= UNKNOWN; c->status =

ROUTE; }

15 }

while ( !path.empty() );

16 return false;

17

}

代码4.13 迷宫

寻径

§4.5

队列 第

4章 栈不队列

104

该问题的搜

索过程中，局

部解是一条

源自起始格

点的路径，它

随着试探、回

溯相应地伸

长、

缩短。因此

，这里借助栈

path按次序记录

组成当前路

径的所有格

点，并动态地

随着试探、回

溯

做入栈、出

栈操作。路径

的起始格点

、当前的末端

格点分别对

应于path的栈底

和栈顶，当后

者

抵达目标

格点时搜索

成功，此时path所

对应的路径

即可作为全

局解返回。



实

例

图4.10给出了

以上迷宫寻

径算法的一

次运行实例

。

图4.10 迷宫寻径

算法实例

左

侧为随机生

成的1313迷宫。算

法启动时，其

中格点分为

可用（AVAILABLE，白色）与

障

碍（WALL，黑色）两

种状态。在前

一类中，随机

指定了起始

格点（+）和目标

格点（



)。中图为

算法

执行过程的

某一时刻，可

见原先为可

用状态的一

些格点已经

转换为新的

状态：转入ROUTE状

态的格点，依

次联接构成

一条（尚未完

成的）通路；曾

参与构成通

路但后因所

有前进方向

均已尝

试完

毕而回溯的

格点，则进而

从ROUTE转入TRIED状态

（以圆圈注明

）。



正确性

该算

法会尝试当

前格点的所

有相邻格点

，因此通过数

学归纳可知

，若在找到全

局解后依然

继

续查找，则

该算法可以

抵达与起始

格点连通的

所有格点。因

此，只要目标

格点与起始

格点的确相

互连通，则这

一算法必将

如右图所示

找出一条联

接于二者之

间的通路。

从

算法的中间

过程及最终

结果都可清

晰地看出，这

里用以记录

通路的栈结

构的确相当

于忒修

斯手

中的线绳，它

确保了算法

可沿着正确

地方向回溯

。另外，这里给

所有回溯格

点所做的状

态标

记则等

效于用粉笔

做的记号，正

是这些标记

确保了格点

不致被重复

搜索，从而有

效地避免了

沿环

路的死

循环现象。



复

杂度

算法的

每一步迭代

仅需常数时

间，故总体时

间复杂度线

性正比于试

探、回溯操作

的总数。由

于

每个格点至

多参与试探

和回溯各一

次，故亦可度

量为所有被

访问过的格

点总数在图

4.10

中，也就是最

终路径的总

长度再加上

圆圈标记的

数目。

§4.5 队列

4.5.1 概

述

 入队与出

队

与栈一样

，队列（queue）也是存

放数据对象

的一种容器

，其中的数据

对象也按线

性的逻辑

第

4章

栈不队列

§4.5 队列

105

次序排

列。队列结构

同样支持对

象的插入和

删除，但两种

操作的范围

分别被限制

于队列的两

端

若约定新

对象只能从

某一端插入

其中，则只能

从另一端删

除已有的元

素。允许取出

元素的一

端

称作队头（front），而

允许插入元

素的另一端

称作队尾（rear）。

以

如图4.11所示顺

序盛放羽毛

球的球桶为

例。通常，我们

总是从球托

所指的一端

将球取出，

而

从另一端把

球纳入桶中

。因此如果将

球托所指的

一端理解为

队头，另一端

理解为队尾

，则桶中

的羽

毛球即构成

一个队列，其

中每只球都

属于该队列

的一个元素

。

图4.11 在球桶中

顸序排列癿

一组羽毖球

可规作一个

队列 图4.12

队列

操作

一般地

如图4.12所示，元

素的插入与

删除也是修

改队列结构

的两种主要

方式，站在被

操作

对象的

角度，分别称

作入队（enqueue）和出

队（dequeue）操作。



先进

先出

由以上

的约定和限

制不难看出

，与栈结构恰

好相反，队列

中各对象的

操作次序遵

循所谓先进

先出（first-in-first-out, FIFO）的规律

：更早（晚）出队

的元素应为

更早（晚）入队

者，

反之，更早

（晚）入队者应

更早（晚）出队

。

4.5.2 ADT接口

作为一

种抽象数据

类型，队列结

构必须支持

以下操作接

口。

表4.4

队列ADT支

持癿操作接

口

操 作 功

能

size() 报告队列癿

觃模（元素总

数）

empty() 刞断队列

是否为空

enqueue(e) 将

e揑入队尾

dequeue() 初

除队首对象

front()

引用队首对

象

4.5.3 操作实例

按照表4.4定义

的ADT接口，表4.5给

出了一个队

列从被创建

开始，经过一

系列操作的

过程。

表4.5

队列

操作实例（元

素均为整型

）

操作 输出 队

列（右侧为队

头）

操作 输出

队列（右侧为

队头）

§4.5 队列

第

4章 栈不队列

106

操作 输出

队

列（右侧为队

头） 操作 输出

队列（右侧为

队头）

Queue()

enqueue(11) 11 3 7

3

empty() true size()

4 11 3 7

3

enqueue(5) 5 enqueue(6)

6 11 7 3

enqueue(3) 3 5 empty()

false 6 11 3

7 3

dequeue() 5

3 enqueue(7) 6 11

3 7 3

enqueue(7)

7 3 dequeue() 3

7 6 11 3

7

enqueue(3) 3 7

3 dequeue() 7 7

6 11 3

front()

3 3 7 3

front() 3 7 6

11 3

empty() false

3 7 3 size()

4 7 6 11

3

4.5.4 Queue模板类

既然队列也

可视作序列

的特例，故只

要将队列作

为列表的派

生类，即可利

用C++的继承机

制，

基于3.2.2节已

实现的列表

模板类，实现

队列结构。同

样地，也需要

按照队列的

习惯对各相

关的

接口重

新命名。按照

表4.4所列的ADT接

口，可描述并

实现Queue模板类

如下。

1 #include "../List/List.h"

//以List为基

类

2 template <typename

T> class Queue: public

List<T> { //队列模板

类（继承List原有

接口）

3

public: //size()、empty()以及其

它开放接口

均可直接沿

用

4 void

enqueue ( T const&

e ) { insertAsLast

( e ); }

//入队：尾部

揑入

5 T dequeue()

{ return remove (

first() ); } //出队：首

部初除

6 T& front() {

return first()->data; } //队首

7

};

代码4.14 Queue模板类

由代码4.14可见

，队列的enqueue()操作

等效于将新

元素作为列

表的末元素

插入，dequeue()

操作则

等效于删除

列表的首元

素，front()操作可直

接返回对列

表首元素的

引用。而size()及

empty()等

接口，均可直

接沿用基类

的同名接口

。

这里插入和

删除操作的

位置分别限

制于列表的

末端和首端

，故由3.3.5节的分

析结论可知

，

队列结构以

上接口的时

间复杂度均

为常数。

套用

以上思路，也

可直接基于

2.2.3节的Vector模板类

派生出Stack类（习

题[4-2]）。

第4章 栈不

队列 §4.6 队列应

用

107

§4.6 队列应用

4.6.1 循环分配器

为在客户（client）群

体中共享的

某一资源（比

如多个应用

程序共享同

一CPU），一套公平

且高效的分

配规则必不

可少，而队列

结构则非常

适于定义和

实现这样的

一套分配规

则①。

具体地，可

以借助队列

Q实现一个资

源循环分配

器，其总体流

程大致如算

法4.2所示。

RoundRobin { //循环

分配器

Queue Q(clients); //参不

资源分配癿

所有客户组

成队列Q

while (!ServiceClosed()) { //在服

务兲闭乀前

，反复地

e = Q.dequeue(); //队首

癿客户出队

，幵

serve(e); //接叐服务

，然后

 Q.enqueue(e);

//重新入

队

 }

}

算法4.2 刟用

队列结极实

现癿循环分

配器

在以上

所谓轮值（round robin）算

法中，首先令

所有参与资

源分配的客

户组成一个

队列Q。

接下来

是一个反复

轮回式的调

度过程：取出

当前位于队

头的客户，将

资源交予该

客户使用；在

经

过固定的

时间之后，回

收资源，并令

该客户重新

入队。得益于

队列“先进先

出”的特性，如

此既

可在所

有客户之间

达成一种均

衡的公平，也

可使得资源

得以充分利

用。

这里，每位

客户持续占

用资源的时

间，对该算法

的成败至关

重要。一方面

，为保证响应

速度，

这一时

间值通常都

不能过大。另

一方面，因占

有权的切换

也需要耗费

一定的时间

，故若该时间

值

取得过小

，切换过于频

繁，又会造成

整体效率的

下降。因此，往

往需要通过

实测确定最

佳值。

反过来

，在单一客户

使用多个资

源的场合，队

列也可用以

保证资源的

均衡使用，提

高整体使

用

效率。针式打

印机配置的

色带，即是这

样的一个实

例，环形②色带

收纳于两端

开口的色带

盒内。

在打印

过程中，从一

端不断卷出

的色带，在经

过打印头之

后，又从另一

端重新卷入

盒中，并如此

往复。可见，此

处色带盒的

功能等效于

一个队列，色

带的各部分

按照“先进先

出”的原则被

均衡

地使用

，整体使用寿

命因而得以

延长。

4.6.2 银行服

务模拟

以下

以银行这一

典型场景为

例，介绍如何

利用队列结

构实现顾客

服务的调度

与优化。

通常

，银行都设有

多个窗口，顾

客按到达的

次序分别在

各窗口排队

等待办理业

务。为此，可

首

先定义顾客

类Customer如下，以记

录顾客所属

的队列及其

所办业务的

服务时长。

1

struct Customer { int

window; unsigned int time;

}; //顼

客类：所属窗

口（队列）、服务

时长

代码4.15 顺

客对象

① 更复

杂条件和需

求下癿调度

分配算法，可

参考排队讳

（queuing theory）癿相兲资料

②

严格地说，色

带是个Möbius环，如

此可迕一步

保证其“两”面

都能被均衡

使用

§4.6 队列应

用 第4章

栈不

队列

108

顾客在

银行中接受

服务的整个

过程，可由如

代码4.16所示的

simulate()函数模拟。

1

void simulate ( int

nWin, int servTime )

{ //按

指定窗口数

、服务总时间

模拟银行业

务

2 Queue<Customer>*

windows = new Queue<Customer>[nWin];

//为殏一窗

口创建一个

队列

3 for (

int now = 0;

now < servTime; now++

) { //在下班

乀前，殏隑一

个单位时间

4 if

( rand() % (

1 + nWin )

) { //新顼客以nWin/(nWin +

1)癿

概率刡达

5 Customer c

; c.time = 1

+ rand() % 98;

//新

顼客刡达，服

务时长随机

确定

6 c.window =

bestWindow ( windows, nWin

); //找出最

佳（最短）癿服

务窗口

7 windows[c.window].enqueue

( c ); //新顼

客加入对应

癿队列

8 }

9 for

( int i =

0; i < nWin;

i++ ) //分删

检查

10

if ( !windows[i].empty() )

//各非空

队列

11 if (

-- windows[i].front().time <= 0

) //队首顼

客癿服务时

长减少一个

单位

12 windows[i].dequeue();

//服务完

毕癿顼客出

列，由后继顼

客接替

13 } //for

14 delete [] windows;

//释放

所有队列（此

前，~List()会自劢清

空队列）

15 }

代码

4.16

银行服务模

拟

这里，首先

根据银行所

设窗口的数

量相应地建

立多个队列

。以下以单位

时间为间隔

反复迭代，

直

至下班。每一

时刻都有一

位顾客按一

定的概率抵

达，随机确定

所办业务服

务时长之后

，归入某

一“最

优”队列。每经

单位时间，各

队列最靠前

顾客（如果有

的话）的待服

务时长均相

应减少一

个

单位。若时长

归零，则意味

着该顾客的

业务已办理

完毕，故应退

出队列并由

后一位顾客

（如果

有的话

）接替。可见，顾

客归入队列

和退出队列

的事件可分

别由enqueue()和dequeue()操作

模

拟，查询并

修改队首顾

客时长的事

件则可由front()操

作模拟。

1

int bestWindow ( Queue<Customer>

windows[], int nWin )

{ //为新

刡顼客确定

最佳队列

2 int

minSize = windows[0].size(), optiWin

= 0; //最

优队列（窗口

）

3

for ( int i

= 1; i <

nWin; i++ ) //在所有窗口

中

4 if ( minSize

> windows[i].size() ) //挑选出

5 { minSize =

windows[i].size(); optiWin = i;

} //队

列最短者

6 return

optiWin; //迒

回

7 }

代码4.17 查找

最短队列

为

更好地为新

到顾客确定

一个队列，这

里采用了“最

短优先”的原

则。如代码4.17所

示，

为此只需

遍历所有的

队列并通过

size()接口比较其

规模，即可找

到其中的最

短者。

第5章

二

叉树

§5.1 二叉树

及其表示

第

5章 二叉树

110

通

过前面的章

节，我们已经

了解了一些

基本的数据

结构。根据其

实现方式，这

些数据结构

大

致可以分

为两种类型

：基于数组的

实现与基于

链表的实现

。正如我们已

经看到的，就

其效率而言

，

二者各有长

短。具体来说

，前一实现方

式允许我们

通过下标或

秩，在常数的

时间内找到

目标对象；

然

而，一旦需要

对这类结构

进行修改，那

么无论是插

入还是删除

，都需要耗费

线性的时间

。反过

来，后一

实现方式允

许我们借助

引用或位置

对象，在常数

的时间内插

入或删除元

素；但是为了

找

出居于特

定次序的元

素，我们却不

得不花费线

性的时间，对

整个结构进

行遍历查找

。能否将这两

类结构的优

点结合起来

，并回避其不

足呢？本章所

讨论的树结

构，将正面回

答这一问题

。

在此前介绍

的这些结构

中，元素之间

都存在一个

自然的线性

次序，故它们

都属于所谓

的线性

结构

（linear structure）。树则不然，其

中的元素之

间并不存在

天然的直接

后继或直接

前驱

关系。不

过，正如我们

马上就要看

到的，只要附

加某种约束

（比如遍历），也

可以在树中

的元素

之间

确定某种线

性次序，因此

树属于半线

性结构（semi-linear structure）。

无论

如何，随着从

线性结构转

入树结构，我

们的思维方

式也将有个

飞跃；相应地

，算法设计

的

策略与模式

也会因此有

所变化，许多

基本的算法

也将得以更

加高效地实

现。以第7章和

第8章将

要介

绍的平衡二

叉搜索树为

例，若其中包

含n个元素，则

每次查找、更

新、插入或删

除操作都可

在O(logn)时间内完

成相对于线

性结构，几乎

提高了一个

线性因子（习

题[1-9]）。

树结构有

着不计其数

的变种，在算

法理论以及

实际应用中

，它们都扮演

着最为关键

的角色。

之所

以如此，是因

得益于其独

特而又普适

的逻辑结构

。树是一种分

层结构，而层

次化这一特

征几

乎蕴含

于所有事物

及其联系当

中，成为其本

质属性之一

。从文件系统

、互联网域名

系统和数据

库

系统，一直

到地球生态

系统乃至人

类社会系统

，层次化特征

以及层次结

构均无所不

在。

有趣的是

，作为树的特

例，二叉树实

际上并不失

其一般性。本

章将指出，无

论就逻辑结

构或

算法功

能而言，任何

有根有序的

多叉树，都可

等价地转化

并实现为二

叉树。因此，本

章讲解的重

点也将放在

二叉树上。我

们将以通讯

编码算法的

实现这一应

用实例作为

线索贯穿全

章。

§5.1 二叉树及

其表示

5.1.1 树

 有

根树

从图论

的角度看，树

等价于连通

无环图。因此

与一般的图

相同，树也由

一组顶点（vertex）

以

及联接与其

间的若干条

边（edge）组成。在计

算机科学中

，往往还会在

此基础上，再

指定某

一特

定顶点，并称

之为根（root）。在指

定根节点之

后，我们也称

之为有根树

（rooted tree）。

此时，从程序

实现的角度

，我们也更多

地将顶点称

作节点（node）。

第5章

二叉树

§5.1 二叉

树及其表示

111

 深度与层次

由树的连通

性，每一节点

与根之间都

有一条路径

相联；而根据

树的无环性

，由根通往每

个节

点的路

径必然唯一

。因此如图5.1所

示，沿每个节

点v到根r的唯

一通路所经

过边的数目

，称作v

的深度

（depth），记作depth(v)。依据深

度排序，可对

所有节点做

分层归类。特

别地，约定根

节点的深度

depth(r) = 0，故属于第0层

。

 祖先、后代与

子树

图5.1 有根

树癿逡辑结

极

任一节点

v在通往树根

沿途所经过

的每个节点

都是

其祖先

（ancestor），v是它们的后

代（descendant）。

特别地，v的

祖先/后代包

括其本身，而

v本身以外的

祖先

/后代称

作真祖先（proper

ancestor）/真

后代（proper 

descendant）。

节点v历

代祖先的层

次，自下而上

以1为单位逐

层递

减；在每

一层次上，v的

祖先至多一

个。特别地，若

节点u

是v的祖

先且恰好比

v高出一层，则

称u是v的父亲

（parent），v是u的孩子（child）。

v的

孩子总数，称

作其度数或

度（degree），记作

deg(v)。无孩

子的节点称

作叶节点（leaf），包

括根在

内的

其余节点皆

为内部节点

（internal node）。

v所有的后代

及其之间的

联边称作子

树（subtree），记作subtree(v)。在不

致歧义时，我

们往往不再

严格区分节

点（v）及以之为

根的子树（subtree(v)）。



高

度

树T中所有

节点深度的

最大值称作

该树的高度

（height），记作height(T)。

不难理

解，树的高度

总是由其中

某一叶节点

的深度确定

的。特别地，本

书约定，仅含

单个节

点的

树高度为0，空

树高度为-1。

推

而广之，任一

节点v所对应

子树subtree(v)的高度

，亦称作该节

点的高度，记

作

height(v)。特别地，全

树的高度亦

即其根节点

r的高度，height(T) = height(r)。

5.1.2 二叉

树

图5.2 事叉树

：(a)逡辑结极；(b)实

例

如图5.2所示

，二叉树（binary tree）

中每

个节点的度

数均不超过

2。

因此在二叉

树中，同一父

节点的孩子

都可

以左、右

相互区分此

时，亦称作有

序二叉

树（ordered binary tree）。本

书所提到的

二叉树，默认

地都是有序

的。

特别地，不

含一度节点

的二叉树称

作真二

叉树

（proper binary tree）（习题[5-2]）。

§5.1 二叉树

及其表示 第

5章 二叉树

112

5.1.3 多

叉树

一般地

，树中各节点

的孩子数目

并不确定。每

个节点的孩

子均不超过

k个的有根树

，称作k

叉树（k-ary tree）。本

节将就此类

树结构的表

示与实现方

法做一简要

介绍。

 父节点

由如图5.3(a)实例

不难看出，在

多叉树中，根

节点以外的

任一节点有

且仅有一个

父节点。

因此

可如图5.3(b)所示

，将各节点组

织

为向量或

列表，其中每

个元素除保

存节点本

身

的信息（data）外，还

需要保存父

节点

（parent）的秩或

位置。可为树

根指定一个

虚构的父节

点-1或NULL，以便统

一判断。

如此

，所有向量或

列表所占的

空间总量

为

O(n)，线性正比于

节点总数n。时

间方面，

仅需

常数时间，即

可确定任一

节点的父节

点；

但反过来

，孩子节点的

查找却不得

不花费

O(n)时间

访遍所有节

点。 图5.3 多叉树

癿“父节点”表

示法

图5.4

多叉

树癿“孩子节

点”表示法

图

5.5 多叉树癿“父

节点 +

孩子节

点”表示法

第

5章 二叉树 §5.1

二

叉树及其表

示

113

 孩子节点

若注重孩子

节点的快速

定位，可如图

5.4所示，令各节

点将其所有

的孩子组织

为一个向量

或

列表。如此

，对于拥有r个

孩子的节点

，可在O(r + 1)时间内

列举出其所

有的孩子。



父

节点 + 孩子节

点

以上父节

点表示法和

孩子节点表

示法各有所

长，但也各有

所短。为综合

二者的优势

，消除缺

点，可

如图5.5所示令

各节点既记

录父节点，同

时也维护一

个序列以保

存所有孩子

。

尽管如此可

以高效地兼

顾对父节点

和孩子的定

位，但在节点

插入与删除

操作频繁的

场合，为

动态

地维护和更

新树的拓扑

结构，不得不

反复地遍历

和调整一些

节点所对应

的孩子序列

。然而，

向量和

列表等线性

结构的此类

操作都需耗

费大量时间

，势必影响到

整体的效率

。

 有序多叉树

= 二叉树

解决

上述难题的

方法之一，就

是采用支持

高效动态调

整的二叉树

结构。为此，必

须首先建立

起从多叉树

到二叉树的

某种转换关

系，并使得在

此转换的意

义下，任一多

叉树都等价

于某棵二叉

树。当然，为了

保证作为多

叉树特例的

二叉树有足

够的能力表

示任何一棵

多叉树，我们

只需给多

叉

树增加一项

约束条件同

一节点的所

有孩子之间

必须具有某

一线性次序

。

仿照有序二

叉树的定义

，凡符合这一

条件的多叉

树也称作有

序树（ordered tree）。幸运

的

是，这一附加

条件在实际

应用问题中

往往自然满

足。以互联网

域名系统所

对应的多叉

树为例，

其中

同一域名下

的分支通常

即按照字典

序排列。

 长子

+ 兄弟

由图5.6(a)的

实例可见，有

序多叉树中

任一非叶节

点都有唯一

的“长子”，而且

从该“长

子”出

发，可按照预

先约定或指

定的次序遍

历所有孩子

节点。因此可

如图(b)所示，为

每个节点

设

置两个指针

，分别指向其

“长子”和下一

“兄弟”。

图5.6

多叉

树癿“长子 + 兄

弟”表示法（(b)中

长子和兄弟

指针，分删以

垂直实线和

水平虚线示

意）

现在，若将

这两个指针

分别与二叉

树节点的左

、右孩子指针

统一对应起

来，则可进一

步地将

原有

序多叉树转

换为如图(c)所

示的常规二

叉树。

在这里

，一个饶有趣

味的现象出

现了：尽管二

叉树只是多

叉树的一个

子集，但其对

应用问题

的

描述与刻画

能力绝不低

于后者。实际

上以下我们

还将进一步

发现，即便是

就计算效率

而言，二

叉树

也并不逊色

于一般意义

上的树。反过

来，得益于其

定义的简洁

性以及结构

的规范性，二

叉树

所支撑

的算法往往

可以更好地

得到描述，更

加简捷地得

到实现。二叉

树的身影几

乎出现在所

有的

应用领

域当中，这也

是一个重要

的原因。

§5.2 编码

树

第5章 二叉

树

114

§5.2

编码树

本

章将以通讯

编码算法的

实现作为二

叉树的应用

实例。通讯理

论中的一个

基本问题是

，如何

在尽可

能低的成本

下，以尽可能

高的速度，尽

可能忠实地

实现信息在

空间和时间

上的复制与

转移。

在现代

通讯技术中

，无论采用电

、磁、光或其它

任何形式，在

信道上传递

的信息大多

以二进制比

特的形式表

示和存在，而

每一个具体

的编码方案

都对应于一

棵二叉编码

树。

5.2.1 二进制编

码

在加载到

信道上之前

，信息被转换

为二进制形

式的过程称

作编码（encoding）；反之

，经

信道抵达

目标后再由

二进制编码

恢复原始信

息的过程称

作解码（decoding）。

图5.7 完

整癿通讯过

秳由预处理

、编码和解码

阶段组成

如

图5.7所示，编码

和解码的任

务分别由发

送方和接收

方分别独立

完成，故在开

始通讯之

前

，双方应已经

以某种形

式

，就编码规则

达成过共

同

的约定或协

议。

 生成编码

表

原始信息

的基本组成

单位称作字

符，它们都来

自于某一特

定的有限集

合，也称作字

符集

（alphabet）。而以二

进制形式承

载的信息，都

可表示为来

自编码表Γ = {

0, 1 }*的

某一特

定二

进制串。从这

个角度理解

，每一编码表

都是从字符

集到编码表

Γ的一个单射

，编码就是对

信

息文本中

各字符逐个

实施这一映

射的过程，而

解码则是逆

向映射的过

程。

表5.1  =

{ 'A', 'E', 'G',

'M', 'S' }癿一仹

事迕刢编码

表

字符

A E G M

S

编码

00 01 10

110 111

表5.1即为二进

制编码表的

实例。编码表

一旦制定，信

息的发送方

与接收方之

间也就建立

起

了一个约

定与默契，从

而使得独立

的编码与解

码成为可能

。

 二进制编码

现在，所谓编

码就是对于

任意给定的

文本，

通过查

阅编码表逐

一将其中的

字符转译为

二进

制编码

，这些编码依

次串接起来

即得到了全

文的

编码。比

如若待编码

文本为"MESSAGE"，则根

据

由表5.1确定

的编码方案

，对应的二进

制编码串

应

为"11001111111001001"

①。

表5.2 事迕刢

解码过秳

事

迕刢编码 当

前匹配字符

解出原文

11001111111001001 M M

01111111001001

E ME

111 11001001

S MES

111001001 S

MESS

01001 A MESSA

1001 G MESSAG

01

E MESSAGE

① 返

里对各比特

位做了适弼

癿上下秱位

，以便读者匙

分各字符编

码串癿范围

；在实际编码

中，它们幵无

“高度”癿匙删

第5章 二叉树

§5.2 编码树

115

 二进

制解码

由编

码器生成的

二进制流经

信道送达之

后，接收方可

以按照事先

约定的编码

表（表5.1），

依次扫

描各比特位

，并经匹配逐

一转译出各

字符，从而最

终恢复出原

始的文本。

仍

以二进制编

码串"11001111111001001"为例，其

解码过程如

表5.2所示。

 解码

歧义

请注意

，编码方案确

定之后，尽管

编码结果必

然确定，但解

码过程和结

果却不见得

唯一。

表5.3  =

{ 'A', 'E', 'G',

'M', 'S' }癿另

一仹编码表

字 符

A E G M

S

编码 00 01

10 11 111

比

如，上述字符

集的另一编

码方案如表

5.3所示，与表5.1的

差异在于，字

符'M'的编码由

"110"改为"11"。此时，原

始文本"MESSAGE"经编

码得到二进

制编码串"1101111111001001"，

但

如表5.4左侧和

右侧所示，解

码方法却至

少有两种。

表

5.4 按照表5.3“确定

”癿编码协议

，可能有多种

解码结枅

事

迕刢编码

当

前匹配字符

解出原文 事

迕刢编码 当

前匹配字符

解出原文

1101111111001001

M M 1101111111001001 M

M

01111111001001 E ME

01111111001001 E ME

111111001001

S MES 111111001001 M

MEM

111001001 S MESS

1111001001 M MEMM

001001

A MESSA 11001001 M

MEMMM

1001 G MESSAG

001001 A MEMMMA

01

E MESSAGE 1001 G

MEMMMAG

01 E MEMMMAGE

进

一步推敲之

后不难发现

，按照这份编

码表，有时甚

至还会出现

无法完成解

码的情况。

 前

缀无歧义编

码

解码过程

之所以会出

现上述歧义

甚至错误，根

源在于编码

表制订不当

。这里的解码

算法采用

的

是，按顺序对

信息比特流

做子串匹配

的策略，因此

为消除匹配

的歧义性，任

何两个原始

字符所

对应

的二进制编

码串，相互都

不得是前缀

。比如在表5.3中

，字符'M'的编码

（"11"）即为字符

'S'的

编码（"111"）的前缀

，于是编码串

"111111"既可以解释

为：

"SS"

= "111

111"

也可以解

释为

"MMM" = "1111

11"

反过来

，只要各字符

的编码串互

不为前缀，则

即便出现无

法解码的错

误，也绝对不

致歧义。

这类

编码方案即

所谓的“前缀

无歧义编码

”（prefix-free code），简称PFC编码。此

类编码

算法

，可以明确地

将二进制编

码串，分割为

一系列与各

原始字符对

应的片段，从

而实现无歧

义的

解码。得

益于这一特

点，此类算法

在整个解码

过程中，对信

息比特流的

扫描不必回

溯。

那么，PFC编码

的以上特点

，可否直观解

释？从算法角

度看，PFC编码与

解码过程，又

该如

何准确

描述？从数据

结构角度看

，这些过程的

实现，需要借

助哪些功能

接口？支持这

些接口的数

据结构，又该

如何高效率

地实现？以下

以二叉树结

构为模型，逐

步解答这些

疑问。

§5.2

编码树

第5章 二叉树

116

5.2.2 二叉编码树



根通路与节

点编码

任一

编码方案都

可描述为一

棵二叉树：从

根节点出发

，每次

向左（右

）都对应于一

个0（1）比特位。于

是如图5.8所示

，由从

根节点

到每个节点

的唯一通路

，可以为各节

点v赋予一个

互异的二

进

制串，称作根

通路串（root path string），记作

rps(v)。

当然，|rps(v)|

= depth(v)就是v的

深度。

若将中

的字符分别

映射至二叉

树的节点，则

字符x的二进

制

编码串即

可取作rps(v(x))。以下

，在不致引起

混淆的前提

下，

不再区分

字符x和与之

对应的节点

v(x)。于是，rps(v(x))可简记

作rps(x)；depth(v(x))可简记作

depth(x)。

图5.8 事叉树中

每个节点都

由根通

路串

唯一确定

 PFC编

码树

仍以字

符集 =

{ 'A', 'E', 'G',

'M', 'S' }为例，表

5.1、表5.3所定义的

编码方案

分

别对应于如

图5.9左、右所示

的二叉编码

树。

易见，rps(u)是rps(v)的

前

缀，当且仅

当节点u是v的

祖先，故

表5.3中

编码方案导

致解码歧义

的

根

源 在 于

， 在

其 编 码 树

（

图

5.9(b)）中字符'M'是

'S'的父亲。

反之

，只要所有字

符都对应于

叶节点，歧义

现象即自然

消除

这也是

实现PFC编码的

简明策略。

比

如，图5.9(a)即为一

种可行的

PFC编

码方案。 图5.9 

= { 'A','E','G','M','S' }两

种编码斱案

对应癿事叉

编码树

 基于

PFC编码树的解

码

反过来，依

据PFC编码树可

便捷地完成

编码串的解

码。依然以图

5.9(a)中编码树为

例，设对

编码

串"11001111111001001"解码。从前

向后扫描该

串，同时在树

中相应移动

。起始时从树

根

出发，视各

比特位的取

值相应地向

左或右深入

下一层，直到

抵达叶节点

。比如，在扫描

过前三位

"110"后

将抵达叶节

点'M'。此时，可以

输出其对应

的字符'M'，然后

重新回到树

根，并继续扫

描

编码串的

剩余部分。比

如，再经过接

下来的两位

"01"后将抵达叶

节点'E'，同样地

输出字符'E'

并

回到树根。如

此迭代，即可

无歧义地解

析出原文中

的所有字符

（习题[5-6]）。

实际上

，这一解码过

程甚至可以

在二进制编

码串的接收

过程中实时

进行，而不必

等到所有比

特位都到达

之后才开始

，因此这类算

法属于在线

算法。

 PFC编码树

的构造

由上

可见，PFC编码方

案可由PFC编码

树来描述，由

编码树不仅

可以快速生

成编码表，而

且

直接支持

高效的解码

。那么，任意给

定一个字符

集，如何构造

出PFC编码方案

呢？

为此，需要

首先解决二

叉树本身作

为数据结构

的描述和实

现问题。

第5章

二叉树 §5.3

二叉

树癿实现

117

§5.3 二

叉树的实现

作为图的特

殊形式，二叉

树的基本组

成单元是节

点与边；作为

数据结构，其

基本的组成

实体

是二叉

树节点（binary tree node），而边

则对应于节

点之间的相

互引用。

5.3.1

二叉

树节点

 BinNode模板

类

以二叉树

节点BinNode模板类

，可定义如代

码5.1所示。

1 #define BinNodePosi(T) BinNode<T>*

//节点

位置

2 #define stature(p)

((p) ? (p)->height :

-1) //节点高

度（不“空树高

度为-1”癿约定

相统一）

3 typedef

enum { RB_RED, RB_BLACK}

RBColor; //节点

颜色

4

5

template <typename T> struct

BinNode { //二叉树

节点模板类

6 //

成员（为简化

描述起见统

一开放，读者

可根据需要

迕一步封装

）

7 T data;

//数值

8 BinNodePosi(T) parent;

BinNodePosi(T) lc; BinNodePosi(T) rc;

//父节点

及左、右孩子

9 int height; //高度（通用）

10 int npl; //Null

Path Length（左

式堆，也可直

接用height代替）

11 RBColor

color; //颜

色（红黑树）

12 //

极

造函数

13 BinNode() :

14 parent ( NULL

), lc ( NULL

), rc ( NULL

), height ( 0

), npl ( 1

), color ( RB_RED

) { }

15

BinNode ( T e,

BinNodePosi(T) p = NULL,

BinNodePosi(T) lc = NULL,

BinNodePosi(T) rc = NULL,

16 int h =

0, int l =

1, RBColor c =

RB_RED ) :

17

data ( e ),

parent ( p ),

lc ( lc ),

rc ( rc ),

height ( h ),

npl ( l ),

color ( c )

{ }

18 //

操作

接口

19 int size();

//统计弼

前节点后代

总数，亦即以

其为根癿子

树癿觃模

20 BinNodePosi(T) insertAsLC

( T const& );

//作

为弼前节点

癿左孩子揑

入新节点

21 BinNodePosi(T) insertAsRC

( T const& );

//作

为弼前节点

癿右孩子揑

入新节点

22 BinNodePosi(T) succ();

//叏

弼前节点癿

直接后继

23 template <typename

VST> void travLevel (

VST& ); //子

树局次遍历

24 template

<typename VST> void travPre

( VST& ); //子树先序遍

历

25 template <typename VST>

void travIn ( VST&

); //子树中序

遍历

26 template

<typename VST> void travPost

( VST& ); //子树后

序遍历

27 // 比较

器、刞等器（各

列其一，其余

自行补充）

28

bool operator< ( BinNode

const& bn ) {

return data < bn.data;

} //小

亍

29 bool

operator== ( BinNode const&

bn ) { return

data == bn.data; }

//等亍

30 };

代码

5.1

事叉树节点

模板类BinNode

这里

，通过宏BinNodePosi来指

代节点位置

，以简化后续

代码的描述

；通过定义宏

stature，

则可以保证

从节点返回

的高度值，能

够与“空树高

度为-1”的约定

相统一。

§5.3

二叉

树癿实现 第

5章 二叉树

118

 成

员变量

如图

5.10所示，BinNode节点由

多个

成员变

量组成，它们

分别记录了

当前节点

的

父亲和孩子

的位置、节点

内存放的数

据

以及节点

的高度等指

标，这些都是

二叉树

相关

算法赖以实

现的基础。 图

5.10

BinNode模板类癿逡

辑结极

其中

，data的类型由模

板变量T指定

，用于存放各

节点所对应

的数值对象

。lc、rc和parent

均为指针

类型，分别指

向左、右孩子

以及父节点

的位置。如此

，既可将各节

点联接起来

，也可在

它们

之间漫游移

动。比如稍后

5.4节将要介绍

的遍历算法

，就必须借助

此类位置变

量。当然，通

过

判断这些变

量所指位置

是否为NULL，也可

确定当前节

点的类型。比

如，v.parent = NULL当

且仅当

v是根节点，而

v.lc

= v.rc = NULL当且仅当v是

叶节点。

后续

章节将基于

二叉树实现

二叉搜索树

和优先级队

列等数据结

构，而节点高

度height在其

中的

具体语义也

有所不同。比

如，8.3节的红黑

树将采用所

谓的黑高度

（black height），而

10.3节的左式

堆则采用所

谓的空节点

通路长度（null

path length）。尽

管后者也可

以直接沿

用

height变量，但出于

可读性的考

虑，这里还是

专门设置了

一个变量npl。

有

些种类的二

叉树还可能

需要其它的

变量来描述

节点状态，比

如针对其中

节点的颜色

，红黑

树需要

引入一个属

于枚举类型

RB_Color的变量color。

根据

不同应用需

求，还可以针

对节点的深

度增设成员

变量depth，或者针

对以当前节

点为根

的子

树规模（该节

点的后代数

目）增设成员

变量size。利用这

些变量固然

可以加速静

态的查询

或

搜索，但为保

持这些变量

的时效性，在

所属二叉树

发生结构性

调整（比如节

点的插入或

删除）

之后，这

些成员变量

都要动态地

更新。因此，究

竟是否值得

引入此类成

员变量，必须

权衡利弊。

比

如，在二叉树

结构改变频

繁以至于动

态操作远多

于静态操作

的场合，舍弃

深度、子树规

模等变

量，转

而在实际需

要时再直接

计算这些指

标，应是更为

明智的选择

。



快捷方式

在

BinNode模板类各接

口以及后续

相关算法的

实现中，将频

繁检查和判

断二叉树节

点的状态

与

性质，有时还

需要定位与

之相关的（兄

弟、叔叔等）特

定节点，为简

化算法描述

同时增强可

读

性，不妨如

代码5.2所示将

其中常用功

能以宏的形

式加以整理

归纳。

1 /******************************************************************************************

2 *

BinNode状态不

性质癿刞断

3 ******************************************************************************************/

4 #define

IsRoot(x) ( ! (

(x).parent ) )

5

#define IsLChild(x) ( !

IsRoot(x) && ( &

(x) == (x).parent->lc )

)

6 #define IsRChild(x)

( ! IsRoot(x) &&

( & (x) ==

(x).parent->rc ) )

7

#define HasParent(x) ( !

IsRoot(x) )

8 #define

HasLChild(x) ( (x).lc )

9 #define HasRChild(x) (

(x).rc )

10 #define

HasChild(x) ( HasLChild(x) ||

HasRChild(x) ) //至少拥有一

个孩子

11

#define HasBothChild(x) ( HasLChild(x)

&& HasRChild(x) ) //同时

拥有两个孩

子

第5章 二叉

树 §5.3 二叉树癿

实现

119

12 #define IsLeaf(x)

( ! HasChild(x) )

13

14 /******************************************************************************************

15

* 不BinNode具有

特定兲系癿

节点及指针

16 ******************************************************************************************/

17

#define sibling(p) /*兄弟*/ \

18 ( IsLChild( *

(p) ) ? (p)->parent->rc

: (p)->parent->lc )

19

20 #define uncle(x) /*叔叔*/

\

21 ( IsLChild(

* ( (x)->parent )

) ? (x)->parent->parent->rc :

(x)->parent->parent->lc )

22

23

#define FromParentTo(x) /*来

自父亲癿引

用*/ \

24 ( IsRoot(x) ?

_root : ( IsLChild(x)

? (x).parent->lc : (x).parent->rc

) )

代码5.2 以宏

癿形式对基

二BinNode癿操作做

一归纳整理

5.3.2

二叉树节点

操作接口

由

于BinNode模板类本

身处于底层

，故这里也将

所有操作接

口统一设置

为开放权限

，以简化

描述

。同样地，注重

数据结构封

装性的读者

可在此基础

之上自行修

改扩充。



插入

孩子节点

1 template <typename

T> BinNodePosi(T) BinNode<T>::insertAsLC (

T const& e )

2 { return lc

= new BinNode (

e, this ); }

//将

e作为弼前节

点癿左孩子

揑入二叉树

3

4 template <typename

T> BinNodePosi(T) BinNode<T>::insertAsRC (

T const& e )

5 { return rc

= new BinNode (

e, this ); }

//将e作为弼前

节点癿右孩

子揑入二叉

树

代码5.3 事叉

树节点左、右

孩子癿揑入

可见，为将新

节点作为当

前节点的左

孩子插

入树

中，可如图5.11(a)所

示，先创建新

节点；

再如图

(b)所示，将当前

节点作为新

节点的父亲

，

并令新节点

作为当前节

点的左孩子

。这里约定，

在

插入新节点

之前，当前节

点尚无左孩

子。

右孩子的

插入过程完

全对称，不再

赘述。

图5.11 事叉

树节点左孩

子揑入过秳

 定位直接后

继

稍后在5.4.3节

我们将会看

到，通过中序

遍历，可在二

叉树各节点

之间定义一

个线性次序

。

相应地，各节

点之间也可

定义前驱与

后继关系。这

里的succ()接口，可

以返回当前

节点的直接

后继（如果存

在）。该接口的

具体实现，将

在129页代码5.16中

给出。

 遍历

稍

后的5.4节，将从

递归和迭代

两个角度，分

别介绍各种

遍历算法的

不同实现。为

便于测试

与

比较，不妨将

这些算法的

不同版本统

一归入统一

的接口中，并

在调用时随

机选择。

§5.3 二叉

树癿实现 第

5章

二叉树

120

1 template

<typename T> template <typename

VST> //元

素类型、操作

器

2 void

BinNode<T>::travIn ( VST& visit

) { //二叉树中

序遍历算法

统一入口

3

switch ( rand() %

5 ) { //此

处暂随机选

择以做测试

，共五种选择

4

case 1: travIn_I1 (

this, visit ); break;

//迭代版#1

5 case 2:

travIn_I2 ( this, visit

); break; //迭代

版#2

6

case 3: travIn_I3 (

this, visit ); break;

//迭代版#3

7 case 4:

travIn_I4 ( this, visit

); break; //迭

代版#4

8

default: travIn_R ( this,

visit ); break; //逑弻版

9

}

10 }

代码5.4

事叉树

中序遍历算

法癿统一入

口

比如，中序

遍历算法的

五种实现方

式（其中travIn_I4留作

习题[5-17]），即可如

代码5.4

所示，纳

入统一的BinNode::travIn()接

口。其余遍历

算法的处理

方法类似，不

再赘述。

5.3.3

二叉

树

 BinTree模板类

在

BinNode模板类的基

础之上，可如

代码5.5所示定

义二叉树BinTree模

板类。

1 #include "BinNode.h" //引入二

叉树节点类

2

template <typename T> class

BinTree { //二叉树模板

类

3

protected:

4 int _size;

BinNodePosi(T) _root; //觃模、根节

点

5

virtual int updateHeight (

BinNodePosi(T) x ); //更新节点

x癿高度

6 void updateHeightAbove (

BinNodePosi(T) x ); //更新

节点x及其祖

先癿高度

7 public:

8 BinTree()

: _size ( 0

), _root ( NULL

) { } //极

造函数

9 ~BinTree() { if

( 0 < _size

) remove ( _root

); } //枂极

函数

10

int size() const {

return _size; } //觃模

11 bool empty() const

{ return !_root; }

//刞

空

12 BinNodePosi(T) root()

const { return _root;

} //树根

13 BinNodePosi(T)

insertAsRoot ( T const&

e ); //揑入

根节点

14

BinNodePosi(T) insertAsLC ( BinNodePosi(T)

x, T const& e

); //e作为

x癿左孩子（原

无）揑入

15 BinNodePosi(T)

insertAsRC ( BinNodePosi(T) x,

T const& e );

//e作为

x癿右孩子（原

无）揑入

16 BinNodePosi(T) attachAsLC

( BinNodePosi(T) x, BinTree<T>*

&T ); //T作为

x左子树接入

17 BinNodePosi(T)

attachAsRC ( BinNodePosi(T) x,

BinTree<T>* &T ); //T作为x右子树

接入

18 int remove (

BinNodePosi(T) x ); //初除以

位置x处节点

为根癿子树

，迒回诠子树

原先癿觃模

19

BinTree<T>* secede ( BinNodePosi(T)

x ); //将子树x从弼

前树中摘除

，幵将其转换

为一棵独立

子树

20

template <typename VST> //操作器

21

void travLevel ( VST&

visit ) { if

( _root ) _root->travLevel

( visit ); }

//局次遍历

22 template <typename

VST> //操

作器

23 void

travPre ( VST& visit

) { if (

_root ) _root->travPre (

visit ); } //先序遍

历

第5章 二叉

树 §5.3 二叉树癿

实现

121

24 template <typename

VST> //操作器

25 void travIn

( VST& visit )

{ if ( _root

) _root->travIn ( visit

); } //中序遍历

26

template <typename VST> //操

作器

27 void travPost (

VST& visit ) {

if ( _root )

_root->travPost ( visit );

} //后序遍

历

28 bool

operator< ( BinTree<T> const&

t ) //比较器（其

余自行补充

）

29

{ return _root &&

t._root && lt (

_root, t._root ); }

30 bool operator== (

BinTree<T> const& t )

//刞等器

31 { return

_root && t._root &&

( _root == t._root

); }

32 };

//BinTree

代码

5.5 事叉树模板

类BinTree



高度更新

二叉树任一

节点的高度

，都等于其孩

子节点的最

大高度加一

。于是，每当某

一节点的孩

子或

后代有

所增减，其高

度都有必要

及时更新。然

而实际上，节

点自身很难

发现后代的

变化，因此这

里不妨反过

来采用另一

处理策略：一

旦有节点加

入或离开二

叉树，则更新

其所有祖先

的高度。请

读

者自行验证

，这一原则实

际上与前一

个等效（习题

[5-3]）。

在每一节点

v处，只需读出

其左、右孩子

的高度并取

二者之间的

大者，再计入

当前节点本

身，

就得到了

v的新高度。通

常，接下来还

需要从v出发

沿parent指针逆行

向上，依次更

新各代祖先

的高度记录

。这一过程可

具体实现如

代码5.6所示。

1 template <typename

T> int BinTree<T>::updateHeight (

BinNodePosi(T) x ) //更

新节点x高度

2

{ return x->height =

1 + max (

stature ( x->lc ),

stature ( x->rc )

); } //具体觃则，因

树而异

3

4 template <typename T>

void BinTree<T>::updateHeightAbove ( BinNodePosi(T)

x ) //更新

高度

5

{ while ( x

) { updateHeight (

x ); x =

x->parent; } } //从x出収

，覆盖历代祖

先。可优化

代

码5.6 事叉树节

点癿高度更

新

更新每一

节点本身的

高度，只需执

行两次getHeight()操作

、两次加法以

及两次取最

大操作，

不过

常数时间，故

updateHeight()算法总体运

行时间也是

O(depth(v)

+ 1)，其中depth(v)

为节点

v的深度。当然

，这一算法还

可进一步优

化（习题[5-4]）。

在某

些种类的二

叉树（例如8.3节

将要介绍的

红黑树）中，高

度的定义有

所不同，因此

这里

将updateHeight()定义

为保护级的

虚方法，以便

派生类在必

要时重写（override）。

 节

点插入

二叉

树节点可以

通过三种方

式插入二叉

树中，具体实

现如代码5.7所

示。

1 template <typename T>

BinNodePosi(T) BinTree<T>::insertAsRoot ( T

const& e )

2

{ _size = 1;

return _root = new

BinNode<T> ( e );

} //将e弼作根

节点揑入空

癿二叉树

3

4

template <typename T> BinNodePosi(T)

BinTree<T>::insertAsLC ( BinNodePosi(T) x,

T const& e )

5 { _size++; x->insertAsLC

( e ); updateHeightAbove

( x ); return

x->lc; } //e揑

入为x癿左孩

子

6

7 template <typename T>

BinNodePosi(T) BinTree<T>::insertAsRC ( BinNodePosi(T)

x, T const& e

)

§5.3 二叉树癿

实现 第5章

二

叉树

122

8 {

_size++; x->insertAsRC ( e

); updateHeightAbove ( x

); return x->rc; }

//e揑入为

x癿右孩子

代

码5.7 事叉树根

、左、右节点癿

揑入

insertAsRoot()接口用

于将节点插

入空树中，当

然，该节点随

即也应成为

树根。

一般地

，如图5.12(a)所示，若

二叉树T

中 某

节点 x

的 右 孩

子 为

空 ， 则 可

通

过

T.insertAsRC()接口为

其添加一个

右孩子。

为此

可如图(b)所示

，调用x->insertAsRC()

接口，将

二者按照父

子关系相互

联接，同时通

过updateHeightAbove()接口更新

x所有祖

先的

高度，并更新

全树规模。

请

注意这里的

两个同名insertAsRC()

接

口，它们各自

所属的对象

类型不同。

图

5.12

右节点揑入

过秳：(a)揑入前

；(b)揑入后

左侧

节点的插入

过程与此相

仿，可对称地

调用insertAsLC()完成。

 子

树接入

如代

码5.8所示，任一

二叉树均可

作为另一二

叉树中指定

节点的左子

树或右子树

，植入其中。

1 template <typename

T> //二

叉树子树接

入算法：将S弼

作节点x癿左

子树接入，S本

身置空

2 BinNodePosi(T)

BinTree<T>::attachAsLC ( BinNodePosi(T) x,

BinTree<T>* &S ) {

//x->lc == NULL

3

if ( x->lc =

S->_root ) x->lc->parent =

x; //接入

4 _size +=

S->_size; updateHeightAbove ( x

); //更新全树觃

模不x所有祖

先癿高度

5 S->_root

= NULL; S->_size =

0; release ( S

); S = NULL;

return x; //释

放原树，迒回

接入位置

6

}

7

8 template

<typename T> //二

叉树子树接

入算法：将S弼

作节点x癿右

子树接入，S本

身置空

9

BinNodePosi(T) BinTree<T>::attachAsRC ( BinNodePosi(T)

x, BinTree<T>* &S )

{ //x->rc == NULL

10 if ( x->rc

= S->_root ) x->rc->parent

= x; //接入

11 _size

+= S->_size; updateHeightAbove (

x ); //更新全树觃

模不x所有祖

先癿高度

12

S->_root = NULL; S->_size

= 0; release (

S ); S =

NULL; return x; //释

放原树，迒回

接入位置

13 }

代

码5.8 事叉树子

树癿接入

图

5.13 右子树接入

过秳：(a)接入前

；(b)接入后

如图

5.13(a)，若二叉树T中

节点x的右孩

子为空，则attachAsRC()接

口首先将待

植入

的二叉

树S的根节点

作为x的右孩

子，同时令x

作

为该根节点

的父亲；然后

，更新全树规

模以

及节点

x所有祖先的

高度；最后，将

树S中除已

接

入的各节点

之外的其余

部分归还系

统。

左子树接

入过程与此

类似，可对称

地调用

attachAsLC()完成

。

第5章 二叉树

§5.4 遍历

123

 子树删

除

子树删除

的过程，与如

图5.13所示的子

树接入过程

恰好相反，不

同之处在于

，需要将被摘

除子树中的

节点，逐一释

放并归还系

统（习题[5-5]）。具体

实现如代码

5.9所示。

1 template <typename T>

//初除二

叉树中位置

x处癿节点及

其后代，迒回

被初除节点

癿数值

2 int BinTree<T>::remove

( BinNodePosi(T) x )

{ //assert: x为二

叉树中癿合

法位置

3

FromParentTo ( *x )

= NULL; //切断

来自父节点

癿指针

4

updateHeightAbove ( x->parent );

//更新

祖先高度

5 int n

= removeAt ( x

); _size -= n;

return n; //初

除子树x，更新

觃模，迒回初

除节点总数

6 }

7 template <typename T>

//初除二叉树

中位置x处癿

节点及其后

代，迒回被初

除节点癿数

值

8 static int

removeAt ( BinNodePosi(T) x

) { //assert: x为二叉树

中癿合法位

置

9 if ( !x

) return 0; //逑弻基：空

树

10 int n =

1 + removeAt (

x->lc ) + removeAt

( x->rc ); //逑弻释放

左、右子树

11 release ( x->data

); release ( x

); return n; //释

放被摘除节

点，幵迒回初

除节点总数

12

}

代码5.9 事叉树

子树癿初除

 子树分离

子

树分离的过

程与以上的

子树删除过

程基本一致

，不同之处在

于，需要对分

离出来的子

树重

新封装

，并返回给上

层调用者。具

体实现如代

码5.10所示。

1 template

<typename T> //二叉

树子树分离

算法：将子树

x从弼前树中

摘除，将其封

装为一棵独

立子树迒回

2 BinTree<T>*

BinTree<T>::secede ( BinNodePosi(T) x

) { //assert: x为二叉树中

癿合法位置

3

FromParentTo ( *x )

= NULL; //切断来自父

节点癿指针

4 updateHeightAbove

( x->parent ); //更新原树中

所有祖先癿

高度

5 BinTree<T>* S =

new BinTree<T>; S->_root =

x; x->parent = NULL;

//新树以

x为根

6 S->_size =

x->size(); _size -= S->_size;

return S; //更新觃

模，迒回分离

出来癿子树

7 }

代码5.10 事叉树

子树癿分离

 复杂度

就二

叉树拓扑结

构的变化范

围而言，以上

算法均只涉

及局部的常

数个节点。因

此，除了更新

祖先高度和

释放节点等

操作，只需常

数时间。

§5.4 遍历

对二叉树的

访问多可抽

象为如下形

式：按照某种

约定的次序

，对节点各访

问一次且仅

一次。

与向量

和列表等线

性结构一样

，二叉树的这

类访问也称

作遍历（traversal）。遍历

之于二叉树

的意义，同样

在于为相关

算法的实现

提供通用的

框架。此外，这

一过程也等

效于将半线

性的树形

结

构，转换为线

性结构。不过

，二叉树毕竟

已不再属于

线性结构，故

相对而言其

遍历更为复

杂。

为此，以下

首先针对几

种典型的遍

历策略，按照

代码5.1和代码

5.5所列接口，分

别给出相

应

的递归式实

现；然后，再分

别介绍其对

应的迭代式

实现，以提高

遍历算法的

实际效率。

§5.4 遍

历

第5章 二叉

树

124

5.4.1

递归式遍

历

图5.14 事叉树

遍历癿全尿

次序由尿部

次序觃则确

定

二叉树本

身并不具有

天然的全局

次序，故为实

现遍历，首先

需要在各节

点与其孩子

之间约定

某

种局部次序

，从而间接地

定义出全局

次序。按惯例

左孩子优先

于右孩子，故

若将节点及

其孩子

分别

记作V、L和R，则如

图5.14所示，局部

访问的次序

有VLR、LVR和LRV三种选

择。根据节点

V

在其中的访

问次序，这三

种策略也相

应地分别称

作先序遍历

、中序遍历和

后序遍历，分

述如下。



先序

遍历

得益于

递归定义的

简洁性，如代

码5.11所示，只需

数行即可实

现先序遍历

算法。

1 template

<typename T, typename VST>

//元素类

型、操作器

2 void travPre_R

( BinNodePosi(T) x, VST&

visit ) { //二

叉树先序遍

历算法（逑弻

版）

3 if ( !x

) return;

4 visit

( x->data );

5

travPre_R ( x->lc, visit

);

6 travPre_R (

x->rc, visit );

7

}

代码5.11 事叉

树先序遍历

算法（递归版

）

图5.15

事叉树（上

）癿先序遍历

序列（下）

为遍

历（子）树x，首先

核对x是否为

空。若x为空，则

直接退出其

效果相当于

递归基。

反之

，若x非空，则按

照先序遍历

关于局部次

序的定义，优

先访问其根

节点x；然后，依

次深入左

子

树和右子树

，递归地进行

遍历。实际上

，这一实现模

式也同样可

以应用于中

序和后序遍

历。

第5章 二叉

树 §5.4 遍历

125

如图

5.15所示，经遍历

之后，可将节

点按某一线

性次序排列

，称作遍历（生

成）序列。

 后序

遍历

1 template <typename T,

typename VST> //元素类

型、操作器

2

void travPost_R ( BinNodePosi(T)

x, VST& visit )

{ //二

叉树后序遍

历算法（逑弻

版）

3 if

( !x ) return;

4 travPost_R ( x->lc,

visit );

5 travPost_R

( x->rc, visit );

6 visit ( x->data

);

7 }

代码5.12

事叉

树后序遍历

算法（递归版

）

仿照以上先

序遍历的模

式，可如代码

5.12所示实现递

归版后序遍

历算法。

图5.16 事

叉树癿后序

遍历序列

按

照后序遍历

规则，为遍历

非空的（子）树

x，将在依次递

归遍历其左

子树和右子

树之后，

才访

问节点x。对于

以上二叉树

实例，其完整

的后序遍历

过程以及生

成的遍历序

列如图5.16所示

。

与图5.15做一对

比可见，先序

遍历序列与

后序遍历序

列并非简单

的逆序关系

。



中序遍历

再

次仿照以上

模式，可实现

递归版中序

遍历算法如

代码5.13所示。

1 template

<typename T, typename VST>

//元

素类型、操作

器

2 void travIn_R

( BinNodePosi(T) x, VST&

visit ) { //二叉树中

序遍历算法

（逑弻版）

3 if ( !x

) return;

4 travIn_R

( x->lc, visit );

5 visit ( x->data

);

6 travIn_R (

x->rc, visit );

7

}

代码

5.13 事叉树中序

遍历算法（递

归版）

§5.4

遍历 第

5章 二叉树

126

按

照中序遍历

规则，为遍历

非空的（子）树

x，将依次递归

遍历其左子

树、访问节点

x、递

归遍历其

右子树。以上

二叉树实例

的中序遍历

过程以及生

成的遍历序

列，如图5.17所示

。

图5.17 事叉树癿

中序遍历序

列

与以上的

先序和后序

遍历序列做

一对比不难

发现，各节点

在中序遍历

序列中的局

部次序，与

按

照有序树定

义所确定的

全局左、右次

序完全吻合

。这一现象并

非巧合，在第

7章和第8章中

，这

正是搜索

树及其等价

变换的原理

和依据所在

。

5.4.2

*迭代版先序

遍历

无论以

上各种递归

式遍历算法

还是以下各

种迭代式遍

历算法，都只

需渐进的线

性时间（习题

[5-9]和[5-11]）；而且相对

而言，前者更

加简明。既然

如此，有何必

要介绍迭代

式遍历算法

呢？

首先，递归

版遍历算法

时间、空间复

杂度的常系

数，相对于迭

代版更大。同

时，从学习的

角

度来看，从

底层实现迭

代式遍历，也

是加深对相

关过程与技

巧理解的有

效途径。

 版本

1

观察先序遍

历的递归版

（代码5.11）可发现

，其中针对右

子树的递归

属于尾递归

，左子树

的则

接近于尾递

归。故参照消

除尾递归的

一般性方法

，不难将其改

写迭代版（习

题[5-10]）。

 版本2

很遗

憾，以上思路

并不容易推

广到非尾递

归的场合，比

如在中序或

后序遍历中

，至少有一个

递归方向严

格地不属于

尾递归。此时

，如下另一迭

代式版本的

实现思路，则

更具参考价

值。

如图5.18所示

，在二叉树T中

，从根节点出

发沿着左分

支一直下行

的那条通路

（以粗线示意

），

称作最左侧

通路（leftmost path）。若将沿

途节点分别

记作Lk，k = 0,

1, 2, ..., d，则

最左

侧通路终止

于没有左孩

子末端节点

Ld。若这些节点

的右孩子和

右子树分别

记作Rk和Tk，k = 0,

1, 2, ..., d，则该

二叉树的先

序遍历序列

可表示为：

preorder(T) =

 visit(L0),

visit(L1), ..., visit(Ld);

preorder(Td), ..., preorder(T1), preorder(T0)

第

5章 二叉树 §5.4 遍

历

127

图5.18 先序遍

历过秳：先沿

最左侧通路

自顶而下讵

问沿途节点

，再自底而上

依次遍历返

些节点癿右

子树

也就是

说，先序遍历

序列可分解

为两段：沿最

左侧通路自

顶而下访问

的各节点，以

及自底而

上

遍历的对应

右子树。基于

对先序遍历

序列的这一

理解，可以导

出以下迭代

式先序遍历

算法。

1 //从弼前

节点出収，沿

左分支丌断

深入，直至没

有左分支癿

节点；沿递节

点遇刡后立

即讵问

2

template <typename T, typename

VST> //元素

类型、操作器

3 static void

visitAlongLeftBranch ( BinNodePosi(T) x,

VST& visit, Stack<BinNodePosi(T)>& S

) {

4 while

( x ) {

5 visit ( x->data

); //讵问弼前节

点

6 S.push

( x->rc ); //右孩子入

栈暂存（可优

化：通过刞断

，避免空癿右

孩子入栈）

7 x = x->lc;

//沿

左分支深入

一局

8 }

9

}

10

11 template

<typename T, typename VST>

//元素类

型、操作器

12 void travPre_I2

( BinNodePosi(T) x, VST&

visit ) { //二

叉树先序遍

历算法（迭代

版#2）

13 Stack<BinNodePosi(T)> S; //辅劣栈

14 while ( true

) {

15 visitAlongLeftBranch

( x, visit, S

); //从

弼前节点出

収，逐批讵问

16 if (

S.empty() ) break; //直刡栈空

17 x = S.pop();

//弹

出下一批癿

起点

18 }

19

}

代码5.14 事

叉树先序遍

历算法（迭代

版#2）

如代码5.14所

示，在全树以

及其中每一

棵子树的根

节点处，该算

法都首先调

用函数

VisitAlongLeftBranch()，自顶

而下访问最

左侧通路沿

途的各个节

点。这里也使

用了一个辅

助

栈，逆序记

录最左侧通

路上的节点

，以便确定其

对应右子树

自底而上的

遍历次序。

§5.4 遍

历

第5章 二叉

树

128

5.4.3

*迭代版中

序遍历

如上

所述，在中序

遍历的递归

版本（125页代码

5.13）中，尽管右子

树的递归遍

历是尾递归

，

但左子树绝

对不是。实际

上，实现迭代

式中序遍历

算法的难点

正在于此，不

过好在迭代

式先序遍

历

的版本2可以

为我们提供

启发和借鉴

。

 版本1

图5.19 中序

遍历过秳：顸

着最左侧通

路，自底而上

依次讵问沿

途各节点及

其右子树

如

图5.19所示，参照

迭代式先序

遍历版本2的

思路，再次考

查二叉树T的

最左侧通路

，并对

其中的

节点和子树

标记命名。于

是，T的中序遍

历序列可表

示为：

inorder(T) =

visit(Ld), inorder(Td);

 visit(Ld-1),

inorder(Td-1);

 ..., ...;

visit(L1), inorder(T1);

 visit(L0),

inorder(T0)

也就是

说，沿最左侧

通路自底而

上，以沿途各

节点为界，中

序遍历序列

可分解为d + 1段

。

如图5.19左侧所

示，各段彼此

独立，且均包

括访问来自

最左侧通路

的某一节点

Lk，以及遍历其

对

应的右子

树Tk。

基于对中

序遍历序列

的这一理解

，即可导出如

代码5.15所示的

迭代式中序

遍历算法。

1

template <typename T> //从

弼前节点出

収，沿左分支

丌断深入，直

至没有左分

支癿节点

2 static void goAlongLeftBranch

( BinNodePosi(T) x, Stack<BinNodePosi(T)>&

S ) {

3

while ( x )

{ S.push ( x

); x = x->lc;

} //弼

前节点入栈

后随即向左

侧分支深入

，迭代直刡无

左孩子

4 }

5

6 template <typename

T, typename VST> //元素

类型、操作器

7

void travIn_I1 ( BinNodePosi(T)

x, VST& visit )

{ //二叉树中序

遍历算法（迭

代版#1）

第5章 二

叉树

§5.4 遍历

129

8

Stack<BinNodePosi(T)> S; //辅

劣栈

9

while ( true )

{

10 goAlongLeftBranch (

x, S ); //从弼前

节点出収，逐

批入栈

11 if ( S.empty()

) break; //直至

所有节点处

理完毕

12

x = S.pop(); visit

( x->data ); //弹出

栈顶节点幵

讵问乀

13 x = x->rc;

//转向

右子树

14 }

15

}

代码

5.15 事叉树中序

遍历算法（迭

代版#1）

在全树

及其中每一

棵子树的根

节点处，该算

法首先调用

函数goAlongLeftBranch()，沿最

左

侧通路自顶

而下抵达末

端节点Ld。在此

过程中，利用

辅助栈逆序

地记录和保

存沿途经过

的各个

节点

，以便确定自

底而上各段

遍历子序列

最终在宏观

上的拼接次

序。

图5.20 迭代式

中序遍历实

例（出栈节点

以深色示意

）

图5.20以左侧二

叉树为例，给

出了中序遍

历辅助栈从

初始化到再

次变空的演

变过程。

 直接

后继及其定

位

与所有遍

历一样，中序

遍历的实质

功能也可理

解为，为所有

节点赋予一

个次序，从而

将半线

性的

二叉树转化

为线性结构

。于是一旦指

定了遍历策

略，即可与向

量和列表一

样，在二叉树

的节

点之间

定义前驱与

后继关系。其

中没有前驱

（后继）的节点

称作首（末）节

点。

对于后面

将要介绍的

二叉搜索树

，中序遍历的

作用至关重

要。相关算法

必需的一项

基本操作，

就

是定位任一

节点在中序

遍历序列中

的直接后继

。为此，可实现

succ()接口如代码

5.16所示。

1 template <typename T>

BinNodePosi(T) BinNode<T>::succ() { //定位节

点v癿直接后

继

2 BinNodePosi(T) s =

this; //记弽后继

癿临时发量

3 if (

rc ) { //若有右孩子

，则直接后继

必在右子树

中，具体地就

是

4 s = rc;

//右子树中

5 while ( HasLChild

( *s ) )

s = s->lc; //最靠左（最小

）癿节点

6 } else {

//否则

，直接后继应

是“将弼前节

点包含亍其

左子树中癿

最低祖先”，具

体地就是

7 while (

IsRChild ( *s )

) s = s->parent;

//逆

向地沿右向

分支，丌断朝

左上斱秱劢

8 s = s->parent;

//最后再朝右

上斱秱劢一

步，即抵达直

接后继（如枅

存在）

9 }

10

return s;

11 }

代码5.16 事

叉树节点直

接后继癿定

位

§5.4 遍历

第5章

二叉树

130

这里

，共分两大类

情况。若当前

节点有右孩

子，则其直接

后继必然存

在，且属于其

右子树。

此时

只需转入右

子树，再沿该

子树的最左

侧通路朝左

下方深入，直

到抵达子树

中最靠左（最

小）

的节点。以

图5.20中节点b为

例，如此可确

定其直接后

继为节点c。

反

之，若当前节

点没有右子

树，则若其直

接后继存在

，必为该节点

的某一祖先

，且是将当前

节点纳入其

左子树的最

低祖先。于是

首先沿右侧

通路朝左上

方上升，当不

能继续前进

时，再朝右

上

方移动一步

即可。以图5.20中

节点e为例，如

此可确定其

直接后继为

节点f。

作为后

一情况的特

例，出口时s可

能为NULL。这意味

着此前沿着

右侧通路向

上的回溯，抵

达

了树根。也

就是说，当前

节点全树右

侧通路的终

点它也是中

序遍历的终

点，没有后继

。

 版本2

代码5.15经

进一步改写

之后，可得到

如代码5.17所示

的另一迭代

式中序遍历

算法。

1 template <typename T,

typename VST> //元素类

型、操作器

2

void travIn_I2 ( BinNodePosi(T)

x, VST& visit )

{ //二

叉树中序遍

历算法（迭代

版#2）

3 Stack<BinNodePosi(T)>

S; //辅劣栈

4 while

( true )

5

if ( x )

{

6 S.push (

x ); //根

节点迕栈

7

x = x->lc; //深

入遍历左子

树

8 } else if

( !S.empty() ) {

9 x = S.pop();

//尚未讵问

癿最低祖先

节点退栈

10 visit (

x->data ); //讵

问诠祖先节

点

11

x = x->rc; //遍历祖先

癿右子树

12 } else

13

break; //遍

历完成

14 }

代码

5.17 事叉树中序

遍历算法（迭

代版#2）

虽然版

本2只不过是

版本1的等价

形式，但借助

它可便捷地

设计和实现

以下版本3。



版

本3

以上的迭

代式遍历算

法都需使用

辅助栈，尽管

这对遍历算

法的渐进时

间复杂度没

有实质影

响

，但所需辅助

空间的规模

将线性正比

于二叉树的

高度，在最坏

情况下与节

点总数相当

。

为此，可对代

码5.17版本2继续

改进，借助BinNode对

象内部的parent指

针，如代码5.18

所

示实现中序

遍历的第三

个迭代版本

。该版本无需

使用任何结

构，总体仅需

O(1)的辅助空间

，

属于就地算

法。当然，因需

要反复调用

succ()，时间效率有

所倒退（习题

[5-16]）。

1 template

<typename T, typename VST>

//元素类型、操

作器

2 void travIn_I3

( BinNodePosi(T) x, VST&

visit ) { //二叉树

中序遍历算

法（迭代版#3，无

需辅劣栈）

3 bool backtrack =

false; //前

一步是否刚

从右子树回

溯——省去栈，仅

O(1)辅劣空间

4 while

( true )

5

if ( !backtrack &&

HasLChild ( *x )

) //若

有左子树且

丌是刚刚回

溯，则

6 x

= x->lc; //深入遍

历左子树

7

else { //否

则——无左子树

戒刚刚回溯

（相弼亍无左

子树）

第5章

二

叉树 §5.4 遍历

131

8 visit ( x->data

); //讵

问诠节点

9 if

( HasRChild ( *x

) ) { //若

其右子树非

空，则

10 x = x->rc;

//深入右

子树继续遍

历

11 backtrack =

false; //幵兲闭回

溯标志

12 }

else { //若右

子树空，则

13

if ( ! (

x = x->succ() )

) break; //回

溯（含抵达末

节点时癿退

出迒回）

14

backtrack = true; //幵讴

置回溯标志

15

}

16 }

17

}

代码5.18 事叉树

中序遍历算

法（迭代版#3）

可

见，这里相当

于将原辅助

栈替换为一

个标志位backtrack。每

当抵达一个

节点，借助该

标

志即可判

断此前是否

刚做过一次

自下而上的

回溯。若不是

，则按照中序

遍历的策略

优先遍历左

子

树。反之，若

刚发生过一

次回溯，则意

味着当前节

点的左子树

已经遍历完

毕（或等效地

，左子树

为空

），于是便可访

问当前节点

，然后再深入

其右子树继

续遍历。

图5.21

中

序遍历过秳

中，在无右孩

子癿节点处

需做回溯

每

个节点被访

问之后，都应

转向其在遍

历序列中的

直接后继。按

照以上的分

析，通过检查

右

子树是否

为空，即可在

两种情况间

做出判断：该

后继要么在

当前节点的

右子树（若该

子树非空）

中

，要么（当右子

树为空时）是

其某一祖先

。如图5.21所示，后

一情况即所

谓的回溯。

请

注意，由succ()返回

的直接后继

可能是NULL，此时

意味着已经

遍历至中序

遍历意义下

的

末节点，于

是遍历即告

完成。

5.4.4 *迭代版

后序遍历

在

如代码5.12所示

后序遍历算

法的递归版

本中，左、右子

树的递归遍

历均严格地

不属于尾

递

归，因此实现

对应的迭代

式算法难度

更大。不过，仍

可继续套用

此前的思路

和技巧。我们

思考

的起点

依然是，此时

首先访问的

是哪个节点

？

§5.4

遍历 第5章 二

叉树

132

如图5.22所

示，将树T画在

二维平面上

，并假设所有

节点和边均

不透明。于是

从左侧水平

向

右看去，未

被遮挡的最

高叶节点v称

作最高左侧

可见叶节点

（HLVFL）即为后序遍

历首

先访问

的节点。请注

意，该节点既

可能是左孩

子，也可能是

右孩子，故在

图中以垂直

边示意它与

其父节点之

间的联边。

图

5.22

后序遍历过

秳也可划分

为模式雷同

癿若干段

考

查联接于v与

树根之间的

唯一通路（以

粗线示意）。与

先序与中序

遍历类似地

，自底而上

地

沿着该通路

，整个后序遍

历序列也可

分解为若干

个片段。每一

片段，分别起

始于通路上

的一个

节点

，并包括三步

：访问当前节

点，遍历以其

右兄弟（若存

在）为根的子

树，以及向上

回溯至其

父

节点（若存在

）并转入下一

片段。

基于以

上理解，即可

导出如代码

5.19所示的迭代

式后序遍历

算法。

1 template

<typename T> //在以S栈

顶节点为根

癿子树中，找

刡最高左侧

可见叶节点

2 static

void gotoHLVFL ( Stack<BinNodePosi(T)>&

S ) { //沿递所遇节

点依次入栈

3

while ( BinNodePosi(T) x

= S.top() ) //自顶而下，反

复检查弼前

节点（即栈顶

）

4 if ( HasLChild

( *x ) )

{ //尽可能向左

5 if (

HasRChild ( *x )

) S.push ( x->rc

); //若有右孩子

，优先入栈

6 S.push

( x->lc ); //然

后才转至左

孩子

7 } else //实丌得

已

8 S.push ( x->rc

); //才向右

9 S.pop();

//迒

回乀前，弹出

栈顶癿空节

点

10 }

11

12 template <typename T,

typename VST>

13 void

travPost_I ( BinNodePosi(T) x,

VST& visit ) {

//二叉树癿

后序遍历（迭

代版）

14 Stack<BinNodePosi(T)> S;

//辅劣栈

15 if ( x

) S.push ( x

); //根节点入栈

16 while (

!S.empty() ) {

第5章

二叉树

§5.4 遍历

133

17

if ( S.top() !=

x->parent ) //若栈顶

非弼前节点

乀父（则必为

其右兄），此时

需

18

gotoHLVFL ( S );

//在以其右

兄为根乀子

树中，找刡HLVFL（相

弼亍逑弻深

入其中）

19 x =

S.pop(); visit ( x->data

); //弹出

栈顶（即前一

节点乀后继

），幵讵问乀

20 }

21 }

代

码5.19 事叉树后

序遍历算法

（迭代版）

可见

，在每一棵（子

）树的根节点

，该算法都首

先定位对应

的HLVFL节点。同时

在此过程中

，

依然利用辅

助栈逆序地

保存沿途所

经各节点，以

确定遍历序

列各个片段

在宏观上的

拼接次序。

图

5.23以左侧二叉

树为例，给出

了后序遍历

辅助栈从初

始化到再次

变空的演变

过程。

图5.23

迭代

式后序遍历

实例（出栈节

点以深色示

意，収生gotoHLVFL()调用

癿节点以大

写字母示意

）

请留意此处

的入栈规则

。在自顶而下

查找HLVFL节点的

过程中，始终

都是尽可能

向左，只有

在

左子树为空

时才向右。前

一情况下，需

令右孩子（若

有）和左孩子

先后入栈，然

后再转向左

孩

子。后一情

况下，只需令

右孩子入栈

。因此，在主函

数travPost_I()的每一步

while迭代中，

若当

前节点node的右

兄弟存在，则

该兄弟必然

位于辅助栈

顶。按照后序

遍历约定的

次序，此时

应

再次调用gotoHLVFL()以

转向以该兄

弟为根的子

树，并模拟以

递归方式对

该子树的遍

历。

5.4.5 层次遍历

在所谓广度

优先遍历或

层次遍历（level-order

traversal）中

，确定节点访

问次序的原

则可概括为

“先上后下、先

左后右”先访

问树根，再依

次是左孩子

、右孩子、左孩

子的左孩

子

、左孩子的右

孩子、右孩子

的左孩子、右

孩子的右孩

子、...，依此类推

。

§5.4 遍历

第5章 二

叉树

134

当然，有

根性和有序

性是

层次遍

历序列得以

明确定义的

基础。正因为

确定了树根

，各

节点方可

拥有深度这

一指标，

并进

而依此排序

；有序性则保

证孩子有左

、右之别，并依

此

确定同深

度节点之间

的次序。

为对

比效果，同样

考查此

前图

5.15、图5.16和图5.17均

采

用的二叉树

实例。该树完

整

的层次遍

历过程以及

生成的遍

历

序列，如图5.24所

示。

图5.24 事叉树

癿局次遍历

序列



算法实

现

此前介绍

的迭代式遍

历，无论先序

、中序还是后

序遍历，大多

使用了辅助

栈，而迭代式

层次

遍历则

需要使用与

栈对称的队

列结构，算法

的具体实现

如代码5.20所示

。

1

template <typename T> template

<typename VST> //元素类型、操

作器

2

void BinNode<T>::travLevel ( VST&

visit ) { //二叉树

局次遍历算

法

3 Queue<BinNodePosi(T)> Q; //辅劣队列

4

Q.enqueue ( this );

//根节点入队

5 while ( !Q.empty()

) { //在队列再次

发空乀前，反

复迭代

6

BinNodePosi(T) x = Q.dequeue();

visit ( x->data );

//叏出

队首节点幵

讵问乀

7 if (

HasLChild ( *x )

) Q.enqueue ( x->lc

); //左孩

子入队

8 if

( HasRChild ( *x

) ) Q.enqueue (

x->rc ); //右孩

子入队

9

}

10 }

代码

5.20

事叉树局次

遍历算法

图

5.25 局次遍历实

例（出队节点

以深色示意

）

第5章

二叉树

§5.4 遍历

135

初始化

时先令树根

入队，随后进

入循环。每一

步迭代中，首

先取出并访

问队首节点

，然后其

左、右

孩子（若存在

）将顺序入队

。一旦在试图

进入下一迭

代前发现队

列为空，遍历

即告完成。

图

5.25以左侧二叉

树为例，给出

了层次遍历

辅助队列从

初始化到再

次变空的演

变过程。

 完全

二叉树

反观

代码5.20，在层次

遍历算法的

每一次迭代

中，必有一个

节点出队（而

且不再入队

），

故累计恰好

迭代n次。然而

，每次迭代中

入队节点的

数目并不确

定。若在对某

棵二叉树的

层次遍

历过

程中，前n/2次迭

代中都有左

孩子入队，且

前n/2 -

1次迭代中

都有右孩子

入队，则称之

为完全二叉

树（complete binary tree）。

图5.26给出了

完全二叉树

的实例，及其

一般性的宏

观拓扑结构

特征：叶节点

只能出现在

最

底部的两

层，且最底层

叶节点均处

于次底层叶

节点的左侧

（习题[5-18]和[5-19]）。由此

不难

验证，高

度为h的完全

二叉树，规模

应该介于2

h 至

2

h+1

- 1之间；反之，规

模为n的完全

二叉树，

高度

h

= log2n = O(logn)。另外，叶节点

虽不致少于

内部节点，但

至多多出一

个。以图5.26

左侧

的完全二叉

树为例，高度

h = 4；共有n =

20个节点

，其中内部节

点和叶节点

各10个。

图5.26 完全

事叉树实例

及其宏观结

极

得益于以

上特性，完全

二叉树可以

借助向量结

构，实现紧凑

存储和高效

访问（习题[5-20]）。

 满

二叉树

完全

二叉树的一

种特例是，所

有叶节点同

处于最底层

（非底层节点

均为内部节

点）。于是根

据

数学归纳法

，每一层的节

点数都应达

到饱和，故将

称其为满二

叉树（full

binary tree）。

图5.27 满事

叉树实例及

其宏观结极

类似地不难

验证，高度为

h的满二叉树

由2

h+1

- 1个节点组

成，其中叶节

点总是恰好

比内部

节点

多出一个。图

5.27左侧即为一

棵包含n

= 15个节

点、高度h = 3的满

二叉树，其中

叶节点8

个，内

部节点7个；右

侧则给出了

满二叉树的

一般性宏观

结构。

§5.5 Huffman编码 第

5章

二叉树

136

§5.5 Huffman编

码

5.5.1 PFC编码及解

码

以下基于

二叉树结构

，按照图5.28的总

体框架，介绍

PFC编码和解码

算法的具体

实现。

图5.28

为实

现PFC编码和解

码过秳所需

癿数据结极

和算法

图5.29 子

集癿PFC编码树

合幵后，

即是

全集癿一棵

PFC编码树

如图

5.29所示，若字符

集1和2之间没

有公共字符

，且PFC编码方案

分别对应于

二叉树T1和

T2，则

通过引入一

个根节点合

并T1和T2之后所

得到的二叉

树，就是对应

于12的一种PFC编

码方

案。请注

意，无论T1和T2的

高度与规模

是否相等，这

一性质总是

成立。

利用上

述性质，可自

底而上地构

造PFC编码树。首

先，由每一字

符分别构造

一棵单节点

二叉

树，并将

它们视作一

个森林。此后

，反复从森林

中取出两棵

树并将其合

二为一。如此

，经|| -

1步迭代之

后，初始森林

中的||棵树将

合并成为一

棵完整的PFC编

码树。接下来

，再将PFC编码

树

转译为编码

表，以便能够

根据待编码

字符快捷确

定与之对应

的编码串。至

此，对于任何

待编码

文本

，通过反复查

阅编码表，即

可高效地将

其转化为二

进制编码串

。

与编码过程

相对应地，接

收方也可以

借助同一棵

编码树来记

录双方约定

的编码方案

。于是，

每当接

收到经信道

传送过来的

编码串后，（只

要传送过程

无误）接收方

都可通过在

编码树中反

复

从根节点

出发做相应

的漫游，依次

完成对信息

文本中各字

符的解码。

 总

体框架

以上

编码和解码

过程可描述

为代码5.21，这也

是同类编码

、解码算法的

统一测试入

口。

1

int main ( int

argc, char* argv[] )

{ //PFC编码、解码

算法统一测

试入口

2 PFCForest*

forest = initForest(); //刜始

化PFC森枃

3 PFCTree* tree =

generateTree ( forest );

release ( forest );

//生成

PFC编码树

4 PFCTable* table

= generateTable ( tree

); //将PFC编

码树转换为

编码表

5 for

( int i =

1; i < argc;

i++ ) { //对亍

命令行传入

癿殏一明文

串

6 Bitmap codeString; //二迕刢编

码串

7 int n =

encode ( table, codeString,

argv[i] ); //将根据

编码表生成

（长度为n）

8

decode ( tree, codeString,

n ); //刟用

编码树，对长

度为n癿二迕

刢编码串解

码（直接输出

）

9

}

10 release (

table ); release (

tree ); return 0;

//释放编码表

、编码树

11 }

代码

5.21

基二事叉树

癿PFC编码

第5章

二叉树 §5.5 Huffman编码

137

 数据结构的

选取与设计

如代码5.22所示

，这里使用向

量实现PFC森林

，其中各元素

分别对应于

一棵编码树

；使用9.2

节将要

介绍的跳转

表式词典结

构实现编码

表，其中的词

条各以某一

待编码字符

为关键码，以

对应

的编码

串为数据项

；使用位图Bitmap（习

题[2-34]）实现各字

符的二进制

编码串。

1 /******************************************************************************************

2 *

PFC编码

使用癿数据

结极

3 ******************************************************************************************/

4

#include "../BinTree/BinTree.h" //用BinTree实现

PFC树

5

typedef BinTree<char> PFCTree; //PFC树

6

7 #include "../Vector/Vector.h"

//用Vector实现

PFC森枃

8 typedef Vector<PFCTree*>

PFCForest; //PFC森枃

9

10

#include "../Bitmap/Bitmap.h" //使

用位图结极

实现二迕刢

编码串

11

#include "../Skiplist/Skiplist.h" //引入

Skiplist式词典结极

实现

12

typedef Skiplist<char, char*> PFCTable;

//PFC编码表

，词条格式为

：(key = 字符, value

= 编码串

)

13

14

#define N_CHAR (0x80 -

0x20) //叧考虑可打

印字符

代码

5.22 实现PFC编码所

需癿数据结

极

以下，分别

给出各功能

部分的具体

实现，请读者

对照注解自

行分析。

 初始

化PFC森林

1

PFCForest* initForest() { //PFC编码

森枃刜始化

2

PFCForest* forest = new

PFCForest; //首先创建空

森枃，然后

3 for

( int i =

0; i < N_CHAR;

i++ ) { //对

殏一个可打

印字符[0x20,

0x80)

4 forest->insert (

i, new PFCTree() );

//创建

一棵对应癿

PFC编码树，刜始

时其中

5 ( *forest

) [i]->insertAsRoot ( 0x20

+ i ); //叧包

含对应癿一

个（叶、根）节点

6

}

7 return forest;

//迒回包含N_CHAR棵

树癿森枃，其

中殏棵树各

包含一个字

符

8 }

代码5.23

刜始

化PFC森枃

 构造

PFC编码树

1

PFCTree* generateTree ( PFCForest*

forest ) { //极造

PFC树

2 srand ( (

unsigned int ) time

( NULL ) );

//返里将随

机叏树合幵

，故先讴置随

机种子

3 while (

1 < forest->size() )

{ //共做

|forest|-1次合幵

4 PFCTree*

s = new PFCTree;

s->insertAsRoot ( '^' );

//创建

新树（根标记

为"^"）

5 Rank r1

= rand() % forest->size();

//随机选叏

r1，且

6 s->attachAsLC (

s->root(), ( *forest )

[r1] ); //作为左子

树接入后

7

forest->remove ( r1 );

//随

即剔除

8 Rank r2

= rand() % forest->size();

//随机

选叏r2，且

§5.5 Huffman编码

第5章 二叉树

138

9 s->attachAsRC ( s->root(),

( *forest ) [r2]

); //作为右子树

接入后

10 forest->remove

( r2 ); //随即

剔除

11 forest->insert ( forest->size(),

s ); //合幵后

癿PFC树重新植

入PFC森枃

12

}

13 return (

*forest ) [0]; //至此

，森枃中尚存

癿最后一棵

树，即全尿PFC编

码树

14 }

代码5.24 极

造PFC编码树

 生

成PFC编码表

1 void

generateCT //通

过遍历获叏

各字符癿编

码

2 (

Bitmap* code, int length,

PFCTable* table, BinNodePosi (

char ) v )

{

3 if (

IsLeaf ( *v )

) //若是叶节

点

4 {

table->put ( v->data, code->bits2string

( length ) );

return; }

5 if

( HasLChild ( *v

) ) //Left =

0

6 { code->clear

( length ); generateCT

( code, length +

1, table, v->lc );

}

7 if (

HasRChild ( *v )

) //right = 1

8 { code->set (

length ); generateCT (

code, length + 1,

table, v->rc ); }

9 }

10

11

PFCTable* generateTable ( PFCTree*

tree ) { //极造PFC编码

表

12 PFCTable* table =

new PFCTable; //创建以Skiplist实

现癿编码表

13 Bitmap*

code = new Bitmap;

//用亍记弽RPS癿

位图

14 generateCT (

code, 0, table, tree->root()

); //遍历以

获叏各字符

（叶节点）癿RPS

15 release

( code ); return

table; //释

放编码位图

，迒回编码表

16 }

代码5.25

生成PFC编

码表

 编码

1

int encode ( PFCTable*

table, Bitmap& codeString, char*

s ) { //PFC编

码算法

2 int n =

0;

3 for (

size_t m = strlen

( s ), i

= 0; i <

m; i++ ) {

//对亍

明文s[]中癿殏

个字符

4 char** pCharCode

= table->get ( s[i]

); //叏出

其对应癿编

码串

5 if

( !pCharCode ) pCharCode

= table->get ( s[i]

+ 'A' - 'a'

); //小写字

殎转为大写

6 if (

!pCharCode ) pCharCode =

table->get ( ' '

); //无法识删癿

字符统一规

作空格

7 printf

( "%s", *pCharCode );

//输出

弼前字符癿

编码

8 for (

size_t m = strlen

( *pCharCode ), j

= 0; j <

m; j++ ) //将弼前

字符癿编码

接入编码串

9

'1' == * (

*pCharCode + j )

? codeString.set ( n++

) : codeString.clear (

n++ );

10 }

11 return n; //二迕刢编码

串记弽亍codeString中

，迒回编码串

总长

12 }

代码5.26 PFC编

码

第5章 二叉

树 §5.5 Huffman编码

139

 解码

13 void

decode ( PFCTree* tree,

Bitmap& code, int n

) { //PFC解码算法

14

BinNodePosi ( char )

x = tree->root(); //根

据PFC编码树

15 for ( int

i = 0; i

< n; i++ )

{ //将

编码（二迕刢

位图）

16 x

= code.test ( i

) ? x->rc :

x->lc; //转译为

明码幵

17 if

( IsLeaf ( *x

) ) { printf

( "%c", x->data );

x = tree->root(); }

//打印

输出

18 }

19

}

代码5.27 PFC解

码



优化

在介

绍过PFC及其实

现方法后，以

下将就其编

码效率做一

分析，并设计

出更佳的编

码方法。

同样

地，我们依然

暂且忽略硬

件成本和信

道误差等因

素，而主要考

查如何高效

率地完成文

本

信息的编

码和解码。不

难理解，在计

算资源固定

的条件下，不

同编码方法

的效率主要

体现于所生

成二进制编

码串的总长

，或者更确切

地，体现于二

进制码长与

原始文本长

度的比率。

那

么，面对千变

万化、长度不

一的待编码

文本，从总体

上我们应该

按照何种尺

度来衡量这

一

因素呢？基

于这一尺度

，又该应用哪

些数据结构

来实现相关

的算法呢？

5.5.2 最

优编码树

在

实际的通讯

系统中，信道

的使用效率

是个很重要

的问题，这在

很大程度上

取决于编码

算法

本身的

效率。比如，高

效的编码算

法生成的编

码串应该尽

可能地短。那

么，如何做到

这一点呢？

在

什么情况下

能够做到这

一点呢？以下

首先来看如

何对编码长

度做“度量”。



平

均编码长度

与叶节点平

均深度

由5.2.2节

的结论，字符

x的编码长度

|rps(x)|就是其对应

叶节点的深

度depth(v(x))。于

是，各字

符的平均编

码长度就是

编码树T中各

叶节点的平

均深度（average leaf

depth）：

ald(T) = x

|rps(x)| / || =

x

depth(x) / ||

以如

图5.9(a)所示编码

树为例，字符

'A'、'E'和'G'的编码长

度为2，'M'和'S'的编

码长度为3，

故

该编码方案

的平均编码

长度为：

ald(T) =

(2 + 2 +

2 + 3 +

3) / 5 =

2.4

既然

ald(T)值是反映编

码效率的重

要指标，我们

自然希望这

一指标尽可

能地小。

 最优

编码树

同一

字符集的所

有编码方案

中，平均编码

长度最小者

称作最优方

案；对应编码

树的ald()值

也达

到最小，故称

之为最优二

叉编码树，简

称最优编码

树（optimal encoding tree）。

对于任一

字符集，深度

不超过||的编

码树数目有

限，故在其中

ald()值最小者必

然存在。

需注

意的是，最优

编码树不见

得唯一（比如

，同层节点互

换位置后，并

不影响全树

的平均深度

），

但从工程的

角度看，任取

其中一棵即

可。

为导出最

优编码树的

构造算法，以

下需从更为

深入地了解

最优编码树

的性质入手

。

§5.5 Huffman编码 第5章 二

叉树

140

 双子性

图5.30 最优编码

树癿双子性

首先，最优二

叉编码树必

为真二叉树

：

内部节点的

左、右孩子全

双（习题[5-2]）。

若不

然，如图5.30(a)所示

假设在某棵

最优二叉编

码树T中，内部

节点p拥有唯

一

的孩子x。于

是如图(b)，此时

只需将节点

p

删除并代之

以子树x，即可

得到原字符

集的

另一棵

编码树T'。

不难

看出，除了子

树x中所有叶

节点的编码

长度统一缩

短1层之外，其

余叶节点的

编码长度

不

变，因此相对

于T，T'的平均编

码长度必然

更短这与T的

最优性矛盾

。



层次性

最优

编码树中，叶

节点位置的

选取有

严格

限制其深度

之差不得超

过1。

为

证 明 这

一 重

要 特 性

， 可

如 图

5.31(a)假设

，某棵最优二

叉编码树T含

有深度之差

不小于2的一

对叶节点x和

y。

不失一般性

设x更深，并令

p为x的父亲。

于

是由双子性

，作为内部节

点的p必然还

有另一孩子

q。 图5.31 最优编码

树癿局次性

如图(b)所示，令

叶节点y与子

树p互换位置

，从而得到一

棵新树T'。易见

，T'依然是原字

符

集的一棵

二叉编码树

。更重要的是

，就深度而言

，除了x、y以及子

树q中的叶节

点外，其余叶

节

点均保持

不变。其中，x的

提升量与y的

下降量相互

抵消，而子树

q中的叶节点

都至少提升

1层。

因此相对

于T，T'的平均编

码长度必然

更短这与T的

最优性矛盾

。

以上的节点

位置互换是

一种十分重

要的技巧，藉

此可从任一

编码树出发

，不断提高编

码效率，

直至

最优。以图5.32为

例，对同一字

符集

= { 'A', 'I',

'M', 'N' }，左、右两

棵编码树

的

ald()值均为9/4，而经

一次交换转

换为居中的

编码树后，ald()值

均降至8/4。

图5.32 通

过节点交换

提高编码效

率完全事叉

树不满事叉

树

 最优编码

树的构造

由

上可知，最优

编码树中的

叶节点只能

出现于最低

两层，故这类

树的一种特

例就是真完

全树。

第5章 二

叉树 §5.5

Huffman编码

141

由

此，可以直接

导出如下构

造最优编码

树的算法：创

建一棵规模

为2|| -

1的完全二

叉树T，再

将中

的字符任意

分配给T的||个

叶节点。

仍以

字符集 

= { 'A', 'E',

'G', 'M', 'S' }

为例

，只需创建包

含2  5 -

1 = 9

个节点的

一棵完全二

叉树，并将各

字符分配至

5个叶节点，即

得到一棵最

优编码树。再

适当交换

同

深度的节点

，即可得到如

116页图5.9(a)所示的

编码树由于

此类节点交

换并不改变

平均编

码长

度，故它仍是

一棵最优编

码树。

5.5.3 Huffman编码树



字符出现概

率

以上最优

编码树算法

的实际应用

价值并不大

，除非中各字

符在文本串

中出现的次

数相等。

遗憾

的是，这一条

件往往并不

满足，甚至不

确定。为此，需

要从待编码

的文本中取

出若干样本

，

通过统计各

字符在其中

出现的次数

（亦称作字符

的频率），估计

各字符实际

出现的概率

。

当然，每个字

符x都应满足

p(x)  0，且同一字符

集中的所有

字符满足xp(x) =

1。

表

5.5 在一篇典型

癿英文文章

中，各字母出

现癿次数

字

符

A B C D

E F G H

I J K L

N O P Q

R S T U

V W X Y

Z

次数 623 99

239 290 906 224

136 394 600 5

56 306 586 622

148 10 465 491

732 214 76 164

16 139 13

实际

上，多数应用

所涉及的字

符集中，各字

符的出现频

率不仅极少

相等或相近

，而且往往

相

差悬殊。以如

表5.5所示的英

文字符集为

例，'e'、't'等字符的

出现频率通

常是'z'、'j'等

字符

的数百倍。这

种情况下，应

该从另一角

度更为准确

地衡量平均

编码长度。

 带

权平均编码

长度与叶节

点带权平均

深度

若考虑

字符各自的

出现频率，则

可将带权

平

均编码长度

取作编码树

T的叶节点带

权平均

深度

（weighted average

leaf depth），

亦即：

wald(T)

= x

p(x)∙|rps(x)|

以字符

集

= { 'A', 'I',

'M', 'N' }

为例，若各

字符出现的

概率依次为

2/6、1/6、

2/6和1/6（比如文本

串"MAMANI"），则按照

图

5.33的编码方案

，各字符对wald(T)的

贡献

分别为

：

图5.33

考虑字符

出现频率，以

平均带

权深

度衡量编码

效率

3(2/6) =

1; 2(1/6) = 1/3;

3(2/6) = 1; 1(1/6)

= 1/6

相应地

，这一编码方

案对应的平

均带权深度

就是：

wald(T)

= 1 + 1/3

+ 1 + 1/6

= 2.5

若各字

符出现的概

率依次为3/8、1/8、4/8和

0/8（比如文本串

"MAMMAMIA"），则有

wald(T)

= 3(3/8) + 2(1/8)

+ 3(4/8) + 1(0/8)

= 2.875

 完全二

叉编码树

 wald()最

短

那么，wald()值能

否进一步降

低呢？仍然以

 =

{ 'A', 'I', 'M',

'N' }为例。

§5.5 Huffman编码

第

5章 二叉树

142

我

们首先想到

的是前节提

到的完全二

叉编码树。如

图5.34所示，由于

此时各字符

的编码长

度

都是2，故无论

其出现概率

具体分布如

何，其对应的

平均带权深

度都将为2。

图

5.34 若考虑出现

频率，完全事

叉树戒满树

未必最优 图

5.35

若考虑出现

频率，最优编

码树往往丌

是完全事叉

树

然而，在考

虑各字符出

现概率的不

同之后，某些

非完全二叉

编码树的wald()值

却可能更小

。

以图5.35的二叉

编码树为例

，当各字符频

率与"MAMANI"相同时

，wald(T) =

2，与图5.34方案

相

当；但当字符

频率与"MAMMAMIA"相同

时，wald(T) = 1.625，反而更优

。

 最优带权编

码树

若字符

集中各字符

的出现频率

分布为p()，则wald()值

最小的编码

方案称作（按

照p()分

布的）的

最优带权编

码方案，对应

的编码树称

作最优带权

编码树。当然

，与不考虑字

符出现概率

时同理，此时

的最优带权

编码树也必

然存在（尽管

通常并不唯

一）。

为得出最

优带权编码

树的构造算

法，以下还是

从分析其性

质入手。一方

面不难验证

，此时的

最优

编玛树依然

必须满足双

子性。另一方

面，尽管最优

编玛树不一

定仍是完全

的（比如在图

5.35

中，叶节点的

深度可能相

差2层以上），却

依然满足某

种意义上的

层次性。



层次

性

具体地，若

字符x和y的出

现概率在所

有字符中最

低，则必然存

在某棵最优

带权编码树

，使x

和y在其中

同处于最底

层，且互为兄

弟。为证明这

一重要特性

，如图5.36(a)所示任

取一棵最优

带权编码树

T。根据双子性

，必然可以在

最低层找到

一对兄弟节

点a和b。不妨设

它们不是x和

y。

图5.36

最优编码

树癿局次性

现在，交换a和

x，

再交换b和y，从

而得到

该字

符集的另一

编码

树T'，x和y成

为其中最

低

层的一对兄

弟。因字

符x和

y权重最小，故

如

此交换之

后，wald(T')

不致增加

。

于是根据T的

最优性，T'必然

也是一棵最

优编码树。

5.5.4 Huffman编

码算法



原理

与构思

设字

符x和y在中的

出现概率最

低。考查另一

字符集' = (\{x,

y})  {z}，其中

新增

第5章

二

叉树 §5.5 Huffman编码

143

字

符z的出现概

率取作被剔

除字符x和y之

和，即p(z) = p(x) +

p(y)，其余字

符的概率不

变。

任取'的一

棵最优带权

编码树T'，于是

根据层次性

，只需将T'中与

字符z对应的

叶节点替换

为内

部节点

，并在其下引

入分别对应

于x和y的一对

叶节点，即可

得到的一棵

最优带权编

码树。

仍以142页

图5.35中字符集



= { 'A', 'I',

'N', 'M' }为例，设各字

符出现的频

率与

编码串

'MAMMAMIA"吻合，则不难

验证，图5.37左侧

即为的一棵

最优带权编

码树T。

图5.37 最优

编码树中底

局兄弟节点

合幵后，依然

是最优编码

树

现在，将其

中出现频率

最低的'N'和'I'合

并，代之以新

字符'X'，且令'X'的

出现频率为

二

者之和

1/8 + 0/8 =

1/8 。若

T中也做相应

的调整之后

，则可得图5.37右

侧所示的编

码树T'。

不难验

证，T'是新字符

集' =

{ 'A', 'X', 'M'

}的一棵最

优带权编码

树；反之，在T'中

将

'X'拆分为'N'和

'I'后，亦是的一

棵最优带权

编码树（习题

[5-28]）。

 策略与算法

因此，对于字

符出现概率

已知的任一

字符集，都可

采用如下算

法构造其对

应的最优带

权编

码树：首

先，对应于中

的每一字符

，分别建立一

棵单个节点

的树，其权重

取作该字符

的频率，

这||棵

树构成一个

森林F。接下来

，从F中选出权

重最小的两

棵树，创建一

个新节点，并

分别以

这两

棵树作为其

左、右子树，如

此将它们合

并为一棵更

高的树，其权

重取作二者

权重之和。实

际

上，此后可

以将合并后

的新树等效

地视作一个

字符，称作超

字符。

这一选

取、合并的过

程反复进行

，每经过一轮

迭代，F中的树

就减少一棵

。当最终F仅包

含

一棵树时

，它就是一棵

最优带权编

码树，构造过

程随即完成

。

以上构造过

程称作Huffman编码

算法②，由其生

成的编码树

称作Huffman编码树

（Huffman

encoding tree）。需再次强调

的是，Huffman编码树

只是最优带

权编码树中

的一棵。

 实例

表5.6

由6个字符

极成癿字符

集，以及各字

符癿出现频

率

字符 A B

C D E F

频率

623 99 239 290

906 224

考查表5.6所列

由6各字符构

成的字符集

。为构造与之

相对应的一

棵Huffman编码树，在

初

始化之后

共需经过5步

迭代，具体过

程如图5.38(a~f)所示

。

② 由David A.

Huffman亍1952年収明

§5.5 Huffman编码 第5章 二

叉树

144

图5.38 Huffman树极

造算法实例

请注意，以上

构造过程不

见得是确定

的，在选取、合

并子树时都

可能出现歧

义。幸运的是

，

这一问题不

难解决（习题

[5-29]）。

以下，我们分

别介绍Huffman编码

算法各个环

节的具体实

现。

 总体框架

以上编码和

解码过程可

描述为代码

5.28，这也是同类

编码、解码算

法的统一测

试入口。

1

/******************************************************************************************

2 * 无讳

编码森枃由

列表、完全堆

迓是左式堆

实现，本测试

过程都可适

用

3 * 编码森枃

癿实现斱式

采用优先级

队列时，编译

前对应癿工

程叧需讴置

相应标志：

4

* DSA_PQ_List、DSA_PQ_ComplHeap戒

DSA_PQ_LeftHeap

5 ******************************************************************************************/

6 int main (

int argc, char* argv[]

) { //Huffman编码算法统

一测试

7

int* freq = statistics

( argv[1] ); //根据

样本文件，统

计各字符癿

出现频率

8 HuffForest* forest =

initForest ( freq );

release ( freq );

//创

建Huffman森枃

9 HuffTree* tree

= generateTree ( forest

); release ( forest

); //生成

Huffman编码树

10 HuffTable*

table = generateTable (

tree ); //将Huffman编

码树转换为

编码表

11

for ( int i

= 2; i <

argc; i++ ) {

//对亍

命令行传入

癿殏一明文

串

12 Bitmap* codeString

= new Bitmap; //二迕刢编

码串

13 int n =

encode ( table, codeString,

argv[i] ); //将根据

编码表生成

（长度为n）

14

decode ( tree, codeString,

n ); //刟用

Huffman编码树，对长

度为n癿二迕

刢编码串解

码

15

release ( codeString );

16 }

第5章 二叉

树

§5.5 Huffman编码

145

17

release ( table );

release ( tree );

return 0; //释放

编码表、编码

树

18

}

代码5.28 基二

事叉树癿Huffman编

码



（超）字符

如

前所述，无论

是输入的字

符还是合并

得到的超字

符，在构造Huffman编

码树过程中

都可等

效地

加以处理就

其本质而言

，相关信息无

非就是对应

的字符及其

出现频率。

1

#define N_CHAR (0x80 -

0x20) //仅

以可打印字

符为例

2 struct

HuffChar { //Huffman（超）字

符

3

char ch; int weight;

//字符、频率

4 HuffChar ( char

c = '^', int

w = 0 )

: ch ( c

), weight ( w

) {};

5 //

比较器、刞等

器（各列其一

，其余自行补

充）

6 bool operator<

( HuffChar const& hc

) { return weight

> hc.weight; } //此处故意

大小颞倒

7 bool operator== (

HuffChar const& hc )

{ return weight ==

hc.weight; }

8 };

代

码5.29 HuffChar结极

因此

如代码5.29所示

，可相应地定

义一个HuffChar类。对

于经合并生

成的超字符

，这里统

一用

'^'表示，同时其

权重weight设为被

合并字符的

权重之和。作

为示例，这里

字符集取ASCII

字

符集在[0x20, 0x80)区间

内的子集，包

含所有可打

印字符。

另外

，为便于超字

符做权重的

比较和判等

，这里还重载

了相关的操

作符。



数据结

构的选取与

设计

如代码

5.30所示，可借助

BinTree模板类定义

Huffman编码树类型

HuffTree。

1 #define

HuffTree BinTree<HuffChar> //Huffman树，由BinTree派生，节

点类型为HuffChar

代

码5.30

Huffman编码树结

极

如代码5.31所

示，可借助List模

板类定义Huffman森

林类型HuffForest。

1 #include

"../List/List.h" //用List实

现

2 typedef

List<HuffTree*> HuffForest; //Huffman森枃

代码

5.31

Huffman森枃结极

如

代码5.32所示，可

借助位图类

Bitmap（习题[2-34]）定义Huffman二

进制编码串

类型

HuffCode。

1

#include "../Bitmap/Bitmap.h" //基亍Bitmap实

现

2

typedef Bitmap HuffCode; //Huffman二迕刢编

码

代码5.32 Huffman事迕

刢编码串

作

为PFC编码表的

一种，Huffman编码表

与代码5.22一样

，自然可以由

跳转表实现

。作为对

后面

第9章中词典

结构的统一

测试，这里选

择了与跳转

表接口相同

的散列表结

构（9.3节），并

基于

该结构实现

HuffTable类型。

§5.5 Huffman编码 第

5章

二叉树

146

1 #include

"../Hashtable/Hashtable.h" //用

HashTable实现

2 typedef

Hashtable<char, char*> HuffTable; //Huffman编码表

代码5.33

Huffman编码表

如代码5.33所示

，可以9.3节将要

介绍的Hashtable结构

来实现HuffTable。其中

，词条的

关键

码key（即带编码

的字符）为字

符类型char，数值

value（即字符对应

的二进制编

码串）为

字符

串类型char*。



字符

出现频率的

样本统计

如

代码5.34所示，这

里通过对样

例文本的统

计，对各字符

的出现频率

做出估计。

1 int*

statistics ( char* sample_text_file

) { //统

计字符出现

频率

2

int* freq = new

int[N_CHAR]; //以下统

计需随机讵

问，故以数组

记弽各字符

出现次数

3 memset

( freq, 0, sizeof

( int ) *

N_CHAR ); //清

零

4

FILE* fp = fopen

( sample_text_file, "r" );

//assert: 文件存在

且可正确打

开

5 for

( char ch; 0

< fscanf ( fp,

"%c", &ch ); )

//逐个扫描

样本文件中

癿殏个字符

6 if ( ch

>= 0x20 ) freq[ch

- 0x20]++; //累计对应癿

出现次数

7

fclose ( fp );

return freq;

8 }

代

码5.34 Huffman算法：字符

出现频率癿

样本统计

为

方便统计过

程的随机访

问，这里使用

了数组freq。样例

文件（假设存

在且可正常

打开）

的路径

作为函数参

数传入。文件

打开后顺序

扫描，并累计

各字符的出

现次数。

 初始

化Huffman森林

1 HuffForest*

initForest ( int* freq

) { //根据

频率统计表

，为殏个字符

创建一棵树

2 HuffForest*

forest = new HuffForest;

//以List实现癿Huffman森

枃

3 for (

int i = 0;

i < N_CHAR; i++

) { //为殏个字

符

4

forest->insertAsLast ( new HuffTree

); //生成一棵

树，幵将字符

及其频率

5 forest->last()->data->insertAsRoot

( HuffChar ( 0x20

+ i, freq[i] )

); //存

入其中

6 }

7 return forest;

8

}

代码

5.35 刜始化Huffman森枃

 构造Huffman编码树

1

HuffTree* minHChar ( HuffForest*

forest ) { //在Huffman森枃中找

出权重最小

癿（超）字符

2 ListNodePosi ( HuffTree*

) p = forest->first();

//从

首节点出収

查找

3 ListNodePosi (

HuffTree* ) minChar =

p; //最小Huffman树

所在癿节点

位置

4 int

minWeight = p->data->root()->data.weight; //目前癿

最小权重

5 while ( forest->valid

( p = p->succ

) ) //遍

历所有节点

6 if

( minWeight > p->data->root()->data.weight

) //若弼前节点

所含树更小

，则

7 {

minWeight = p->data->root()->data.weight; minChar

= p; } //更新记弽

第5章

二叉树

§5.5 Huffman编码

147

8

return forest->remove ( minChar

); //将挑选

出癿Huffman树从森

枃中摘除，幵

迒回

9 }

10

11 HuffTree* generateTree

( HuffForest* forest )

{ //Huffman编码算

法

12 while

( 1 < forest->size()

) {

13 HuffTree*

T1 = minHChar (

forest ); HuffTree* T2

= minHChar ( forest

);

14 HuffTree* S

= new HuffTree();

15

S->insertAsRoot ( HuffChar (

'^', T1->root()->data.weight + T2->root()->data.weight

) );

16 S->attachAsLC

( S->root(), T1 );

S->attachAsRC ( S->root(), T2

);

17 forest->insertAsLast (

S );

18 }

//assert: 循环结束

时，森枃中唯

一（列表首节

点中）癿那棵

树即Huffman编码树

19 return forest->first()->data;

20 }

代码5.36 极造Huffman编

码树

根据以

上的构思，generateTree()实

现为一个循

环迭代的过

程。如代码5.36所

示，每一步

迭

代都通过调

用minHChar()，从当前的

森林中找出

权值最小的

一对超字符

，将它们合并

为一个

更大

的超字符，并

重新插入森

林。每迭代一

次，森林的规

模即减一，故

共需迭代n -

1次

，直到

只剩一

棵树。minHChar()每次都

要遍历森林

中所有的超

字符（树），所需

时间线性正

比于当时

森

林的规模。因

此总体运行

时间应为：

O(n)

+ O(n - 1)

+ ... + O(2)

= O(n2

)



生

成Huffman编码表

1 static void

//通

过遍历获叏

各字符癿编

码

2 generateCT (

Bitmap* code, int length,

HuffTable* table, BinNodePosi (

HuffChar ) v )

{

3 if (

IsLeaf ( *v )

) //若是叶节

点（迓有夗种

斱法可以刞

断）

4 {

table->put ( v->data.ch, code->bits2string

( length ) );

return; }

5 if

( HasLChild ( *v

) ) //Left =

0

6 { code->clear

( length ); generateCT

( code, length +

1, table, v->lc );

}

7 if (

HasRChild ( *v )

) //Right = 1

8 { code->set (

length ); generateCT (

code, length + 1,

table, v->rc ); }

9 }

10

11

HuffTable* generateTable ( HuffTree*

tree ) { //将各字符

编码统一存

入以散列表

实现癿编码

表中

12 HuffTable* table =

new HuffTable; Bitmap* code

= new Bitmap;

13

generateCT ( code, 0,

table, tree->root() );

14

release ( code );

return table;

15 };

代码5.37 生

成Huffman编码表

 编

码

1 // 按编码表

对Bitmap串做Huffman编码

§5.5 Huffman编码

第5章 二

叉树

148

2

int encode ( HuffTable*

table, Bitmap* codeString, char*

s ) {

3

int n = 0;

//待迒回

癿编码串总

长n

4 for (

size_t m = strlen

( s ), i

= 0; i <

m; i++ ) {

//对亍明文

中癿殏个字

符

5 char** pCharCode

= table->get ( s[i]

); //叏出其对

应癿编码串

6 if (

!pCharCode ) pCharCode =

table->get ( s[i] +

'A' - 'a' );

//小写字殎转

为大写

7 if (

!pCharCode ) pCharCode =

table->get ( ' '

); //无法

识删癿字符

统一规作空

格

8 printf

( "%s", *pCharCode );

//输出弼前

字符癿编码

9 for ( size_t

m = strlen (

*pCharCode ), j =

0; j < m;

j++ ) //将弼前字符

癿编码接入

编码串

10

'1' == * (

*pCharCode + j )

? codeString->set ( n++

) : codeString->clear (

n++ );

11 }

12 printf ( "\n"

); return n;

13

} //二迕

刢编码串记

弽亍位图codeString中

代码5.38 Huffman编码



解

码

1 // 根据编码

树对长为n癿

Bitmap串做Huffman解码

2 void decode (

HuffTree* tree, Bitmap* code,

int n ) {

3 BinNodePosi ( HuffChar

) x = tree->root();

4 for ( int

i = 0; i

< n; i++ )

{

5 x =

code->test ( i )

? x->rc : x->lc;

6 if ( IsLeaf

( *x ) )

{ printf ( "%c",

x->data.ch ); x =

tree->root(); }

7 }

8 } //解

出癿明码，在

此直接打印

输出；实用中

可改为根据

需要迒回上

局调用者

代

码5.39

Huffman解码

第6章

图

§6.1 概述

第6章

图

150

4.4节曾仿效

古希腊英雄

忒修斯，以栈

等基本数据

结构模拟线

绳和粉笔，展

示了试探回

溯策

略的应

用技巧。实际

上，这一技巧

可进一步推

广至更为一

般性的场合

，包括可以图

结构描述的

应

用问题，从

而导出一系

列对应的图

算法。

忒修斯

取得成功的

关键在于，借

助线绳掌握

迷宫内各通

道之间的联

接关系。在很

多应用中，

能

否有效描述

和利用这类

信息，同样至

关重要。一般

地，这类信息

往往可表述

为定义于一

组对象

之间

的二元关系

，比如城市交

通图中，联接

于各公交站

之间的街道

，或者互联网

中，联接于IP

节

点之间的路

由，等等。尽管

在某种程度

上，第5章所介

绍的树结构

也可用以表

示这种二元

关系，

但仅限

于父、子节点

之间。相互之

间均可能存

在二元关系

的一组对象

，从数据结构

的角度分类

，

属于非线性

结构（non-linear structure）。此类一

般性的二元

关系，属于图

论（Graph

Theory）

的研究范

畴。从算法的

角度对此类

结构的处理

策略，与上一

章相仿，也是

通过遍历将

其转化为半

线性结构，进

而借助树结

构已有的处

理方法和技

巧，最终解决

问题。

以下首

先简要介绍

图的基本概

念和术语，已

有相关基础

的读者可直

接跳过。接下

来，介绍如

何

实现作为抽

象数据类型

的图结构，主

要讨论邻接

矩阵和邻接

表两种实现

方式。然后，从

遍历的

角度

介绍将图转

化为树的典

型方法，包括

广度优先搜

索和深度优

先搜索。进而

，分别以拓扑

排序

和双连

通域分解为

例，介绍利用

基本数据结

构并基于遍

历模式，设计

图算法的主

要方法。最后

，

从“数据结构

决定遍历次

序”的观点出

发，将所有遍

历算法概括

并统一为最

佳优先遍历

这一模式。

如

此，我们不仅

能够更加准

确和深刻地

理解不同图

算法之间的

共性与联系

，更可以学会

通过选择

和

改进数据结

构，高效地设

计并实现各

种图算法这

也是本章的

重点与精髓

。

§6.1 概述



图

图结

构是描述和

解决实际应

用问题的一

种基本而有

力的工具。所

谓的图（graph），可定

义

为G =

(V, E)。其中，集

合V中的元素

称作顶点（vertex）；集

合E中的元素

分别对应于

V中的

某一对

顶点(u, v)，表示它

们之间存在

某种关系，故

亦称作边（edge）①。一

种直观显示

图结构

的方

法是，用小圆

圈或小方块

代表顶点，用

联接于其间

的直线段或

曲线弧表示

对应的边。

从

计算的需求

出发，我们约

定V和E均为有

限集，通常将

其规模分别

记n = |V|和e

= |E|。

 无向图

、有向图及混

合图

若边(u, v)所

对应顶点u和

v的次序无所

谓，则称作无

向边（undirected edge），例如表

示同学关系

的边。反之若

u和v不对等，则

称(u, v)为有向边

（directed

edge），例如描述企

业与银行之

间的借贷关

系，或者程序

之间的相互

调用关系的

边。

 

①

在某些文

献中，顶点也

称作节点（node），边

亦称作弧（arc），本

章则统一称

作顶点和边

。

第6章 图 §6.1

概述

151

如此，无向边

(u, v)也可记作(v, u)，而

有向的(u,

v)和(v, u)则

不可混淆。这

里约定，

有向

边(u, v)从u指向v，其

中u称作该边

的起点（origin）或尾

顶点（tail），而v称作

该边的

终点

（destination）或头顶点（head）。

若

E中各边均无

方向，则G称作

无向图（undirected graph，简称

undigraph）。例如在描

述

影视演员相

互合作关系

的图G中，若演

员u和v若曾经

共同出演过

至少一部影

片，则在他（她

）

们之间引入

一条边(u, v)。反之

，若E中只含有

向边，则G称作

有向图（directed graph，简称

digraph）。例如在C++类的

派生关系图

中，从顶点u指

向顶点v的有

向边，意味着

类u派生自类

v。

特别地，若E同

时包含无向

边和有向边

，则G称作混合

图（mixed

graph）。例如在北

京市内交通

图中，有些道

路是双行的

，另一些是单

行的，对应地

可分别描述

为无向边和

有向边。

图6.1 (a)无

向图、(b)混合图

和(c)有向图

相

对而言，有向

图的通用性

更强，因为无

向图和混合

图都可转化

为有向图如

图6.1所示，

每条

无向边(u, v)都可

等效地替换

为对称的一

对有向边(u, v)和

(v, u)。因此，本章将

主要针

对有

向图，介绍图

结构及其算

法的具体实

现。

 度

对于任

何边e

= (u, v)，称顶点

u和v彼此邻接

（adjacent），互为邻居；而

它们都与边

e

彼此关联（incident）。在

无向图中，与

顶点v关联的

边数，称作v的

度数（degree），记作deg(v)。

以

图6.1(a)为例，顶点

{ A, B, C,

D }的度数为{ 2, 3,

2, 1 }。

对

于有向边e

= (u, v)，e称

作u的出边（outgoing edge）、v的

入边（incoming

edge）。

v的出边

总数称作其

出度（out-degree），记作outdeg(v)；入

边总数称作

其入度（in-degree），

记作

indeg(v)。在图6.1(c)中，各顶

点的出度为

{ 1,

3, 1, 1 }，入度为{

2, 1, 2, 1

}。

 简单

图

联接于同

一顶点之间

的边，称作自

环（self-loop）。在某些特

定的应用中

，这类边可能

的

确具有意

义比如在城

市交通图中

，沿着某条街

道，有可能不

需经过任何

交叉路口即

可直接返

回

原处。不含任

何自环的图

称作简单图

（simple graph），也是本书主

要讨论的对

象。



通路与环

路

所谓路径

或通路（path），就是

由m + 1个顶点与

m条边交替而

成的一个序

列：

 = { v0,

e1, v1, e2, v2,

..., em, vm }

且对任何

0 < i 

m都有ei = (vi-1, vi)。也就是

说，这些边依

次地首尾相

联。其中沿途

边的总数m，亦

称作通路的

长度，记作||

= m。

为

简化描述，也

可依次给出

通路沿途的

各个顶点，而

省略联接于

其间的边，即

表示为：



= { v0, v1,

v2, ..., vm }

§6.1 概述

第6章 图

152

图6.2(a)中

的{ C, A, B,

A, D }，即是

从顶

点C到D的一条

通路，其长度

为4。可见，尽

管

通路上的边

必须互异，但

顶点却可能

重复。

沿途顶

点互异的通

路，称作简单

通路（simple 

path）。在图6.2(b)中

，{

C, A, D, B

}即

是从顶点

C到B的一条简

单通路，其长

度为3。

特别地

，对于长度m 

1的

通路，若起止

顶点相同（即

v0 = vm），则称作环路

（cycle），

其长度也取

作沿途边的

总数。图6.3(a)中，{

C, 

A, B,

A, D, B, C

}即

是一条环路

，其长度为

6。反

之，不含任何

环路的有向

图，称作有向

无

环图（directed acyclic

graph, DAG）。

同样

，尽管环路上

的各边必须

互异，但顶

点

却也可能重

复。反之若沿

途除v0

= vm外所有

顶点均互异

，则称作简单

环路（simple cycle）。

例如，图

6.3(b)中的{

C, A, B, C

}即是一

条简单环路

，其长度为3。特

别地，经过图

中各

边一次

且恰好一次

的环路，称作

欧拉环路

（Eulerian tour）当

然，其长度也

恰好

等于图

中边的总数

e。

图6.2 通路不简

单通路

图6.3

环

路不简单环

路

图6.4 欧拉环

路不哈密尔

须环路

图6.4(a)中

的{

C, A, B, A,

D, C, D, B,

C }即是一条

欧拉环路，其

长度为8。对偶

地，

经过图中

各顶点一次

且恰好一次

的环路，称作

哈密尔顿环

路（Hamiltonian tour），其长度亦

等于构成环

路的边数。图

6.4(b)中，{

C, A, D, B,

C }即是一条

长度为4的哈

密尔顿环路

。

 带权网络

图

不仅需要表

示顶点之间

是否存在某

种关系，有时

还需要表示

这一关系的

具体细节。以

铁路

运输为

例，可以用顶

点表示城市

，用顶点之间

的联边，表示

对应的城市

之间是否有

客运铁路联

接；

同时，往往

还需要记录

各段铁路的

长度、承运能

力，以及运输

成本等信息

。

为适应这类

应用要求，需

通过一个权

值函数，为每

一边e指定一

个权重（weight），比如

wt(e)

即为边e的权

重。各边均带

有权重的图

，称作带权图

（weighted graph）或带权网络

（weighted 

network），有时也简称

网络（network），记作G(V,

E, wt())。

 复

杂度

与其它

算法一样，图

算法也需要

就时间性能

和空间性能

，进行分析和

比较。相应地

，问题的

输入

规模，也应该

以顶点数与

边数的总和

（n + e）来度量。不难

看出，无论顶

点多少，边数

都

有可能为

0。那么反过来

，在包含n个顶

点的图中，至

多可能包含

多少条边呢

？

对于无向图

，每一对顶点

至多贡献一

条边，故总共

不超过n(n - 1)/2条边

，且这个上界

由

完全图达

到。对于有向

图，每一对顶

点都可能贡

献（互逆的）两

条边，因此至

多可有n(n - 1)

条边

。总而言之，必

有e

= O(n2

)。

第6章

图 §6.2 抽

象数据类型

153

§6.2

抽象数据类

型

6.2.1 操作接口

作为抽象数

据类型，图支

持的操作接

口分为边和

顶点两类，分

列于表6.1和表

6.2。

表6.1

图ADT支持癿

边操作接口

操 作 接 口

功

能 描 述

e()

边总

数|E|

exist(v, u) 刞断联边

(v,

u)是否存在

insert(v, u) 引

入从顶点v刡

u癿联边

remove(v, u) 初除

从顶点v刡u癿

联边

type(v,

u) 边在遍

历树中所属

癿类型

edge(v, u)

边所

对应癿数据

域

weight(v, u) 边癿权重

表6.2

图ADT支持癿

顶点操作接

口

操 作 接

口

功 能 描 述

n() 顶

点总数| |

inser

(v) 在顶

点集V中揑入

新顶点v

remo e(v)

将顶

点v从顶点集

中初除

outDegre

inDegree(v)

e(v)

顶点

v癿入度、出度

firstNbr(v) 顶点v癿首个

邻接顶点

nextNbr(v, u)

在

v癿邻接顶点

中，u癿后继

status(v) 顶

点v癿状态

dTime(v)、fTime(v)

顶

点v癿时间标

签

parent(v) 顶点v在遍

历树中癿父

节点

priority(v)

顶点v在

遍历树中癿

权重

6.2.2 Graph模板类

代码6.1以抽象

模板类的形

式，给出了图

ADT的具体定义

。

1

typedef enum { UNDISCOVERED,

DISCOVERED, VISITED } VStatus;

//顶点状态

2 typedef enum

{ UNDETERMINED, TREE, CROSS,

FORWARD, BACKWARD } EType;

//边

在遍历树中

所属癿类型

3

4 template <typename

Tv, typename Te> //顶点类型、边

类型

5 class Graph {

//图Graph模板

类

6 private:

7

void reset() { //所有顶点

、边癿辅劣信

息复位

8 for ( int

i = 0; i

< n; i++ )

{ //所有

顶点癿

9 status

( i ) =

UNDISCOVERED; dTime ( i

) = fTime (

i ) = -1;

//状态

，时间标签

10 parent (

i ) = -1;

priority ( i )

= INT_MAX; //（在

遍历树中癿

）父节点，优先

级数

11

for ( int j

= 0; j <

n; j++ ) //所有边

癿

12 if ( exists

( i, j )

) type ( i,

j ) = UNDETERMINED;

//类型

13 }

14

}

15 void BFS

( int, int& );

//（连通

域）广度优先

搜索算法

16 void DFS

( int, int& );

//（连

通域）深度优

先搜索算法

17 void BCC (

int, int&, Stack<int>& );

//（连通域）基亍

DFS癿双连通分

量分解算法

18 bool TSort (

int, int&, Stack<Tv>* );

//（连通域）基亍

DFS癿拓扑排序

算法

19 template <typename

PU> void PFS (

int, PU ); //（连通域

）优先级搜索

框架

§6.2 抽象数

据类型 第6章

图

154

20 public:

21 //

顶点

22 int n;

//顶点

总数

23 virtual int

insert ( Tv const&

) = 0; //揑入顶

点，迒回编号

24

virtual Tv remove (

int ) = 0;

//初除顶点及

其兲联边，迒

回诠顶点信

息

25 virtual Tv&

vertex ( int )

= 0; //顶点v癿数

据（诠顶点癿

确存在）

26

virtual int inDegree (

int ) = 0;

//顶点

v癿入度（诠顶

点癿确存在

）

27 virtual int

outDegree ( int )

= 0; //顶点v癿出度

（诠顶点癿确

存在）

28

virtual int firstNbr (

int ) = 0;

//顶点v癿

首个邻接顶

点

29 virtual int

nextNbr ( int, int

) = 0; //顶点v癿（相

对亍顶点j癿

）下一邻接顶

点

30 virtual VStatus& status

( int ) =

0; //顶点v癿状

态

31 virtual

int& dTime ( int

) = 0; //顶点v癿时

间标签dTime

32 virtual int& fTime

( int ) =

0; //顶点

v癿时间标签

fTime

33 virtual

int& parent ( int

) = 0; //顶点v在遍历

树中癿父亲

34

virtual int& priority (

int ) = 0;

//顶点v在遍历

树中癿优先

级数

35 // 边：返里

约定，无向边

均统一转化

为斱向互逆

癿一对有向

边，从而将无

向图规作有

向图癿特例

36

int e; //边总数

37

virtual bool exists (

int, int ) =

0; //边(v, u)是

否存在

38

virtual void insert (

Te const&, int, int,

int ) = 0;

//在顶

点v和u乀间揑

入权重为w癿

边e

39 virtual Te

remove ( int, int

) = 0; //初除顶点

v和u乀间癿边

e，迒回诠边信

息

40 virtual EType& type

( int, int )

= 0; //边(v, u)癿类型

41

virtual Te& edge (

int, int ) =

0; //边(v, u)癿数据（诠

边癿确存在

）

42

virtual int& weight (

int, int ) =

0; //边(v, u)癿权重

43

// 算

法

44 void

bfs ( int );

//广度优先

搜索算法

45 void dfs

( int ); //深

度优先搜索

算法

46 void bcc (

int ); //基亍DFS癿

双连通分量

分解算法

47

Stack<Tv>* tSort ( int

); //基

亍DFS癿拓扑排

序算法

48 void

prim ( int );

//最小

支撑树Prim算法

49 void dijkstra (

int ); //最短路径Dijkstra算

法

50

template <typename PU> void

pfs ( int, PU

); //优先级搜

索框架

51 };

代码

6.1 图ADT操作接口

仍为简化起

见，这里直接

开放了变量

n和e。除以上所

列的操作接

口，这里还明

确定义了顶

点和边可能

处于的若干

状态，并通过

内部接口reset()复

位顶点和边

的状态。

图的

部分基本算

法在此也以

操作接口的

形式供外部

用户直接使

用，比如广度

优先搜索、深

度

优先搜索

、双连通分量

分解、最小支

撑树、最短路

径等。为求解

更多的具体

应用问题，读

者可照

此模

式，独立地补

充相应的算

法。

就功能而

言，这些算法

均超脱于图

结构的具体

实现方式，借

助统一的顶

点和边ADT操作

接口

直接编

写。尽管如此

，正如以下即

将看到的，图

算法的时间

、空间性能，却

与图结构的

具体实现

方

式紧密相关

，在这方面的

理解深度，也

将反映和决

定我们对图

结构的驾驭

与运用能力

。

第6章 图 §6.3 邻接

矩阵

155

§6.3 邻接矩

阵

6.3.1

原理

邻接

矩阵（adjacency matrix）是图ADT最

基本的实现

方式，使用方

阵A[n][n]表示由n

个

顶点构成的

图，其中每个

单元，各自负

责描述一对

顶点之间可

能存在的邻

接关系，故此

得名。

图6.5 邻接

矩阵（空白单

元对应癿边

丌存在，其统

一叏值标注

二矩阵最左

上角）

对于无

权图，存在

（不

存在）从顶点

u到v的

边，当且

仅当A[u][v] = 

1（0）。图6.5(a)和(b)

即

为无向图和

有向图的

邻

接矩阵实例

。

这一表示方

式，不难

推广

至带权网络

。此时如

图(c)所

示，矩阵各单

元

可从布尔

型改为整型

或

浮点型，记

录所对应边

的

权重。对于

不存在的边

，

通常统一取

值为或0。

6.3.2 实现

基于以上原

理与构思实

现的图结构

如代码6.2所示

。

1

#include "../Vector/Vector.h" //引入向量

2

#include "../Graph/Graph.h" //引

入图ADT

3

4 template <typename Tv>

struct Vertex { //顶点对

象（为简化起

见，幵未严格

封装）

5 Tv data; int

inDegree, outDegree; VStatus status;

//数据、出

入度数、状态

6 int dTime, fTime;

//时间标签

7 int parent;

int priority; //在

遍历树中癿

父节点、优先

级数

8

Vertex ( Tv const&

d = ( Tv

) 0 ) :

//极造新

顶点

9 data (

d ), inDegree (

0 ), outDegree (

0 ), status (

UNDISCOVERED ),

10 dTime

( -1 ), fTime

( -1 ), parent

( -1 ), priority

( INT_MAX ) {}

//暂丌考

虑权重溢出

11 };

12

13

template <typename Te> struct

Edge { //边对象（为简

化起见，幵未

严格封装）

14

Te data; int weight;

EType type; //数

据、权重、类型

15 Edge

( Te const& d,

int w ) :

data ( d ),

weight ( w ),

type ( UNDETERMINED )

{} //极造

16 };

17

18 template <typename

Tv, typename Te> //顶点类

型、边类型

§6.3 邻

接矩阵 第6章

图

156

19 class GraphMatrix :

public Graph<Tv, Te> {

//基亍向量

，以邻接矩阵

形式实现癿

图

20 private:

21

Vector< Vertex< Tv >

> V; //顶点集（向

量）

22

Vector< Vector< Edge< Te

> * > >

E; //边集（邻接

矩阵）

23 public:

24 GraphMatrix() { n

= e = 0;

} //极造

25 ~GraphMatrix()

{ //枂

极

26 for

( int j =

0; j < n;

j++ ) //所有劢态

创建癿

27

for ( int k

= 0; k <

n; k++ ) //边记

弽

28 delete E[j][k]; //逐条清除

29

}

30 // 顶点癿基本

操作：查诟第

i个顶点（0

<= i < n）

31 virtual Tv& vertex

( int i )

{ return V[i].data; }

//数据

32 virtual int inDegree

( int i )

{ return V[i].inDegree; }

//入度

33 virtual int

outDegree ( int i

) { return V[i].outDegree;

} //出度

34 virtual

int firstNbr ( int

i ) { return

nextNbr ( i, n

); } //首

个邻接顶点

35 virtual

int nextNbr ( int

i, int j )

//相对亍顶点

j癿下一邻接

顶点（改用邻

接表可提高

效率）

36 { while

( ( -1 <

j ) && (

!exists ( i, --j

) ) ); return

j; } //逆向线

性试探

37

virtual VStatus& status (

int i ) {

return V[i].status; } //状态

38

virtual int& dTime (

int i ) {

return V[i].dTime; } //时间标签dTime

39 virtual int& fTime

( int i )

{ return V[i].fTime; }

//时

间标签fTime

40 virtual int&

parent ( int i

) { return V[i].parent;

} //在遍

历树中癿父

亲

41 virtual

int& priority ( int

i ) { return

V[i].priority; } //在遍历树

中癿优先级

数

42

// 顶点癿劢

态操作

43 virtual

int insert ( Tv

const& vertex ) {

//揑入

顶点，迒回编

号

44 for (

int j = 0;

j < n; j++

) E[j].insert ( NULL

); n++; //各顶点预

留一条潜在

癿兲联边

45

E.insert ( Vector<Edge<Te>*> (

n, n, ( Edge<Te>*

) NULL ) );

//创

建新顶点对

应癿边向量

46 return V.insert (

Vertex<Tv> ( vertex )

); //顶点向量增

加一个顶点

47 }

48

virtual Tv remove (

int i ) {

//初除第i个顶

点及其兲联

边（0 <= i <

n）

49 for (

int j = 0;

j < n; j++

) //所有出边

50 if (

exists ( i, j

) ) { delete

E[i][j]; V[j].inDegree--; } //逐条初除

51 E.remove ( i

); n--; //初

除第i行

52

Tv vBak = vertex

( i ); V.remove

( i ); //初除

顶点i

53 for ( int

j = 0; j

< n; j++ )

//所有入

边

54 if (

Edge<Te> * e =

E[j].remove ( i )

) { delete e;

V[j].outDegree--; } //逐条初除

55 return

vBak; //迒回被初除

顶点癿信息

56 }

57

// 边癿确讣操

作

58 virtual

bool exists ( int

i, int j )

//边(i, j)是否存

在

59 {

return ( 0 <=

i ) && (

i < n )

&& ( 0 <=

j ) && (

j < n )

&& E[i][j] != NULL;

}

60 // 边癿基本

操作：查诟顶

点i不j乀间癿

联边（0

<= i, j <

n且exists(i, j)）

第6章

图 §6.3

邻接矩阵

157

61 virtual EType&

type ( int i,

int j ) {

return E[i][j]->type; } //边(i,

j)癿类型

62 virtual Te&

edge ( int i,

int j ) {

return E[i][j]->data; } //边

(i,

j)癿数据

63 virtual int&

weight ( int i,

int j ) {

return E[i][j]->weight; } //边(i,

j)癿

权重

64 // 边癿劢

态操作

65 virtual void insert

( Te const& edge,

int w, int i,

int j ) {

//揑入

权重为w癿边

e = (i, j)

66 if ( exists

( i, j )

) return; //确保诠边尚

丌存在

67

E[i][j] = new Edge<Te>

( edge, w );

//创建

新边

68 e++; V[i].outDegree++;

V[j].inDegree++; //更新边

计数不兲联

顶点癿度数

69 }

70

virtual Te remove (

int i, int j

) { //初除顶点i和

j乀间癿联边

（exists(i, j)）

71 Te eBak =

edge ( i, j

); delete E[i][j]; E[i][j]

= NULL; //备仹后初除

边记弽

72

e--; V[i].outDegree--; V[j].inDegree--; //更新

边计数不兲

联顶点癿度

数

73 return eBak; //迒回被初

除边癿信息

74

}

75 };

代码6.2

基二邻

接矩阵实现

癿图结极

可

见，这里利用

第2章实现并

封装的Vector结构

，在内部将所

有顶点组织

为一个向量

V[]；

同时通过嵌

套定义，将所

有（潜在的）边

组织为一个

二维向量E[][]亦

即邻接矩阵

。

每个顶点统

一表示为Vertex对

象，每条边统

一表示为Edge对

象。

边对象的

属性weight统一简

化为整型，既

可用于表示

无权图，亦可

表示带权网

络。

6.3.3 时间性能

按照代码6.2的

实现方式，各

顶点的编号

可直接转换

为其在邻接

矩阵中对应

的秩，从而使

得

图ADT中所有

的静态操作

接口，均只需

O(1)时间这主要

是得益于向

量“循秩访问

”的特长与优

势。另外，边的

静态和动态

操作也仅需

O(1)时间其代价

是邻接矩阵

的空间冗余

。

然而，这种方

法并非完美

无缺。其不足

主要体现在

，顶点的动态

操作接口均

十分耗时。为

了

插入新的

顶点，顶点集

向量V[]需要添

加一个元素

；边集向量E[][]也

需要增加一

行，且每行都

需要添加一

个元素。顶点

删除操作，亦

与此类似。不

难看出，这些

恰恰也是向

量结构固有

的不足。

好在

通常的算法

中，顶点的动

态操作远少

于其它操作

。而且，即便计

入向量扩容

的代价，就

分

摊意义而言

，单次操作的

耗时亦不过

O(n)（习题[6-2]）。

6.3.4 空间性

能

上述实现

方式所用空

间，主要消耗

于邻接矩阵

，亦即其中的

二维边集向

量E[][]。每个Edge

对象

虽需记录多

项信息，但总

体不过常数

。根据2.4.4节的分

析结论，Vector结构

的装填因子

始

终不低于

50%，故空间总量

渐进地不超

过O(n  n) =

O(n2

)。

当然，对于

无向图而言

，仍有改进的

余地。如图6.5(a)所

示，无向图的

邻接矩阵必

为对称

阵，其

中除自环以

外的每条边

，都被重复地

存放了两次

。也就是说，近

一半的单元

都是冗余的

。

为消除这一

缺点，可采用

压缩存储等

技巧，进一步

提高空间利

用率（习题[6-4]）。

§6.4 邻

接表 第6章

图

158

§6.4 邻接表

6.4.1

原理

即便就有向

图而言，(n2

)的空

间亦有改进

的余地。实际

上，如此大的

空间足以容

纳所有潜

在

的边。然而实

际应用所处

理的图，所含

的边通常远

远少于O(n2

)。比如

在平面图之

类的稀疏图

（sparse

graph）中，边数渐进

地不超过O(n)，仅

与顶点总数

大致相当（习

题[6-3]）。

由此可见

，邻接矩阵的

空间效率之

所以低，是因

为其中大量

单元所对应

的边，通常并

未在图

中出

现。因静态空

间管理策略

导致的此类

问题，并非首

次出现，比如

此前的2.4节，就

曾指出这

类

缺陷并试图

改进。既然如

此，为何不仿

照3.1节的思路

，将这里的向

量替换为列

表呢？

是的，按

照这一思路

，的确可以导

出图结构的

另一种表示

与实现形式

。

图6.6 以邻接表

斱式描述和

实现图

以如

图6.6(a)所示的无

向图为例，只

需将如图(b)所

示的邻接矩

阵，逐行地转

换为如图(c)

所

示的一组列

表，即可分别

记录各顶点

的关联边（或

等价地，邻接

顶点）。这些列

表，也因此称

作邻接表（adjacency list）。实

际上，这种通

用方法不难

推广至有向

图（习题[6-5]）。

6.4.2 复杂

度

可见，邻接

表所含列表

数等于顶点

总数n，每条边

在其中仅存

放一次（有向

图）或两次（无

向图），故空间

总量为O(n + e)，与图

自身的规模

相当，较之邻

接矩阵有很

大改进。

当然

，空间性能的

这一改进，需

以某些方面

时间性能的

降低为代价

。比如，为判断

顶点v到

u的联

边是否存在

，exists(v, u)需在v对应的

邻接表中顺

序查找，共需

O(n)时间。

与顶点

相关操作接

口，时间性能

依然保持，甚

至有所提高

。比如，顶点的

插入操作，可

在

O(1)而不是O(n)时

间内完成。当

然，顶点的删

除操作，仍需

遍历所有邻

接表，共需O(e)时

间。

尽管邻接

表访问单条

边的效率并

不算高，却十

分擅长于以

批量方式，处

理同一顶点

的所有关

联

边。在以下图

遍历等算法

中，这是典型

的处理流程

和模式。比如

，为枚举从顶

点v发出的所

有

边，现在仅

需(1 +

outDegree(v))而非(n)时间

。故总体而言

，邻接表的效

率较之邻接

矩阵

更高。因

此，本章对以

下各算法的

复杂度分析

，多以基于邻

接表的实现

方式为准。

第

6章 图

§6.6 广度优

先搜索

159

§6.5

图遍

历算法概述

图算法是个

庞大的家族

，其中大部分

成员的主体

框架，都可归

结于图的遍

历。与5.4节中树

的遍历类似

，图的遍历也

需要访问所

有顶点一次

且仅一次；此

外，图遍历同

时还需要访

问所有的

边

一次且仅一

次尽管对树

而言这显而

易见并对边

做分类，以便

后续的处理

。

实际上，无论

采用何种策

略和算法，图

的遍历都可

理解为，将非

线性结构转

化为半线性

结构

的过程

。经遍历而确

定的边类型

中，最重要的

一类即所谓

的树边，它们

与所有顶点

共同构成了

原

图的一棵

支撑树（森林

），称作遍历树

（traversal tree）。以遍历树为

背景，其余各

种类型

的边

，也能提供关

于原图的重

要信息，比如

其中所含的

环路等。

图中

顶点之间可

能存在多条

通路，故为避

免对顶点的

重复访问，在

遍历的过程

中，通常还要

动态地设置

各顶点不同

的状态，并随

着遍历的进

程不断地转

换状态，直至

最后的“访问

完毕”。

图的遍

历更加强调

对处于特定

状态顶点的

甄别与查找

，故也称作图

搜索（graph search）。

与树遍

历一样，作为

图算法基石

的图搜索，本

身也必须能

够高效地实

现。幸运的是

，正如我

们马

上就会看到

的，诸如深度

优先、广度优

先、最佳优先

等基本而典

型的图搜索

，都可以在线

性

时间内完

成。准确地，若

顶点数和边

数分别为n和

e，则这些算法

自身仅需O(n + e)时

间。既然

图搜

索需要访问

所有的顶点

和边，故这已

经是我们所

能期望的最

优的结果。

§6.6 广

度优先搜索

6.6.1 策略

各种图

搜索之间的

区别，体现为

边分类结果

的不同，以及

所得遍历树

（森林）的结构

差异。

其决定

因素在于，搜

索过程中的

每一步迭代

，将依照何种

策略来选取

下一接受访

问的顶点。

通

常，都是选取

某个已访问

到的顶点的

邻居。同一顶

点所有邻居

之间的优先

级，在多数遍

历

中不必讲

究。因此，实质

的差异应体

现在，当有多

个顶点已被

访问到，应该

优先从谁的

邻居中选

取

下一顶点。比

如，广度优先

搜索（breadth-first

search, BFS）采用的

策略，可概括

为：

越早被访

问到的顶点

，其邻居越优

先被选用

于

是，始自图中

顶点s的BFS搜索

，将首先访问

顶点s；再依次

访问s所有尚

未访问到的

邻居；

再按后

者被访问的

先后次序，逐

个访问它们

的邻居；...；如此

不断。在所有

已访问到的

顶点中，

仍有

邻居尚未访

问者，构成所

谓的波峰集

（frontier）。于是，BFS搜索过

程也可等效

地理解为：

反

复从波峰集

中找到最早

被访问到顶

点v，若其邻居

均已访问到

，则将其逐出

波

峰集；否则

，随意选出一

个尚未访问

到的邻居，并

将其加入到

波峰集中

不

难发现，若将

上述BFS策略应

用于树结构

，则效果等同

于层次遍历

（5.4.5节）波峰

集内

顶点的深度

始终相差不

超过一，且波

峰集总是优

先在更浅的

层次沿广度

方向拓展。实

际上，

树层次

遍历的这些

特性，在一定

程度上也适

用于图的BFS搜

索（习题[6-7]）。

由于

每一步迭代

都有一个顶

点被访问，故

至多迭代O(n)步

。另一方面，因

为不会遗漏

每个

刚被访

问顶点的任

何邻居，故对

于无向图必

能覆盖s所属

的连通分量

（connected component），

对于有向图

必能覆盖以

s为起点的可

达分量（reachable component）。倘若

还有来自其

它连通

分量

或可达分量

的顶点，则不

妨从该顶点

出发，重复上

述过程。

§6.6 广度

优先搜索 第

6章

图

160

6.6.2 实现

图

的广度优先

搜索算法，可

实现如代码

6.3所示。

1 template <typename

Tv, typename Te> //广度优

先搜索BFS算法

（全图）

2 void Graph<Tv, Te>::bfs

( int s )

{ //assert: 0 <=

s < n

3

reset(); int clock =

0; int v =

s; //刜始化

4 do //逐一检查所

有顶点

5 if ( UNDISCOVERED

== status ( v

) ) //一旦

遇刡尚未収

现癿顶点

6

BFS ( v, clock

); //即

从诠顶点出

収启劢一次

BFS

7 while

( s != (

v = ( ++v

% n ) )

); //按序号检查

，故丌漏丌重

8 }

9

10 template <typename Tv,

typename Te> //广度优先搜

索BFS算法（单个

连通域）

11

void Graph<Tv, Te>::BFS (

int v, int& clock

) { //assert: 0

<= v < n

12 Queue<int> Q; //引入

辅劣队列

13 status ( v

) = DISCOVERED; Q.enqueue

( v ); //刜

始化起点

14 while ( !Q.empty()

) { //在

Q发空乀前，丌

断

15

int v = Q.dequeue();

dTime ( v )

= ++clock; //叏出队首

顶点v

16

for ( int u

= firstNbr ( v

); -1 < u;

u = nextNbr (

v, u ) )

//构丼v癿

所有邻屁u

17 if (

UNDISCOVERED == status (

u ) ) {

//若

u尚未被収现

，则

18 status (

u ) = DISCOVERED;

Q.enqueue ( u );

//収现诠顶

点

19 type (

v, u ) =

TREE; parent ( u

) = v; //引入树边

拓展支撑树

20

} else { //若u已被収现

，戒者甚至已

讵问完毕，则

21

type ( v, u

) = CROSS; //将(v,

u)弻类亍跨

边

22 }

23

status ( v )

= VISITED; //至此，弼前

顶点讵问完

毕

24

}

25 }

代码6.3

BFS算法

算法的实质

功能，由子算

法BFS()完成。对该

函数的反复

调用，即可遍

历所有连通

或可达域。

仿

照树的层次

遍历，这里也

借助队列Q，来

保存已被发

现，但尚未访

问完毕的顶

点。因此，

任何

顶点在进入

该队列的同

时，都被随即

标记为DISCOVERED（已发

现）状态。

BFS()的每

一步迭代，都

先从Q中取出

当前的首顶

点v；再逐一核

对其各邻居

u的状态并做

相

应处理；最

后将顶点v置

为VISITED（访问完毕

）状态，即可进

入下一步迭

代。

若顶点u尚

处于UNDISCOVERED（未发现

）状态，则令其

转为DISCOVERED状态，并

随即加入

队

列Q。实际上，每

次发现一个

这样的顶点

u，都意味着遍

历树可从v到

u拓展一条边

。于是，将

边(v,

u)标

记为树边（tree edge），并

按照遍历树

中的承袭关

系，将v记作u的

父节点。

若顶

点u已处于DISCOVERED状

态（无向图），或

者甚至处于

VISITED状态（有向图

），则意

味着边

(v,

u)不属于遍历

树，于是将该

边归类为跨

边（cross edge）（习题[6-11]）。

BFS()遍历

结束后，所有

访问过的顶

点通过parent[]指针

依次联接，从

整体上给出

了原图

某一

连通或可达

域的一棵遍

历树，称作广

度优先搜索

树，或简称BFS树

（BFS

tree）。

第6章 图 §6.6

广度

优先搜索

161

6.6.3 实

例

图6.7给出了

一个含8个顶

点和11条边的

有向图，起始

于顶点S的BFS搜

索过程。请留

意观察

辅助

队列（下方）的

演变，顶点状

态的变化，边

的分类与结

果，以及BFS树的

生长过程。

图

6.7 广度优先搜

索示例

不难

看出，BFS(s)将覆盖

起始顶点s所

属的连通分

量或可达分

量，但无法抵

达此外的顶

点。

而上层主

函数bfs()的作用

，正在于处理

多个连通分

量或可达分

量并存的情

况。具体地，在

逐个

检查顶

点的过程中

，只要发现某

一顶点尚未

被发现，则意

味着其所属

的连通分量

或可达分量

尚未

触及，故

可从该顶点

出发再次启

动BFS()，以遍历其

所属的连通

分量或可达

分量。如此，各

次BFS()

调用所得

的BFS树构成一

个森林，称作

BFS森林（BFS forest）。

6.6.4 复杂度

除作为输入

的图本身外

，BFS搜索所使用

的空间，主要

消耗在用于

维护顶点访

问次序的辅

助

队列、用于

记录顶点和

边状态的标

识位向量，累

计O(n) + O(n) +

O(e) = O(n +

e)。

时间方面

，首先需花费

O(n + e)时间复位所

有顶点和边

的状态。不计

对子函数BFS()的

调

用，bfs()本身对

所有顶点的

枚举共需O(n)时

间。而在对BFS()的

所有调用中

，每个顶点、每

条

边均只耗

费O(1)时间，累计

O(n + e)。综合起来，BFS搜

索总体仅需

O(n

+ e)时间。

6.6.5 应用

基

于BFS搜索，可有

效地解决连

通域分解（习

题[6-6]）、最短路径

（习题[6-8]）等问题

。

§6.7 深度优先搜

索 第6章

图

162

§6.7 深

度优先搜索

6.7.1

策略

深度优

先搜索（Depth-First Search, DFS）选取

下一顶点的

策略，可概括

为：

优先选取

最后一个被

访问到的顶

点的邻居

于

是，以顶点s为

基点的DFS搜索

，将首先访问

顶点s；再从s所

有尚未访问

到的邻居中

任取

其一，并

以之为基点

，递归地执行

DFS搜索。故各顶

点被访问到

的次序，类似

于树的先序

遍历

（5.4.2节）；而各

顶点被访问

完毕的次序

，则类似于树

的后序遍历

（5.4.4节）。

6.7.2 实现

深度

优先遍历算

法可实现如

代码6.4所示。

1

template <typename Tv, typename

Te> //深

度优先搜索

DFS算法（全图）

2 void

Graph<Tv, Te>::dfs ( int

s ) { //assert:

0 <= s <

n

3 reset(); int

clock = 0; int

v = s; //刜

始化

4 do //逐一检

查所有顶点

5 if

( UNDISCOVERED == status

( v ) )

//一旦遇刡尚

未収现癿顶

点

6 DFS (

v, clock ); //即从诠顶

点出収启劢

一次DFS

7 while ( s

!= ( v =

( ++v % n

) ) ); //按序号

检查，故丌漏

丌重

8 }

9

10

template <typename Tv, typename

Te> //深度优

先搜索DFS算法

（单个连通域

）

11 void

Graph<Tv, Te>::DFS ( int

v, int& clock )

{ //assert: 0 <=

v < n

12

dTime ( v )

= ++clock; status (

v ) = DISCOVERED;

//収现弼前顶

点v

13 for (

int u = firstNbr

( v ); -1

< u; u =

nextNbr ( v, u

) ) //构丼v癿所

有邻屁u

14

switch ( status (

u ) ) {

//幵规

其状态分删

处理

15 case UNDISCOVERED:

//u尚未収

现，意味着支

撑树可在此

拓展

16 type (

v, u ) =

TREE; parent ( u

) = v; DFS

( u, clock );

break;

17 case DISCOVERED:

//u已被収

现但尚未讵

问完毕，应属

被后代指向

癿祖先

18 type (

v, u ) =

BACKWARD; break;

19 default:

//u已讵

问完毕（VISITED，有向

图），则规承袭

兲系分为前

向边戒跨边

20 type ( v,

u ) = (

dTime ( v )

< dTime ( u

) ) ? FORWARD

: CROSS; break;

21

}

22 status (

v ) = VISITED;

fTime ( v )

= ++clock; //至此，弼前顶

点v斱告讵问

完毕

23

}

代码6.4 DFS算

法

算法的实

质功能，由子

算法DFS()递归地

完成。每一递

归实例中，都

先将当前节

点v标记为

DISCOVERED（已

发现）状态，再

逐一核对其

各邻居u的状

态并做相应

处理。待其所

有邻居均已

处

理完毕之

后，将顶点v置

为VISITED（访问完毕

）状态，便可回

溯。

若顶点u尚

处于UNDISCOVERED（未发现

）状态，则将边

(v, u)归类为树边

（tree

edge），

第6章 图 §6.7

深度

优先搜索

163

并

将v记作u的父

节点。此后，便

可将u作为当

前顶点，继续

递归地遍历

。

若顶点u处于

DISCOVERED状态，则意味

着在此处发

现一个有向

环路。此时，在

DFS遍历树中

u必

为v的祖先（习

题[6-13]），故应将边

(v, u)归类为后向

边（back edge）。

这里为每

个顶点v都记

录了被发现

的和访问完

成的时刻，对

应的时间区

间[dTime(v),

fTime(v)]均称作v的

活跃期（active duration）。实际

上，任意顶点

v和u之间是否

存在祖先

/后

代的“血缘”关

系，完全取决

于二者的活

跃期是否相

互包含（习题

[6-12]）。

对于有向图

，顶点u还可能

处于VISITED状态。此

时，只要比对

v与u的活跃期

，即可判定在

DFS树中v是否为

u的祖先。若是

，则边(v,

u)应归类

为前向边（forward edge）；否

则，二者

必然

来自相互独

立的两个分

支，边(v, u)应归类

为跨边（cross

edge）。

DFS(s)返回

后，所有访问

过的顶点通

过parent[]指针依次

联接，从整体

上给出了顶

点s所

属连通

或可达分量

的一棵遍历

树，称作深度

优先搜索树

或DFS树（DFS tree）。与BFS搜索

一样，

此时若

还有其它的

连通或可达

分量，则可以

其中任何顶

点为基点，再

次启动DFS搜索

。

最终，经各次

DFS搜索生成的

一系列DFS树，构

成了DFS森林（DFS forest）。

6.7.3

实

例

图6.8针对含

7个顶点和10条

边的某有向

图，给出了DFS搜

索的详细过

程。请留意观

察顶点时

间

标签的设置

，顶点状态的

演变，边的分

类和结果，以

及DFS树（森林）的

生长过程。

图

6.8

深度优先搜

索实例（粗边

框白色，为当

前顶点；细边

框白色、双边

框白色和黑

色，分删为处

二

UNDISCOVERED、DISCOVERED和VISITED状态癿

顶点；dTime和fTime标签

，分删标注二

各顶点癿左

右）

§6.7 深度优先

搜索

第6章 图

164

图6.8 深度优先

搜索实例（续

）：(a~m)对应二DFS(A)，(n~s)为随

后癿DFS(D)

最终结

果如图(t)所示

，为包含两棵

DFS树的一个DFS森

林。可以看出

，选用不同的

起始基点，

生

成的DFS树（森林

）也可能各异

。如本例中，若

从D开始搜索

，则DFS森林可能

如图(u)所示。

图

6.9 以

时 间 为 横

坐标，

绘 出 了

图

6.8(u)中DFS树内各

顶点的活跃

期。可以清

晰

地看出，活跃

期相互包含

的顶点，在DFS

树

中都是“祖先

-后代”关系（比

如B之于C，

或者

D之于F）；反之亦

然。

这种对应

关系并非偶

然，籍此可以

便捷

地判定

节点之间的

承袭关系（习

题[6-12]）。

故无论是

对DFS搜索本身

，还是对基于

DFS的

各种算法

而言，时间标

签都至关重

要。 图6.9

活跃期

不“祖先-后代

”关系乊间癿

对应关系

第

6章 图 §6.8

拓扑排

序

165

6.7.4 复杂度

除

了原图本身

，深度优先搜

索算法所使

用的空间，主

要消耗于各

顶点的时间

标签和状态

标记，

以及各

边的分类标

记，二者累计

不超过O(n) + O(e)

= O(n + e)。当然

，如采用以上

代码6.4

的直接

递归实现方

式，操作系统

为维护运行

栈还需耗费

一定量的空

间尽管这部

分增量在渐

进

意义下还

不足以动摇

以上结论。为

此，不妨仿照

5.4节的做法，通

过显式地引

入并维护一

个栈结

构，将

DFS算法改写为

迭代版本（习

题[6-14]）。

时间方面

，首先需要花

费O(n

+ e)时间对所

有顶点和边

的状态复位

。不计对子函

数DFS()

的调用，dfs()本

身对所有顶

点的枚举共

需O(n)时间。不计

DFS()之间相互的

递归调用，每

个顶

点、每条

边只在子函

数DFS()的某一递

归实例中耗

费O(1)时间，故累

计亦不过O(n

+ e)时

间。

综合而言

，深度优先搜

索算法也可

在O(n +

e)时间内完

成。

6.7.5 应用

深度

优先搜索无

疑是最为重

要的图遍历

算法。基于DFS的

框架，可以导

出和建立大

量的图算

法

。以4.4节英雄忒

修斯营救公

主的故事为

例，为寻找从

迷宫入口（起

始顶点）至公

主所在位置

（目标顶点）的

通路，可将迷

宫内不同位

置之间的联

接关系表示

为一幅图，并

将问题转化

为起点

和终

点之间的可

达性判定，从

而可利用DFS算

法便捷地加

以解决。非但

如此，一旦找

到通路，则

不

仅可以顺利

抵达终点与

公主会合，还

能沿这条通

路安全返回

。当然，与广度

优先搜索一

样，深

度优先

搜索也可用

作连通分量

的分解，或者

有向无环图

的判定。

下面

仅以拓扑排

序和双连通

域分解为例

，对DFS模式的应

用做更为具

体的介绍。

§6.8 拓

扑排序

6.8.1

应用

图6.10 拓扑排序

以教材的编

写这一实际

问题为例。首

先，作者可借

助有向图结

构，整理出相

关知识点之

间的

依赖关

系。如图6.10(a)所示

，因向量是散

列表和查找

表的基础知

识点，故从Vector发

出两条边

分

别指向Hashing和Search

Table；同

理，查找表是

二叉搜索树

的基础知识

点，故也从前

者引

出一条

边指向后者

；...；诸如此类。那

么，如何将这

些知识点串

联为一份教

学计划，以保

证在

整个授

课进程中，每

堂课的基础

知识点均在

此前业已讲

授呢？

§6.8

拓扑排

序 第6章 图

166

若

将图6.10(a)抽象为

图(b)，则不难看

出，图(c)就是一

份可行的教

材目录和授

课计划。

实际

上，许多应用

问题，都可转

化和描述为

这一标准形

式：给定描述

某一实际应

用（图(a)）的

有向

图（图(b)），如何在

与该图“相容

”的前提下，将

所有顶点排

成一个线性

序列（图(c)）。

此处

的“相容”，准确

的含义是：每

一顶点都不

会通过边，指

向其在此序

列中的前驱

顶点。

这样的

一个线性序

列，称作原有

向图的一个

拓扑排序（topological sorting）。

6.8.2 有

向无环图

那

么，拓扑排序

是否必然存

在？若存在，又

是否唯一？这

两个问题都

不难回答。

在

图6.10(c)中，顶点A和

B互换之后依

然是一个拓

扑排序，故知

同一有向图

的拓扑排序

未必

唯一。又

若在图(b)中引

入一条从顶

点F指向B的边

，使顶点B、C和F构

成一个有向

环路，则无论

如何也不可

能得到一个

“相容”的线性

序列，故拓扑

排序也未必

存在。

反之，不

含环路的有

向图有向无

环图一定存

在拓扑排序

吗？答案是肯

定的。

有向无

环图的拓扑

排序必然存

在；反之亦然

。这是因为，有

向无环图对

应于偏序关

系，而拓

扑排

序则对应于

全序关系。在

顶点数目有

限时，与任一

偏序相容的

全序必然存

在。

实际上，在

任一有限偏

序集中，必有

极值元素（尽

管未必唯一

）；相应地，任一

有向无环图

，

也必包含入

度为零的顶

点。否则，每个

顶点都至少

有一条入边

，这意味着图

中包含环路

。

于是，只要将

入度为0的顶

点m（及其关联

边）从图G中取

出，则剩余的

G'依然是有向

无环图，

故其

拓扑排序也

必然存在。从

递归的角度

看，一旦得到

了G'的拓扑排

序，只需将m作

为最大顶点

插入，即可得

到G的拓扑排

序。如此，我们

已经得到了

一个拓扑排

序的算法（习

题[6-18]）。

图6.11 刟用“DAG必

有零入度顶

点”癿特性，实

现拓扑排序

图6.11给出了该

算法的一个

实例。以下，将

转而从BFS搜索

入手，给出另

一拓扑排序

算法。

6.8.3 算法

不

妨将关注点

，转至与极大

顶点相对称

的极小顶点

。

同理，有限偏

序集中也必

然存在极小

元素（同样，未

必唯一）。该元

素作为顶点

，出度必然

为

零比如图6.10(b)中

的顶点D和F。而

在对有向无

环图的DFS搜索

中，首先因访

问完成而转

换至VISITED状态的

顶点m，也必然

具有这一性

质；反之亦然

。

进一步地，根

据DFS搜索的特

性，顶点m（及其

关联边）对此

后的搜索过

程将不起任

何作用。

于是

，下一转换至

VISITED状态的顶点

可等效地理

解为是，从图

中剔除顶点

m（及其关联边

）之

后的出度

为零者在拓

扑排序中，该

顶点应为顶

点m的前驱。由

此可见，DFS搜索

过程中各顶

点被标记为

VISITED的次序，恰好

（按逆序）给出

了原图的一

个拓扑排序

。

此外，DFS搜索善

于检测环路

的特性，恰好

可以用来判

别输入是否

为有向无环

图。具体地，

搜

索过程中一

旦发现后向

边，即可终止

算法并报告

“因非DAG而无法

拓扑排序”。

第

6章 图

§6.8 拓扑排

序

167

6.8.4

实现

基于

DFS搜索框架的

拓扑排序算

法，可实现如

代码6.5所示。

1 template

<typename Tv, typename Te>

//基

亍DFS癿拓扑排

序算法

2 Stack<Tv>* Graph<Tv,

Te>::tSort ( int s

) { //assert: 0

<= s < n

3 reset(); int clock

= 0; int v

= s;

4 Stack<Tv>*

S = new Stack<Tv>;

//用栈

记弽排序顶

点

5 do {

6 if ( UNDISCOVERED

== status ( v

) )

7 if

( !TSort ( v,

clock, S ) )

{ //clock幵非必需

8 while (

!S->empty() ) //仸一连通域

（亦即整图）非

DAG

9

S->pop(); break; //则丌必继续

计算，故直接

迒回

10

}

11 } while

( s != (

v = ( ++v

% n ) )

);

12 return S;

//若输入

为DAG，则S内各顶

点自顶向底

排序；否则（丌

存在拓扑排

序），S空

13 }

14

15 template <typename Tv,

typename Te> //基亍DFS癿

拓扑排序算

法（单趟）

16

bool Graph<Tv, Te>::TSort (

int v, int& clock,

Stack<Tv>* S ) {

//assert: 0 <= v

< n

17 dTime

( v ) =

++clock; status ( v

) = DISCOVERED; //収现

顶点v

18 for ( int

u = firstNbr (

v ); -1 <

u; u = nextNbr

( v, u )

) //构丼v癿

所有邻屁u

19 switch

( status ( u

) ) { //幵

规u癿状态分

删处理

20 case UNDISCOVERED:

21

parent ( u )

= v; type (

v, u ) =

TREE;

22 if (

!TSort ( u, clock,

S ) ) //从顶

点u处出収深

入搜索

23 return false; //若u及

其后代丌能

拓扑排序（则

全图亦必如

此），故迒回幵

报告

24 break;

25 case

DISCOVERED:

26 type (

v, u ) =

BACKWARD; //一旦収

现后向边（非

DAG），则

27 return

false; //丌必深入

，故迒回幵报

告

28 default:

//VISITED (digraphs only)

29

type ( v, u

) = ( dTime

( v ) <

dTime ( u )

) ? FORWARD :

CROSS;

30 break;

31

}

32 status (

v ) = VISITED;

S->push ( vertex (

v ) ); //顶点被标

记为VISITED时，随即

入栈

33 return true; //v及其后

代可以拓扑

排序

34 }

代码6.5 基

二DFS搜索框架

实现拓扑排

序算法

相对

于标准的DFS搜

索算法，这里

增设了一个

栈结构。一旦

某个顶点被

标记为VISITED状态

，

便随即令其

入栈。如此，当

搜索终止时

，所有顶点即

按照被访问

完毕的次序

亦即拓扑排

序的

次序在

栈中自顶而

下排列。

§6.9

*双连

通域分解 第

6章 图

168

6.8.5 实例

图

6.12以含6个顶点

和7

条边的有

向无环图为

例，给

出了以

上算法的执

行过程。

共分

三步迭代，分

别对应于

起

始于顶点C、B和

A的三趟

DFS搜索

。请留意观察

，各顶

点的入

栈次序。 图6.12 基

二DFS搜索癿拓

扑排序实例

另外，对照图

6.11中的结果可

见，因多个极

大、极小元素

（入度、出度为

零顶点）并存

而

导致拓扑

排序的不唯

一性并未消

除，而是转由

该算法对每

趟DFS起点的选

择策略决定

。

6.8.6 复杂度

这里

仅额外引入

的栈，规模不

超过顶点总

数O(n)。总体而言

，空间复杂度

与基本的深

度优

先搜索

算法同样，仍

为O(n

+ e)。该算法的

递归跟踪过

程与标准DFS搜

索完全一致

，且各递归实

例自身的执

行时间依然

保持为O(1)，故总

体运行时间

仍为O(n + e)。

为与基

本的DFS搜索算

法做对比，代

码6.5保留了代

码6.4的通用框

架，但并非所

有操作都与

拓扑排序直

接相关。因此

通过精简代

码，还可进一

步地优化（习

题[6-19]）。

§6.9 

*双连通域

分解

6.9.1 关节点

与双连通域

考查无向图

G。若删除顶点

v后G所包含的

连通域增多

，则v称作切割

节点（cut vertex）或

关节

点（articulation

point）。如图6.13中的

C即是一个关

节点它的删

除将导致连

通域

增加两

块。反之，不含

任何关节点

的图称作双

连通图。任一

无向图都可

视作由若干

个极大的双

连

通子图组

合而成，这样

的每一子图

都称作原图

的一个双连

通域（bi-connected component）。

例如图

6.14(a)中的无向图

，可分解为如

图(b)所示的三

个双连通域

。

图6.13 关节点 图

6.14

双还通域

较

之其它顶点

，关节点更为

重要。在网络

系统中它们

对应于网关

，决定子网之

间能否连通

。

在航空系统

中，某些机场

的损坏，将同

时切断其它

机场之间的

交通。故在资

源总量有限

的前提下，

找

出关节点并

重点予以保

障，是提高系

统整体稳定

性和鲁棒性

的基本策略

。

第6章 图 §6.9 *双连

通域分解

169

6.9.2 蛮

力算法

那么

，如何才能找

出图中的关

节点呢？

由其

定义，可直接

导出蛮力算

法大致如下

：首先，通过BFS或

DFS搜索统计出

图G所含连通

域

的数目；然

后逐一枚举

每个顶点v，暂

时将其从图

G中删去，并再

次通过搜索

统计出图G\{v}所

含

连通域的

数目。于是，顶

点v是关节点

，当且仅当图

G\{v}包含的连通

域多于图G。

这

一算法需执

行n趟搜索，耗

时O(n(n

+ e))，如此低的

效率无法令

人满意。

以下

将介绍基于

DFS搜索的另一

算法，它不仅

效率更高，而

且可同时对

原图做双连

通域分解。

6.9.3

可

行算法

图6.15 DFS树

根节点是关

节点，当且仅

当它拥有多

个分支

经DFS搜

索生成的DFS树

，表面上看似

乎“丢失”

了原

图的一些信

息，但实际上

就某种意义

而言，依然可

以提供足够

多的信息。

比

如，DFS树中的叶

节点，绝不可

能是原图中

的关

节点此

类顶点的删

除既不致影

响DFS树的连通

性，

也不致影

响原图的连

通性。此外，DFS树

的根节点若

至

少拥有两

个分支，则必

是一个关节

点。如图6.15所示

，

在原无向图

中，根节点R的

不同分支之

间不可能通

过跨

边相联

，R是它们之间

唯一的枢纽

。反之，若根节

点仅

有一个

分支，则与叶

节点同理，它

也不可能是

关节点。

那么

，又该如何甄

别一般的内

部节点是否

为关节点呢

？

考查图6.16中的

内部节点C。若

节点C的移除

导致其某一

棵（比如以D为

根的）真子树

与其真

祖先

（比如A）之间无

法连通，则C必

为关节点。反

之，若C的所有

真子树都能

（如以E为根的

子

树那样）与

C的某一真祖

先连通，则C就

不可能是关

节点。

图6.16 内部

节点C是关节

点，当且仅当

C癿某棵枀大

真子树丌（绊

后向边）联接

刡C癿真祖先

当然，在原无

向图的DFS树中

，C的真子树只

可能通过后

向边与C的真

祖先连通。因

此，只要

在DFS搜

索过程记录

并更新各顶

点v所能（经由

后向边）连通

的最高祖先

（highest connected

ancestor, HCA）hca[v]，即可及时认

定关节点，并

报告对应的

双连通域。

§6.9 *双

连通域分解

第6章

图

170

6.9.4 实现

根据以上分

析，基于DFS搜索

框架的双连

通域分解算

法，可实现如

代码6.6所示。

1 template <typename Tv,

typename Te> void Graph<Tv,

Te>::bcc ( int s

) { //基

亍DFS癿BCC分解算

法

2

reset(); int clock =

0; int v =

s; Stack<int> S; //栈S用以记

弽已讵问癿

顶点

3 do

4 if

( UNDISCOVERED == status

( v ) )

{ //一旦収

现未収现癿

顶点（新连通

分量）

5 BCC

( v, clock, S

); //即从诠

顶点出収启

劢一次BCC

6 S.pop();

//遍历

迒回后，弹出

栈中最后一

个顶点——弼前

连通域癿起

点

7 }

8

while ( s !=

( v = (

++v % n )

) );

9 }

10 #define hca(x) (fTime(x))

//刟用此处

闲置癿fTime[]充弼

hca[]

11 template <typename

Tv, typename Te> //顶点类型、边

类型

12 void Graph<Tv, Te>::BCC

( int v, int&

clock, Stack<int>& S )

{ //assert: 0 <=

v < n

13

hca ( v )

= dTime ( v

) = ++clock; status

( v ) =

DISCOVERED; S.push ( v

); //v被収现

幵入栈

14 for

( int u =

firstNbr ( v );

-1 < u; u

= nextNbr ( v,

u ) ) //构丼

v癿所有邻屁

u

15 switch ( status

( u ) )

{ //幵规u癿状态

分删处理

16 case

UNDISCOVERED:

17 parent (

u ) = v;

type ( v, u

) = TREE; BCC

( u, clock, S

); //从

顶点u处深入

18 if (

hca ( u )

< dTime ( v

) ) //遍历迒回后

，若収现u（通过

后向边）可指

向v癿真祖先

19 hca

( v ) =

min ( hca (

v ), hca (

u ) ); //则v亦必如此

20

else { //否则，以v为兲

节点（u以下即

是一个BCC，且其

中顶点此时

正集中亍栈

S癿顶部）

21

while ( v !=

S.pop() ); //依次

弹出弼前BCC中

癿节点，亦可

根据实际需

求转存至其

它结极

22

S.push ( v );

//最后

一个顶点（兲

节点）重新入

栈——总计至夗

两次

23 }

24

break;

25 case DISCOVERED:

26 type ( v,

u ) = BACKWARD;

//标记(v, u)，幵

按照“越小越

高”癿准则

27 if

( u != parent

( v ) )

hca ( v )

= min ( hca

( v ), dTime

( u ) );

//更

新hca[v]

28 break;

29

default: //VISITED (digraphs only)

30 type ( v,

u ) = (

dTime ( v )

< dTime ( u

) ) ? FORWARD

: CROSS;

31 break;

32 }

33 status

( v ) =

VISITED; //对v癿讵问

结束

34 }

35 #undef hca

代码6.6

基

二DFS搜索框架

实现双还通

域分解算法

由于处理的

是无向图，故

DFS搜索在顶点

v的孩子u处返

回之后，通过

比较hca[u]与dTime[v]

的大

小，即可判断

v是否关节点

。

这里将闲置

的fTime[]用作hca[]。故若

hca[u] 

dTime[v]，则说明u及其

后代无法通

过

第6章 图 §6.9

*双

连通域分解

171

后向边与v的

真祖先连通

，故v为关节点

。既然栈S存有

搜索过的顶

点，与该关节

点相对应的

双连

通域内

的顶点，此时

都应集中存

放于S顶部，故

可依次弹出

这些顶点。v本

身必然最后

弹出，作为

多

个连通域的

联接枢纽，它

应重新进栈

。

反之若hca[u] < dTime[v]，则意

味着u可经由

后向边连通

至v的真祖先

。果真如此，则

这

一性质对

v同样适用，故

有必要将hca[v]，更

新为hca[v]与hca[u]之间

的更小者。

当

然，每遇到一

条后向边(v, u)，也

需要及时地

将hca[v]，更新为hca[v]与

dTime[u]之

间的更小

者，以保证hca[v]能

够始终记录

顶点v可经由

后向边向上

连通的最高

祖先。

同样地

，为便于与基

本的DFS搜索算

法相对比，代

码6.6也保留了

代码6.4的通用

框架。因此，

通

过清理与双

连通域分解

无关的操作

并精简代码

，也可降低时

间复杂度的

常系数（习题

[6-20]）。

6.9.5 实例

图6.17以一

个包含10个顶

点和12条边的

无向图为例

，详细给出了

以上算法的

完整计算过

程。

图6.17 基二DFS搜

索癿双还通

域分解实例

（细边框白色

、双边框白色

和黑色分删

示意处二UNDISCOVERED、DISCOVERED和

VISITED状态癿顶点

，

粗边框白色

示意当前顶

点；dTime和fTime（hca）标签分

删标注二各

顶点癿左、右

）

§6.10

优先级搜索

第6章 图

172

图6.17

基

二DFS搜索癿双

还通域分解

实例（续）

6.9.6 复杂

度

与基本的

DFS搜索算法相

比，这里只增

加了一个规

模O(n)的辅助栈

，故整体空间

复杂度仍为

O(n

+ e)。时间方面，尽

管同一顶点

v可能多次入

栈，但每一次

重复入栈都

对应于某一

新发现的

双

连通域，与之

对应地必有

至少另一顶

点出栈且不

再入栈。因此

，这类重复入

栈操作不会

超过n

次，入栈

操作累计不

超过2n次，故算

法的整体运

行时间依然

是O(n

+ e)。

§6.10 优先级搜

索

6.10.1 优先级与

优先级数

以

上图搜索应

用虽各具特

点，但其基本

框架却颇为

相似。总体而

言，都需通过

迭代逐一发

现

各顶点，将

其纳入遍历

树中并做相

应处理，同时

根据应用问

题的需求，适

时给出解答

。各算法在

功

能上的差异

，主要体现为

每一步迭代

中对新顶点

的选取策略

不同。比如，BFS搜

索会优先考

查

更早被发

现的顶点，而

DFS搜索则恰好

相反，会优先

考查最后被

发现的顶点

。

第6章 图

§6.10 优先

级搜索

173

每一

种选取策略

都等效于，给

所有顶点赋

予不同的优

先级，而且随

着算法的推

进不断调整

；

而每一步迭

代所选取的

顶点，都是当

时的优先级

最高者。按照

这种理解，包

括BFS和DFS在内的

几乎所有图

搜索，都可纳

入统一的框

架。鉴于优先

级在其中所

扮演的关键

角色，故亦称

作优先级

搜

索（priority-first search, PFS），或最佳优

先搜索（best-first

search, BFS）。

为落

实以上理解

与构思，图ADT（表

6.2和代码6.1）提供

了priority()接口，以支

持对顶

点优

先级数（priority

number）的读

取和修改。在

实际应用中

，引导优化方

向的指标，往

往

对应于某

种有限的资

源或成本（如

光纤长度、通

讯带宽、机票

价格等），故这

里不妨约定

优先级

数越

大（小）顶点的

优先级越低

（高）。相应地，在

算法的初始

化阶段（如代

码6.1中的reset()），

通常

都将顶点的

优先级数统

一置为最大

（比如对于int类

型，可采用INT_MAX）或

等价地，

优先

级最低。

6.10.2 基本

框架

按照上

述思路，优先

级搜索算法

的框架可具

体实现如代

码6.7所示。

1 template <typename Tv,

typename Te> template <typename

PU> //优先

级搜索（全图

）

2 void

Graph<Tv, Te>::pfs ( int

s, PU prioUpdater )

{ //assert: 0 <=

s < n

3

reset(); int v =

s; //刜始化

4 do

//逐一

检查所有顶

点

5 if (

UNDISCOVERED == status (

v ) ) //一旦遇刡

尚未収现癿

顶点

6 PFS ( v,

prioUpdater ); //即从诠

顶点出収启

劢一次PFS

7

while ( s !=

( v = (

++v % n )

) ); //按序

号检查，故丌

漏丌重

8

}

9

10 template

<typename Tv, typename Te>

template <typename PU> //顶点

类型、边类型

、优先级更新

器

11 void Graph<Tv, Te>::PFS

( int s, PU

prioUpdater ) { //优先级搜

索（单个连通

域）

12 priority ( s

) = 0; status

( s ) =

VISITED; parent ( s

) = -1; //刜始化，起

点s加至PFS树中

13

while ( 1 )

{ //将下一顶点

和边加至PFS树

中

14 for

( int w =

firstNbr ( s );

-1 < w; w

= nextNbr ( s,

w ) ) //构丼s癿所

有邻屁w

15 prioUpdater ( this,

s, w ); //更新

顶点w癿优先

级及其父顶

点

16 for ( int

shortest = INT_MAX, w

= 0; w <

n; w++ )

17

if ( UNDISCOVERED ==

status ( w )

) //从尚未加

入遍历树癿

顶点中

18 if

( shortest > priority

( w ) )

//选出

下一个

19 { shortest

= priority ( w

); s = w;

} //优先

级最高癿顶

点s

20 if

( VISITED == status

( s ) )

break; //直至所有

顶点均已加

入

21 status

( s ) =

VISITED; type ( parent

( s ), s

) = TREE; //将s及不其

父癿联边加

入遍历树

22 }

23 }

//通

过定丿具体

癿优先级更

新策略prioUpdater，即可

实现丌同癿

算法功能

代

码6.7 优先级搜

索算法框架

可见，PFS搜索的

基本过程和

功能与常规

的图搜索算

法一样，也是

以迭代方式

逐步引入顶

点

和边，最终

构造出一棵

遍历树（或者

遍历森林）。如

上所述，每次

都是引入当

前优先级最

高（优

先级数

最小）的顶点

s，然后按照不

同的策略更

新其邻接顶

点的优先级

数。

§6.11 最小支撑

树 第6章

图

174

这

里借助函数

对象prioUpdater，使算法

设计者得以

根据不同的

问题需求，简

明地描述和

实

现对应的

更新策略。具

体地，只需重

新定义prioUpdater对象

即可，而不必

重复实现公

共部分。

比如

，此前的BFS搜索

和DFS搜索都可

按照此模式

统一实现（习

题[6-21]）。

下面，以最

小支撑树和

最短路径这

两个经典的

图算法为例

，深入介绍这

一框架的具

体应用。

6.10.3 复杂

度

PFS搜索由两

重循环构成

，其中内层循

环又含并列

的两个循环

。若采用邻接

表实现方式

，同

时假定prioUpdater()只

需常数时间

，则前一内循

环的累计时

间应取决于

所有顶点的

出度总和，

即

O(e)；后一内循环

固定迭代n次

，累计O(n2）时间。两

项合计总体

复杂度为O(n2

)。

实

际上，借助稍

后第10章将要

介绍的优先

级队列等结

构，PFS搜索的效

率还有进一

步提高的

余

地（习题[10-16]和[10-17]）。

§6.11 最

小支撑树

6.11.1 支

撑树

如图6.18所

示，连通图G的

某一无环连

通子图T若覆

盖G中所有的

顶点，则称作

G的一棵支撑

树或生成树

（spanning tree）。

图6.18 支撑树

就

保留原图中

边的数目而

言，支撑树既

是“禁止环路

”前提下的极

大子图，也是

“保持连通”

前

提下的最小

子图。在实际

应用中，原图

往往对应于

由一组可能

相互联接（边

）的成员（顶点

）

构成的系统

，而支撑树则

对应于该系

统最经济的

联接方案。确

切地，尽管同

一幅图可能

有多棵支

撑

树，但由于其

中的顶点总

数均为n，故其

采用的边数

也均为n - 1。

6.11.2 最小

支撑树

若图

G为一带权网

络，则每一棵

支撑树的成

本（cost）即为其所

采用各边权

重的总和。在

G

的所有支撑

树中，成本最

低者称作最

小支撑树（minimum

spanning tree, MST）。

聚

类分析、网络

架构设计、VLSI布

线设计等诸

多实际应用

问题，都可转

化并描述为

最小支

撑树

的构造问题

。在这些应用

中，边的权重

大多对应于

某种可量化

的成本，因此

作为对应优

化问

题的基

本模型，最小

支撑树的价

值不言而喻

。另外，最小支

撑树构造算

法也可为一

些NP问题提供

足够快速、足

够接近的近

似解法（习题

[6-22]）。正因为受到

来自众多应

用和理论领

域的需求

推

动，最小支撑

树的构造算

法也发展得

较为成熟。

第

6章

图 §6.11 最小支

撑树

175

6.11.3 歧义性

尽管同一带

权网络通常

都有多棵支

撑树，但总数

毕竟有限，故

必有最低的

总体成本。然

而，

总体成本

最低的支撑

树却未必唯

一。以包含三

个顶点的完

全图为例，若

三条边的权

重相等，则其

中任意两条

边都构成总

体成本最低

的一棵支撑

树。

图6.19

枀小支

撑树不最小

支撑树

更一

般的例子如

图6.19所示，对应

于左侧的带

权网络，有两

棵支撑树的

总体成本均

达到最

低（44）。故

严格说来，此

类支撑树应

称作极小支

撑树（minimal spanning

tree）。当然，

通

过强制附加

某种次序即

可消除这种

歧义性（习题

[6-23]），故不妨仍称

之为最小支

撑树。

6.11.4 蛮力算

法

由最小支

撑树的定义

，可直接导出

蛮力算法大

致如下：逐一

考查G的所有

支撑树并统

计其成

本，从

而挑选出其

中的最低者

。然而根据Cayley公

式，由n个互异

顶点组成的

完全图共有

n

n-2棵

支撑树，即

便忽略掉构

造所有支撑

树所需的成

本，仅为更新

最低成本的

记录就需要

O(nn-2

)时间。

事实上

基于PFS搜索框

架，并采用适

当的顶点优

先级更新策

略，即可得出

如下高效的

最小支

撑树

构造算法。

6.11.5

Prim算

法

为更好地

理解这一算

法的原理，以

下先从最小

支撑树的性

质入手。为简

化起见，不妨

假定各

边的

权重互异。实

际上，为将最

小支撑树的

以下性质及

其构造算法

的正确性等

结论推广到

允许多

边等

权的退化情

况，还需补充

更为严格的

分析与证明

（习题[6-25]、[6-26]和[6-27]）。

 割与

极短跨越边

图G = (V;

E)中，顶点集

V的任一非平

凡子集U及其

补集V\U都构成

G的一个割（cut），记

作(U : V\U)。若边uv满足

uU且vU，则称作该

割的一条跨

越边（crossing edge）。因此类

边联接于V及

其补集之间

，故亦形象地

称作该割的

一座桥（bridge）。

Prim算法

②的正确性基

于以下事实

：最小支撑树

总是会采用

联接每一割

的最短跨越

边。

否则，如图

6.20(a)所示假设uv是

割(U : V\U)的最短跨

越边，而最小

支撑树T并未

采用该

边。于

是由树的连

通性，如图(b)所

示在T中必有

至少另一跨

边st联接该割

（有可能s = u或t =

② 由

R.

C. Prim亍1956年収明

§6.11 最

小支撑树

第

6章 图

176

v，尽管二

者不能同时

成立）。同样由

树的连通性

，T中必有分别

联接于u和s、v和

t之间的两条

通路。由于树

是极大的无

环图，故倘若

将边uv加至T中

，则如图(c)所示

，必然出现穿

过u、v、t

和s的唯一

环路。接下来

，只要再删除

边st，则该环路

必然随之消

失。

图6.20 最小支

撑树总是会

采用联接每

一割癿最短

跨越边

经过

如此的一出

一入，若设T转

换为T'，则T'依然

是连通图，且

所含边数与

T相同均为n

- 1。

这

就意味着，T'也

是原图的一

棵支撑树。就

结构而言，T'与

T的差异仅在

于边uv和边st，故

二者

的成本

之差就是这

两条边的权

重之差。不难

看出，边st的权

重必然大于

身为最短跨

越边的uv，

故T'的

总成本低于

T这与T总体权

重最小的前

提矛盾。

注意

，以上性质并

不意味着同

一割仅能为

最小支撑树

贡献一条跨

越边（习题[6-17]）。

 贪

心迭代

由以

上性质，可基

于贪心策略

导出一个迭

代式算法。每

一步迭代之

前，假设已经

得到最小支

撑树T的一棵

子树Tk = (Vk; Ek)，其中Vk包

含k个顶点，Ek包

含k

- 1条边。于是

，若将Vk及其补

集视作原图

的一个割，则

在找到该割

的最短跨越

边ek = (vk,

uk)（vkVk且ukVk）之后，即

可

将Tk扩展为

一棵更大的

子树Tk+1 = (Vk+1;

Ek+1)，其中Vk+1 = Vk 

{uk}，Ek+1 = Ek 

{ek}。

最

初的T1不含边

而仅含单个

顶点，故可从

原图的顶点

中任意选取

。

 实例

图6.21以一

个含8个顶点

和15条边的无

向图G（图(a)）为例

，给出了Prim算法

的执行过程

。

第6章 图 §6.11

最小

支撑树

177

图6.21 Prim算

法示例（阴影

区域示意丌

断扩展癿子

树Tk，粗线示意

树边）

首先如

图(b)所示，任选

一个顶点A作

为初始的子

树T1 = ( {

A };  )。此时，T1所对

应

的割共有

AB、AD和AG三条跨越

边，故选取其

中最短者AB，如

图(c)所示将T1扩

充至T2 = ( {

A, 

B };

{ AB } )。此时，T2所

对应的割共

有BC、AD和AG三条跨

越边，依然选

取其中最短

者AD，

如图(d)所示

将T2扩充至T3 = ( {

A, B, D };

{ AB, AD }

)。

如

此反复，直至

最终如图(i)所

示得到：

T8 =

( { A, B,

D, G, C, E,

F, H }; {

AB, AD, DG, DC,

CE, CF, FH }

)

此即

原图的最小

支撑树。

可以

证明，即便出

现多条极短

跨越边共存

的退化情况

，以上方法依

然可行（习题

[6-27]）。



实现

以上Prim算

法完全可以

纳入6.10.2节的优

先级搜索算

法框架。为此

，每次由Tk扩充

至Tk+1

时，可以将

Vk之外每个顶

点u到Vk的距离

视作u的优先

级数。如此，每

一最短跨越

边ek对应的顶

点

uk都会因拥

有最小的优

先级数（即最

高的优先级

）而自然地被

选中。

1 template <typename Tv,

typename Te> struct PrimPU

{ //针对Prim算

法癿顶点优

先级更新器

2 virtual void

operator() ( Graph<Tv, Te>*

g, int uk, int

v ) {

3

if ( UNDISCOVERED ==

g->status ( v )

) //对亍uk殏一尚

未被収现癿

邻接顶点v

4 if

( g->priority ( v

) > g->weight (

uk, v ) )

{ //按

Prim策略做松弛

5 g->priority (

v ) = g->weight

( uk, v );

//更新优先级

（数）

6 g->parent (

v ) = uk;

//更新父节

点

7 }

8

}

9 };

代码6.8

Prim算法

癿顶点优先

级更新器

那

么，uk和ek加入Tk之

后，应如何快

速更新Vk+1以外

顶点的优先

级数呢？实际

上，与uk互不

关

联的顶点都

无需考虑，故

只需遍历uk的

每一邻居v，若

边ukv的权重小

于v当前的优

先级数，则

将

后者更新为

前者。这一思

路可具体落

实为如代码

6.8所示的优先

级更新器。

 复

杂度

不难看

出，以上顶点

优先级更新

器只需常数

的运行时间

，故由6.10.3节对优

先级搜索算

法

性能的分

析结论，以上

Prim算法的时间

复杂度为O(n2

)。作

为PFS搜索的特

例，Prim算法的效

率

也可借助

优先级队列

进一步提高

（习题[10-16]和[10-17]）。

§6.12 最短

路径

第6章 图

178

§6.12 最短路径

若

以带权图来

表示真实的

通讯、交通、物

流或社交网

络，则各边的

权重可能代

表信道成本

、

交通运输费

用或交往程

度。此时我们

经常关心的

一类问题（习

题[6-8]），可以概括

为：

给定带权

网络G =

(V, E)，以及源

点（source）sV，对于所有

的其它顶点

v，

s到v的最短通

路有多长？该

通路由哪些

边构成？

6.12.1

最短

路径树

 单调

性

如图6.22所示

，设顶点s到v的

最短

路径为

。于是对于该

路径上的任

一顶点

u，若其

在上对应的

前缀为，则也

必

是s到u的最

短路径（之一

）。否则，若

从s到

u还有另一严

格更短的路

径τ，则易

见不

可能是s到v的

最短路径。 图

6.22 最短路径癿

仸一前缀也

是最短路径

 歧义性

较之

最小支撑树

，最短路径的

歧义性更难

处理。首先，即

便各边权重

互异，从s到v的

最短

路径也

未必唯一（习

题[6-31]）。另外，当存

在非正权重

的边，并导致

某个环路的

总权值非正

时，最短路径

甚至无从定

义。因此以下

不妨假定，带

权网络G内各

边权重均大

于零。

 无环性

图6.23

有向带权

图(a)，及其最短

路径树(b)和(c)

在

如图6.23(a)所示的

任意带权网

络中，考查从

源点到其余

顶点的最短

路径（若有多

条，任

选其一

）。于是由以上

单调性，这些

路径的并集

必然不含任

何（有向）回路

。这就意味着

，它们

应如图

(b)和图(c)所示，构

成所谓的最

短路径树（shortest-path

tree）。

6.12.2 Dijkstra③算

法



最短路径

子树序列

将

顶点ui到起点

s的距离记作

：di = dist(s,

ui)，1  i 

n。不妨设di按非

降序排列，

即

di  dj当且仅当i

 j。于

是与s自身相

对应地必有

：u1 = s。

③

E. W.

Dijkstra（1930/05/11-2002/08/06），杰出癿计算

机科学家，1972年

图灵奖得主

第6章 图 §6.12 最短

路径

179

在从最

短路径树T中

删除顶点{ uk+1, uk+2,

..., un }及

其关联各边

之后，将残存

的子图记

作

Tk。于是Tn

= T，T1仅含单

个顶点s。实际

上，Tk必为一棵

树。为验证这

一点，只需归

纳证明

Tk是连

通的。为从Tk+1转

到Tk而删除的

顶点uk+1，在Tk+1中必

是叶节点。而

根据最短路

径的单调性

，

作为Tk+1中距离

最远的顶点

，uk+1不可能拥有

后代。

于是，如

上定义的子

树{ T1, T2, ...,

Tn }，便构成一

个最短路径

子树序列。

图

6.24 最短路径子

树序列

仍以

图6.23中的最短

路径树为例

，最后五棵最

短

路径子树

，如图6.24所示。

为

便于相互比

对，其

中每个

顶点都注有

其到s

的距离

。可见，只需从

Tk+1

中 删 除

距 离

最 远 的

顶 点

uk+1，即可将Tk+1转换

至Tk。

 贪心迭代

颠倒上述思

路可知，只要

能够确定uk+1，便

可反过来将

Tk扩展为Tk+1。如此

，便可按照到

s距

离的非降

次序，逐一确

定各个顶点

{ u1, u2, ...,

un }，同时得到各

棵最短路径

子树，并得到

最终的最短

路径树T = Tn。现在

，问题的关键

就在于：

如何

才能高效地

找到uk+1？

实际上

，由最短路径

子树序列的

上述性质，每

一个顶点uk+1都

是在Tk之外，距

离s最近者。

若

将此距离作

为各顶点的

优先级数，则

与最小支撑

树的Prim算法类

似，每次将uk+1加

入Tk并将其

拓

展至Tk+1后，需要

且只需要更

新那些仍在

Tk+1之外，且与Tk+1关

联的顶点的

优先级数。

可

见，该算法与

Prim算法仅有一

处差异：考虑

的是uk+1到s的距

离，而不再是

其到Tk的距离

。

 实现

与Prim算法

一样，Dijkstra算法也

可纳入此前

6.10.2节的优先级

搜索算法框

架。

为此，每次

由Tk扩展至Tk+1时

，可将Vk之外各

顶点u到Vk的距

离看作u的优

先级数（若u与

Vk

内顶点均无

联边，则优先

级数设为+）。如

此，每一最短

跨越边ek所对

应的顶点uk，都

会因拥有

最

小的优先级

数（或等价地

，最高的优先

级）而被选中

。

1

template <typename Tv, typename

Te> struct DijkstraPU {

//针对Dijkstra算法癿

顶点优先级

更新器

2 virtual void

operator() ( Graph<Tv, Te>*

g, int uk, int

v ) {

3

if ( UNDISCOVERED ==

g->status ( v )

) //对亍

uk殏一尚未被

収现癿邻接

顶点v，按Dijkstra策略

4 if (

g->priority ( v )

> g->priority ( uk

) + g->weight (

uk, v ) )

{ //做松弛

5 g->priority

( v ) =

g->priority ( uk )

+ g->weight ( uk,

v ); //更新

优先级（数）

6

g->parent ( v )

= uk; //幵

同时更新父

节点

7

}

8 }

9

};

代码6.9 Dijkstra算

法癿顶点优

先级更新器

§6.12 最短路径

第

6章 图

180

唯一需

要专门处理

的是，在uk和ek加

入Tk之后，应如

何快速地更

新Vk+1以外顶点

的优先级数

。

实际上，只有

与uk邻接的那

些顶点，才有

可能在此后

降低优先级

数。因此与Prim算

法一样，也可

遍历uk的每一

个邻居v，只要

边ukv的权重加

上uk的优先级

数，小于v当前

的优先级数

，即可将后

者

更新为前者

。具体地，这一

思路可落实

为如代码6.9所

示的优先级

更新器。

 实例

依然以图6.21(a)中

无向图为例

，一次Dijkstra算法的

完整执行过

程如图6.25所示

。

图6.25 Dijkstra算法示例

（阴影区域示

意丌断扩展

癿子树Tk，粗线

示意树边）

 复

杂度

不难看

出，以上顶点

优先级更新

器只需常数

运行时间。同

样根据6.10.3节对

PFS搜索性能的

分析结论，Dijkstra算

法这一实现

版本的时间

复杂度为O(n2

)。

作

为PFS搜索的特

例，Dijkstra算法的效

率也可借助

优先级队列

进一步提高

（习题[10-16]

和[10-17]）。

第7章

搜索树

第7章

搜索树

182

从本

章开始，讨论

的重点将逐

步转入查找

技术。实际上

，此前的若干

章节已经就

此做过一些

讨论，在向量

与列表等结

构中，甚至已

经提供并实

现了对应的

ADT接口。然而遗

憾的是，此前

这

类接口的

总体效率均

无法令人满

意。

以31页代码

2.1中的向量模

板类Vector为例，其

中针对无序

和有序向量

的查找，分别

提供了

find()和search()接

口。前者的实

现策略只不

过是将目标

对象与向量

内存放的对

象逐个比对

，

故最坏情况

下需要运行

O(n)时间。后者利

用二分查找

策略尽管可

以确保在O(logn)时

间内完成单

次查找，但一

旦向量本身

需要修改，无

论是插入还

是删除，在最

坏情况下每

次仍需O(n)时间

。

而就代码3.2中

的列表模板

类List（70页）而言，情

况反而更糟

：即便不考虑

对列表本身

的修改，

无论

find()或search()接口，在最

坏情况或平

均情况下都

需要线性的

时间。另外，基

于向量或

列

表实现的栈

和队列，一般

地甚至不提

供对任意成

员的查找接

口。总之，若既

要求对象集

合的组

成可

以高效率地

动态调整，同

时也要求能

够高效率地

查找，则以上

线性结构均

难以胜任。

那

么，高效率的

动态修改和

高效率的静

态查找，究竟

能否同时兼

顾？如有可能

，又应该采用

什么样的数

据结构？接下

来的两章，将

逐步回答这

两个层次的

问题。

因为这

部分内容所

涉及的数据

结构变种较

多，它们各具

特色、各有所

长，也有其各

自的适用

范

围，故按基本

和高级两章

分别讲解，相

关内容之间

的联系如图

7.1所示。

图7.1

第7章

和第8章内容

纵觅

本章将

首先介绍树

式查找的总

体构思、基本

算法以及数

据结构，通过

对二分查找

策略的抽象

与推广，定义

并实现二叉

搜索树结构

。尽管就最坏

情况下的渐

进时间复杂

度而言，这一

方法与此

前

相比并无实

质的改进，但

这部分内容

依然十分重

要基于半线

性的树形结

构的这一总

体构

思，正是

后续内容的

立足点和出

发点。比如，本

章的后半部

分将据此提

出理想平衡

和适度平衡

等

概念，并相

应地引入和

实现AVL树这一

典型的平衡

二叉搜索树

。借助精巧的

平衡调整算

法，AVL

树可以保

证，即便是在

最坏情况下

，单次动态修

改和静态查

找也均可以

在O(logn)时间内完

成。

这样，以上

关于兼顾动

态修改与静

态查找操作

效率的问题

，就从正面得

到了较为圆

满的回答。接

下来的第8章

将在此基础

上，针对更为

具体的应用

需求和更为

精细的性能

指标，介绍平

衡搜索树

家

族的其它典

型成员。

第7章

搜索树 §7.1 查找

183

§7.1

查找

7.1.1 循关键

码访问

所谓

的查找或搜

索（search），指从一组

数据对象中

找出符合特

定条件者，这

是构建算法

的一种基本

而重要的操

作。其中的数

据对象，统一

地表示和实

现为词条（entry）的

形式；不同

词

条之间，依照

各自的关键

码（key）彼此区分

。根据身份证

号查找特定

公民，根据车

牌号查找

特

定车辆，根据

国际统一书

号查找特定

图书，均属于

根据关键码

查找特定词

条的实例。

请

注意，与此前

的“循秩访问

”和“循位置访

问”等完全不

同，这一新的

访问方式，与

数据

对象的

物理位置或

逻辑次序均

无关。实际上

，查找的过程

与结果，仅仅

取决于目标

对象的关键

码，

故这种方

式亦称作循

关键码访问

（call-by-key）。

7.1.2 词条

一般地

，查找集内的

元素，均可视

作如代码7.1所

示词条模板

类Entry的实例化

对象。

1 template <typename K,

typename V> struct Entry

{ //词条模

板类

2 K

key; V value; //兲键码

、数值

3 Entry ( K

k = K(), V

v = V() )

: key ( k

), value ( v

) {}; //默讣极

造函数

4

Entry ( Entry<K, V>

const& e ) :

key ( e.key ),

value ( e.value )

{}; //基亍

克隆癿极造

函数

5 bool

operator< ( Entry<K, V>

const& e ) {

return key < e.key;

} //比较器

：小亍

6 bool

operator> ( Entry<K, V>

const& e ) {

return key > e.key;

} //比较器

：大亍

7 bool

operator== ( Entry<K, V>

const& e ) {

return key == e.key;

} //刞等器

：等亍

8 bool

operator!= ( Entry<K, V>

const& e ) {

return key != e.key;

} //刞等器

：丌等亍

9 };

//得益

亍比较器和

刞等器，从此

往后，丌必严

格匙分词条

及其对应癿

兲键码

代码

7.1 词条模板类

Entry

词条对象拥

有成员变量

key和value。前者作为

特征，是词条

之间比对和

比较的依据

；后者

为实际

的数据。若词

条对应于商

品的销售记

录，则key为其条

形扫描码，value可

以是其单价

或

库存量等

信息。设置词

条类只为保

证查找算法

接口的统一

，故不必过度

封装。

7.1.3 序与比

较器

由代码

7.1可见，通过重

载对应的操

作符，可将词

条的判等与

比较等操作

转化为关键

码的判

等与

比较（故在不

致歧义时，往

往无需严格

区分词条及

其关键码）。当

然，这里隐含

地做了一个

假定所有词

条构成一个

全序关系，可

以相互比对

和比较。需指

出的是，这一

假定条件不

见得

总是满

足。比如在人

事数据库中

，作为姓名的

关键码之间

并不具有天

然的大小次

序。另外，在任

务相对单纯

但更加讲求

效率的某些

场合，并不允

许花费过多

时间来维护

全序关系，只

能转而付出

有限的代价

维护一个偏

序关系。后者

的一个实例

，即第10章将要

介绍的优先

级队列根据

其

ADT接口规范

，只需高效地

跟踪全局的

极值元素，其

它元素一般

无需直接访

问。

实际上，任

意词条之间

可相互比较

大小，也是此

前（2.6.5节至2.6.8节）有

序向量得以

定

义，以及二

分查找算法

赖以成立的

基本前提。以

下将基于同

样的前提，讨

论如何将二

分查找的技

巧融入二叉

树结构，进而

借助二叉搜

索树以实现

高效的查找

。

§7.2 二叉搜索树

第7章

搜索树

184

§7.2 二叉搜索树

7.2.1 顺序性

若二

叉树中各节

点所对应的

词条之间支

持大小比较

，则在不致歧

义的情况下

，我们可以不

必

严格区分

树中的节点

、节点对应的

词条以及词

条内部所存

的关键码。

如

图7.2所示，在所

谓的二叉搜

索树（binary search

tree）中，处处

都满足顺序

性：

任一节点

r的左（右）子树

中，所有节点

（若存在）均不

大于（不小于

）r

图7.2 事叉搜索

树即处处满

足顸序性癿

事叉树

为回

避边界情况

，这里不妨暂

且假定所有

节点互不相

等。于是，上述

顺序性便可

简化表述为

：

任一节点r的

左（右）子树中

，所有节点（若

存在）均小于

（大于）r

图7.3 事叉

搜索树癿三

个实例（左），以

及三个反例

（右）

当然，在实

际应用中，对

相等元素的

禁止既不自

然也不必要

。读者可在本

书所给代码

的基础

上继

续扩展，使得

二叉搜索树

的接口支持

相等词条的

同时并存（习

题[7-10]）。比如，在去

除

掉这一限

制之后，图7.3中

原先的第一

个反例，将转

而成为合法

的二叉搜索

树。

7.2.2

中序遍历

序列

图7.4 事叉

搜索树（上）癿

中序遍历序

列（下），必然单

调非降

第7章

搜索树

§7.2 二叉

搜索树

185

顺序

性是一项很

强的条件。实

际上，搜索树

中节点之间

的全序关系

，已完全“蕴含

”于这一

条件

之中。以如图

7.4所示的二叉

搜索树为例

，只需采用5.4.3节

的算法对该

树做一次中

序遍历，

即可

将该树转换

为一个线性

序列，且该序

列中的节点

严格按照其

大小次序排

列。

这一现象

，并非巧合。借

助数学归纳

法，可以证明

更具一般性

的结论（习题

[7-1]）：

任何一棵二

叉树是二叉

搜索树，当且

仅当其中序

遍历序列单

调非降

7.2.3 BST模板

类

既然二叉

搜索树属于

二叉树的特

例，故自然可

以基于BinTree模板

类（121页代码5.5），

派

生出如代码

7.2所示的BST模板

类。

1 #include "../BinTree/BinTree.h" //引入BinTree

2

3 template <typename

T> class BST :

public BinTree<T> { //由BinTree派

生BST模板类

4 protected:

5 BinNodePosi(T)

_hot; //“命

中”节点癿父

亲

6 BinNodePosi(T)

connect34 ( //按照“3 +

4”结极

，联接3个节点

及四棵子树

7 BinNodePosi(T), BinNodePosi(T), BinNodePosi(T),

8 BinNodePosi(T), BinNodePosi(T), BinNodePosi(T),

BinNodePosi(T) );

9 BinNodePosi(T)

rotateAt ( BinNodePosi(T) x

); //对x及其父亲

、祖父做统一

旋转调整

10 public:

//基

本接口：以virtual修

饰，强刢要求

所有派生类

（BST发种）根据各

自癿觃则对

其重写

11 virtual BinNodePosi(T)

& search ( const

T& e ); //查找

12

virtual BinNodePosi(T) insert (

const T& e );

//揑入

13 virtual bool

remove ( const T&

e ); //初除

14

};

代

码7.2 由BinTree派生癿

事叉搜索树

模板类BST

可见

，在继承原模

板类BinTree的同时

，BST内部也继续

沿用了二叉

树节点模板

类BinNode。

按照二叉

搜索树的接

口规范定义

，这里新增了

三个标准的

对外接口search()、insert()和

remove()，分别对应于

基本的查找

、插入和删除

操作。这三个

标准接口的

调用参数，都

是属于

元素

类型T的对象

引用这正是

此类结构“循

关键码访问

”方式的具体

体现。

另外，既

然这些操作

接口的语义

均涉及词条

的大小和相

等关系，故这

里也假定基

本元素类型

T或者直接支

持比较和判

等操作，或者

已经重载过

对应的操作

符。

本章以及

下一章还将

以BST为基类，进

一步派生出

二叉搜索树

的多个变种

。无论哪一变

种，

既必须支

持上述三个

基本接口，同

时在内部的

具体实现方

式又有所不

同。因此，它们

均被定义为

虚成员函数

，从而强制要

求派生的所

有变种，根据

各自的规则

对其重写。

7.2.4 查

找算法及其

实现



算法

二

叉搜索树的

查找算法，亦

采用了减而

治之的思路

与策略，其执

行过程可描

述为：

从树根

出发，逐步地

缩小查找范

围，直到发现

目标（成功）或

缩小至空树

（失败）

§7.2

二叉搜

索树 第7章 搜

索树

186

例如，在

图7.5中查找关

键码22的过程

如下。

首先，经

与根节点

16比

较确认目标

关键

码更大

，故深入右子

树

25递归查找

；经比较发

现

目标关键码

更小，故

继续

深入左子树

19递

归查找；经

再次比较确

认目标关键

码更大后，

深

入右子树22递

归查

找；最终

在节点22处匹

配，查找成功

。 图7.5 事叉搜索

树癿查找过

秳（查找所绊

过癿通路，以

粗线条示意

）

当然，查找未

必成功。比如

针对关键码

20的查找也会

经过同一查

找通路并抵

达节点22，但

在

因目标关键

码更小而试

图继续向左

深入时发现

左子树为空

①，至此即可确

认查找失败

。

一般地，在上

述查找过程

中，一旦发现

当前节点为

NULL，即说明查找

范围已经缩

小至空，

查找

失败；否则，视

关键码比较

结果，向左（更

小）或向右（更

大）深入，或者

报告成功（相

等）。

对照中序

遍历序列可

见，整个过程

与有序向量

的二分查找

过程等效，故

可视作后者

的推广。

 searchIn()算法

与search()接口

一般

地，在子树v中

查找关键码

e的过程，可实

现为如代码

7.3所示的算法

searchIn()。

1 template <typename T>

//在以v为根癿

（AVL、SPLAY、rbTree等）BST子树中查

找兲键码e

2 static BinNodePosi(T)

& searchIn ( BinNodePosi(T)

& v, const T&

e, BinNodePosi(T) & hot

) {

3 if

( !v || (

e == v->data )

) return v; //逑

弻基：在节点

v（戒假想癿通

配节点）处命

中

4 hot = v;

//一般情冴

：先记下弼前

节点，然后再

5 return searchIn (

( ( e <

v->data ) ? v->lc

: v->rc ), e,

hot ); //深入一局，逑

弻查找

6

} //迒回

时，迒回值指

向命中节点

（戒假想癿通

配哨兵），hot指向

其父亲（退化

时为刜始值

NULL）

代码7.3 事叉搜

索树searchIn()算法癿

递归实现

节

点的插入和

删除操作，都

需要首先调

用查找算法

，并根据查找

结果确定后

续的处理方

式。

因此，这里

以引用方式

传递（子）树根

节点，以为后

续操作提供

必要的信息

。

如代码7.4所示

，通过调用searchIn()算

法，即可实现

二叉搜索树

的标准接口

search()。

1

template <typename T> BinNodePosi(T)

& BST<T>::search ( const

T& e ) //在BST中查找兲

键码e

2 { return searchIn

( _root, e, _hot

= NULL ); }

//迒回目

标节点位置

癿引用，以便

后续揑入、初

除操作

代码

7.4 事叉搜索树

search()接口

① 此类空

节点通常对

应亍空孩子

指针戒引用

，也可假想地

等效为“真实

”节点，后一斱

式丌仅可简

化算法描述

以及退化

情

冴癿处理，也

可直观地解

释（B-树乀类）纵

贯夗级存储

局次癿搜索

树。故在后一

场合，空节点

也称作外部

节点

（external

node），幵等效

地弼作叶节

点癿“孩子”。返

里暂采用前

一斱式，故空

节点丌在揑

图中出现。

第

7章 搜索树 §7.2

二

叉搜索树

187

 语

义约定

以上

查找算法之

所以如此实

现，是为了统

一并简化后

续不同搜索

树的各种操

作接口的实

现。

其中的技

巧，主要体现

于返回值和

hot变量（即BinTree对象

内部的_hot变量

）的语义约定

。

若查找成功

，则searchIn()以及search()的返

回值都将如

图7.6(a)所示，指向

一个关键

码

为e且真实存

在的节点；若

查找失败，则

返回值的数

值虽然为NULL，但

是它作为引

用将如图(b)

所

示，指向最后

一次试图转

向的空节点

。对于后一情

况，不妨假想

地将此空节

点转换为一

个数值

为e的

哨兵节点如

此，无论成功

与否，查找的

返回值总是

等效地指向

“命中节点”。

图

7.6 searchIn()算法对迒回

值和_hot癿语义

定义：(a)

查找成

功；(b) 查找失败

在调用searchIn()算法

之前，search()接口首

先将内部变

量_hot初始化为

NULL，然后作

为引

用型参数hot传

递给searchIn()。在整个

查找的过程

中，hot变量始终

指向当前节

点的父亲。

因

此在算法返

回时，按照如

上定义，_hot亦将

统一指向“命

中节点”的父

亲。

请注意，_hot节

点是否拥有

另一个孩子

，与查找成功

与否无关。查

找成功时，节

点e可能是

叶

子，也可能是

内部节点；查

找失败时，假

想的哨兵e等

效于叶节点

，但可能有兄

弟。

同时也请

读者对照代

码7.3验证，即便

在退化的情

况下（比如查

找终止并返

回于树根处

），

算法searchIn()的输出

依然符合以

上语义约定

。

在7.2.6节将要介

绍的删除操

作中，也首先

要进行查找

（不妨设查找

成功）。按照如

上语义，

命中

节点必然就

是待摘除节

点；该节点与

其父亲_hot，联合

指示了删除

操作的位置

。7.2.5节将

要介绍

的插入操作

，亦首先需做

查找（不妨设

查找失败）。按

照如上语义

，假想的“命中

节点”

也就是

待插入的新

节点；_hot所指向

的，正是该节

点可行的接

入位置。

 效率

在二叉搜索

树的每一层

，查找算法至

多访问一个

节点，且只需

常数时间，故

总体所需时

间应

线性正

比于查找路

径的长度，或

最终返回节

点的深度。在

最好情况下

，目标关键码

恰好出现在

树

根处（或其

附近），此时只

需O(1)时间。然而

不幸的是，对

于规模为n的

二叉搜索树

，深度在最

坏

情况下可达

(n)。比如，当该树

退化为（接近

于）一条单链

时，发生此类

情况的概率

将很高。

此时

的单次查找

可能需要线

性时间并不

奇怪，因为实

际上这样的

一棵“二分”搜

索树，已经退

化

成了一个

不折不扣的

一维有序列

表，而此时的

查找则等效

于顺序查找

。

由此我们可

得到启示：若

要控制单次

查找在最坏

情况下的运

行时间，须从

控制二叉搜

索树的

高度

入手。后续章

节将要讨论

的平衡二叉

搜索树，正是

基于这一思

路而做的改

进。

§7.2 二叉搜索

树 第7章

搜索

树

188

7.2.5 插入算法

及其实现

 算

法

为了在二

叉搜索树中

插入一个节

点，首先需要

利用查找算

法search()确定插入

的位置及方

向，然后才能

将新节点作

为叶子插入

。

以如图7.7(a)所示

的二叉搜索

树为例。若欲

插入关键码

40，则在执行search(40)之

后，如

图(b)所示

，_hot将指向比较

过的最后一

个节点46，同时

返回其左孩

子（此时为空

）的位置。于

是

接下来如图

(c)所示，只需创

建新节点40，并

将其作为46的

左孩子接入

，拓扑意义上

的节点插

入

即告完成。不

过，为保持二

叉搜索树作

为数据结构

的完整性和

一致性，还需

从节点_hot（46）

出发

，自底而上地

逐个更新新

节点40历代祖

先的高度。

图

7.7 事叉搜索树

节点揑入算

法实例

接下

来若欲插入

关键码55，则在

执行search(55)之后如

图(c)所示，_hot将指

向比较过的

最后一个节

点53，同时返回

其右孩子（此

时为空）的位

置。于是如图

(d)所示，创建新

节点55，

并将其

作为53的右孩

子接入。当然

，此后同样需

从节点_hot出发

，逐代更新祖

先的高度。

 insert()接

口的实现

一

般地，在二叉

搜索树中插

入新节点e的

过程，可描述

为代码7.5中的

函数insert()。

1

template <typename T> BinNodePosi(T)

BST<T>::insert ( const T&

e ) { //将兲键

码e揑入BST树中

2

BinNodePosi(T) & x =

search ( e );

if ( x )

return x; //确讣目标丌

存在（留意对

_hot癿讴置）

3

x = new BinNode<T>

( e, _hot );

//创建

新节点x：以e为

兲键码，以_hot为

父

4 _size++; //更新全树

觃模

5 updateHeightAbove ( x

); //更新x及

其历代祖先

癿高度

6 return

x; //新揑

入癿节点，必

为叶子

7 }

//无讳

e是否存在亍

原树中，迒回

时总有x->data == e

代码

7.5

事叉搜索树

insert()接口

首先调

用search()查找e。若返

回位置x非空

，则说明已有

雷同节点，插

入操作失败

。否则，

x必是_hot节

点的某一空

孩子，于是创

建这个孩子

并存入e。此后

，更新全树的

规模记录，并

调

用代码5.6中

的updateHeightAbove()更新x及其

历代祖先的

高度。

注意，按

照以上实现

方式，无论插

入操作成功

与否，都会返

回一个非空

位置，且该处

的节点

与拟

插入的节点

相等。如此可

以确保一致

性，以简化后

续的操作。另

外，也请对照

代码7.3和代

码

7.4中的查找算

法，体会这里

对“首个节点

插入空树”等

特殊情况的

处理手法。

第

7章

搜索树 §7.2 二

叉搜索树

189

 效

率

由上可见

，节点插入操

作所需的时

间，主要消耗

于对算法search()及

updateHeightAbove()

的调用。后者

与前者一样

，在每一层次

至多涉及一

个节点，仅消

耗O(1)时间，故其

时间复杂度

也同样取决

于新节点的

深度，在最坏

情况下不超

过全树的高

度。

7.2.6 删除算法

及其实现

为

从二叉搜索

树中删除节

点，首先也需

要调用算法

BST::search()，判断目标节

点是否的

确

存在于树中

。若存在，则需

返回其位置

，然后方能相

应地具体实

施删除操作

。

图7.8 事叉搜索

树节点初除

算法实例

 单

分支情况

以

如图7.8(a)所示二

叉搜索树为

例。若欲删除

节点69，需首先

通过search(69)定位待

删除

节点（69）。因

该节点的右

子树为空，故

只需如图(b)所

示，将其替换

为左孩子（64），则

拓扑

意义上

的节点删除

即告完成。当

然，为保持二

叉搜索树作

为数据结构

的完整性和

一致性，还需

更

新全树的

规模记录，释

放被摘除的

节点（69），并自下

而上地逐个

更新替代节

点（64）历代祖

先

的高度。注意

，首个需要更

新高度的祖

先（58），恰好由_hot指

示。

不难理解

，对于没有左

孩子的目标

节点，也可以

对称地予以

处理。当然，以

上同时也已

涵盖

了左、右

孩子均不存

在（即目标节

点为叶节点

）的情况。

那么

，当目标节点

的左、右孩子

双全时，删除

操作又该如

何实施呢？

 双

分支情况

继

续上例，设拟

再删除二度

节点36。如图7.8(b)所

示，首先调用

BinNode::succ()算法，

找到该

节点的直接

后继（40）。然后，只

需如图(c)所示

交换二者的

数据项，则可

将后继节点

等

效地视作

待删除的目

标节点。不难

验证，该后继

节点必无左

孩子，从而相

当于转化为

此前相对简

单的情况。于

是最后可如

图(d)所示，将新

的目标节点

（36）替换为其右

孩子（46）。

请注意

，在中途互换

数据项之后

，这一局部如

图(c)所示曾经

一度并不满

足顺序性。但

这并

不要紧

不难验证，在

按照上述方

法完成整个

删除操作之

后，全树的顺

序性必然又

将恢复。

同样

地，除了更新

全树规模记

录和释放被

摘除节点，此

时也要更新

一系列祖先

节点的高度

。

不难验证，此

时首个需要

更新高度的

祖先（53），依然恰

好由_hot指示。

 remove()

一

般地，删除关

键码e的过程

，可描述为如

代码7.6所示的

函数remove()。

§7.2 二叉搜

索树 第7章 搜

索树

190

1 template <typename

T> bool BST<T>::remove (

const T& e )

{ //从BST树中

初除兲键码

e

2 BinNodePosi(T)

& x = search

( e ); if

( !x ) return

false; //确讣目标存

在（留意_hot癿讴

置）

3 removeAt

( x, _hot );

_size--; //实斲初除

4 updateHeightAbove (

_hot ); //更新_hot及其历

代祖先癿高

度

5

return true;

6 }

//初除成功

不否，由迒回

值指示

代码

7.6 事叉搜索树

remove()接口

首先调

用search()查找e。若返

回位置x为空

，则说明树中

不含目标节

点，故删除操

作随即

可以

失败返回。否

则，调用removeAt()删除

目标节点x。同

样，此后还需

更新全树的

规模，并调

用

函数updateHeightAbove(_hot)（121页代码

5.6），更新被删除

节点历代祖

先的高度。

 removeAt()

这

里，实质的删

除操作由removeAt()负

责分情况实

施，其具体实

现如代码7.7所

示。

1 /******************************************************************************************

2

* BST节点初除

算法：初除位

置x所指癿节

点（全尿静态

模板函数，适

用亍AVL、Splay、RedBlack等各种

BST）

3 *

目标x在此前

经查找定位

，幵确讣非NULL，故

必初除成功

；不searchIn丌同，调用

乀前丌必将

hot置空

4 * 迒回值

指向实际被

初除节点癿

接替者，hot指向

实际被初除

节点癿父亲

——二者均有可

能是NULL

5 ******************************************************************************************/

6 template

<typename T>

7 static

BinNodePosi(T) removeAt ( BinNodePosi(T)

& x, BinNodePosi(T) &

hot ) {

8

BinNodePosi(T) w = x;

//实际被

摘除癿节点

，刜值同x

9 BinNodePosi(T) succ

= NULL; //实际

被初除节点

癿接替者

10

if ( !HasLChild (

*x ) ) //若

*x癿左子树为

空，则可

11 succ = x

= x->rc; //直接

将*x替换为其

右子树

12

else if ( !HasRChild

( *x ) )

//若右

子树为空，则

可

13 succ =

x = x->lc; //对称地处

理——注意：此时

succ

!= NULL

14 else

{ //若左右子树

均存在，则选

择x癿直接后

继作为实际

被摘除节点

，为此需要

15 w

= w->succ(); //（在

右子树中）找

刡*x癿直接后

继*w

16

swap ( x->data, w->data

); //交换*x和*w癿

数据元素

17 BinNodePosi(T)

u = w->parent;

18

( ( u ==

x ) ? u->rc

: u->lc ) =

succ = w->rc; //隑

离节点*w

19 }

20 hot

= w->parent; //记弽

实际被初除

节点癿父亲

21 if

( succ ) succ->parent

= hot; //幵将被初除

节点癿接替

者不hot相联

22

release ( w->data );

release ( w );

return succ; //释

放被摘除节

点，迒回接替

者

23

}

代码7.7 事叉

搜索树removeAt()算法

 效率

删除操

作所需的时

间，主要消耗

于对search()、succ()和updateHeightAbove()的调

用。

在树中的

任一高度，它

们至多消耗

O(1)时间。故总体

的渐进时间

复杂度，亦不

超过全树的

高度。

第7章 搜

索树

§7.3 平衡二

叉搜索树

191

§7.3

平

衡二叉搜索

树

7.3.1 树高与性

能

根据7.2节对

二叉搜索树

的实现与分

析，search()、insert()和remove()等主要

接口的运

行

时间，均线性

正比于二叉

搜索树的高

度。而在最坏

情况下，二叉

搜索树可能

彻底地退化

为列表，

此时

的查找效率

甚至会降至

O(n)，线性正比于

数据集的规

模。因此，若不

能有效地控

制树高，

则就

实际的性能

而言，较之此

前的向量和

列表，二叉搜

索树将无法

体现出明显

优势。

那么，出

现上述最坏

（或较坏）情况

的概率有多

大？或者，至少

从平均复杂

度的角度来

看，

二叉搜索

树的性能是

否还算令人

满意？

以下，将

按照两种常

用的随机统

计口径，就二

叉搜索树的

平均性能做

一比较。

 随机

生成

不妨设

各节点对应

于n个互异关

键码{ e1, e2, ...,

en }。于是按

照每一排列

：

 =

( ei1

, ei2

, ..., ein

)

只要从空树

开始，通过依

次执行insert(eik

)，即可

得到这n个关

键码的一棵

二叉搜索树

T()。

与随机排列

如此相对应

的二叉搜索

树T()，称作由“随

机生成”（randomly generated）。

图7.9以

三个关键码

{ 1, 2, 3

}为例，列出了

由其所有排

列所生成的

二叉搜索树

。

图7.9 由三个关

键码{ 1,

2, 3 }癿6种全

排列生成癿

事叉搜索树

显然，任意的

n个互异关键

码，都可以构

成n!种全排列

。若各排列作

为输入序列

的概率均等

，

则只要将它

们各自所生

成二叉搜索

树的平均查

找长度进行

平均，即可在

一定程度上

反映二叉搜

索

树的平均

查找性能。可

以证明[29][30]，在这

一随机意义

下，二叉搜索

树的平均高

度为(logn)。

 随机组

成

另一随机

策略是，假定

n个互异节点

同时给定，然

后在遵守顺

序性的前提

下，随机确定

它们

之间的

拓扑联接。如

此，称二叉搜

索树由这组

节点“随机组

成”（randomly composed）。

实际上，由

n个互异节点

组成的二叉

搜索树，总共

可能有(2n)!/n!/(n +

1)!棵（习

题

[7-2]）。若这些树

出现的概率

均等，则通过

对其高度做

平均可知[30]，平

均查找长度

为( n)。



比较

前一

口径的(logn)与后

一口径的( n)之

间，就渐进意

义而言有实

质的差别。原

因何在？

读者

也许已经发

现，同一组关

键码的不同

排列所生成

的二叉搜索

树，未必不同

。仍以图7.9

为例

，排列(2, 1, 3)与(2, 3,

1)生成

的，实际上就

是同一棵二

叉搜索树。而

在按照前一

口径

估计平

均树高时，这

棵树被统计

了两次。实际

上一般而言

，越是平衡的

树，被统计的

次数亦越多

。

从这个角度

讲，前一种平

均的方式，在

无形中高估

了二叉搜索

树的平均性

能。因此相对

而言，按

照后

一口径所得

的估计值更

加可信。

§7.3 平衡

二叉搜索树

第7章 搜索树

192



树高与平均

树高

实际上

，即便按照以

上口径统计

出平均树高

，仍不足以反

映树高的随

机分布情况

。实际上，

树高

较大情况的

概率依然可

能很大。另外

，理想的随机

并不常见，实

际应用中的

情况恰恰相

反，

一组关键

码往往会按

照（接近）单调

次序出现，因

此频繁出现

极高的搜索

树也不足为

怪。

另外，若removeAt()操

作的确如代

码7.7所示，总是

固定地将待

删除的二度

节点与其直

接

后继交换

，则随着操作

次数的增加

，二叉搜索树

向左侧倾斜

的趋势将愈

发明显（习题

[7-9]）。

7.3.2 理想平衡与

适度平衡

 理

想平衡

既然

二叉搜索树

的性能主要

取决于高度

，故在节点数

目固定的前

提下，应尽可

能地降低高

度。

相应地，应

尽可能地使

兄弟子树的

高度彼此接

近，即全树尽

可能地平衡

。当然，包含n个

节点的

二叉

树，高度不可

能小于log2n（习题

[7-3]）。若树高恰好

为log2n，则称作理

想平衡树。

例

如，如图5.26所示

的完全二叉

树，甚至如图

5.27所示的满二

叉树，均属此

列。

遗憾的是

，完全二叉树

“叶节点只能

出现于最底

部两层”的限

制过于苛刻

。略做简单的

组合

统计不

难发现，相对

于二叉树所

有可能的形

态，此类二叉

树所占比例

极低；而随着

二叉树规模

的

增大，这一

比例还将继

续锐减（习题

[7-2]）。由此可见，从

算法可行性

的角度来看

，有必要依

照

某种相对宽

松的标准，重

新定义二叉

搜索树的平

衡性。

 适度平

衡

在渐进意

义下适当放

松标准之后

的平衡性，称

作适度平衡

。

幸运的是，适

度平衡的标

准的确存在

。比如，若将树

高限制为“渐

进地不超过

O(logn)”，

则下节将要

介绍的AVL树，以

及下一章将

要介绍的伸

展树、红黑树

、kd-树等，都属于

适度平衡。

这

些变种，因此

也都可归入

平衡二叉搜

索树（balanced

binary search tree, BBST）之列。

7.3.3 等

价变换

 等价

二叉搜索树

如图7.10所示，若

两棵二叉搜

索树的中序

遍历序列相

同，则称它们

彼此等价；反

之亦然。

图7.10 由

同一组共11个

节点组成，相

互等价癿两

棵事叉搜索

树（事者在拓

扑上癿差异

，以阴影圀出

）

由该图也不

难看出，虽然

等价二叉搜

索树中各节

点的垂直高

度可能有所

不同，但水平

次序完

全一

致。这一特点

可概括为“上

下可变，左右

不乱”，它也是

以下等价变

换的基本特

性。

第7章 搜索

树 §7.3 平衡二叉

搜索树

193

 局部

性

平衡二叉

搜索树的适

度平衡性，都

是通过对树

中每一局部

增加某种限

制条件来保

证的。比如，

在

红黑树中，从

树根到叶节

点的通路，总

是包含一样

多的黑节点

；在AVL树中，兄弟

节点的高度

相差不过1。事

实上，这些限

制条件设定

得非常精妙

，除了适度平

衡性，还具有

如下局部性

：

1）经过单次动

态修改操作

后，至多只有

O(1)处局部不再

满足限制条

件

2）总可在O(logn)时

间内，使这O(1)处

局部（以至全

树）重新满足

限制条件

这

就意味着：刚

刚失去平衡

的二叉搜索

树，必然可以

迅速转换为

一棵等价的

平衡二叉搜

索树。

等价二

叉搜索树之

间的上述转

换过程，也称

作等价变换

。

这里的局部

性至关重要

。比如，尽管任

何二叉搜索

树都可等价

变换至理想

平衡的完全

二叉树，

然而

鉴于二者的

拓扑结构可

能相去甚远

，在最坏情况

下我们为此

将不得不花

费O(n)时间。反观

图7.10中相互等

价的两棵二

叉搜索树，右

侧属于AVL树，而

左侧不是。鉴

于二者的差

异仅限于某

一局部（阴影

区域），故可轻

易地将后者

转换为前者

。

那么，此类局

部性的失衡

，具体地可以

如何修复？如

何保证修复

的速度？

7.3.4 旋转

调整

最基本

的修复手段

，就是通过围

绕特定节点

的旋转，实现

等价前提下

的局部拓扑

调整。



zig和zag

如图

7.11(a)所示，设c和Z是

v的左孩子、右

子树，X和Y是c的

左、右子树。所

谓以v为轴的

zig

旋转，即如图

(b)所示，重新调

整这两个节

点与三

棵子

树的联接关

系：将X和v作为

c的左子树、右

孩

子，Y和Z分别

作为v的左、右

子树。

可见，尽

管局部结构

以及子树根

均有变化，但

中序遍历序

列仍是{ ..., X,

c, Y, v, Z,

... }，

故zig旋

转属于等价

变换。

对称地

如图7.12(a)所示，设

X和c是v的左子

树、右孩子，Y和

Z分别是c的左

、右子树。所谓

以v

为轴的zag旋

转，即如图(b)所

示，重新调整

这两个

节点

与三棵子树

的联接关系

：将v和Z作为c的

左孩

子、右子

树，X和Y分别作

为v的左、右子

树。

同样地，旋

转之后中序

遍历序列依

然不变，故

zag旋

转亦属等价

变换。

图7.11 zig(v)：顸时

针旋转

图7.12

zag(v)：逆

时针旋转

 效

率与效果

zig和

zag旋转均属局

部操作，仅涉

及常数个节

点及其之间

的联接关系

，故均可在常

数时间

内完

成。正因如此

，在后面实现

各种二叉搜

索树平衡化

算法时，它们

都是支撑性

的基本操作

。

就与树相关

的指标而言

，经一次zig或zag旋

转之后，节点

v的深度加一

，节点c的深度

减一；

这一局

部子树（乃至

全树）的高度

可能发生变

化，但上、下幅

度均不超过

一层。

§7.4

AVL树 第7章

搜索树

194

§7.4

AVL树

通

过合理设定

适度平衡的

标准，并借助

以上等价变

换，AVL树（AVL tree）②可以实

现近乎

理想

的平衡。在渐

进意义下，AVL树

可始终将其

高度控制在

O(logn)以内，从而保

证每次查找

、

插入或删除

操作，均可在

O(logn)的时间内完

成。

7.4.1 定义及性

质



平衡因子

任一节点v的

平衡因子（balance factor）定

义为“其左、右

子树的高度

差”，即

balFac(v) =

height(lc(v)) - height(rc(v))

请注意

，本书中空树

高度取-1，单节

点子树（叶节

点）高度取0，与

以上定义没

有冲突。

所谓

AVL树，即平衡因

子受限的二

叉搜索树其

中各节点平

衡因子的绝

对值均不超

过1。

 接口定义

基于BST模板类

（185页代码7.2），可直

接派生出AVL模

板类如代码

7.8所示。

1

#include "../BST/BST.h" //基亍BST实

现AVL树

2

template <typename T> class

AVL : public BST<T>

{ //由BST派生

AVL树模板类

3 public:

4 BinNodePosi(T) insert (

const T& e );

//揑

入（重写）

5 bool remove

( const T& e

); //初除

（重写）

6 //

BST::search()等其余

接口可直接

沿用

7 };

代码7.8

基

二BST定义癿AVL树

接口

可见，这

里直接沿用

了BST模板类的

search()等接口，并根

据AVL树的重平

衡规则与算

法，

重写了insert()和

remove()接口，其具体

实现将在后

续数节陆续

给出。

另外，为

简化对节点

平衡性的判

断，算法实现

时可借用以

下宏定义：

1 #define Balanced(x) (

stature( (x).lc ) ==

stature( (x).rc ) )

//理

想平衡条件

2 #define BalFac(x) (

stature( (x).lc ) -

stature( (x).rc ) )

//平衡因子

3 #define AvlBalanced(x)

( ( -2 <

BalFac(x) ) && (

BalFac(x) < 2 )

) //AVL平

衡条件

代码

7.9 用二简化AVL树

算法描述癿

宏

 平衡性

在

完全二叉树

中各节点的

平衡因子非

0即1，故完全二

叉树必是AVL树

；不难举例说

明，反之

不然

。完全二叉树

的平衡性可

以自然保证

（习题[7-3]），那AVL树的

平衡性又如

何呢？可以证

明，高度为h的

AVL树至少包含

fib(h

+ 3) - 1个节点。为此

需做数学归

纳。

作为归纳

基，当h = 0时，T中至

少包含fib(3) -

1 = 2 -

1 = 1个节

点，命题成立

；

当h

= 1时，T中至少

包含fib(4) - 1

= 3 - 1

= 2个节点

，命题也成立

。

② 由G. M. Adelson-Velsky和E.

M. Landis不1962年収

明[36]，幵以他们

名字癿首字

殎命名

第7章

搜索树 §7.4

AVL树

195

假

设对于高度

低于h的任何

AVL树，以上

命题

均成立。现考

查高度为h的

所有AVL树，

并取

S为其中节点

最少的任何

一棵（请注意

，

这样的S可能

不止一棵）。

如

图7.13，设S的根节

点为r，r的左、

右

子树分别为

SL和SR，将其高度

记作hL和hR，

其规

模记作|SL|和|SR|。于

是就有：

|S| = 1

+ |SL| + |SR|

图7.13 在

高度固定为

h癿前提下，节

点最少癿AVL树

作为S的子树

，SL和SR也都是AVL树

，而且高度不

超过h - 1。进一步

地，在考虑到

AVL树有

关平衡

因子的要求

的同时，既然

S中的节点数

最少，故SL和SR的

高度只能是

一个为h - 1，另一

个

为h

- 2不失一

般性，设hL = h

- 1，hR = h

- 2。而且

，在所有高度

为hL（hR）的AVL树中，

SL（SR）中

包含的节点

也应该最少

。因此，根据归

纳假设，可得

如下关系：

|S|

= 1 + (fib(h

+ 2) - 1)

+ (fib(h + 1)

- 1)

根

据Fibonacci数列的定

义，可得：

|S|

= fib(h + 2)

+ fib(h + 1)

- 1 = fib(h

+ 3) - 1

总而

言之，高度为

h的AVL树的确至

少包含fib(h + 3) -

1个节

点。于是反过

来，包含n个

节

点的AVL树的高

度应为O(logn)。因此

就渐进意义

而言，AVL树的确

是平衡的。

 失

衡与重平衡

AVL树与常规的

二叉搜索树

一样，也应支

持插入、删除

等动态修改

操作。但经过

这类操作之

后，节点的高

度可能发生

变化，以致于

不再满足AVL树

的条件。

以插

入操作为例

，考查图7.14(b)中的

AVL树，其中的关

键码为字符

类型。现按代

码7.5中

二叉搜

索树的通用

算法BST::insert()插入关

键码'M'，于是如

图(c)所示，节点

'N'、'R'和'G'

都将失衡

。类似地，按代

码7.6中二叉搜

索树的通用

算法BST::remove()摘除关

键码'Y'之后，

也

会如图(a)所示

导致节点'R'的

失衡。

图7.14 绊节

点初除和揑

入操作后，AVL树

可能失衡（加

减号示意平

衡因子，双圀

表示失衡节

点）

如此因节

点x的插入或

删除而暂时

失衡的节点

，构成失衡节

点集，记作UT(x)。请

注意，若x

为被

摘除的节点

，则UT(x)仅含单个

节点；但若x为

被引入的节

点，则UT(x)可能包

含多个节点

（习

题[7-13]）。由以上

实例，也可验

证这一性质

。

以下，我们从

对UT(x)的分析入

手，分别介绍

使失衡搜索

树重新恢复

平衡的调整

算法。

§7.4 AVL树

第7章

搜索树

196

7.4.2 节点

插入

 失衡节

点集

不难看

出，新引入节

点x后，UT(x)中的节

点都是x的祖

先，且高度不

低于x的祖父

。以下，

将其中

的最深者记

作g(x)。在x与g(x)之间

的通路上，设

p为g(x)的孩子，v为

p的孩子。注意

，

既然g(x)不低于

x的祖父，则p必

是x的真祖先

。

 重平衡

首先

，需要找到如

上定义的g(x)。为

此，可从x出发

沿parent指针逐层

上行并核对

平衡因子，

首

次遇到的失

衡祖先即为

g(x)。既然原树是

平衡的，故这

一过程只需

O(logn)时间。

请注意

，既然g(x)是因x的

引入而失衡

，则p和v的高度

均不会低于

其各自的兄

弟。因此，借

助

如代码7.10所示

的宏tallerChild()，即可反

过来由g(x)找到

p和v。

1

/******************************************************************************************

2 * 在左、右孩

子中叏更高

者

3 * 在AVL平衡调

整前，倚此确

定重极斱案

4 ******************************************************************************************/

5 #define tallerChild(x) (

\

6 stature( (x)->lc

) > stature( (x)->rc

) ? (x)->lc :

( /*左高*/ \

7

stature( (x)->lc ) <

stature( (x)->rc ) ?

(x)->rc : ( /*右高*/

\

8 IsLChild( *

(x) ) ? (x)->lc

: (x)->rc /*等

高：不父亲x同

侧者（zIg-zIg戒zAg-zAg）优先

*/ \

9 ) \

10

) \

11 )

代码7.10 恢复平

衡癿调整斱

案，决定二失

衡节点癿更

高孩子、更高

孙子节点癿

斱向

这里并

未显式地维

护各节点的

平衡因子，而

是在需要时

通过比较子

树的高度直

接计算。

以下

，根据节点g(x)、p和

v之间具体的

联接方向，将

采用不同的

局部调整方

案。分述如下

。

 单旋

如图7.15(a)所

示，设v是p的右

孩

子，且p是g的

右孩子。

这种

情况下，必是

由于在子树

v中刚

插入某

节点x，而使g(x)不

再平衡。图中

以虚线联接

的每一对灰

色方块中，其

一

对应于节

点x，另一为空

。

此时，可采用

7.3.4节的技巧，做

逆时针旋转

zag(g(x))，得到如图(b)所

示的另一棵

等价二叉搜

索树。

可见，经

如此调整之

后，g(x)必将

恢复

平衡。不难验

证，通过zig(g(x))

可以

处理对称的

失衡。 图7.15

节点

揑入后，通过

单旋操作使

AVL树重新平衡

第7章 搜索树

§7.4 AVL树

197

 双旋

如图

7.16(a)所示，设节点

v是p的左孩子

，而p是g(x)的右孩

子。

图7.16

节点揑

入后通过还

续癿两次旋

转操作使AVL树

重新平衡

这

种情况，也必

是由于在子

树v中插入了

新节点x，而致

使g(x)不再平衡

。同样地，在图

中

以虚线联

接的每一对

灰色方块中

，其一对应于

新节点x，另一

为空。

此时，可

先做顺时针

旋转zig(p)，得到如

图(b)所示的一

棵等价二叉

搜索树。再做

逆时针旋

转

zag(g(x))，得到如图(c)所

示的另一棵

等价二叉搜

索树。

此类分

别以父子节

点为轴、方向

互逆的连续

两次旋转，合

称“双旋调整

”。可见，经如此

调

整之后，g(x)亦

必将重新平

衡。不难验证

，通过zag(p)和zig(g(x))可以

处理对称的

情况。



高度复

原

纵观图7.15和

图7.16可见，无论

单旋或双旋

，经局部调整

之后，不仅g(x)能

够重获平衡

，

而且局部子

树的高度也

必将复原。这

就意味着，g(x)以

上所有祖先

的平衡因子

亦将统一地

复原

换而言

之，在AVL树中插

入新节点后

，仅需不超过

两次旋转，即

可使整树恢

复平衡。

 实现

1 template <typename

T> BinNodePosi(T) AVL<T>::insert (

const T& e )

{ //将兲键码e揑

入AVL树中

2 BinNodePosi(T)

& x = search

( e ); if

( x ) return

x; //确讣

目标节点丌

存在

3 BinNodePosi(T)

xx = x =

new BinNode<T> ( e,

_hot ); _size++; //创建新

节点x

4 // 此时，x癿

父亲_hot若增高

，则其祖父有

可能失衡

5

for ( BinNodePosi(T) g

= _hot; g; g

= g->parent ) {

//从

x乀父出収向

上，逐局检查

各代祖先g

6 if (

!AvlBalanced ( *g )

) { //一

旦収现g失衡

，则（采用“3 +

4”算法

）使乀复衡，幵

将子树

7 FromParentTo (

*g ) = rotateAt

( tallerChild ( tallerChild

( g ) )

); //重新

接入原树

8 break;

//g复

衡后，尿部子

树高度必然

复原；其祖先

亦必如此，故

调整随即结

束

9 } else

//否则（g依然

平衡），叧需简

单地

10 updateHeight (

g ); //更新其

高度（注意：即

便g未失衡，高

度亦可能增

加）

11

} //至夗叧需

一次调整；若

枅真做过调

整，则全树高

度必然复原

12 return xx;

//迒回新节点

位置

13 } //无讳e是

否存在亍原

树中，总有AVL::insert(e)->data

== e

代

码7.11 AVL树节点癿

揑入

§7.4 AVL树 第7章

搜索树

198

 效率

如代码7.11所示

，该算法首先

按照二叉搜

索树的常规

算法，在O(logn)时间

内插入新节

点x。

既然原树

是平衡的，故

至多检查O(logn)个

节点即可确

定g(x)；如有必要

，至多旋转两

次，即可

使局

部乃至全树

恢复平衡。由

此可见，AVL树的

节点插入操

作可以在O(logn)时

间内完成。

7.4.3 节

点删除

 失衡

节点集

与插

入操作十分

不同，在摘除

节点x后，以及

随后的调整

过程中，失衡

节点集UT(x)始终

至

多只含一

个节点（习题

[7-13]）。而且若该节

点g(x)存在，其高

度必与失衡

前相同。

另外

还有一点重

要的差异是

，g(x)有可能就是

x的父亲。



重平

衡

与插入操

作同理，从_hot节

点（7.2.6节）出发沿

parent指针上行，经

过O(logn)时间即

可

确定g(x)位置。作

为失衡节点

的g(x)，在不包含

x的一侧，必有

一个非空孩

子p，且p的高度

至

少为1。于是

，可按以下规

则从p的两个

孩子（其一可

能为空）中选

出节点v：若两

个孩子不等

高，

则v取作其

中的更高者

；否则，优先取

v与p同向者（亦

即，v与p同为左

孩子，或者同

为右孩子）。

以

下不妨假定

失衡后g(x)的平

衡因子为+2（为

-2的情况完全

对称）。根据祖

孙三代节点

g(x)、p和v的位置关

系，通过以g(x)和

p为轴的适当

旋转，同样可

以使得这一

局部恢复平

衡。

 单旋

如图

7.17(a)所示，由于在

T3中删除了节

点而致使g(x)不

再平衡，但p的

平衡因子非

负时，

通过以

g(x)为轴顺时针

旋转一次即

可恢复局部

的平衡。平衡

后的局部子

树如图(b)所示

。

图7.17 节点初除

后绊一次旋

转恢复尿部

平衡

同样地

这里约定，图

中以虚线联

接的灰色方

块所对应的

节点，不能同

时为空；T2底部

的灰色

方块

所对应的节

点，可能为空

，也可能非空

。

 双旋

如图7.18(a)所

示，g(x)失衡时若

p的平衡因子

为-1，则经过以

p为轴的一次

逆时针旋转

之

后（图(b)），即可

转化为图7.17(a)的

情况。

第7章 搜

索树

§7.4 AVL树

199

图7.18

节

点初除后通

过两次旋转

恢复尿部平

衡

接着再套

用上一情况

的处理方法

，以g(x)为轴顺时

针旋转，即可

恢复局部平

衡（图(c)）。

 失衡传

播

与插入操

作不同，在删

除节点之后

，尽管也可通

过单旋或双

旋调整使局

部子树恢复

平衡，但

复平

衡之后，局部

子树的高就

全局而言，依

然可能再次

失衡。若能仔

细观察图7.17(b)和

图

7.18(c)，则不难发

现：g(x)恢度却可

能降低。这与

引入节点之

后的重平衡

后完全不同

在上

一节我

们已看到，后

者不仅能恢

复子树的平

衡性，也同时

能恢复子树

的高度。

设g(x)复

衡之后，局部

子树的高度

的确降低。此

时，若g(x)原本属

于某一更高

祖先的更短

分支，则因为

该分支现在

又进一步缩

短，从而会致

使该祖先失

衡。在摘除节

点之后的调

整过程中，

这

种由于低层

失衡节点的

重平衡而致

使其更高层

祖先失衡的

现象，称作“失

衡传播”。

请注

意，失衡传播

的方向必然

自底而上，而

不致于影响

到后代节点

。在此过程中

的任一时刻

，

至多只有一

个失衡的节

点；高层的某

一节点由平

衡转为失衡

，只可能发生

在下层失衡

节点恢复平

衡之后。因此

，可沿parent指针逐

层遍历所有

祖先，每找到

一个失衡的

祖先节点，即

可套用以

上

方法使之恢

复平衡（习题

[7-19]）。

 实现

以上算

法过程，可描

述并实现如

代码7.12所示。

1 template <typename T>

bool AVL<T>::remove ( const

T& e ) {

//从

AVL树中初除兲

键码e

2 BinNodePosi(T) &

x = search (

e ); if (

!x ) return false;

//确讣目

标存在（留意

_hot癿讴置）

3 removeAt (

x, _hot ); _size--;

//先按

BST觃则初除乀

（此后，原节点

乀父_hot及其祖

先均可能失

衡）

4 for (

BinNodePosi(T) g = _hot;

g; g = g->parent

) { //从_hot出収向

上，逐局检查

各代祖先g

5

if ( !AvlBalanced (

*g ) ) //一

旦収现g失衡

，则（采用“3

+ 4”算法

）使乀复衡，幵

将诠子树联

至

6 g

= FromParentTo ( *g

) = rotateAt (

tallerChild ( tallerChild (

g ) ) );

//原父亲

7 updateHeight (

g ); //幵

更新其高度

（注意：即便g未

失衡，高度亦

可能降低）

8

} //可

能需做Omega(logn)次调

整——无讳是否

做过调整，全

树高度均可

能降低

9 return

true; //初除

成功

10 }

//若目标

节点存在且

被初除，迒回

true；否则迒回false

代

码7.12 AVL树节点癿

初除

§7.4

AVL树 第7章

搜索树

200



效率

由上可见，较

之插入操作

，删除操作可

能需在重平

衡方面多花

费一些时间

。不过，既然需

做

重平衡的

节点都是x的

祖先，故重平

衡过程累计

只需不过O(logn)时

间（习题[7-17]）。综合

各

方面的消

耗，AVL树的节点

删除操作总

体的时间复

杂度依然是

O(logn)。

7.4.4

统一重平衡

算法

上述重

平衡的方法

，需要根据失

衡节点及其

孩子节点、孙

子节点的相

对位置关系

，分别做单

旋

或双旋调整

。按照这一思

路直接实现

调整算法，代

码量大且流

程繁杂，必然

导致调试困

难且容

易出

错。为此，本节

将引入一种

更为简明的

统一处理方

法。

无论对于

插入或删除

操作，新方法

也同样需要

从刚发生修

改的位置x出

发逆行而上

，直至遇

到最

低的失衡节

点g(x)。于是在g(x)更

高一侧的子

树内，其孩子

节点p和孙子

节点v必然存

在，

而且这一

局部必然可

以g(x)、p和v为界，分

解为四棵子

树按照图7.15至

图7.18中的惯例

，

将它们按中

序遍历次序

重命名为T0至

T3。

若同样按照

中序遍历次

序，重新排列

g(x)、p和v，并将其命

名为a、b和c，则这

一局部的中

序遍历序列

应为：

{ T0, a,

T1, b, T2, c,

T3 }

这就意

味着，这一局

部应等价于

如图7.19所示的

子树。更重要

的是，纵观图

7.15至图7.18

可见，这

四棵子树的

高度相差不

超过一层，故

只需如图7.19所

示将这三个

节点与四棵

子树重新

“组

装”起来，恰好

即是一棵AVL树

！

图7.19 节点揑入

后癿统一重

新平衡

实际

上，这一理解

涵盖了此前

两节所有的

单旋和双旋

情况。相应的

重构过程，仅

涉及局部的

三个节点及

其四棵子树

，故称作“3

+ 4”重构

。其具体实现

如代码7.13所示

。

1 /******************************************************************************************

2 * 按照“3 +

4”结极联

接3个节点及

其四棵子树

，迒回重组乀

后癿尿部子

树根节点位

置（即b）

3 * 子树根

节点不上局

节点乀间癿

双向联接，均

须由上局调

用者完成

4 * 可

用亍AVL和RedBlack癿尿

部平衡调整

5 ******************************************************************************************/

6 template <typename T>

BinNodePosi(T) BST<T>::connect34 (

7

BinNodePosi(T) a, BinNodePosi(T) b,

BinNodePosi(T) c,

8 BinNodePosi(T)

T0, BinNodePosi(T) T1, BinNodePosi(T)

T2, BinNodePosi(T) T3

9

) {

10 a->lc

= T0; if (

T0 ) T0->parent =

a;

11 a->rc =

T1; if ( T1

) T1->parent = a;

updateHeight ( a );

第7章 搜索树

§7.4 AVL树

201

12 c->lc = T2;

if ( T2 )

T2->parent = c;

13

c->rc = T3; if

( T3 ) T3->parent

= c; updateHeight (

c );

14 b->lc

= a; a->parent =

b;

15 b->rc =

c; c->parent = b;

updateHeight ( b );

16 return b; //诠子树新

癿根节点

17 }

代

码7.13 “3

+ 4”重极

利用

以上connect34()算法，即

可视不同情

况，按如下具

体方法完成

重平衡：

1

/******************************************************************************************

2 * BST节点

旋转发换统

一算法（3节点

+

4子树），迒回调

整乀后尿部

子树根节点

癿位置

3 * 注意

：尽管子树根

会正确指向

上局节点（如

枅存在），但反

向癿联接须

由上局函数

完成

4 ******************************************************************************************/

5 template

<typename T> BinNodePosi(T) BST<T>::rotateAt

( BinNodePosi(T) v )

{ //v为非空

孙辈节点

6 BinNodePosi(T)

p = v->parent; BinNodePosi(T)

g = p->parent; //规

v、p和g相对位置

分四种情冴

7

if ( IsLChild (

*p ) ) /*

zig */

8 if

( IsLChild ( *v

) ) { /*

zig-zig */

9 p->parent

= g->parent; //向上联接

10

return connect34 ( v,

p, g, v->lc, v->rc,

p->rc, g->rc );

11

} else { /*

zig-zag */

12 v->parent

= g->parent; //向

上联接

13

return connect34 ( p,

v, g, p->lc, v->lc,

v->rc, g->rc );

14

}

15 else /*

zag */

16 if

( IsRChild ( *v

) ) { /*

zag-zag */

17 p->parent

= g->parent; //向上

联接

18

return connect34 ( g,

p, v, g->lc, p->lc,

v->lc, v->rc );

19

} else { /*

zag-zig */

20 v->parent

= g->parent; //向上联

接

21

return connect34 ( g,

v, p, g->lc, v->lc,

v->rc, p->rc );

22

}

23 }

代码7.14

AVL树癿

统一重平衡

将图7.19与图7.15至

图7.18做一比对

即可看出，统

一调整算法

的效果，的确

与此前的单

旋、

双旋算法

完全一致。另

外不难验证

，新算法的复

杂度也依然

是O(1)。

§7.4 AVL树

第7章 搜

索树

202

第8章

高

级搜索树

§8.1 伸

展树 第8章

高

级搜索树

204

除

了AVL树，本章将

按照如图7.1所

示的总体框

架，继续介绍

平衡二叉搜

索树家族中

的其它

成员

。首先，鉴于数

据访问的局

部性在实际

应用中普遍

存在，将按照

“最常用者优

先”的启发策

略，引入并实

现伸展树。尽

管最坏情况

下其单次操

作需要O(n)时间

，但分摊而言

仍在O(logn)

以内。构

思巧妙，实现

简洁，加上适

用广泛，这些

特点都使得

伸展树具有

别样的魅力

。

接下来，通过

对平衡二叉

搜索树的推

广，引入平衡

多路搜索树

，并着重讨论

作为其中典

型代

表的B-树

。借助此类结

构，可以有效

地弥合不同

存储级别之

间，在访问速

度上的巨大

差异。

对照4阶

B-树，还将引入

并实现红黑

树。红黑树不

仅能保持全

树的适度平

衡，从而有效

地控

制单次

操作的时间

成本，而且可

以将每次重

平衡过程执

行的结构性

调整，控制在

常数次数以

内。

后者也是

该树有别于

其它变种的

关键特性，它

不仅保证了

红黑树更高

的实际计算

效率，更为持

久

性结构（persistent structure）之

类高级数据

结构的实现

，提供了直接

而有效的方

法。

最后，将针

对平面范围

查询应用，介

绍基于平面

子区域正交

划分的kd-树结

构。该结构是

对

四叉树（quadtree）和

八叉树（octree）等结

构的一般性

推广，它也为

计算几何类

应用问题的

求解，提供了

一种基本的

模式和有效

的方法。

§8.1 伸展

树

与前一章

的AVL树一样，伸

展树（splay tree）①也是平

衡二叉搜索

树的一种形

式。相对于

前

者，后者的实

现更为简捷

。伸展树无需

时刻都严格

地保持全树

的平衡，但却

能够在任何

足够长

的真

实操作序列

中，保持分摊

意义上的高

效率。伸展树

也不需要对

基本的二叉

树节点结构

，做任

何附加

的要求或改

动，更不需要

记录平衡因

子或高度之

类的额外信

息，故适用范

围更广。

8.1.1 局部

性

信息处理

的典型模式

是，将所有数

据项视作一

个集合，并将

其组织为某

种适宜的数

据结构，

进而

借助操作接

口高效访问

。本书介绍的

搜索树、词典

和优先级队

列等，都可归

于此类。

为考

查和评价各

操作接口的

效率，除了从

最坏情况的

角度出发，也

可假定所有

操作彼此独

立、

次序随机

且概率均等

，并从平均情

况的角度出

发。然而，后一

尺度所依赖

的假定条件

，往往并不

足

以反映真实

的情况。实际

上，通常在任

意数据结构

的生命期内

，不仅执行不

同操作的概

率往往

极不

均衡，而且各

操作之间具

有极强的相

关性，并在整

体上多呈现

出极强的规

律性。其中最

为典

型的，就

是所谓的“数

据局部性”（data locality），这

包括两个方

面的含义：

1）刚

刚被访问过

的元素，极有

可能在不久

之后再次被

访问到

2）将被

访问的下一

元素，极有可

能就处于不

久之前被访

问过的某个

元素的附近

充分利用好

此类特性，即

可进一步地

提高数据结

构和算法的

效率。比如习

题[3-6]中的自调

① 由D.

D. Sleator和R. E. Tarjan亍1985年収

明[41]

第8章 高级

搜索树 §8.1 伸展

树

205

整列表，就

是通过“即用

即前移”的启

发式策略，将

最为常用的

数据项集中

于列表的前

端，从而

使得

单次操作的

时间成本大

大降低。同样

地，类似的策

略也可应用

于二叉搜索

树。

就二叉搜

索树而言，数

据局部性具

体表现为：

1）刚

刚被访问过

的节点，极有

可能在不久

之后再次被

访问到

2）将被

访问的下一

节点，极有可

能就处于不

久之前被访

问过的某个

节点的附近

因此，只需将

刚被访问的

节点，及时地

“转移”至树根

（附近），即可加

速后续的操

作。当然，

转移

前后的搜索

树必须相互

等价，故为此

仍需借助7.3.4节

中等价变换

的技巧。

8.1.2

逐层

伸展

 简易伸

展树

一种直

接方式是：每

访问过一个

节点之后，随

即反复地以

它的父节点

为轴，经适当

的旋转将

其

提升一层，直

至最终成为

树根。以图8.1为

例，若深度为

3的节点E刚被

访问无论查

找或插

入，甚

至“删除”都可

通过3次旋转

，将该树等价

变换为以E为

根的另一棵

二叉搜索树

。

图8.1 通过自下

而上癿一系

列等价发换

，可使仸一节

点上升至树

根

随着节点

E的逐层上升

，两侧子树的

结构也不断

地调整，故这

一过程也形

象地称作伸

展

（splaying），而采用这

一调整策略

的二叉搜索

树也因此得

名。不过，为实

现真正意义

上的伸

展树

，还须对以上

策略做点微

妙而本质的

改进。之所以

必须改进，是

因为目前的

策略仍存在

致命

的缺陷

对于很多访

问序列，单次

访问的分摊

时间复杂度

在极端情况

下可能高达

(n)。

 最坏情况

不

难验证，若从

空树开始依

次插入关键

码{ 1,

2, 3, 4, 5

}，且其间采

用如上调整

策略，

则可得

到如图8.2(a)所示

的二叉搜索

树。

图8.2 简易伸

展树癿最坏

情冴

接下来

，若通过search()接口

，再由小到大

地依次访问

各节点一次

，则该树在各

次访问之

后

的结构形态

将如图(b~f)所示

。

可见，在各次

访问之后，为

将对应节点

伸展调整至

树根，分别需

做4、4、3、2和1次旋转

。

§8.1

伸展树 第8章

高级搜索树

206

一般地，若节

点总数为n，则

旋转操作的

总次数应为

：

(n - 1) +

{ (n - 1)

+ (n - 2)

+ ... + 1

}

= (n2

+

n - 2)/2 =

(n2

)

如此分摊下

来，每次访问

平均需要(n)时

间。很遗憾，这

一效率不仅

远远低于AVL树

，而且甚至

与

原始的二叉

搜索树的最

坏情况相当

。而事实上，问

题还远不止

于此。

稍做比

对即不难发

现，图8.2(a)与(f)中二

叉搜索树的

结构完全相

同。也就是说

，经过以上

连

续的5次访问

之后，全树的

结构将会复

原！这就意味

着，以上情况

可以持续地

再现。

当然，这

一实例，完全

可以推广至

规模任意的

二叉搜索树

。于是对于规

模为任意n的

伸展树，

只要

按关键码单

调的次序，周

期性地反复

进行查找，则

无论总的访

问次数m

>> n有多

大，就分

摊意

义而言，每次

访问都将需

要(n)时间！

那么

，这类最坏的

访问序列能

否回避？具体

地，又应该如

何回避？

8.1.3 双层

伸展

为克服

上述伸展调

整策略的缺

陷，一种简便

且有效的方

法就是：将逐

层伸展改为

双层伸展。

具

体地，每次都

从当前节点

v向上追溯两

层（而不是仅

一层），并根据

其父亲p以及

祖父g的相对

位置，进行相

应的旋转。以

下分三类情

况，分别介绍

具体的处理

方法。

 zig-zig/zag-zag

如图8.3(a)所

示，

设v是p的左

孩子，且p也

是

g的左孩子；设

W和X分

别是v的

左、右子树，Y和

Z分别是p和g的

右子树。

图8.3 通

过zig-zig操作，将节

点v上推两局

针对这种情

况，首先以节

点g为轴做顺

时针旋转zig(g)，其

效果如图(b)所

示。然后，再以

p

为轴做顺时

针旋转zig(p)，其效

果如图(c)所示

。如此连续的

两次zig旋转，合

称zig-zig调整。

自然

地，另一完全

对称的情形

v是p的右孩子

，且p也是g的右

孩子则可通

过连续的

两

次逆时针旋

转实现调整

，合称zag-zag操作。这

一操作的具

体过程，请读

者独立绘出

。



zig-zag/zag-zig

如图8.4(a)所示，

设

v是p的左孩子

，而p是g

的右孩

子；设W是g的左

子

树，X和Y分别

是v的左、

右子

树，Z是p的右子

树。

图8.4 通过zig-zag操

作，将节点v上

推两局

针对

这种情况，首

先以节点p为

轴做顺时针

旋转zig(p)，其效果

如(b)所示。然后

，再以g

为轴做

逆时针旋转

zag(g)，其效果如图

(c)所示。如此zig旋

转再加zag旋转

，合称zig-zag调整。

同

样地，另一完

全对称的情

形v是p的右孩

子，而p是g的左

孩子则可通

过zag旋转再

加

zig旋转实现调

整，合称zag-zig操作

。这一操作的

具体过程，请

读者独立绘

出。

第8章 高级

搜索树 §8.1 伸展

树

207

 zig/zag

如图8.5(a)所示

，若v最初的深

度为奇数，则

经

过若干次

双层调整至

最后一次调

整时，v的父亲

p即是

树根r。将

v的左、右子树

记作X和Y，节点

p = r的另

一子树

记作Z。

此时，只

需围绕p = r做顺

时针旋转zig(p)，即

可如图(b)所示

，使v最终攀升

至树根，从而

结束整个

伸

展调整的过

程。

zag调整与之

对称，其过程

请读者独立

绘出。 图8.5 通过

zig操作，将节点

v上推一局，成

为树根

 效果

与效率

综合

以上各种情

况，每经过一

次双层调整

操作，节点v都

会上升两层

。若v的初始深

度depth(v)

为偶数，则

最终v将上升

至树根。若depth(v)为

奇数，则当v上

升至深度为

1时，不妨最后

再相应

地做

一次zig或zag单旋

操作。无论如

何，经过depth(v)次旋

转后，v最终总

能成为树根

。

重新审视图

8.2的最坏实例

不难发现，这

一访问序列

导致(n)平均单

次访问时间

的原因，

可以

解释为：在这

一可持续重

复的过程中

，二叉搜索树

的高度始终

不小于n/2；而且

，至少有

一半

的节点在接

受访问时，不

仅没有如最

初设想的那

样靠近树根

，而且反过来

恰恰处于最

底层。

从树高

的角度看，问

题根源也可

再进一步地

解释为：在持

续访问的过

程中，树高依

算术级数逐

步

从n - 1递减至

n/2，然后再逐步

递增回到n

- 1。那

么，采用上述

双层伸展的

策略将每一

刚被

访问过

的节点推至

树根，可否避

免如图8.2所示

的最坏情况

呢？

稍作对比

不难看出，就

调整之后的

局部结构而

言，zig-zag和zag-zig调整与

此前的逐层

伸

展完全一

致（亦等效于

AVL树的双旋调

整），而zig-zig和zag-zag调整

则有所不同

。事实上，

后者

才是双层伸

展策略优于

逐层伸展策

略的关键所

在。

以如图8.6(b)所

示的二叉搜

索树为例，在

find(1)操作之后，采

用逐层调整

策略与双层

调

整策略的

效果，分别如

图(a)和图(c)所示

。

图8.6 双局调整

策略癿高度

折半效枅

可

见，最深节点

（1）被访问之后

再经过双层

调整，不仅同

样可将该节

点伸展至树

根，而且

同时

可使树的高

度接近于减

半。就树的形

态而言，双层

伸展策略可

“智能”地“折叠

”被访问的

子

树分支，从而

有效地避免

对长分支的

连续访问。这

就意味着，即

便节点v的深

度为(n)，双层

伸

展策略既可

将v推至树根

，亦可令对应

分支的长度

以几何级数

（大致折半）的

速度收缩。

§8.1 伸

展树

第8章 高

级搜索树

208

图

8.7则给出了一

个节点更多

、更具一般性

的例子，从中

可更加清晰

地看出这一

效果。

图8.7 伸展

树中轳深癿

节点一旦被

讵问刡，对应

分支癿长度

将随即减半

尽管在任一

时刻伸展树

中都可能存

在很深的节

点，但与含羞

草类似地，一

旦这类“坏”节

点

被“碰触”到

，经过随后的

双层伸展，其

对应的分支

都会收缩至

长度大致折

半。于是，即便

每次

都“恶意

地”试图访问

最底层节点

，最坏情况也

不会持续发

生。可见，伸展

树虽不能杜

绝最坏情

况

的发生，却能

有效地控制

最坏情况发

生的频度，从

而在分摊意

义下保证整

体的高效率

。

更准确地，Tarjan等

人[41]采用势能

分析法（potential analysis）业已

证明，在改用

“双

层伸展”策

略之后，伸展

树的单次操

作均可在分

摊的O(logn)时间内

完成（习题[8-2]）。

8.1.4 伸

展树的实现

 伸展树接口

定义

基于BST类

，可定义伸展

树模板类Splay如

代码8.1所示。

1 #include "../BST/BST.h" //基

亍BST实现Splay

2 template <typename T>

class Splay : public

BST<T> { //由BST派

生癿Splay树模板

类

3

protected:

4 BinNodePosi(T) splay

( BinNodePosi(T) v );

//将节点v伸

展至根

5 public:

6

BinNodePosi(T) & search (

const T& e );

//查找

（重写）

7 BinNodePosi(T) insert

( const T& e

); //揑入（重

写）

8 bool

remove ( const T&

e ); //初除（重写

）

9

};

代码8.1 基二BST定

义癿伸展树

接口

可见，这

里直接沿用

二叉搜索树

类，并根据伸

展树的平衡

规则，重写了

三个基本操

作接口

search()、insert()和remove()，另

外，针对伸展

调整操作，设

有一个内部

保护型接口

splay()。

这些接口的

具体实现将

在以下数节

陆续给出。需

强调的是，与

一般的二叉

搜索树不同

，伸展

树的查

找也会引起

整树的结构

调整，故search()操作

也需重写。

第

8章

高级搜索

树 §8.1 伸展树

209

 伸

展算法的实

现

8.1.3节所述的

伸展调整方

法，可具体实

现如代码8.2所

示。

1

template <typename NodePosi> inline

//在节点*p不

*lc（可能为空）乀

间建立父（左

）子兲系

2 void attachAsLChild

( NodePosi p, NodePosi

lc ) { p->lc

= lc; if (

lc ) lc->parent =

p; }

3

4

template <typename NodePosi> inline

//在节

点*p不*rc（可能为

空）乀间建立

父（右）子兲系

5 void attachAsRChild (

NodePosi p, NodePosi rc

) { p->rc =

rc; if ( rc

) rc->parent = p;

}

6

7 template

<typename T> //Splay树伸展算法

：从节点v出収

逐局伸展

8

BinNodePosi(T) Splay<T>::splay ( BinNodePosi(T)

v ) { //v为

因最近讵问

而需伸展癿

节点位置

9 if ( !v

) return NULL; BinNodePosi(T)

p; BinNodePosi(T) g; //*v癿

父亲不祖父

10

while ( ( p

= v->parent ) &&

( g = p->parent

) ) { //自下而上，反

复对*v做双局

伸展

11 BinNodePosi(T) gg =

g->parent; //殏轮乀

后*v都以原曾

祖父（great-grand parent）为父

12

if ( IsLChild (

*v ) )

13

if ( IsLChild (

*p ) ) {

//zig-zig

14 attachAsLChild (

g, p->rc ); attachAsLChild

( p, v->rc );

15 attachAsRChild ( p,

g ); attachAsRChild (

v, p );

16

} else { //zig-zag

17 attachAsLChild ( p,

v->rc ); attachAsRChild (

g, v->lc );

18

attachAsLChild ( v, g

); attachAsRChild ( v,

p );

19 }

20 else if (

IsRChild ( *p )

) { //zag-zag

21

attachAsRChild ( g, p->lc

); attachAsRChild ( p,

v->lc );

22 attachAsLChild

( p, g );

attachAsLChild ( v, p

);

23 } else

{ //zag-zig

24 attachAsRChild

( p, v->lc );

attachAsLChild ( g, v->rc

);

25 attachAsRChild (

v, g ); attachAsLChild

( v, p );

26 }

27 if

( !gg ) v->parent

= NULL; //若

*v原先癿曾祖

父*gg丌存在，则

*v现在应为树

根

28

else //否则，*gg此后

应诠以*v作为

左戒右孩子

29 ( g

== gg->lc ) ?

attachAsLChild ( gg, v

) : attachAsRChild (

gg, v );

30

updateHeight ( g );

updateHeight ( p );

updateHeight ( v );

31 } //双局伸展结

束时，必有g ==

NULL，但

p可能非空

32 if (

p = v->parent )

{ //若

p枅真非空，则

额外再做一

次单旋

33 if

( IsLChild ( *v

) ) { attachAsLChild

( p, v->rc );

attachAsRChild ( v, p

); }

34 else

{ attachAsRChild ( p,

v->lc ); attachAsLChild (

v, p ); }

35 updateHeight ( p

); updateHeight ( v

);

36 }

37

v->parent = NULL; return

v;

38 } //调整

乀后新树根

应为被伸展

癿节点，故迒

回诠节点癿

位置以便上

局函数更新

树根

代码8.2 伸

展树节点癿

调整

§8.1 伸展树

第8章

高级搜

索树

210

 查找算

法的实现

在

伸展树中查

找任一关键

码e的过程，可

实现如代码

8.3所示。

1 template <typename

T> BinNodePosi(T) & Splay<T>::search

( const T& e

) { //在伸展

树中查找e

2

BinNodePosi(T) p = searchIn

( _root, e, _hot

= NULL );

3

_root = splay (

( p ? p

: _hot ) );

//将

最后一个被

讵问癿节点

伸展至根

4 return _root;

5 } //不

其它BST丌同，无

讳查找成功

不否，_root都指向

最后被讵问

癿节点

代码

8.3

伸展树节点

癿查找

首先

，调用二叉搜

索树的通用

算法searchIn()（代码7.3）尝

试查找具有

关键码e的节

点。

无论查找

是否成功，都

继而调用splay()算

法，将查找终

止位置处的

节点伸展到

树根。



插入算

法的实现

为

将节点插至

伸展树中，固

然可以调用

二叉搜索树

的标准插入

算法BST::insert()（188页

代码

7.5），再通过双层

伸展，将新插

入的节点提

升至树根。

然

而，以上接口

Splay::search()已集成了splay()伸

展功能，故查

找返回后，树

根节点

要么

等于查找目

标（查找成功

），要么就是_hot，而

且恰为拟插

入节点的直

接前驱或直

接后继

（查找

失败）。因此，不

妨改用如下

方法实现Splay::insert()接

口。

图8.8 伸展树

癿节点揑入

如图8.8所示，为

将关键码e插

至伸展树T中

，首先调用伸

展树查找接

口Splay::search(e)，

查找该关

键码（图(a)）。于是

，其中最后被

访问的节点

t，将通过伸展

被提升为树

根，其左、

右子

树分别记作

TL和TR（图(b)）。

接下来

，根据e与t的大

小关系（不妨

排除二者相

等的情况），以

t为界将T分裂

为两棵子树

。

比如，不失一

般性地设e大

于t。于是，可切

断t与其右孩

子之间的联

系（图(c)），再将以

e为关

键码的

新节点v作为

树根，并以t作

为其左孩子

，以TR作为其右

子树（图(d)）。

v小于

t的情况与此

完全对称，请

读者独立做

出分析。

上述

算法过程，可

具体实现如

代码8.4所示。

1

template <typename T> BinNodePosi(T)

Splay<T>::insert ( const T&

e ) { //将

兲键码e揑入

伸展树中

2 if ( !_root

) { _size++; return

_root = new BinNode<T>

( e ); }

//处

理原树为空

癿退化情冴

3 if ( e

== search ( e

)->data ) return _root;

//确讣目标节

点丌存在

4 _size++; BinNodePosi(T)

t = _root; //创

建新节点。以

下调整<=7个指

针以完成尿

部重极

第8章

高级搜索树

§8.1 伸展树

211

5

if ( _root->data <

e ) { //揑入

新根，以t和t->rc为

左、右孩子

6 t->parent = _root

= new BinNode<T> (

e, NULL, t, t->rc

); //2 + 3个

7

if ( HasRChild (

*t ) ) {

t->rc->parent = _root; t->rc

= NULL; } //<=

2个

8 } else

{ //揑入新根

，以t->lc和t为左、右

孩子

9 t->parent

= _root = new

BinNode<T> ( e, NULL,

t->lc, t ); //2

+ 3个

10 if

( HasLChild ( *t

) ) { t->lc->parent

= _root; t->lc =

NULL; } //<= 2个

11 }

12 updateHeightAbove

( t ); //更

新t及其祖先

（实际上叧有

_root一个）癿高度

13

return _root; //新节点必然

置亍树根，迒

回乀

14

} //无讳e是

否存在亍原

树中，迒回时

总有_root->data == e

代码8.4 伸

展树节点癿

揑入

尽管伸

展树并不需

要记录和维

护节点高度

，为与其它平

衡二叉搜索

树的实现保

持统一，这里

还是对节点

的高度做了

及时的更新

。出于效率的

考虑，实际应

用中可视情

况，省略这类

更新。



删除算

法的实现

为

从伸展树中

删除节点，固

然也可以调

用二叉搜索

树标准的节

点删除算法

BST::remove()

（190页代码7.6），再通

过双层伸展

，将该节点此

前的父节点

提升至树根

。

然而同样地

，在实施删除

操作之前，通

常都需要调

用Splay::search()定位目标

节点，而

该接

口已经集成

了splay()伸展功能

，从而使得在

成功返回后

，树根节点恰

好就是待删

除节点。

因此

，亦不妨改用

如下策略，以

实现Splay::remove()接口。

图

8.9 伸展树癿节

点初除

如图

8.9所示，为从伸

展树T中删除

关键码为e的

节点，首先亦

调用接口Splay::search(e)，

查

找该关键码

，且不妨设命

中节点为v（图

(a)）。于是，v将随即

通过伸展被

提升为树根

，其左、

右子树

分别记作TL和

TR（图(b)）。接下来，将

v摘除（图(c)）。然后

，在TR中再次查

找关键码e。

尽

管这一查找

注定失败，却

可以将TR中的

最小节点m，伸

展提升为该

子树的根。

得

益于二叉搜

索树的顺序

性，此时节点

m的左子树必

然为空；同时

，TL中所有节点

都应小于m

（图

(d)）。于是，只需将

TL作为左子树

与m相互联接

，即可得到一

棵完整的二

叉搜索树（图

(e)）。

如此不仅删

除了v，而且既

然新树根m在

原树中是v的

直接后继，故

数据局部性

也得到了利

用。

§8.2

B-树 第8章 高

级搜索树

212

上

述算法过程

，可具体实现

如代码8.5所示

。

1 template <typename

T> bool Splay<T>::remove (

const T& e )

{ //从伸展树中

初除兲键码

e

2 if

( !_root || (

e != search (

e )->data ) )

return false; //若树空戒目

标丌存在，则

无法初除

3

BinNodePosi(T) w = _root;

//assert: 经

search()后节点e已被

伸展至树根

4 if (

!HasLChild ( *_root )

) { //若无左子树

，则直接初除

5 _root

= _root->rc; if (

_root ) _root->parent =

NULL;

6 } else

if ( !HasRChild (

*_root ) ) {

//若无右子树

，也直接初除

7 _root = _root->lc;

if ( _root )

_root->parent = NULL;

8

} else { //若左右子树

同时存在，则

9

BinNodePosi(T) lTree = _root->lc;

10 lTree->parent = NULL;

_root->lc = NULL; //暂时将左子

树切除

11 _root = _root->rc;

_root->parent = NULL; //叧保

留右子树

12 search ( w->data

); //以

原树根为目

标，做一次（必

定失败癿）查

找

13 /////

assert: 至此，右子

树中最小节

点必伸展至

根，且（因无雷

同节点）其左

子树必空，亍

是

14 _root->lc

= lTree; lTree->parent =

_root; //叧需将原

左子树接回

原位即可

15 }

16 release ( w->data

); release ( w

); _size--; //释

放节点，更新

觃模

17

if ( _root )

updateHeight ( _root );

//此后，若

树非空，则树

根癿高度需

要更新

18 return true;

//迒回

成功标志

19 } //若

目标节点存

在且被初除

，迒回true；否则迒

回false

代码8.5 伸展

树节点癿初

除

当然，其中

的第二次查

找也可在TL（若

非空）中进行

。读者不妨独

立实现这一

对称的版本

。

§8.2

B-树

8.2.1 多路平衡

查找



分级存

储

现代电子

计算机发展

速度空前。就

计算能力而

言，ENIAC②每秒只能

够执行5000次加

法运算，

而今

天的超级计

算机每秒已

经能够执行

31016次以上的浮

点运算③。就存

储能力而言

，情况似乎

也

是如此：ENIAC只有

一万八千个

电子管，而如

今容量以TB计

的硬盘也不

过数百元，内

存的常规

容

量也已达到

GB量级。

然而从

实际应用的

需求来看，问

题规模的膨

胀却远远快

于存储能力

的增长。以数

据库为例，

在

20世纪80年代初

，典型数据库

的规模为10~100 MB，而

三十年后的

今天，典型数

据库的规模

已

需要以TB为

单位来计量

。计算机存储

能力提高速

度相对滞后

，是长期存在

的现象，而且

随着时间

的

推移，这一矛

盾将日益凸

显。鉴于在同

等成本下，存

储器的容量

越大（小）则访

问速度越慢

（快），

因此一味

地提高存储

器容量，亦非

解决这一矛

盾的良策。

② 第

一台电子计

算机， 1946年2月15日

诞生亍美国

宾夕法尼亚

大学工学院

③

2013年6月，天河-2以

此运算速度

，荣登世界超

级计算机500强

榜首

第8章 高

级搜索树 §8.2 B-树

213

实践证明，分

级存储才是

行之有效的

方法。在由内

存与外存（磁

盘）组成的二

级存储系统

中，

数据全集

往往存放于

外存中，计算

过程中则可

将内存作为

外存的高速

缓存，存放最

常用数据项

的

复本。借助

高效的调度

算法，如此便

可将内存的

“高速度”与外

存的“大容量

”结合起来。

两

个相邻存储

级别之间的

数据传输，统

称I/O操作。各级

存储器的访

问速度相差

悬殊，故应

尽

可能地减少

I/O操作。仍以内

存与磁盘为

例，其单次访

问延迟大致

分别在纳秒

（ns）和毫秒（ms）

级别

，相差5至6个数

量级。也就是

说，对内存而

言的一秒/一

天，相当于磁

盘的一星期

/两千年。

因此

，为减少对外

存的一次访

问，我们宁愿

访问内存百

次、千次甚至

万次。也正因

为此，在衡量

相关算法的

性能时，基本

可以忽略对

内存的访问

，转而更多地

关注对外存

的访问次数

。



多路搜索树

当数据规模

大到内存已

不足以容纳

时，常规平衡

二叉搜索树

的效率将大

打折扣。其原

因在于，

查找

过程对外存

的访问次数

过多。例如，若

将10^9个记录在

外存中组织

为AVL树，则每次

查找大

致需

做30次外存访

问。那么，如何

才能有效减

少外存操作

呢？

为此，需要

充分利用磁

盘之类外部

存储器的另

一特性：就时

间成本而言

，读取物理地

址连续

的一

千个字节，与

读取单个字

节几乎没有

区别。既然外

部存储器更

适宜于批量

式访问，不妨

通过

时间成

本相对极低

的多次内存

操作，来替代

时间成本相

对极高的单

次外存操作

。相应地，需要

将

通常的二

叉搜索树，改

造为多路搜

索树在中序

遍历的意义

下，这也是一

种等价变换

。

图8.10

事叉搜索

树不四路搜

索树

具体地

如图8.10所示，比

如可以两层

为间隔，将各

节点与其左

、右孩子合并

为“大节点”：

原

节点及其孩

子的共三个

关键码予以

保留；孩子节

点原有的四

个分支也予

以保留并按

中序遍历次

序排列；节点

到左、右孩子

的分支转化

为“大节点”内

部的搜索，在

图中表示为

水平分支。如

此

改造之后

，每个“大节点

”拥有四个分

支，故称作四

路搜索树。

这

一策略还可

进一步推广

，比如以三层

为间隔，将各

节点及其两

个孩子、四个

孙子合并为

含

有七个关

键码、八个分

支的“大节点

”，进而得到八

路搜索树。一

般地，以k层为

间隔如此重

组，

可将二叉

搜索树转化

为等价的2^k路

搜索树，统称

多路搜索树

（multi-way search

tree）。

不难验证，多

路搜索树同

样支持查找

等操作，且效

果与原二叉

搜索树完全

等同；然而重

要的

是，其对

外存的访问

方式已发生

本质变化。实

际上，在此时

的搜索每下

降一层，都以

“大节点”

为单

位从外存读

取一组（而不

再是单个）关

键码。更为重

要的是，这组

关键码在逻

辑上与物理

上

都彼此相

邻，故可以批

量方式从外

存一次性读

出，且所需时

间与读取单

个关键码几

乎一样。

当然

，每组关键码

的最佳数目

，取决于不同

外存的批量

访问特性。比

如旋转式磁

盘的读写操

作多以扇区

为单位，故可

根据扇区的

容量和关键

码的大小，经

换算得出每

组关键码的

最佳规模。

例

如若取k =

8，则每

个“大节点”将

拥有255个关键

码和256个分支

，此时同样对

于1G个记录，

每

次查找所涉

及的外存访

问将减至4~5次

。

§8.2 B-树

第8章 高级

搜索树

214



多路

平衡搜索树

所谓m阶B-树④（B-tree），即

m路平衡搜索

树（m  2），其宏观结

构如图8.11所示

。

图8.11

B-树癿宏观

结极（外部节

点以深色示

意，深度完全

一致，且都同

处二最底局

）

其中，所有外

部节点均深

度相等。同时

，每个内部节

点都存有不

超过m - 1个关键

码，以及

用以

指示对应分

支的不超过

m个引用。具体

地，存有n  m -

1个关

键码：

 K1 <

K2 < K3 <

K4 < . .

. < Kn

的内部

节点，同时还

配有n

+ 1  m个引用

：

A0 < A1 <

A2 < A3 <

A4 < . .

. < An

反过来，各内

部节点的分

支数也不能

太少。具体地

，除根以外的

所有内部节

点，都应满足

：

n + 1 

m/2

而在非空的

B-树中，根节点

应满足：

n +

1  2

由于

各节点的分

支数介于m/2至

m之间，故m阶B-树

也称作(m/2,

m)-树，如

(2, 3)-树、

(3, 6)-树或(7,

13)-树等

。

B-树的外部节

点（external node）更加名副

其实它们实

际上未必意

味着查找失

败，

而可能表

示目标关键

码存在于更

低层次的某

一外部存储

系统中，顺着

该节点的指

示，即可深入

至

下一级存

储系统并继

续查找。正因

为如此，不同

于常规的搜

索树，如图8.11所

示，在计算B-树

高度时，还需

要计入其最

底层的外部

节点。

例如，图

8.12(a)即为一棵由

9个内部节点

、15个外部节点

以及14个关键

码组成的4阶

B-树，

其高度h =

3，其

中每个节点

包含1~3个关键

码，拥有2~4个分

支。

作为与二

叉搜索树等

价的“扁平化

”版本，B-树的宽

度（亦即最底

层外部节点

的数目）往

往

远大于其高

度。因此在以

图形描述B-树

的逻辑结构

时，我们往往

需要简化其

中分支的画

法，并

转而采

用如图(b)所示

的紧凑形式

。

另外，既然外

部节点均同

处于最底层

，且深度完全

一致，故在将

它们省略之

后，通常还不

致

造成误解

。因此，还可以

将B-树的逻辑

结构，进一步

精简为如图

(c)所示的最紧

凑形式。

由这

种最紧凑的

表示形式，也

可同时看出

，B-树叶节点（即

最深的内部

节点）的深度

也必

然完全

一致，比如[7]、[19,

22]、[28]、[37, 40, 41]、[46]和

[52]。

④ 由R. Bayer和E. McCreight亍1970年合

作収明[43]

第8章

高级搜索树

§8.2 B-树

215

图8.12

(a) 4阶B-树；(b) B-树

癿紧凑表示

；(c) B-树癿最紧凑

表示

8.2.2 ADT接口及

其实现

按照

以上定义，可

以模板类的

形式描述并

实现B-树节点

以及B-树结构

本身如下。



节

点

B-树节点BTNode类

，可实现如代

码8.6所示。

1 #include

"../vector/vector.h"

2 #define BTNodePosi(T)

BTNode<T>* //B-树节

点位置

3

4

template <typename T> struct

BTNode { //B-树节

点模板类

5

// 成

员（为简化描

述起见统一

开放，读者可

根据需要迕

一步封装）

6 BTNodePosi(T)

parent; //父

节点

7 Vector<T>

key; //兲键码

向量

8 Vector<BTNodePosi(T)>

child; //孩子向

量（其长度总

比key夗一）

9 //

极造

函数（注意：BTNode叧

能作为根节

点创建，而且

刜始时有0个

兲键码和1个

空孩子指针

）

10 BTNode() {

parent = NULL; child.insert

( 0, NULL );

}

11 BTNode (

T e, BTNodePosi(T) lc

= NULL, BTNodePosi(T) rc

= NULL ) {

12 parent = NULL;

//作为根节点

，而且刜始时

13 key.insert ( 0,

e ); //叧有一个兲

键码，以及

14

child.insert ( 0, lc

); child.insert ( 1,

rc ); //两

个孩子

15

if ( lc )

lc->parent = this; if

( rc ) rc->parent

= this;

16 }

17 };

代码

8.6 B-树节点

这里

，同一节点的

所有孩子组

织为一个向

量，各相邻孩

子之间的关

键码也组织

为一个向量

。

当然，按照B-树

的定义，孩子

向量的实际

长度总是比

关键码向量

多一。

§8.2 B-树

第8章

高级搜索树

216

 B-树

B-树模板类

，可实现如代

码8.7所示。

1 #include "BTNode.h" //引入

B-树节点类

2

3 template <typename

T> class BTree {

//B-树

模板类

4 protected:

5

int _size; //存放

癿兲键码总

数

6

int _order; //B-树癿阶次

，至少为3——创建

时指定，一般

丌能修改

7

BTNodePosi(T) _root; //根

节点

8

BTNodePosi(T) _hot; //BTree::search()最后讵

问癿非空（除

非树空）癿节

点位置

9

void solveOverflow ( BTNodePosi(T)

); //因揑

入而上溢乀

后癿分裂处

理

10 void

solveUnderflow ( BTNodePosi(T) );

//因初除而

下溢乀后癿

合幵处理

11 public:

12

BTree ( int order

= 3 ) :

_order ( order ),

_size ( 0 )

//极

造函数：默讣

为最低癿3阶

13 { _root =

new BTNode<T>(); }

14

~BTree() { if (

_root ) release (

_root ); } //枂极函数：释

放所有节点

15

int const order() {

return _order; } //阶次

16 int const size()

{ return _size; }

//觃模

17 BTNodePosi(T) &

root() { return _root;

} //树

根

18 bool

empty() const { return

!_root; } //刞空

19

BTNodePosi(T) search ( const

T& e ); //查找

20

bool insert ( const

T& e ); //揑入

21 bool remove (

const T& e );

//初除

22 }; //BTree

代

码8.7 B-树

后面将

会看到，B-树的

关键码插入

操作和删除

操作，可能会

引发节点的

上溢和下溢

。因此，

这里设

有内部接口

solveOverflow()和solveUnderflow()，分别用于

修正此类问

题。在稍后的

8.2.6节和8.2.8节中，将

分别讲解其

具体原理及

实现。

8.2.3 关键码

查找

 算法

如

前述，B-树结构

非常适宜于

在相对更小

的内存中，实

现对大规模

数据的高效

操作。

一般地

如图8.13所示，可

以将大数据

集组织为B-树

并存放于外

存。对于活跃

的B-树，其根

节

点会常驻于

内存；此外，任

何时刻通常

只有另一节

点（称作当前

节点）留驻于

内存。

B-树的查

找过程，与二

叉搜索树的

查找过程基

本类似。

首先

以根节点作

为当前节点

，然后再逐层

深入。若在当

前节点（所包

含的一组关

键码）中能

够

找到目标关

键码，则成功

返回。否则（在

当前节点中

查找“失败”），则

必可在当前

节点中确

定

某一个引用

（“失败”位置），并

通过它转至

逻辑上处于

下一层的另

一节点。若该

节点不是外

部节点，则将

其载入内存

，并更新为当

前节点，然后

继续重复上

述过程。

第8章

高级搜索树

§8.2

B-树

217

整个过程

如图8.13所示，从

根节点开始

，通过关键码

的比较不断

深入至下一

层，直到某一

关键码命中

（查找成功），或

者到达某一

外部节点（查

找失败）。

图8.13

B-树

癿查找过秳

与二叉搜索

树的不同之

处在于，因此

时各节点内

通常都包含

多个关键码

，故有可能需

要经过

（在内

存中的）多次

比较，才能确

定应该转向

下一层的哪

个节点并继

续查找。

仍以

如图8.12所示的

4阶B-树为例，查

找关键码41的

过程大致如

下：在根节点

处经过一次

关

键码比较

（25）之后，即可确

定应转入第

2个分支；再经

过两次比较

（34,

43）之后，确定转

入

第2个分支

；最后经过三

次比较（37, 40, 41）之后

，才成功地找

到目标关键

码。查找关键

码42

的过程与

之类似，只是

在最底层的

内部节点内

，需要经过三

次关键码比

较（37, 40, 41）之后，

才确

定应转入关

键码41右侧的

外部节点，从

而最终确定

查找失败。

可

见，只有在切

换和更新当

前节点时才

会发生I/O操作

，而在同一节

点内部的查

找则完全在

内存中进行

。因内存的访

问速度远远

高于外存，再

考虑到各节

点所含关键

码数量通常

在128~512

之间，故可

直接使用顺

序查找策略

，而不必采用

二分查找之

类的复杂策

略。

 实现

如代

码8.8所示，为简

化代码，节点

内部的查找

直接借用了

有序向量的

search()接口。

1 template <typename

T> BTNodePosi(T) BTree<T>::search (

const T& e )

{ //在B-树中

查找兲键码

e

2 BTNodePosi(T)

v = _root; _hot

= NULL; //从根节点出

収

3

while ( v )

{ //逐局查找

4 Rank r

= v->key.search ( e

); //在弼前节点

中，找刡丌大

亍e癿最大兲

键码

5 if

( ( 0 <=

r ) && (

e == v->key[r] )

) return v; //成功：在

弼前节点中

命中目标兲

键码

6 _hot = v;

v = v->child[r +

1]; //否则，转

入对应子树

（_hot指向其父）——需

做I/O，最费时间

7 } //返里在向量

内是二分查

找，但对通常

癿_order可直接顺

序查找

8 return NULL; //失败

：最终抵达外

部节点

9 }

代码

8.8 B-树关键码癿

查找

与二叉

搜索树的实

现类似，这里

也约定查找

结果由返回

的节点位置

指代：成功时

返回目标关

键码所在的

节点，上层调

用过程可在

该节点内进

一步查找以

确定准确的

命中位置；失

败时返回对

应外部节点

，其父节点则

由变量_hot指代

。

§8.2 B-树 第8章

高级

搜索树

218

8.2.4 性能

分析

由上可

见，B-树查找操

作所需的时

间不外乎消

耗于两个方

面：将某一节

点载入内存

，以及

在内存

中对当前节

点进行查找

。鉴于内存、外

存在访问速

度上的巨大

差异，相对于

前一类时间

消

耗，后一类

时间消耗可

以忽略不计

。也就是说，B-树

查找操作的

效率主要取

决于查找过

程中的外

存

访问次数。那

么，至多需要

访问多少次

外存呢？

由前

节分析可见

，与二叉搜索

树类似，B-树的

每一次查找

过程中，在每

一高度上至

多访问

一个

节点。这就意

味着，对于高

度为h的B-树，外

存访问不超

过O(h - 1)次。

B-树节点

的分支数并

不固定，故其

高度h并不完

全取决于树

中关键码的

总数n。对于包

含N个

关键码

的m阶B-树，高度

h具体可在多

大范围内变

化？就渐进意

义而言，h与m及

N的关系如何

？

 树高

可以证

明，若存有N个

关键码的m阶

B-树高度为h，则

必有：

logm(N + 1)

 h  logm/2

(N + 1) /

2 + 1 ..............

（式8-1）

首先

证明h  logm/2

(N+1)/2 + 1。关键码

总数固定时

，为使B-树更高

，各内部节点

都

应包含尽

可能少的关

键码。于是按

照B-树的定义

，各高度层次

上节点数目

至少是：

n0 = 1

n1

= 2

n2 =

2  m /

2

n3 = 2

 m / 2

2

...

nh-1 =

2  m /

2

h-2

nh =

2  m /

2

h-1

现考

查外部节点

。这些节点对

应于失败的

查找，故其数

量nh应等于失

败查找可能

情形的总数

，

即应比成功

查找可能情

形的总数恰

好多1，而后者

等于关键码

的总数N。于是

有

N + 1 =

nh  2 

(m / 2 )

h-1

, h 

1

即 h 

1 + logm/2 (N

+ 1) / 2

= O(logmN)

再来证

明h 

logm(N + 1)。同理，关键

码总数固定

时，为使B-树更

矮，每个内部

节点都

应该

包含尽可能

多的关键码

。按照B-树的定

义，各高度层

次上的节点

数目至多是

：

n0 = 1

n1

= m

n2 =

m

2

...

nh-1

= m

h-1

nh

= m

h

与上同理，有

N

+ 1 = nh

 m

h

即

h  logm(N +

1) = (logmN)

总之，式8-1必

然成立。也就

是说，存有N个

关键码的m阶

B-树的高度h

= (logmN)。

第

8章 高级搜索

树

§8.2 B-树

219



复杂度

因此，每次查

找过程共需

访问O(logmN)个节点

，相应地需要

做O(logmN)次外存读

取操作。

由此

可知，对存有

N个关键码的

m阶B-树的每次

查找操作，耗

时不超过O(logmN)。

需

再次强调的

是，尽管没有

渐进意义上

的改进，但相

对而言极其

耗时的I/O操作

的次数，却

已

大致缩减为

原先的1/log2m。鉴于

m通常取值在

256至1024之间，较之

此前大致降

低一个数量

级，

故使用B-树

后，实际的访

问效率将有

十分可观的

提高。

8.2.5 关键码

插入

B-树的关

键码插入算

法，可实现如

代码8.9所示。

1 template <typename T>

bool BTree<T>::insert ( const

T& e ) {

//将

兲键码e揑入

B树中

2 BTNodePosi(T) v

= search ( e

); if ( v

) return false; //确讣目

标节点丌存

在

3 Rank r =

_hot->key.search ( e );

//在节点_hot癿

有序兲键码

向量中查找

合适癿揑入

位置

4 _hot->key.insert (

r + 1, e

); //将新兲

键码揑至对

应癿位置

5 _hot->child.insert

( r + 2,

NULL ); //创

建一个空子

树指针

6

_size++; //更新

全树觃模

7 solveOverflow

( _hot ); //如

有必要，需做

分裂

8 return true; //揑入成

功

9 }

代码8.9 B-树关

键码癿揑入

为在B-树中插

入一个新的

关键码e，首先

调用search(e)在树中

查找该关键

码。若查找成

功，

则按照“禁

止重复关键

码”的约定不

予插入，操作

即告完成并

返回false。

否则，按

照代码8.8的出

口约定，查找

过程必然终

止于某一外

部节点v，且其

父节点由变

量

_hot指示。当然

，此时的_hot必然

指向某一叶

节点（可能同

时也是根节

点）。接下来，在

该节

点中再

次查找目标

关键码e。尽管

这次查找注

定失败，却可

以确定e在其

中的正确插

入位置r。最

后

，只需将e插至

这一位置。

至

此，_hot所指的节

点中增加了

一个关键码

。若该节点内

关键码的总

数依然合法

（即不超

过m -

1个

），则插入操作

随即完成。否

则，称该节点

发生了一次

上溢（overflow），此时需

要

通过适当

的处理，使该

节点以及整

树重新满足

B-树的条件。由

代码8.9可见，这

项任务将借

助调

整算法

solveOverflow(_hot)来完成。

8.2.6

上溢

与分裂

 算法

一般地，刚发

生上溢的节

点，应恰好含

有m个关键码

。若取s =

m/2，则它们

依次为：

{ k0, ...,

ks-1; ks; ks+1, ...,

km-1 }

可见

，以ks为界，可将

该节点分前

、后两个子节

点，且二者大

致等长。于是

，可令关键码

ks

上升一层，归

入其父节点

（若存在）中的

适当位置，并

分别以这两

个子节点作

为其左、右孩

子。

这一过程

，称作节点的

分裂（split）。

不难验

证，如此分裂

所得的两个

孩子节点，均

符合m阶B-树关

于节点分支

数的条件。

§8.2 B-树

第8章

高级搜

索树

220

 可能的

情况

以如图

8.14(a1)所示的6阶B-树

局部为例，其

中节点{ 17, 20, 31,

37, 41, 56 }，因

所

含关键码增

至6个而发生

上溢。为完成

修复，可以关

键码37为界，将

该节点分裂

为{ 17, 20, 31

}

和{ 41, 56

}；关键码

37则上升一层

，并以分裂出

来的两个子

节点作为左

、右孩子。

图8.14 通

过分裂修复

上溢节点

被

提升的关键

码，可能有三

种进一步的

处置方式。首

先如图(a1)所示

，设原上溢节

点的父

节点

存在，且足以

接纳一个关

键码。此种情

况下，只需将

被提升的关

键码（37）按次序

插入父节

点

中，修复即告

完成，修复后

的局部如图

(a2)所示。

其次如

图(b1)所示，尽管

上溢节点的

父节点存在

，但业已处于

饱和状态。此

时如图(b2)，

在强

行将被提升

的关键码插

入父节点之

后，尽管上溢

节点也可得

到修复，却会

导致其父节

点继而

发生

上溢这种现

象称作上溢

的向上传递

。好在每经过

一次这样的

修复，上溢节

点的高度都

必

然上升一

层。这意味着

上溢的传递

不至于没有

尽头，最远不

至超过树根

。

最后如图(c1)所

示，若上溢果

真传递至根

节点，则可令

被提升的关

键码（37）自成一

个节

点，并作

为新的树根

。于是如图(c2)所

示，至此上溢

修复完毕，全

树增高一层

。可见，整个过

程中所做分

裂操作的次

数，必不超过

全树的高度

根据8.2.4节结论

，即O(logmN)。

 实现

以上

针对上溢的

处理算法，可

实现如代码

8.10所示。

1

template <typename T> //兲键码

揑入后若节

点上溢，则做

节点分裂处

理

2 void BTree<T>::solveOverflow (

BTNodePosi(T) v ) {

3 if ( _order

>= v->child.size() ) return;

//逑弻基：弼

前节点幵未

上溢

4 Rank s

= _order / 2;

//轴点（此

时应有_order = key.size() =

child.size() - 1）

5

BTNodePosi(T) u = new

BTNode<T>(); //注意

：新节点已有

一个空孩子

6 for (

Rank j = 0;

j < _order -

s - 1; j++

) { //v右侧_order-s-1个孩子

及兲键码分

裂为右侧节

点u

7

u->child.insert ( j, v->child.remove

( s + 1

) ); //逐个秱劢

效率低

8

u->key.insert ( j, v->key.remove

( s + 1

) ); //此策

略可改迕

9

}

10 u->child[_order -

s - 1] =

v->child.remove ( s +

1 ); //秱

劢v最靠右癿

孩子

第8章

高

级搜索树 §8.2 B-树

221

11

if ( u->child[0] )

//若u癿孩子们

非空，则

12 for (

Rank j = 0;

j < _order -

s; j++ ) //令它

们癿父节点

统一

13 u->child[j]->parent = u;

//指向u

14 BTNodePosi(T) p

= v->parent; //v弼

前癿父节点

p

15

if ( !p )

{ _root = p

= new BTNode<T>(); p->child[0]

= v; v->parent =

p; } //若p空则创建

乀

16

Rank r = 1

+ p->key.search ( v->key[0]

); //p中指向u癿

指针癿秩

17 p->key.insert

( r, v->key.remove (

s ) ); //轴

点兲键码上

升

18 p->child.insert ( r

+ 1, u );

u->parent = p; //新节点u不

父节点p互联

19

solveOverflow ( p );

//上升一局，如

有必要则继

续分裂——至夗

逑弻O(logn)局

20 }

代码

8.10

B-树节点癿上

溢处理

请特

别留意上溢

持续传播至

根的情况：原

树根分裂之

后，新创建的

树根仅含单

关键码。由此

也可看出，就

B-树节点分支

数的下限要

求而言，树根

节点的确应

该作为例外

。

 实例

图8.15 3阶B-树

揑入操作实

例（I）

考查如图

8.15(a)所示的3阶B-树

。执行insert(23)后未发

生任何上溢

；如(b)所示不必

做

任何调整

。接下来执行

insert(29)后，如图(c1)所示

发生上溢；经

一次分裂即

完全修复，结

果

如图(c2)所示

。继续执行insert(45)后

，如图(d1)所示发

生上溢；经分

裂做局部修

复之后，如

图

(d2)所示上一层

再次发生上

溢；经再次分

裂后，方得以

实现全树的

修复，结果如

图(d3)所示。

§8.2 B-树

第

8章 高级搜索

树

222

图8.16

3阶B-树揑

入操作实例

（II）

最后，执行insert(87)后

如图8.16(e1)所示亦

发生上溢；经

局部分裂调

整后，在更高

层将

持续发

生上溢，故如

图(e2)、(e3)和(e4)所示，先

后总共经三

次分裂，方得

以实现全树

的修复。

此时

因一直分裂

至根节点，故

最终全树高

度增加一层

这也是B-树长

高的唯一可

能。

 复杂度

若

将B-树的阶次

m视作为常数

，则关键码的

移动和复制

操作所需的

时间都可以

忽略。至于

solveOverflow()算

法，其每一递

归实例均只

需常数时间

，递归层数不

超过B-树高度

。由此可

知，对

于存有N个关

键码的m阶B-树

，每次插入操

作都可在O(logmN)时

间内完成。

实

际上，因插入

操作而导致

(logmN)次分裂的情

况极为罕见

，单次插入操

作平均引发

的分

裂次数

，远远低于这

一估计（习题

[8-6]），故时间通常

主要消耗于

对目标关键

码的查找。

8.2.7

关

键码删除

1 template <typename

T> bool BTree<T>::remove (

const T& e )

{ //从

BTree树中初除兲

键码e

2 BTNodePosi(T)

v = search (

e ); if (

!v ) return false;

//确讣目

标兲键码存

在

3 Rank r

= v->key.search ( e

); //确定目标

兲键码在节

点v中癿秩（由

上，肯定合法

）

4 if

( v->child[0] ) {

//若v非叶子，则

e癿后继必属

亍某叶节点

5 BTNodePosi(T) u =

v->child[r+1]; //在右子树中

一直向左，即

可

6 while

( u->child[0] ) u

= u->child[0]; //找出e癿后

继

7

v->key[r] = u->key[0]; v

= u; r =

0; //幵不乀交

换位置

8 }

//至此

，v必然位亍最

底局，且其中

第r个兲键码

就是待初除

者

9 v->key.remove (

r ); v->child.remove (

r + 1 );

_size--; //初除e，以及

其下两个外

部节点乀一

10 solveUnderflow (

v ); //如有必要，需

做旋转戒合

幵

11

return true;

12 }

代码8.11 B-树关

键码癿初除

第8章 高级搜

索树 §8.2

B-树

223

B-树的

关键码删除

算法的实现

如代码8.11所示

。

为从B-树中删

除关键码e，也

首先需要调

用search(e)查找e所属

的节点。倘若

查找失败，

则

说明关键码

e尚不存在，删

除操作即告

完成；否则按

照代码8.8的出

口约定，目标

关键码所在

的节点必由

返回的位置

v指示。此时，通

过顺序查找

，即可进一步

确定e在节点

v中的秩r。

不妨

假定v是叶节

点否则，e的直

接前驱（后继

）在其左（右）子

树中必然存

在，而且

可在

O(height(v))时间内确定

它们的位置

，其中height(v)为节点

v的高度。此处

不妨选用直

接

后继。于是

，e的直接后继

关键码所属

的节点u必为

叶节点，且该

关键码就是

其中的最小

者u[0]。

既然如此

，只要令e与u[0]互

换位置，即可

确保待删除

的关键码e所

属的节点v是

叶节点。

于是

，接下来可直

接将e（及其左

侧的外部空

节点）从v中删

去。如此，节点

v中所含的关

键

码以及（空

）分支将分别

减少一个。

此

时，若该节点

所含关键码

的总数依然

合法（即不少

于m/2

- 1），则删除操

作随即完成

。

否则，称该节

点发生了下

溢（underflow），并需要通

过适当的处

置，使该节点

以及整树重

新满

足B-树的

条件。由代码

8.11可见，这项任

务将借助调

整算法solveUnderflow(v)来完

成。

8.2.8 下溢与合

并

由上，在m阶

B-树中，刚发生

下溢的节点

V必恰好包含

m/2 -

2个关键码和

m/2 - 1个分

支。以下

将根据其左

、右兄弟所含

关键码的数

目，分三种情

况做相应的

处置。

 V的左兄

弟L存在，且至

少包含m/2个关

键码

图8.17 下溢

节点向父亲

“借”一个关键

码，父亲再向

左兄弟“借”一

个关键码

如

图8.17(a)所示，不妨

设L和V分别是

其父节点P中

关键码y的左

、右孩子，L中最

大关键码

为

x（x  y）。此时可如图

(b)所示，将y从节

点P转移至节

点V中（作为最

小关键码），再

将x

从L转移至

P中（取代原关

键码y）。至此，局

部乃至整树

都重新满足

B-树条件，下溢

修复完毕。

 V的

右兄弟R存在

，且至少包含

m/2个关键码

图

8.18

下溢节点向

父亲“借”一个

关键码，父亲

再向右兄弟

“借”一个关键

码

如图8.18所示

，可参照前一

情况对称地

修复，不再赘

述。

§8.2 B-树

第8章 高

级搜索树

224



V的

左、右兄弟L和

R或者不存在

，或者其包含

的关键码均

不足m/2个

实际

上，此时的L和

R不可能同时

不存在。如图

8.19(a)所示，不失一

般性地设左

兄弟节点L

存

在。当然，此时

节点L应恰好

包含m/2 -

1个关键

码。

图8.19 下溢节

点向父亲“借

”一个关键码

，然后不左兄

弟“粘接”成一

个节点

于是

为修复节点

V的下溢缺陷

，可如图(b)所示

，从父节点P中

抽出介于L和

V之间的关键

码y，

并通过该

关键码将节

点L和V“粘接”成

一个节点这

一过程称作

节点的合并

（merge）。注意，

在经如

此合并而得

新节点中，关

键码总数应

为：

(m/2 -

1) + 1 +

(m/2 - 2) =

2m/2 - 2 

m - 1

故原节点

V的下溢缺陷

得以修复，而

且同时也不

致于反过来

引发上溢。

接

下来，还须检

查父节点P关

键码y的删除

可能致使该

节点出现下

溢。好在，即便

如此，

也尽可

套用上述三

种方法继续

修复节点P。当

然，修复之后

仍可能导致

祖父节点以

及更高层节

点

的下溢这

种现象称作

下溢的传递

。特别地，当下

溢传递至根

节点且其中

不再含有任

何关键码

时

，即可将其删

除并代之以

其唯一的孩

子节点，全树

高度也随之

下降一层。

与

上溢传递类

似地，每经过

一次下溢修

复，新下溢节

点的高度都

必然上升一

层。再次由8.2.4

节

的式8-1可知，整

个下溢修复

的过程中至

多需做O(logmN)次节

点合并操作

。

 实现

对下溢

节点的整个

处理过程，如

代码8.12所示。

1 template <typename

T> //兲

键码初除后

若节点下溢

，则做节点旋

转戒合幵处

理

2 void

BTree<T>::solveUnderflow ( BTNodePosi(T) v

) {

3 if

( ( _order +

1 ) / 2

<= v->child.size() ) return;

//逑弻基：弼

前节点幵未

下溢

4 BTNodePosi(T) p

= v->parent;

5 if

( !p ) {

//逑弻基

：已刡根节点

，没有孩子癿

下限

6 if (

!v->key.size() && v->child[0] )

{

7 //但倘若

作为树根癿

v已丌含兲键

码，却有（唯一

癿）非空孩子

，则

8

_root = v->child[0]; _root->parent

= NULL; //返个节点

可被跳过

9

v->child[0] = NULL; release

( v ); //幵

因丌再有用

而被销殍

10 } //整

树高度降低

一局

11

return;

12 }

13

Rank r = 0;

while ( p->child[r] !=

v ) r++;

14

//确定v是

p癿第r个孩子

——此时v可能丌

含兲键码，故

丌能通过兲

键码查找

15 //另

外，在实现了

孩子指针癿

刞等器乀后

，也可直接调

用Vector::find()定位

16

// 情冴

1：向左兄弟倚

兲键码

第8章

高级搜索树

§8.2 B-树

225

17 if (

0 < r )

{ //若v丌是p癿

第一个孩子

，则

18 BTNodePosi(T)

ls = p->child[r -

1]; //左兄弟必

存在

19 if

( ( _order +

1 ) / 2

< ls->child.size() ) {

//若诠兄

弟足够“胖”，则

20 v->key.insert ( 0,

p->key[r - 1] );

//p倚出一个兲

键码给v（作为

最小兲键码

）

21 p->key[r -

1] = ls->key.remove (

ls->key.size() - 1 );

//ls癿最大兲键

码转入p

22 v->child.insert (

0, ls->child.remove ( ls->child.size()

- 1 ) );

23 //同时

ls癿最右侧孩

子过继给v

24 if

( v->child[0] ) v->child[0]->parent

= v; //作

为v癿最左侧

孩子

25

return; //至此，通

过右旋已完

成弼前局（以

及所有局）癿

下溢处理

26 }

27 } //至

此，左兄弟要

举为空，要举

太“瘦”

28

// 情冴2：向

右兄弟倚兲

键码

29 if

( p->child.size() - 1

> r ) {

//若v丌是

p癿最后一个

孩子，则

30 BTNodePosi(T) rs

= p->child[r + 1];

//右兄

弟必存在

31 if (

( _order + 1

) / 2 <

rs->child.size() ) { //若

诠兄弟足够

“胖”，则

32 v->key.insert ( v->key.size(),

p->key[r] ); //p倚出一

个兲键码给

v（作为最大兲

键码）

33

p->key[r] = rs->key.remove (

0 ); //ls癿最小

兲键码转入

p

34

v->child.insert ( v->child.size(), rs->child.remove

( 0 ) );

35 //同时rs癿最左

侧孩子过继

给v

36 if

( v->child[v->child.size() - 1]

) //作为v癿最

右侧孩子

37 v->child[v->child.size()

- 1]->parent = v;

38 return; //至

此，通过左旋

已完成弼前

局（以及所有

局）癿下溢处

理

39

}

40 } //至此，右兄

弟要举为空

，要举太“瘦”

41 // 情

冴3：左、右兄弟

要举为空（但

丌可能同时

），要举都太“瘦

”——合幵

42

if ( 0 <

r ) { //不左兄

弟合幵

43 BTNodePosi(T) ls =

p->child[r - 1]; //左兄

弟必存在

44 ls->key.insert ( ls->key.size(),

p->key.remove ( r -

1 ) ); p->child.remove

( r );

45

//p癿

第r - 1个兲键码

转入ls，v丌再是

p癿第r个孩子

46 ls->child.insert

( ls->child.size(), v->child.remove (

0 ) );

47

if ( ls->child[ls->child.size() -

1] ) //v癿最左侧孩

子过继给ls做

最右侧孩子

48 ls->child[ls->child.size()

- 1]->parent = ls;

49 while ( !v->key.empty()

) { //v剩余癿兲键

码和孩子，依

次转入ls

50

ls->key.insert ( ls->key.size(), v->key.remove

( 0 ) );

51 ls->child.insert ( ls->child.size(),

v->child.remove ( 0 )

);

52 if (

ls->child[ls->child.size() - 1] )

ls->child[ls->child.size() - 1]->parent =

ls;

53 }

54

release ( v );

//释放

v

55 } else

{ //不右兄弟合

幵

56 BTNodePosi(T)

rs = p->child[r +

1]; //右兄度必

存在

57 rs->key.insert

( 0, p->key.remove (

r ) ); p->child.remove

( r );

58

//p癿第r个

兲键码转入

rs，v丌再是p癿第

r个孩子

§8.2 B-树 第

8章

高级搜索

树

226

59 rs->child.insert

( 0, v->child.remove (

v->child.size() - 1 )

);

60 if (

rs->child[0] ) rs->child[0]->parent =

rs; //v癿最左侧

孩子过继给

ls做最右侧孩

子

61 while

( !v->key.empty() ) {

//v剩余癿兲

键码和孩子

，依次转入rs

62 rs->key.insert (

0, v->key.remove ( v->key.size()

- 1 ) );

63 rs->child.insert ( 0,

v->child.remove ( v->child.size() -

1 ) );

64

if ( rs->child[0] )

rs->child[0]->parent = rs;

65

}

66 release (

v ); //释

放v

67

}

68 solveUnderflow (

p ); //上升一局

，如有必要则

继续分裂——至

夗逑弻O(logn)局

69

return;

70 }

代

码8.12

B-树节点癿

下溢处理

如

前所述，若下

溢现象持续

传播至树根

，且树根当时

仅含一个关

键码。于是，在

其仅有的两

个孩子被合

并、仅有的一

个关键码被

借出之后，原

树根将退化

为单分支节

点。对这一特

殊情况，

需删

除该树根，并

以刚合并而

成的节点作

为新的树根

整树高度也

随之降低一

层。



实例

考查

如图8.20(a)所示的

3阶B-树。

图8.20 3阶B-树

初除操作实

例（I）

首先执行

remove(41)：因关键码41来

自底层叶节

点，且从中删

除该关键码

后未发生下

溢，

故无需修

复，结果如图

(b1)所示。接下来

执行remove(53)：因关键

码53并非来自

底层叶节点

，

故在将该关

键码与其直

接后继64交换

位置之后，如

图(b2)所示关键

码，53必属于某

底层叶节点

；

在删除该关

键码之后，其

所属节点并

未发生下溢

，故亦无需修

复，结果如图

(b3)所示。

然后执

行remove(75)：关键码75来

自底层叶节

点，故被直接

删除后其所

属节点如图

(c1)所

示发生下

溢；在经父节

点中转，从右

侧兄弟间接

借得一个关

键码之后，结

果如图(c2)所示

。

第8章 高级搜

索树

§8.3 *红黑树

227

图8.21 3阶B-树初除

操作实例（II）

继

续执行remove(84)：同样

地，删除关键

码84后，其原属

底层叶节点

如以图8.21(d1)所示

发生下溢；此

时左、右兄弟

均无法借出

关键码，故在

从父节点借

得关键码79后

，该下溢节点

可与

其左侧

兄弟合并；父

节点借出一

个关键码之

后尚未下溢

，故结果如图

(d2)所示。

最后执

行remove(51)：删除关键

码51后，其原属

底层叶节点

如图(e1)所示发

生下溢；从父

节点借得关

键码36后，该节

点可与左侧

兄弟合并，但

父节点如图

(e2)所示因此发

生下溢；从祖

父（根）节点借

得关键码64后

，父节点可与

其右侧兄弟

合并，但祖父

节点如图(e3)所

示因此发

生

下溢。此时已

抵达树根，故

直接删除空

的根节点，如

图(e4)所示全树

高度降低一

层。

 复杂度

与

插入操作同

理，在存有N个

关键码的m阶

B-树中的每次

关键码删除

操作，都可以

在O(logmN)

时间内完

成。另外同样

地，因某一关

键码的删除

而导致(logmN)次合

并操作的情

况也极为罕

见，

单次删除

操作过程中

平均只需做

常数次节点

的合并。

§8.3 

*红黑

树

平衡二叉

搜索树的形

式多样，且各

具特色。比如

，8.1节的伸展树

实现简便、无

需修改节点

结构、分摊复

杂度低，但可

惜最坏情况

下的单次操

作需要(n)时间

，故难以适用

于核电站、医

院等对可靠

性和稳定性

要求极高的

场合。反之，7.4节

的AVL树尽管可

以保证最坏

情况下的单

次

操作速度

，但需在节点

中嵌入平衡

因子等标识

；更重要的是

，删除操作之

后的重平衡

可能需做多

达(logn)次旋转，从

而频繁地导

致全树整体

拓扑结构的

大幅度变化

。

红黑树即是

针对后一不

足的改进。通

过为节点指

定颜色，并巧

妙地动态调

整，红黑树可

保证：

在每次

插入或删除

操作之后的

重平衡过程

中，全树拓扑

结构的更新

仅涉及常数

个节点。尽管

最坏

情况下

需对多达(logn)个

节点重染色

，但就分摊意

义而言仅为

O(1)个（习题[8-14]）。

当然

，为此首先需

在AVL树“适度平

衡”标准的基

础上，进一步

放宽条件。实

际上，红黑树

所采用的“适

度平衡”标准

，可大致表述

为：任一节点

左、右子树的

高度，相差不

得超过两倍

。

§8.3 *红黑树

第8章

高级搜索树

228

8.3.1 概述



定义与

条件

为便于

对红黑树的

理解、实现与

分析，这里不

妨

仿照8.2.1节中

B-树的做法，如

图8.22所示统一

地引

入n

+ 1个外

部节点，以保

证原树中每

一节点（现称

作

内部节点

，白色八角形

）的左、右孩子

均非空尽

管

有可能其中

之一甚至二

者同时是外

部节点。当然

，

这些外部节

点的引入只

是假想式的

，在具体实现

时并

不一定

需要兑现为

真实的节点

。如此扩展之

后的便利

之

处在于，我们

的考查范围

只需覆盖真

二叉树。

图8.22

通

过假想式地

引入外部节

点（黑色正

斱

形），将事叉树

扩展为真事

叉树

由红、黑

两色节点组

成的二叉搜

索树若满足

以下条件，即

为红黑树⑤（red-black tree）：

(1) 树

根始终为黑

色

(2) 外部节点

均为黑色

(3) 其

余节点若为

红色，则其孩

子节点必为

黑色

(4) 从任一

外部节点到

根节点的沿

途，黑节点的

数目相等

其

中，条件(1)和(2)意

味着红节点

均为内部节

点，且其父节

点及左、右孩

子必然存在

。另

外，条件(3)意

味着红节点

之父必为黑

色，因此树中

任一通路都

不含相邻的

红节点。

由此

可知，在从根

节点通往任

一节点的沿

途，黑节点都

不少于红节

点。除去根节

点本身，沿

途

所经黑节点

的总数称作

该节点的黑

深度（black

depth）根节点

的黑深度为

0，其余依此

类

推。故条件(4)亦

可等效地理

解和描述为

“所有外部节

点的黑深度

统一”。

由条件

(4)可进一步推

知，在从任一

节点通往其

任一后代外

部节点的沿

途，黑节点的

总数亦

必相

等。除去（黑色

）外部节点，沿

途所经黑节

点的总数称

作该节点的

黑高度（black

height）。

如此

，所有外部节

点的黑高度

均为0，其余依

此类推。

特别

地，根节点的

黑高度亦称

作全树的黑

高度，在数值

上与外部节

点的黑深度

相等。



(2,4)-树

红黑

树的上述定

义，不免令人

困惑和费解

。幸运的是，借

助此前已掌

握的概念，我

们完全可

以

清晰地理解

和把握红黑

树的定义，及

其运转过程

。为此，需注意

到如下有趣

的事实：在红

黑树

与8.2节的

4阶B-树之间，存

在极其密切

的联系；经适

当转换之后

，二者相互等

价！

具体地，自

顶而下逐层

考查红黑树

各节点。每遇

到一个红节

点，都将对应

的子树整体

提升一

层，从

而与其父节

点（必黑）水平

对齐，二者之

间的联边则

相应地调整

为横向。

如此

转换之后，横

向边或向左

或向右，但由

红黑树的条

件(3)，同向者彼

此不会相邻

；即便

不考虑

联边的左右

方向，沿水平

方向相邻的

边至多两条

（向左、右各一

条），涉及的节

点至多三

个

（一个黑节点

加上零到两

个红节点）。此

时，若将原红

黑树的节点

视作关键码

，沿水平方向

相

邻的每一

组（父子至多

三个）节点即

恰好构成4阶

B-树的一个节

点。

⑤ 其雏形由

R. Bayer亍1972年収明[44]，命

名为对称二

叉B-树（symmetric binary

B-tree）

后由L. J. Guibas不

R.

Sedgewick亍1978年做过改

迕[45]，幵定名为

红黑树（red-black tree）

第8章

高级搜索树

§8.3 *红黑树

229

图8.23针

对所有可能

的四种情况

，分别给出了

具体的转换

过程。可见，按

照上述对应

关系，

每棵红

黑树都等价

于一棵(2,4)-树；前

者的每一节

点都对应于

后者的一个

关键码。通往

黑节点

的边

，对黑高度有

贡献，并在(2,4)-树

中得以保留

；通往红节点

的边对黑高

度没有贡献

，在(2,4)-

树中对应

于节点内部

一对相邻的

关键码。在本

节的插图中

，这两类边将

分别以实线

、虚线示意。

图

8.23 红黑树刡4阶

B-树癿等价转

换（在完全彩

色版尚未出

版乊前本书

约定，分删以

囿形、正斱形

和八角形表

示红黑树癿

红节点、黑节

点和颜色未

定节点，以长

斱形表示B-树

节点）

为使讲

解简洁，在不

致引起歧义

的前提下，以

下将不再严

格区分红黑

树中的节点

及其在

(2,4)-树中

对应的关键

码。当然，照此

理解，此时的

关键码也被

赋予了对应

的颜色。对照

红黑

树的条

件，(2,4)-树中的每

个节点应包

含且仅包含

一个黑关键

码，同时红关

键码不得超

过两个。

而且

，若某个节点

果真包含两

个红关键码

，则黑关键码

的位置必然

居中。



平衡性

与所有二叉

搜索树一样

，红黑树的性

能首先取

决

于其平衡性

。那么，红黑树

的高度可以

在多大范

围

之内变化呢

？实际上，即便

计入扩充的

外部节

点，包

含n个内部节

点的红黑树

T的高度h也不

致超

过O(logn)。更严

格地有：

log2(n + 1)

 h  2∙log2(n

+ 1)

左侧

的“”显然成立

，故以下只需

证明右侧

“”也

成立。

图8.24 红黑

树癿黑高度

丌低二高度

癿一

半；反乊

，高度丌超过

黑高度癿两

倍

如图8.24所示

，若将T的黑高

度记作H，则H也

是T所对应(2,4)-树

TB的高度，故由

8.2.4节

关于B-树高

度与所含关

键码总数关

系的结论，有

：

H  log4/2



n +

2

1

 +

1  log2 

n + 

2

1

 + 1

 log2(n + 1)

另一方面，既

然任一通路

都不含相邻

的红节点，故

必有：

h  2H

 2∙log2(n + 1)

= O(logn)

也就是

说，尽管红黑

树不能如完

全树那样可

做到理想平

衡，也不如AVL树

那样可做到

较严格

的适

度平衡，但其

高度仍控制

在最小高度

的两倍以内

（习题[8-11]），从渐进

的角度看仍

是

O(logn)，依然保证

了适度平衡

这正是红黑

树可高效率

支持各种操

作的基础。

§8.3 *红

黑树 第8章

高

级搜索树

230

8.3.2 红

黑树接口定

义

基于185页代

码7.2中的BST模板

类，可派生出

RedBlack模板类如代

码8.13所示。

1 #include "../BST/BST.h"

//基亍

BST实现RedBlack

2 template <typename

T> class RedBlack :

public BST<T> { //RedBlack树模板

类

3 protected:

4 void

solveDoubleRed ( BinNodePosi(T) x

); //双红修正

5 void solveDoubleBlack

( BinNodePosi(T) x );

//双黑修正

6 int updateHeight

( BinNodePosi(T) x );

//更

新节点x癿高

度

7 public:

8

BinNodePosi(T) insert ( const

T& e ); //揑入（重写

）

9 bool remove (

const T& e );

//初除（重写）

10 // BST::search()等

其余接口可

直接沿用

11 };

代

码8.13 基二BST定义

癿红黑树接

口

可见，这里

直接沿用了

二叉搜索树

标准的查找

算法search()，并根据

红黑树的重

平衡规则

与

算法，重写了

insert()和remove()接口；新加

的两个内部

功能接口solveDoubleRed()和

solveDoubleBlack()，分别用于在

节点插入或

删除之后恢

复全树平衡

。其具体实现

稍后介绍。

另

外，这里还需

使用此前二

叉树节点模

板类BinNode（117页代码

5.1）中预留的两

个成员

变量

height和color。如代码8.14所

示，仿照AVL树的

实现方式，可

借助辅助宏

来检查节点

的颜

色以及

判定是否需

要更新（黑）高

度记录，如此

可大大简化

相关算法的

描述。

1 #define IsBlack(p)

( ! (p) ||

( RB_BLACK == (p)->color

) ) //外部节

点也规作黑

节点

2

#define IsRed(p) ( !

IsBlack(p) ) //非黑即

红

3

#define BlackHeightUpdated(x) ( /*RedBlack高度更新

条件*/

\

4 ( stature(

(x).lc ) == stature(

(x).rc ) ) &&

\

5 ( (x).height

== ( IsRed(& x)

? stature( (x).lc )

: stature( (x).lc )

+ 1 ) )

\

6 )

代码8.14

用

以简化红黑

树算法描述

癿宏

可见，这

里的确并未

真正地实现

图8.22中所引入

的外部节点

，而是将它们

统一地直接

判定

为黑“节

点”尽管它们

实际上只不

过是NULL。其余节

点，则一概视

作红节点。

1

template <typename T> int

RedBlack<T>::updateHeight ( BinNodePosi(T) x

) { //更

新节点高度

2 x->height

= max ( stature

( x->lc ), stature

( x->rc ) );

//孩子一般黑

高度相等，除

非出现双黑

3 return IsBlack (

x ) ? x->height++

: x->height; //若弼前节点

为黑，则计入

黑深度

4

} //因统

一定丿stature(NULL) = -1，故height比

黑高度少一

，好在丌致影

响刡各种算

法中癿比较

刞断

代码8.15 红

黑树节点癿

黑高度更新

此处的height已不

再是指常规

的树高，而是

红黑树的黑

高度。故如代

码8.15所示，节点

黑

高度需要

更新的情况

共分三种：或

者左、右孩子

的黑高度不

等；或者作为

红节点，黑高

度与其孩

子

不相等；或者

作为黑节点

，黑高度不等

于孩子的黑

高度加一。

第

8章 高级搜索

树 §8.3 *红黑树

231

8.3.3 节

点插入算法

 节点插入与

双红现象

如

代码8.16所示，不

妨假定经调

用接口search(e)做查

找之后，确认

目标节点尚

不存在。

于是

，在查找终止

的位置x处创

建节点，并随

即将其染成

红色（除非此

时全树仅含

一个节点）。

现

在，对照红黑

树的四项条

件，唯有(3)未必

满足亦即，此

时x的父亲也

可能是红色

。

1

template <typename T> BinNodePosi(T)

RedBlack<T>::insert ( const T&

e ) { //将e揑入红黑

树

2 BinNodePosi(T) & x

= search ( e

); if ( x

) return x; //确讣目标

丌存在（留意

对_hot癿讴置）

3 x = new

BinNode<T> ( e, _hot,

NULL, NULL, -1 );

_size++; //创

建红节点x：以

_hot为父，黑高度

-1

4 solveDoubleRed

( x ); return

x ? x :

_hot->parent; //经双红修正

后，即可迒回

5 } //无讳e是否存

在亍原树中

，迒回时总有

x->data

== e

代码8.16 红黑树

insert()接口

因新节

点的引入，而

导致父子节

点同为红色

的此类情况

，称作“双红”（double red）。

为

修正双红缺

陷，可调用solveDoubleRed(x)接

口。每引入一

个关键码，该

接口都可能

迭代地

调用

多次。在此过

程中，当前节

点x的兄弟及

两个孩子（初

始时都是外

部节点），始终

均为黑色。

将

x的父亲与祖

父分别记作

p和g。既然此前

的红黑树合

法，故作为红

节点p的父亲

，g必然存

在且

为黑色。g作为

内部节点，其

另一孩子（即

p的兄弟、x的叔

父）也必然存

在，将其记作

u。

以下，视节点

u的颜色不同

，分两类情况

分别处置。



双

红修正（RR-1）

首先

，考查u为黑色

的情况。此时

，x的兄弟、两个

孩子的黑高

度，均与u相等

。图8.25(a)

和(b)即为此

类情况的两

种可能（另两

种对称情况

，请读者独立

补充）。

图8.25

双红

修正第一种

情冴（RR-1）及其调

整斱法（上斱

、下斱分删为

红黑树及其

对应B-树癿尿

部）

此时红黑

树条件(3)的违

反，从B-树角度

等效地看，即

同一节点不

应包含紧邻

的红色关键

码。

故如图8.25(c')所

示，只需令黑

色关键码与

紧邻的红色

关键码互换

颜色。从图(c)红

黑树的角度

看，这等效于

按中序遍历

次序，对节点

x、p和g及其四棵

子树，做一次

局部“3 +

4”重构。

不

难验证，如此

调整之后，局

部子树的黑

高度将复原

，这意味着全

树的平衡也

必然得以恢

复。

同时，新子

树的根节点

b为黑色，也不

致引发新的

双红现象。至

此，整个插入

操作遂告完

成。

§8.3

*红黑树 第

8章 高级搜索

树

232

 双红修正

（RR-2）

再考查节点

u为红色的情

况。此时，u的左

、右孩子非空

且均为黑色

，其黑高度必

与x的兄弟

以

及两个孩子

相等。图8.26(a)和(b)给

出了两种可

能的此类情

况（另两种对

称情况，请读

者独

立补充

）。此时红黑树

条件(3)的违反

，从B-树角度等

效地看，即该

节点因超过

4度而发生上

溢。

图8.26 双红修

正第事种情

冴（RR-2）及其调整

斱法（带问号

癿关键码可

能存在）

以图

8.26(b)为例。从图(c)红

黑树的角度

来看，只需将

红节点p和u转

为黑色，黑节

点g转

为红色

，x保持红色。从

图(c')B-树的角度

来看，等效于

上溢节点的

一次分裂。

不

难验证，如此

调整之后局

部子树的黑

高度复原。然

而，子树根节

点g转为红色

之后，有可

能

在更高层再

次引发双红

现象。从图8.26(c')B-树

的角度来看

，对应于在关

键码g被移出

并归入

上层

节点之后，进

而导致上层

节点的上溢

即上溢的向

上传播。

若果

真如此，可以

等效地将g视

作新插入的

节点，同样地

分以上两类

情况如法处

置。请注意，

每

经过一次这

样的迭代，节

点g都将在B-树

中（作为关键

码）上升一层

，而在红黑树

中存在双红

缺陷的位置

也将相应地

上升两层，故

累计至多迭

代O(logn)次。

特别地

，若最后一步

迭代之后导

致原树根的

分裂，并由g独

立地构成新

的树根节点

，则应遵

照红

黑树条件(1)的

要求，强行将

其转为黑色

如此，全树的

黑高度随即

增加一层。

 双

红修正的复

杂度

以上情

况的处理流

程可归纳为

图8.27。其中的重

构、染色等局

部操作均只

需常数时间

，故

只需统计

这些操作在

修正过程中

被调用的总

次数。

图8.27 双红

修正流秳图

表8.1 双红修正

算法所涉及

尿部操作癿

统计

情

冴 #旋

转 #染色 单轮

修正乊后

RR-1 u为

黑 1~2 2

调整随即

完成

RR-2 u为红 0

3

戒

再次双红

但

必上升两局

第8章 高级搜

索树

§8.3 *红黑树

233

具体统计，可

归纳为表8.1。可

见，对于前一

种情况，只需

做一轮修正

；后一种情况

虽有可

能需

要反复修正

，但由于修正

位置的高度

会严格单调

上升，故总共

也不过O(logn)轮。另

外从该

表也

可看出，每一

轮修正只涉

及到常数次

的节点旋转

或染色操作

。

因此，节点插

入之后的双

红修正，累计

耗时不会超

过O(logn)。即便计入

此前的关键

码查找

以及

节点接入等

操作，红黑树

的每次节点

插入操作，都

可在O(logn)时间内

完成。

需要特

别指出的是

，只有在RR-1修复

时才需做1~2次

旋转；而且一

旦旋转后，修

复过程必然

随即完成。故

就全树拓扑

结构而言，每

次插入后仅

涉及常数次

调整；而且稍

后将会看到

，红黑树

的节

点删除操作

亦是如此回

顾7.4节的AVL树，却

只能保证前

一点。

 双红修

正算法的实

现

以上针对

双红缺陷的

各种修正方

法，可以概括

并实现如代

码8.17所示。

1 /******************************************************************************************

2 *

RedBlack双红

调整算法：解

决节点x不其

父均为红色

癿问题。分为

两大类情冴

：

3 * RR-1：2次颜色翻转

，2次黑高度更

新，1~2次旋转，丌

再逑弻

4 * RR-2：3次颜

色翻转，3次黑

高度更新，0次

旋转，需要逑

弻

5

******************************************************************************************/

6 template <typename

T> void RedBlack<T>::solveDoubleRed (

BinNodePosi(T) x ) {

//x弼前必为

红

7 if (

IsRoot ( *x )

) //若已（逑弻

）转至树根，则

将其转黑，整

树黑高度也

随乀逑增

8 {

_root->color = RB_BLACK; _root->height++;

return; } //否

则，x癿父亲p必

存在

9

BinNodePosi(T) p = x->parent;

if ( IsBlack (

p ) ) return;

//若p为黑

，则可终止调

整。否则

10 BinNodePosi(T) g

= p->parent; //既然

p为红，则x癿祖

父必存在，且

必为黑色

11

BinNodePosi(T) u = uncle

( x ); //以

下，规x叔父u癿

颜色分删处

理

12 if ( IsBlack

( u ) )

{ //u为黑色（含

NULL）时

13 if

( IsLChild ( *x

) == IsLChild (

*p ) ) //若x不p同侧

（即zIg-zIg戒zAg-zAg），则

14 p->color = RB_BLACK;

//p由红

转黑，x保持红

15 else //若x不p异侧（即

zIg-zAg戒zAg-zIg），则

16

x->color = RB_BLACK; //x由红转

黑，p保持红

17 g->color = RB_RED;

//g必

定由黑转红

18 ///// 以上虽保证

总共两次染

色，但因增加

了刞断而得

丌偿失

19

///// 在旋

转后将根置

黑、孩子置红

，虽需三次染

色但效率更

高

20 BinNodePosi(T)

gg = g->parent; //曾祖父（great-grand

parent）

21 BinNodePosi(T) r

= FromParentTo ( *g

) = rotateAt (

x ); //调

整后癿子树

根节点

22

r->parent = gg; //不原

曾祖父联接

23

} else { //若u为红色

24 p->color = RB_BLACK;

p->height++; //p由

红转黑

25 u->color

= RB_BLACK; u->height++; //u由红

转黑

26 if ( !IsRoot

( *g ) )

g->color = RB_RED; //g若非根

，则转红

27 solveDoubleRed ( g

); //继续

调整g（类似亍

尾逑弻，可优

化为迭代形

式）

28 }

29 }

代码8.17 双红

修正solveDoubleRed()

§8.3 *红黑树

第8章 高级搜

索树

234

8.3.4 节点删

除算法

 节点

删除与双黑

现象

1 template <typename T>

bool RedBlack<T>::remove ( const

T& e ) {

//从红黑

树中初除兲

键码e

2 BinNodePosi(T) &

x = search (

e ); if (

!x ) return false;

//确讣目

标存在（留意

_hot癿讴置）

3 BinNodePosi(T) r

= removeAt ( x,

_hot ); if (

! ( --_size )

) return true; //实斲

初除

4 // assert: _hot某一孩

子刚被初除

，且被r所指节

点（可能是NULL）接

替。以下检查

是否失衡，幵

做必要调整

5

if ( ! _hot

) //若刚被初除

癿是根节点

，则将其置黑

，幵更新黑高

度

6 {

_root->color = RB_BLACK; updateHeight

( _root ); return

true; }

7 //

assert: 以下，原x（现

r）必非根，_hot必非

空

8 if

( BlackHeightUpdated ( *_hot

) ) return true;

//若所有祖

先癿黑深度

依然平衡，则

无需调整

9 if (

IsRed ( r )

) //否

则，若r为红，则

叧需令其转

黑

10 {

r->color = RB_BLACK; r->height++;

return true; }

11

// assert: 以下，原x（现

r）均为黑色

12

solveDoubleBlack ( r );

return true; //经

双黑调整后

迒回

13

} //若目标

节点存在且

被初除，迒回

true；否则迒回false

代

码8.18 红黑树remove()接

口

如代码8.18所

示，为删除关

键码e，首先调

用标准接口

BST::search(e)，查找目标节

点x。

若查找成

功，则调用内

部接口removeAt(x)实施

删除。按照7.2.6节

对该接口所

做的语义约

定，

其间无论

是否做过一

次节点交换

，均以r指向实

际被删除节

点x的接替者

，p =

_hot为其父亲。

不

难验证，此时

红黑树的前

两个条件继

续满足，但后

两个条件却

未必依然满

足。

如图8.28所示

，除了其接替

者r，

x还应有另

一个孩子w。既

然x是实际被

删除者，故w必

为（黑色的）外

部节点

NULL。

如图

(a)和(a')所示，若x为

红

色，则在删

除x并代之以

r后，条件

(3~4)依然

满足；反之，若

x为黑色，

则要

看其替代者

r的颜色。

如图

(b)和(b')所示，若r为

红

色，则只需

将其翻转为

黑色，即可使

条件(3~4)重新满

足。

然而如图

(c)和(c')所示，若x和

r均为黑色，则

为使条件(3~4)重

新成

立，还需

要做略微复

杂一些的处

理。

图8.28 初除节

点x乊后，红黑

树条件(4)：

(a)戒依

然满足，(b)戒绊

重染色后重

新满足，(c)戒丌

再满足

因某

一无红色孩

子的黑节点

被删除，而导

致的此类复

杂情况，称作

“双黑”（double black）

现象。此

时，需从r出发

调用solveDoubleBlack(r)算法予

以修正。

自然

，原黑节点x的

兄弟必然非

空，将其记作

s；x的父亲记作

p，其颜色不确

定（故在图中

以八角形示

意）。以下视s和

p颜色的不同

组合，按四种

情况分别处

置。

第8章 高级

搜索树 §8.3 *红黑

树

235

 双黑修正

（BB-1）

既然节点x的

另一孩子w

= NULL，故

从B-树角度（图

8.29(a')）看节点x被删

除之后的情

况，

可以等效

地理解为：关

键码x原所属

的节点发生

下溢；此时，t和

s必然属于B-树

的同一节点

，且

该节点就

是下溢节点

的兄弟。故可

参照B-树的调

整方法，下溢

节点从父节

点借出一个

关键码（p），

然后

父节点从向

下溢节点的

兄弟节点借

出一个关键

码（s），调整后的

效果如图(b')。

图

8.29 双黑修正（情

冴BB-1）

（带问号癿

关键码可能

存在，且颜色

丌定）

从红黑

树的角度（图

(b)）来看，

上述调

整过程等效

于，对节点t、s和

p

实施“3 +

4”重构。

此

外，根据红黑

树与B-树的对

应

关系不难

理解，若这三

个节点按中

序遍

历次序

重命名为a、b和

c，则还需将a

和

c染成黑色，b则

继承p此前的

颜色。

就图8.29的

具体实例而

言，也就是将

t

和p染成黑色

，s继承p此前的

颜色。注

意，整

个过程中节

点r保持黑色

不变。

由图8.29(b)（及

其对称情况

）不

难验证，经

以上处理之

后，红黑树的

所

有条件，都

在这一局部

以及全局得

到恢

复，故删

除操作遂告

完成。

 双黑修

正（BB-2-R）

节点s及其

两个孩子均

为黑色时，视

节点p颜色的

不同，又可进

一步分为两

种情况。

先考

虑p为红色的

情况。如图8.30(a)所

示，即为一种

典型的此类

情况（与之对

称的情况，

请

读者独立补

充）。

图8.30 双黑修

正（情冴BB-2-R）

（带问

号癿黑关键

码可能但丌

会同时存在

）

与BB-1类似，在对

应的B-树中，关

键码x的删除

导

致其所属

的节点下溢

。但因此时关

键码s所在节

点只有两

个

分支，故下溢

节点无法从

父节点借出

关键码（p）。

按照

8.2.8节的B-树平衡

算法，此时应

如图(b')所

示，将

关键码p取出

并下降一层

，然后以之为

“粘合剂”，

将原

左、右孩子合

并为一个节

点。从红黑树

角度看，这

一

过程可如图

(b)所示等效地

理解为：s和p颜

色互换。

由图

8.30(b)（及其对称情

况）可知，经过

以上处

理，红

黑树的所有

条件都在此

局部得以恢

复。另外，由

于

关键码p原为

红色，故如图

8.30(a')所示，在关键

码p

所属节点

中，其左或右

必然还有一

个黑色关键

码（当然，

不可

能左、右兼有

）这意味着，在

关键码p从其

中取

出之后

，不致引发新

的下溢。至此

，红黑树条件

亦必在

全局

得以恢复，删

除操作即告

完成。

§8.3 *红黑树

第8章

高级搜

索树

236

 双黑修

正（BB-2-B）

接下来，再

考虑节点s、s的

两个孩子以

及节点p均为

黑色的情况

。

如图8.31(a)所示，即

为一种典型

的此类情况

（与之对称的

情况，请读者

独立补充）。此

时

与BB-2-R类似，在

对应的B-树中

，因关键码x的

删除，导致其

所属节点发

生下溢。

因此

可如图(b')所示

，将下溢

节点

与其兄弟合

并。从红黑树

的角

度来看

，这一过程可

如图(b)所示等

效地理解为

：节点s由黑转

红。

由图8.31(b)（及其

对称情况）

可

知，经以上处

理，红黑树所

有条

件都在

此局部得到

恢复。

然而，因

s和x在此之前

均为黑

色，故

如图8.31(a')所示，p原

所

属的B-树节

点必然仅含

p这一个关

键

码。于是在p被

借出之后，该

节点

必将继

而发生下溢

，故有待于后

续

进一步修

正。 图8.31

双黑修

正（情冴BB-2-B）

从红

黑树的角度

来看，此时的

状态可等效

地理解为：节

点p的父节点

刚被删除。当

然，可以

按照

本节所介绍

的算法，视具

体的情况继

续调整。

实际

上稍后总结

时将会看出

，这也是双黑

修正过程中

，需要再次迭

代的唯一可

能。幸运的是

，

尽管此类情

况可能持续

发生，下溢的

位置也必然

不断上升，故

至多迭代O(logn)次

后必然终止

。

 双黑修正（BB-3）

最

后，考虑节点

s为红色的情

况。如图8.32(a)所示

，即为一种典

型的此类情

况（与之对称

的情况，

请读

者独立补充

）。此时，作为红

节点s的父亲

，节点p必为黑

色；同

时，s的两

个孩子也应

均为黑色。

于

是从B-树的角

度来看，只需

如图(b')所示，令

关键码s与p互

换

颜色，即可

得到一棵与

之完全等价

的B-树。而从红

黑树的角度

来看，

这一转

换对应于以

节点p为轴做

一

次旋转，并

交换节点s与

p的颜色。 图8.32 双

黑修正（情冴

BB-3）

读者可能会

发现，经过如

此处理之后

，双黑缺陷依

然存在，而且

缺陷位置的

高度也并未

上升。

既然如

此，这一步调

整的意义又

何在呢？

第8章

高级搜索树

§8.3 *红黑树

237

实际

上，经过这一

转换之后，情

况已经发生

了微妙而本

质的变化。仔

细观察图(b)不

难发现，

在转

换之后的红

黑树中，被删

除节点x（及其

替代者节点

r）有了一个新

的兄弟s'与此

前的

兄弟s不

同，s'必然是黑

的！这就意味

着，接下来可

以套用此前

所介绍其它

情况的处置

方法，继

续并

最终完成双

黑修正。

还有

一处本质的

变化，同样需

要注意：现在

的节点p，也已

经黑色转为

红色。因此接

下来即

便需

要继续调整

，必然既不可

能转换回此

前的情况BB-3，也

不可能转入

可能需要反

复迭代的情

况BB-2-B。实际上反

过来，此后只

可能转入更

早讨论过的

两类情况BB-1或

BB-2-R。这就意

味着

，接下来至多

再做一步迭

代调整，整个

双黑修正的

任务即可大

功告成。

 双黑

修正的复杂

度

以上各种

情况的处理

流程，可以归

纳为图8.33。

图8.33

双

黑修正流秳

图

其中涉及

的重构、染色

等局部操作

，均可在常数

时间内完成

，故为了估计

整个双黑修

正过程

的时

间复杂度，也

只需统计这

些操作各自

的累计执行

次数。具体统

计可归纳为

表8.2。

表8.2

双黑修

正算法所涉

及尿部操作

癿统计

情 冴

#旋转 #染色

单

轮修正乊后

BB-1 黑s有红子t 1~2 3

调

整随即完成

BB-2-R 黑s无红子，p红

0 2 调整随即完

成

BB-2-B 黑s无红子

，p黑 0 1

必然再次

双黑，但将上

升一局

BB-3 红s 1

2 转

为(BB-1)戒(BB-2-R)

可见，前

两种情况各

自只需做一

轮修正，最后

一种情况亦

不过两轮。

情

况BB-2-B虽可能需

要反复修正

，但由于待修

正位置的高

度严格单调

上升，累计也

不致过

O(logn)轮，故

双黑修正过

程总共耗时

不超过O(logn)。即便

计入此前的

关键码查找

和节点摘除

操作，红黑树

的节点删除

操作总是可

在O(logn)时间内完

成。

纵览各种

情况，不难确

认：一旦在某

步迭代中做

过节点的旋

转调整，整个

修复过程便

会随即

完成

。因此与双红

修正一样，双

黑修正的整

个过程，也仅

涉及常数次

的拓扑结构

调整操作。

这

一有趣的特

性同时也意

味着，在每此

插入操作之

后，拓扑联接

关系有所变

化的节点绝

不会

超过常

数个这一点

与AVL树（的删除

操作）完全不

同，也是二者

之间最本质

的一项差异

。

§8.3 *红黑树 第8章

高级搜索树

238

 双黑修正算

法的实现

以

上针对双黑

缺陷的各种

修正方法，可

以概括并实

现如代码8.19所

示。

1

/******************************************************************************************

2 * RedBlack双黑调整

算法：解决节

点x不被其替

代癿节点均

为黑色癿问

题

3 * 分为三大

类共四种情

冴：

4

* BB-1 ：2次颜色翻

转，2次黑高度

更新，1~2次旋转

，丌再逑弻

5

* BB-2R：2次

颜色翻转，2次

黑高度更新

，0次旋转，丌再

逑弻

6 *

BB-2B：1次颜色

翻转，1次黑高

度更新，0次旋

转，需要逑弻

7 * BB-3 ：2次颜色翻转

，2次黑高度更

新，1次旋转，转

为BB-1戒BB2R

8 ******************************************************************************************/

9 template

<typename T> void RedBlack<T>::solveDoubleBlack

( BinNodePosi(T) r )

{

10 BinNodePosi(T) p

= r ? r->parent

: _hot; if (

!p ) return; //r癿父亲

11

BinNodePosi(T) s = (

r == p->lc )

? p->rc : p->lc;

//r癿兄弟

12 if (

IsBlack ( s )

) { //兄弟

s为黑

13

BinNodePosi(T) t = NULL;

//s癿红孩

子（若左、右孩

子皀红，左者

优先；皀黑时

为NULL）

14 if (

HasLChild ( *s )

&& IsRed ( s->lc

) ) t =

s->lc;

15 else if

( HasRChild ( *s

) && IsRed (

s->rc ) ) t

= s->rc;

16 if

( t ) {

//黑s有红孩

子：BB-1

17 RBColor oldColor

= p->color; //备仹原子

树根节点p颜

色，幵对t及其

父亲、祖父

18

BinNodePosi(T) b = FromParentTo

( *p ) =

rotateAt ( t );

//重

平衡，幵将新

子树癿左、右

孩子染黑

19 if (

HasLChild ( *b )

) b->lc->color = RB_BLACK;

updateHeight ( b->lc );

//左

孩子

20 if (

HasRChild ( *b )

) b->rc->color = RB_BLACK;

updateHeight ( b->rc );

//右孩子

21 b->color = oldColor;

updateHeight ( b );

//新子树根节

点继承原根

节点癿颜色

22 } else {

//黑s无红孩子

23 s->color = RB_RED;

s->height--; //s转红

24 if

( IsRed ( p

) ) { //BB-2R

25 p->color = RB_BLACK;

//p转黑，但

黑高度丌发

26 } else {

//BB-2B

27 p->height--; //p保持黑，但黑

高度下降

28 solveDoubleBlack ( p

);

29 }

30

}

31 } else

{ //兄

弟s为红：BB-3

32 s->color

= RB_BLACK; p->color =

RB_RED; //s转黑

，p转红

33 BinNodePosi(T)

t = IsLChild (

*s ) ? s->lc

: s->rc; //叏t不其

父s同侧

34

_hot = p; FromParentTo

( *p ) =

rotateAt ( t );

//对t及

其父亲、祖父

做平衡调整

35 solveDoubleBlack ( r

); //继续修正r处

双黑——此时癿

p已转红，故后

续叧能是BB-1戒

BB-2R

36 }

37 }

代码8.19 双黑修

正solveDoubleBlack()

第8章 高级

搜索树 §8.4 *kd-树

239

§8.4 

*

kd-树

8.4.1 范围查询

 一

维范围查询

如图8.34所示，许

多实际应用

问题，都可归

结为如下形

式的查询：给

定直线L上的

点集P

= 

{ p0,

..., pn-1 }，对于任

一区间R =

[x1, x2]，P中的

哪些点落在

其中？

图8.34 一维

范围查询

比

如，在校友数

据库中查询

1970至2000级的学生

，或者查询IP介

于166.111.68.1至

166.111.68.255之间的

在线节点等

，此类问题统

称为一维范

围查询（range query）。



蛮力

算法

表面看

来，一维范围

查询问题并

不难解决。比

如，只需遍历

点集P，并逐个

地花费O(1)时间

判断各点是

否落在区间

R内如此总体

运行时间为

(n)。这一效率甚

至看起来似

乎还不差

毕

竟在最坏情

况下，的确可

能有多达(n)个

点命中，而直

接打印报告

也至少需要

(n)时间。

然而，当

我们试图套

用以上策略

来处理更大

规模的输入

点集时，就会

发现这种方

法显得力不

从心。实际上

，蛮力算法的

效率还有很

大的提升空

间，这一点可

从以下角度

看出。

首先，当

输入点集的

规模大到需

要借助外部

存储器时，遍

历整个点集

必然引发大

量I/O操作。

正如

8.2.1节所指出的

，此类操作往

往是制约算

法实际效率

提升的最大

瓶颈，应尽量

予以避免。

另

外，当数据点

的坐标分布

范围较大时

，通常的查询

所命中的点

，在整个输入

点集中仅占

较

低甚至极

低的比例。此

时，“查询结果

的输出需要

(n)时间”的借口

，已难以令人

信服。

 预处理

在典型的范

围查询应用

中，输入点集

数据与查询

区域的特点

迥异。一方面

，输入点集P通

常

会在相当

长的时间内

保持相对固

定数据的这

种给出及处

理方式，称作

批处理（batch）或离

线（offline）方式。同时

，对于同一输

入点集，往往

需要针对大

量的随机定

义的区间R，反

复

地进行查

询数据的这

种给出及处

理方式，称作

在线（online）方式。

因

此，只要通过

适当的预处

理，将输入点

集P提前整理

和组织为某

种适当的数

据结构，就有

可能进一步

提高此后各

次查询操作

的效率。

 有序

向量

最为简

便易行的预

处理方法，就

是在O(nlogn)时间内

，将点集P组织

为一个有序

向量。

图8.35 通过

预先排序，高

效地解决一

维范围查询

问题（p-1为假想

着引入癿哨

兵，数值等二

-）

如图8.35所示，此

后对于任何

R =

[x1, x2]，首先利用有

序向量的查

找算法（代码

2.20），

在O(logn)时间内找

到不大于x2的

最大点pt。然后

从pt出发，自右

向左地遍历

向量中的各

点，直

至第一

个离开查询

区间的点ps。其

间经过的所

有点，既然均

属于区间范

围，故可直接

输出。

§8.4 *kd-树 第8章

高级搜索树

240

如此，在每一

次查询中，pt的

定位需要O(logn)时

间。若接下来

的遍历总共

报告出r个点

，

则总体的查

询时间成本

为O(r + logn)。

请注意，此

处估计时间

复杂度的方

法，不免有点

特别。这里，需

要同时根据

问题的输入

规模

和输出

规模进行估

计。一般地，时

间复杂度可

以这种形式

给出的算法

，也称作输出

敏感的（output 

sensitive）算法

。从以上实例

可以看出，与

此前较为粗

略的最坏情

况估计法相

比，这种估计

方

法可以更

加准确和客

观地反映算

法的实际效

率。

 二维范围

查询

接下来

的难点和挑

战在于，在实

际应用中，往

往还需要同

时对多个维

度做范围查

找。以人事

数

据库为例，诸

如“年龄介于

某个区间，而

且工资介于

某个区间”之

类的组合查

询十分普遍

。

图8.36 平面范围

查询（planar range query）

如图8.36所

示，若将年龄

与工资分别

表示

为两个

正交维度，则

人事数据库

中的记录，将

对

应于二维

平面上（第一

象限内）的点

。于是相应

地

，这类查询都

可以抽象为

在二维平面

上，针对

某一

相对固定的

点集的范围

查询，其查询

范围可

描述

为矩形R = [x1,

x2]  [y1, y2]。

很遗

憾，上述基于

二分查找的

方法并不能

直

接推广至

二维情况，更

不用说更高

维的情况了

，

因此必须另

辟蹊径，尝试

其它策略。



平

衡二叉搜索

树

我们还是

回到该问题

的一维版本

，并尝试其它

可以推广至

二维甚至更

高维版本的

方法。比如，

不

妨在O(nlogn)时间内

，将输出点集

组织并转化

为如图8.37所示

的一棵平衡

二叉搜索树

。

图8.37

平衡事叉

搜索树：叶节

点存放输入

点，内部节点

等二左子树

中癿最大者

请注意，其中

各节点的关

键码可能重

复。不过，如此

并不致于增

加渐进的空

间和时间复

杂度：

每个关

键码至多重

复一次，总体

依然只需O(n)空

间；尽管相对

于常规二叉

搜索树仅多

出一层，

但树

高依然是O(logn)。

如

此在空间上

所做的些许

牺牲，可以换

来足够大的

收益：查找的

过程中，在每

一节点处，至

多只需做一

次（而不是两

次）关键码的

比较。当然另

一方面，无论

成功与否，每

次查找因此

都必

然终止

于叶节点不

小于目标关

键码的最小

叶节点。

不难

验证，就接口

和功能而言

，此类形式二

叉搜索树，完

全对应于和

等价于2.6.8节所

介绍

二分查

找算法的版

本C（代码2.24）。

第8章

高级搜索树

§8.4

*kd-树

241

 查询算法

借助上述形

式的平衡二

叉搜索树，如

何高效地解

决一维范围

查询问题呢

？

仍然继续上

例，如图8.38所示

，设查询区间

为[1, 23]。

图8.38 借劣平

衡事叉搜索

树解决一维

范围查询问

题（针对区间

端点癿两条

查找路径加

粗示意）

首先

，在树中分别

查找这一区

间的左、右端

点1和23，并分别

终止于叶节

点3和24。

接下来

，考查这两个

叶节点共同

祖先中的最

低者，即所谓

的最低共同

祖先（lowest common

ancestor, LCA），具体地

亦即

lca(3, 24)

= 15

然后，从

这一共同祖

先节点出发

，分别重走一

遍通往节点

3和24的路径（分

别记作path(3)

和path(24)）。在

沿着path(3)/path(24)下行的

过程中，忽略

所有的右转

/左转；而对于

每一

次左转

/右转，都需要

遍历对应的

右子树/左子

树（图中以阴

影示意），并将

其中的叶节

点悉数报

告

出来。就本例

而言，沿path(3)被报

告出来的叶

节点子集，依

次为：

{ 9,

12, 14, 15 }、{

4, 7 }、{ 3

}

沿path(24)被报

告出来的叶

节点子集，依

次为：

{ 17,

20 }、{ 22 }

 正确性

不难看出，如

此分批报告

出来的各组

节点，都属于

查询输出结

果的一部分

，且它们相互

没有

重叠。另

一方面，除了

右侧路径的

终点24需要单

独地判断一

次，其余的各

点都必然落

在查询范围

以外。因此，该

算法所报告

的所有点，恰

好就是所需

的查询结果

。



效率

在每一

次查询过程

中，针对左、右

端点的两次

查找及其路

径的重走，各

自不过O(logn)时间

（实际上，这些

操作还可进

一步合并精

简）。

在树中的

每一层次上

，两条路径各

自至多报告

一棵子树，故

累计不过O(logn)棵

。幸运的是，

根

据习题[5-11]的结

论，为枚举出

这些子树中

的点，对它们

的遍历累计

不超过O(r)的时

间，其

中r为实

际报告的点

数。

综合以上

分析，每次查

询都可在O(r + logn)时

间内完成。该

查询算法的

运行时间也

与输

出规模

相关，故同样

属于输出敏

感的算法。

新

算法的效率

尽管并不高

于基于有序

向量的算法

，却可以便捷

地推广至二

维甚至更高

维。

§8.4 *kd-树

第8章 高

级搜索树

242

8.4.2

kd-树

循着上一节

采用平衡二

叉搜索树实

现一维查询

的构思，可以

将待查询的

二维点集组

织为所谓

的

kd-树（kd-tree）⑥结构。在任

何的维度下

，kd-树都是一棵

递归定义的

平衡二叉搜

索树。

以下不

妨以二维情

况为例，就2d-树

的原理以及

构造和查询

算法做一介

绍。



节点及其

矩形区域

具

体地，2d-树中的

每个节点，都

对应于二维

平面上的某

一矩形区域

，且其边界都

与坐标轴

平

行。当然，有些

矩形的面积

可能无限。

图

8.39

2d-树中各节点

对应癿区域

，逐局递归地

按所包含癿

输入点数均

衡切分

后面

将会看到，同

层节点

各自

对应的矩形

区域，经合并

之

后恰好能

够覆盖整个

平面，同时

其

间又不得有

任何交叠。因

此，

不妨如图

8.39所示统一约

定，

每个矩形

区域的左边

和底边开

放

，右边和顶边

封闭。

 构造算

法

作为以上

条件的特例

，树根自然对

应于整个平

面。一般地如

图8.39所示，若P为

输入点集与

树中当前节

点所对应矩

形区域的交

集（即落在其

中的所有点

），则可递归地

将该矩形区

域切分为

两

个子矩形区

域，且各包含

P中的一半点

。

若当前节点

深度为偶（奇

）数，则沿垂直

（水平）方向切

分，所得子区

域随同包含

的输入点

分

别构成左、右

孩子。如此不

断，直至子区

域仅含单个

输入点。每次

切分都在中

位点（median 

point）按对应

的坐标排序

居中者处进

行，以保证全

树高度不超

过O(logn)。

具体地，2d-树

的整个构造

过程，可形式

化地递归描

述如算法8.1所

示。

1 KdTree* buildKdTree(P,

d) { //在深度为

d癿局次，极造

一棵对应亍

（子）集合P癿（子

）2d-树

2

if (P == {p})

return CreateLeaf(p); //逑弻基

3

root = CreateKdNode(); //创

建（子）树根

4 root->splitDirection = Even(d)

? VERTICAL : HORIZONTAL;

//确

定划分斱向

5 root->splitLine = FindMedian(root->splitDirection,

P); //确定中位点

6 (P1, P2)

= Divide(P, root->splitDirection, root->splitLine);

//子集划分

7 root->lc =

buildKdTree(P1, d + 1);

//在

深度为d + 1癿局

次，逑弻极造

左子树

8

root->rc = buildKdTree(P2, d

+ 1); //在深

度为d +

1癿局次

，逑弻极造右

子树

9 return root;

//迒回（子

）树根

10 }

算法8.1

极

造2d-树

 

⑥

由J. L. Bentley亍1975年

収明[46]，其名字

来源亍“k-dimensional tree”癿缩

写

适用亍仸

意指定维度

癿欧氏空间

，幵规具体癿

维度，相应地

分删称作2d-树

、3d-树、...，等

故上节

所介绍癿一

维平衡二叉

搜索树，也可

称作1d-树

第8章

高级搜索树

§8.4 *kd-树

243

 实例

以图

8.40(a)为例，首先创

建树根节点

，并指派以整

个平面以及

全部7个输入

点。

图8.40 2d-树癿极

造过秳，就是

对平面递归

划分癿过秳

第一轮切分

如图(b)所示。以

水平方向的

中位点C为界

，将整个平面

分作左、右两

半，点集P

也相

应地被划分

为子集{ A,

B, C, G }和{

D, E, F }，它

们随同对应

的半平面，被

分别指派

给

深度为1的两

个节点。

第二

轮切分如图

(c)所示。对于左

半平面及其

对应的子集

{ A, B,

C, G }，以垂直方向

的

中位点B为

界，将其分为

上、下两半，并

分别随同子

集{B,

G}和{A, C}，指派给

深度为2的一

对

节点；对于

右半平面及

其对应的子

集{ D,

E, F }，以垂直方

向的中位点

F为界，将其分

为上、

下两半

，并分别随同

子集{

E, F }和{ D

}，指派

给深度为2的

另一对节点

。

最后一轮切

分如图(d)所示

。对树中仍含

有至少两个

输入点的三

个深度为2的

节点，分别沿

其各自水平

方向的中位

点，将它们分

为左、右两半

，并随同对应

的子集分配

给三对深度

为3的节

点。至

此，所有叶节

点均只包含

单个输入点

，对平面的整

个划分过程

遂告完成，同

时与原输入

点

集P对应的

一棵2d-树也构

造完毕。

8.4.3 基于

2d-树的范围查

询

 过程

经过

如上预处理

，将待查询点

集P转化为一

棵2d-树之后，对

于任一矩形

查询区域R，范

围查

询的过

程均从树根

节点出发，按

如下方式递

归进行。因为

不致歧义，以

下叙述将不

再严格区分

2d-

树节点及其

对应的矩形

子区域和输

入点子集。

在

任一节点v处

，若子树v仅含

单个节点，则

意味着矩形

区域v中仅覆

盖单个输入

点，此时可

直

接判断该点

是否落在R内

。否则，不妨假

定矩形区域

v中包含多个

输入点。

此时

，视矩形区域

v与查询区域

R的相对位置

，无非三种情

况：

情况A：若矩

形区域v完全

包含于R内，则

其中所有的

输入点亦均

落在R内，于是

只需遍历一

趟子树v，即可

报告这部分

输入点。

情况

B：若二者相交

，则有必要分

别深入到v的

左、右子树中

，继续递归地

查询。

情况C：若

二者彼此分

离，则子集v中

的点不可能

落在R内，对应

的递归分支

至此即可终

止。

§8.4 *kd-树 第8章

高

级搜索树

244

 算

法

以上查询

过程，可递归

地描述如算

法8.2所示。

1 kdSearch(v, R)

{ //在以

v为根节点癿

(子)2d-树中，针对

矩形匙域R做

范围查诟

2 if

(isLeaf(v) //若

抵达叶节点

，则

3 {

if (inside(v, R)) report(v);

return; } //直接刞断

，幵终止逑弻

4

5

if (region(v->lc)  R)

//情冴A：若左子

树完全包含

亍R内，则直接

遍历

6 reportSubtree(v->lc);

7

else if (region(v->lc 

R  ) //情冴B：若

左子树对应

癿矩形不R相

交，则逑弻查

诟

8 kdSearch(v->lc, R);

9

10 if (region(v->rc) 

R) //情冴A：若右

子树完全包

含亍R内，则直

接遍历

11 reportSubtree(v->rc);

12 else if (region(v->rc

 R  )

//情冴

B：若右子树对

应癿矩形不

R相交，则逑弻

查诟

13 kdSearch(v->rc, R);

14 }

算法8.2 基

二2d-树癿平面

范围查询

可

见，递归只发

生于情况B；对

于其余两种

情况，递归都

会随即终止

。特别地，情况

C只需

直接返

回，故在算法

中并无与之

对应的显式

语句。

 实例

考

查 图 8.41 中

的 2d- 树

，设采用

kdSearch()算法

，对阴影区域

进行查询。

不

难验证，递归

调用仅发生

于黑色节

点

（情况B）；而在灰

色节点处，并

未发生

递归

调用（情况C或

父节点属情

况A）。

命中的节

点共分两组

：{

C }作为叶

节点

经直接判断

后确定；{ F,

H }则因

其

所对应区

域完全包含

于查询区域

内部（情

况A），经

遍历悉数输

出（习题[8-17]）。

 正确

性

由上可见

，凡被忽略的

子树，其对应

的矩形区域

均完全落在

查询区域之

外，故

该算法

不致漏报。反

之，凡被报告

的子树，

其对

应的矩形区

域均完全包

含在查询区

域

以内（且互

不相交），故亦

不致误报。

图

8.41 基二2d-树癿平

面范围查询

（A～J共计10个输入

点；命中子树

癿根节点，以

双线囿圀示

意）

 复杂度

平

面范围查询

与一维情况

不同，在同一

深度上可能

递归两次以

上，并报告出

多于两棵子

树。

但更精细

的分析（习题

[8-16]）表明，被报告

的子树总共

不超过O(

n)棵，累

计耗时O( n)。

第9章

词典

第9章

词

典

246

借助数据

结构来表示

和组织的数

字信息，可将

所有数据视

作一个整体

统筹处理，进

而提高信

息

访问的规范

性及其处理

的效率。例如

，借助关键码

直接查找和

访问数据元

素的形式，已

为越来

越多

的数据结构

所采用，这也

成为现代数

据结构的一

个重要特征

。

词典（dictionary）结构，即

是其中最典

型的例子。逻

辑上的词典

，是由一组数

据构成的

集

合，其中各元

素都是由关

键码和数据

项合成的词

条（entry）。映射（map）结构

与词典结构

一样，也是词

条的集合。二

者的差别仅

仅在于，映射

要求不同词

条的关键码

互异，而词典

则允许

多个

词条拥有相

同的关键码

①。除了静态查

找，映射和词

典都支持动

态更新，二者

统称作符号

表

（symbol table）。实际上，“是

否允许雷同

关键码”应从

语义层面，而

非ADT接口的层

面予

以界定

，故本章将不

再过分强调

二者的差异

，而是笼统地

称作词典，并

以跳转表和

散列表为例

，

按照“允许雷

同”和“禁止雷

同”的语义，分

别实现其统

一的接口。

尽

管此处词典

和映射中的

数据元素，仍

表示和实现

为词条形式

，但这一做法

并非必须。与

第

7章和第8章

的搜索树相

比，符号表并

不要求词条

之间能够根

据关键码比

较大小；与稍

后第10章

的优

先级队列相

比，其查找对

象亦不仅限

于最大或最

小的词条。在

符号表的内

部，甚至也不

需要

按照大

小次序来组

织数据项即

便各数据项

之间的确定

义有某种次

序。实际上，以

散列表为代

表的符号表

结构，将转而

依据数据项

的数值，直接

做逻辑查找

和物理定位

。也就是说，对

于此类

结构

，在作为基本

数据单位的

词条内部，关

键码（key）与数值

（value）的地位等同

，二者不

必加

以区分。此类

结构所支持

的这种新的

数据访问方

式，即所谓的

循值访问（call-by-value）。

相

对于此前各

种方式，这一

方式更为自

然，适用范围

也更广泛。

有

趣的是，对这

种“新的”数据

访问方式，在

程序设计方

面已有一定

基础的读者

，往往会或

多

或少地有些

抵触的倾向

；而刚刚涉足

这一领域的

读者，却反过

来会有似曾

相识的亲切

之感，并

更乐

于接受。究其

原因在于，循

值访问方式

与我们头脑

中原本对数

据集合组成

的理解最为

接近；

不幸的

是，在学习C/C++之

类高级程序

语言的过程

中，我们思考

问题的出发

点和方向都

已逐步被

这

些语言所同

化并强化，而

一些与生俱

来的直觉与

思路则逐渐

为我们所淡

忘。比如，在孩

子们的

头脑

中，班级的概

念只不过是

同伴们的一

组笑脸；随着

学习内容的

持续深入和

思维方式的

反复塑

化，这

一概念将逐

渐被一组姓

名所取代；甚

至可能进而

被抽象为一

组学号。

既已

抛开大小次

序的概念，采

用循值访问

方式的计算

过程，自然不

再属于CBA式算

法的范畴，

此

前关于CBA式算

法下界的结

论亦不再适

用，比如在9.4节

我们将看到

，散列式排序

算法将不再

服从2.7节所给

的复杂度下

界。一条通往

高效算法的

崭新大道，由

此在我们面

前豁然展开

。

当然，为支持

循值访问的

方式，在符号

表的内部，仍

然必须强制

地在数据对

象的数值与

其物

理地址

之间建立某

种关联。而所

谓散列，正是

在兼顾空间

与时间效率

的前提下，讨

论和研究赖

以

设计并实

现这种关联

的一般性原

则、技巧与方

法，这些方面

也是本章的

核心与重点

。

① 事实上，某些

文献中所定

丿癿词典和

映射结极，可

能不此约定

恰好相反

第

9章 词典

§9.1 词典

ADT

247

§9.1

词典ADT

9.1.1 操作接

口

除通用的

接口之外，词

典结构主要

的操作接口

可归纳为表

9.1。

表9.1 词典ADT支持

癿标准操作

接口

操 作

接

口 功 能 描

述

get(key) 若词典中存

在以key为兲键

码癿词条，则

迒回诠词条

癿数据对象

；否则，迒回NULL

put(key, value)

揑

入词条(key, value)，幵报

告是否成功

remove(key) 若词典中存

在以key为兲键

码癿词条，则

初除乀幵迒

回true；否则，迒回

false

实际上，包括

Snobol4、MUMPS、SETL、Rexx、Awk、Perl、Ruby、PHP、Java和Python

等在内，许

多编程语言

都以各自不

同形式，支持

类似于以上

词典或映射

ADT接口功能的

基本数据

结

构，有的甚至

将它们作为

基本的数据

类型，统称作

关联数组（associative array）。

9.1.2

操

作实例

比如

，可如图9.1所示

，

将三国名将

所对应的词

条

组织为一

个词典结构

。其中

的每一

词条，都由人

物的字

（style）和姓

名（name）

构成，分别

作为词条的

关键

码和数

据项。

图9.1 三国

人物癿词典

结极

以初始

包含关、张、马

、黄四将的词

典为例，在依

次执行一系

列操作的过

程中，该词典

结构

内容的

变化以及对

应的输出如

表9.2所示。

表9.2 词

典结极操作

实例

操 作

词

典 结 极 输

出

size()

("Yunchang", "Yu GUAN")

("Yide", "Fei ZHANG")

("Mengqi",

"Chao MA")

("Hansheng", "Zhong

HUANG")

4

put("Bofu", "Ce

SUN")

("Yunchang", "Yu GUAN")

("Yide", "Fei ZHANG")

("Mengqi",

"Chao MA")

("Hansheng", "Zhong

HUANG")

("Bofu", "Ce SUN")

true

size() [unchanged] 5

get("Yide") [unchanged] "Fei ZHANG"

get("Zilong") [unchanged] NULL

§9.1

词典ADT 第9章 词

典

248

表9.2 词典结

极操作实例

（续）

操 作

词 典

结 极 输

出

put("Yide", "Fei CHANG")

("Yunchang", "Yu GUAN")

("Yide",

"Fei CHANG")

("Mengqi", "Chao

MA")

("Hansheng", "Zhong HUANG")

("Bofu", "Ce SUN")

true

size() [unchanged] 5

get("Yide")

[unchanged] "Fei CHANG"

remove("Mengqi")

("Yunchang", "Yu GUAN")

("Yide",

"Fei CHANG")

("Hansheng", "Zhong

HUANG")

("Bofu", "Ce SUN")

"Chao MA"

size() [unchanged]

4

请

特别留意以

上第二次put()操

作，其拟插入

词条的关键

码"Yide"，在该词典

中已经存在

。

由该实例可

见，插入效果

等同于用新

词条替换已

有词条；相应

地，put()操作也必

然会成功。这

一处理方式

被包括Python和Perl在

内的众多编

程语言普遍

采用，但本章

采用的约定

与此略有不

同。跳转表将

允许同时保

留多个关键

码雷同的词

条，查找时任

意返回其一

；散列表则维

持原词条

不

变，返回插入

失败标志也

就是说，更接

近于映射的

规范。

9.1.3 接口定

义

这里首先

以如代码9.1所

示模板类的

形式定义词

典的操作接

口。

1

template <typename K, typename

V> struct Dictionary {

//词典Dictionary模板

类

2 virtual int

size() const = 0;

//弼前词条

总数

3 virtual bool

put ( K, V

) = 0; //揑入词

条（禁止雷同

词条时可能

失败）

4 virtual V* get

( K k )

= 0; //读叏词

条

5

virtual bool remove (

K k ) =

0; //初除词条

6 };

代码9.1

词典结

极癿操作接

口觃范

其中

，所有操作接

口均以虚函

数形式给出

，留待在派生

类中予以具

体实现。

另外

，正如此前所

述，尽管词条

关键码类型

可能支持大

小比较，但这

并非词典结

构的必要条

件，Dictionary模板类中

的Entry类只需支

持判等操作

。

9.1.4

实现方法

不

难发现，基于

此前介绍的

任何一种平

衡二叉搜索

树，都可便捷

地实现词典

结构。比如，Java

语

言的java.util.TreeMap类即是

基于红黑树

实现的词典

结构。然而这

类实现方式

都在不经意

中假设“关键

码可以比较

大小”，故其所

实现的并非

严格意义上

的词典结构

。

以下以跳转

表和散列表

为例介绍词

典结构的两

种实现方法

。尽管它们都

在底层引入

了某种

“序”，但

这类“序”只是

内部的一种

约定；从外部

接口来看，依

然只有“相等

”的概念。

第9章

词典 §9.2 *跳转表

249

§9.2 

*跳转表

第2章

所介绍的有

序向量和第

3章所介绍的

有序列表，各

有所长：前者

便于静态查

找，但动

态维

护成本较高

；后者便于增

量式的动态

维护，但只能

支持顺序查

找。为结合二

者的优点，同

时

弥补其不

足，第7章和第

8章逐步引入

了平衡二叉

搜索树，其查

找、插入和删

除操作均可

在O(logn)

时间内完

成。尽管如此

，这些结构的

相关算法往

往较为复杂

，代码实现和

调试的难度

较大，其正

确

性、鲁棒性和

可维护性也

很难保证。

设

计并引入跳

转表②（skip list）结构的

初衷，正是在

于试图找到

另外一种简

便直观的方

式，来完成这

一任务。具体

地，跳转表是

一种高效的

词典结构，它

的定义与实

现完全基于

第3章

的有序

列表结构，其

查询和维护

操作在平均

的意义下均

仅需O(logn)时间。

9.2.1

Skiplist模

板类

跳转表

结构以模板

类形式定义

的接口，如代

码9.2所示。

1 #include

"../List/List.h" //引入

列表

2 #include

"../Entry/Entry.h" //引入词

条

3 #include

"Quadlist.h" //引入Quadlist

4 #include

"../Dictionary/Dictionary.h" //引入

词典

5

6

template <typename K, typename

V> //key、value

7 //符合Dictionary接

口癿Skiplist模板类

（但隐含假讴

元素乀间可

比较大小）

8 class Skiplist :

public Dictionary<K, V>, public

List<Quadlist<Entry<K, V>>*> {

9

protected:

10 bool skipSearch

(

11 ListNode<Quadlist<Entry<K, V>>*>*

&qlist,

12 QuadlistNode<Entry<K, V>>*

&p,

13 K& k

);

14 public:

15

int size() const {

return empty() ? 0

: last()->data->size(); } //底

局Quadlist癿觃模

16 int level() {

return List::size(); } //局

高

== #Quadlist，丌一定要

开放

17 bool

put ( K, V

); //揑入（注

意不Map有删——Skiplist允

讲词条重复

，故必然成功

）

18 V*

get ( K k

); //读叏

19 bool

remove ( K k

); //初除

20 };

代

码9.2 Skiplist模板类

可

见，借助多重

继承（multiple inheritance）机制，由

Dictionary和List共同派生

而

得的Skiplist模板

类，同时具有

这两种结构

的特性；此外

，这里还重写

了在Dictionary抽象类

（代码9.1）中，以虚

函数形式定

义的get()、put()和remove()等接

口。

 

②

由W. Pugh亍1989年収

明[52]

§9.2 *跳转表

第

9章 词典

250

9.2.2

总体

逻辑结构

跳

转表的宏观

逻辑结构如

图9.2所示。其内

部由沿横向

分层、沿纵向

相互耦合的

多个列表{ S0,

S1, S2, ..., Sh

}组

成，h称作跳转

表的高度。

图

9.2 跳转表癿总

体逡辑结极

每一水平列

表称作一层

（level），其中S0和Sh分别

称作底层（bottom）和

顶层（top）。

与通常

的列表一样

，同层节点之

间可定义前

驱与后继关

系。为便于查

找，同层节点

都按关键码

排

序。需再次

强调的是，这

里的次序只

是内部的一

种约定；对外

部而言，各词

条之间仍然

只需支持

判

等操作即可

。为简化算法

实现，每层列

表都设有头

、尾哨兵节点

。

层次不同的

节点可能沿

纵向组成塔

（tower），同一塔内的

节点以高度

为序也可定

义前驱与

后

继关系。塔与

词典中的词

条一一对应

。尽管塔内的

节点相互重

复，但正如随

后将要看到

的，这

种重复

不仅可以加

速查找，而且

只要策略得

当，也不至造

成空间的实

质浪费。

高层

列表总是低

层列表的子

集，其中特别

地，S0包含词典

中的所有词

条，而Sh除头、尾

哨兵

外不含

任何实质的

词条。不难看

出，跳转表的

层高h必然决

定于最大的

塔高。

9.2.3

四联表

按上述约定

，跳转表内各

节点沿水平

和垂直方向

都可定义前

驱和后继，支

持这种联接

方式的

表称

作四联表（quadlist），它

也是代码9.2中

Skiplist模板类的底

层实现方式

。

 Quadlist模板类

四联

表结构可如

代码9.3所示，以

模板类的形

式定义接口

。

1 #include "QuadlistNode.h"

//引入Quadlist节点类

2 template <typename T>

class Quadlist { //Quadlist模板类

3 private:

4 int

_size; QlistNodePosi(T) header; QlistNodePosi(T)

trailer; //觃模

、头哨兵、尾哨

兵

5 protected:

6 void init(); //Quadlist创建时癿

刜始化

7 int clear(); //清除

所有节点

8 public:

9 //

极

造函数

10 Quadlist() {

init(); } //默讣

11 //

枂极函数

12 ~Quadlist() {

clear(); delete header; delete

trailer; } //初

除所有节点

，释放哨兵

13

// 叧

读讵问接口

第9章 词典 §9.2

*跳

转表

251

14 Rank

size() const { return

_size; } //觃模

15

bool empty() const {

return _size <= 0;

} //刞

空

16 QlistNodePosi(T)

first() const { return

header->succ; } //首节点位

置

17

QlistNodePosi(T) last() const {

return trailer->pred; } //末节点位

置

18 bool valid (

QlistNodePosi(T) p ) //刞断位置

p是否对外合

法

19 { return p

&& ( trailer !=

p ) && (

header != p );

}

20 // 可写讵问

接口

21 T remove (

QlistNodePosi(T) p ); //初除（合

法）位置p处癿

节点，迒回被

初除节点癿

数值

22 QlistNodePosi(T) //将*e作为

p癿后继、b癿上

邻揑入

23

insertAfterAbove ( T const&

e, QlistNodePosi(T) p, QlistNodePosi(T)

b = NULL );

24 // 遍历

25 void

traverse ( void (*

) ( T& )

); //遍历各节点

，依次实斲指

定操作（函数

指针，叧读戒

尿部修改）

26 template

<typename VST> //操

作器

27

void traverse ( VST&

); //遍历各

节点，依次实

斲指定操作

（函数对象，可

全尿性修改

节点）

28 };

//Quadlist

代码9.3 Quadlist模

板类

此处定

义的接口包

括：定位首节

点、末节点，在

全表或某一

区间查找具

有特定关键

码的节点，

删

除特定节点

，以及插入特

定节点。通过

它们的相互

组合，即可实

现跳转表相

应的接口功

能。

 四联表节

点

作为四联

表的基本组

成元素，节点

QuadlistNode模板类可定

义如代码9.4所

示。

1 #include "../Entry/Entry.h"

2

#define QlistNodePosi(T) QuadlistNode<T>* //跳转表节

点位置

3

4 template <typename

T> struct QuadlistNode {

//QuadlistNode模板

类

5 T entry;

//所存词条

6 QlistNodePosi(T) pred; QlistNodePosi(T)

succ; //前驱、后继

7 QlistNodePosi(T)

above; QlistNodePosi(T) below; //上

邻、下邻

8 QuadlistNode //极造

器

9

( T e =

T(), QlistNodePosi(T) p =

NULL, QlistNodePosi(T) s =

NULL,

10 QlistNodePosi(T) a

= NULL, QlistNodePosi(T) b

= NULL )

11

: entry ( e

), pred ( p

), succ ( s

), above ( a

), below ( b

) {}

12 QlistNodePosi(T)

insertAsSuccAbove //揑入新节

点，以弼前节

点为前驱，以

节点b为下邻

13 ( T

const& e, QlistNodePosi(T) b

= NULL );

14

};

代码9.4 QuadlistNode模板类

为简化起见

，这里并未做

严格封装。对

应于水平的

前驱与后继

，这里为每个

节点设置了

一对

指针pred和

succ；垂直方向的

上邻和下邻

则对应于above和

below。主要的操作

接口只有

insertAsSuccAbove()，它

负责创建新

节点，并将其

插入于当前

节点之后、节

点b之上。

§9.2 *跳转

表 第9章

词典

252

 初始化与构

造

由代码9.3可

见，四联表的

构造，实际上

是通过调用

如下init()函数完

成的。

1 template <typename T>

void Quadlist<T>::init() { //Quadlist刜始化

，创建Quadlist对象时

统一调用

2 header = new

QuadlistNode<T>; //创

建头哨兵节

点

3 trailer

= new QuadlistNode<T>; //创建尾哨

兵节点

4 header->succ = trailer;

header->pred = NULL; //沿横

向联接哨兵

5

trailer->pred = header; trailer->succ

= NULL; //沿横向联接

哨兵

6

header->above = trailer->above =

NULL; //纵向癿

后继置空

7 header->below

= trailer->below = NULL;

//纵

向癿前驱置

空

8 _size =

0; //记弽觃模

9 } //如此极造癿

四联表，丌含

仸何实质癿

节点，且暂时

不其它四联

表相互独立

代码9.5

Quadlist对象癿

创建

9.2.4 查找

查

找是跳转表

至关重要和

最实质的操

作，词条的插

入和删除等

其它操作均

以之为基础

，其实

现效率

也将直接影

响到跳转表

结构的整体

性能。

 get()

在跳转

表中查找关

键码k的具体

过程，如代码

9.6所示。

1 template <typename K,

typename V> V* Skiplist<K,

V>::get ( K k

) { //跳转表

词条查找算

法

2

if ( empty() )

return NULL;

3 ListNode<Quadlist<Entry<K,

V>>*>* qlist = first();

//从顶局Quadlist癿

4 QuadlistNode<Entry<K, V>>* p

= qlist->data->first(); //首节点开始

5 return

skipSearch ( qlist, p,

k ) ? &

( p->entry.value ) :

NULL; //查找幵报告

6 } //有夗个命中

时靠后者优

先

代码9.6 Skiplist::get()查找

 skipSearch()

由上可见，实

质的查找过

程，只不过是

从某层列表

qlist的首节点first()出

发，调用如代

码9.7所示的内

部函数skipSearch()。

1 /******************************************************************************************

2 *

Skiplist词条

查找算法（供

内部调用）

3 * 入

口：qlist为顶局列

表，p为qlist癿首节

点

4 * 出口：若成

功，p为命中兲

键码所属塔

癿顶部节点

，qlist为p所属列表

5 *

否则，p为所属

塔癿基座，诠

塔对应亍丌

大亍k癿最大

且最靠右兲

键码，qlist为空

6 * 约

定：夗个词条

命中时，沿四

联表叏最靠

后者

7 ******************************************************************************************/

8 template

<typename K, typename V>

bool Skiplist<K, V>::skipSearch (

9 ListNode<Quadlist<Entry<K, V>>*>* &qlist,

//从指定

局qlist癿

10 QuadlistNode<Entry<K, V>>*

&p, //首节点

p出収

11 K&

k ) { //向右、向

下查找目标

兲键码k

第9章

词典 §9.2 *跳转表

253

12

while ( true )

{ //在殏一局

13 while

( p->succ && (

p->entry.key <= k )

) //从

前向后查找

14 p =

p->succ; //直刡出现更

大癿key戒溢出

至trailer

15 p

= p->pred; //此时倒回

一步，即可刞

断是否

16

if ( p->pred &&

( k == p->entry.key

) ) return true;

//命中

17 qlist = qlist->succ;

//否则转入下

一局

18 if (

!qlist->succ ) return false;

//若已刡

穿透底局，则

意味着失败

19 p = (

p->pred ) ? p->below

: qlist->data->first(); //否则转至弼

前塔癿下一

节点

20

} //诼后：通

过实验统计

，验证兲亍平

均查找长度

癿结讳

21 }

代码

9.7 Skiplist::skipSearch()查找

这里利

用参数p和qlist，分

别指示命中

关键码所属

塔的顶部节

点，及其所属

的列表。qlist

和p的

初始值分别

为顶层列表

及其首节点

，返回后它们

将为上层的

查找操作提

供必要的信

息。

 实例

仍以

图9.2为例，针对

关键码21的查

找经过节点

{ -,

-, 8, 8, 8,

8, 13 }，最终抵

达21后

报告成功；针

对关键码34的

查找经过节

点{

-, -, 8, 8

}，最终抵达

34后报告成功

；

针对关键码

1的查找经过

节点{ -, -,

-, -, - }，最终抵

达1后报告成

功。而针对关

键

码80的查找

经过节点{ -, -, 8,

8, 34, 34, 34,

55 }，最

终抵达89后报

告失败；针对

关

键码0的查

找经过节点

{ -,

-, -, -, -

}，最终抵达1后

报告失败；针

对关键码99的

查

找经过节

点{ -, -,

8, 8, 34, 34,

89 }，最终抵达

+后报告失败

。

9.2.5 空间复杂度



“生长概率逐

层减半”条件

不难理解，其

中各塔高度

的随机分布

规律（如最大

值、平均值等

），对跳转表的

总体性能至

关重要。反之

，若不就此作

出显式的限

定，则跳转表

的时间和空

间效率都难

以保证。

比如

，若将最大塔

高（亦即跳转

表的层高）记

作h，则在极端

情况下，每个

词条所对应

塔的

高度均

有可能接近

甚至达到h。果

真如此，在查

找及更新过

程中需要访

问的节点数

量将难以控

制，

时间效率

注定会十分

低下。同时，若

词条总数为

n，则在此类情

况下，跳转表

所需的存储

空间量

也将

高达(nh)。

然而幸

运的是，若能

采用简明而

精妙的策略

，控制跳转表

的生长过程

，则在时间和

空间方面

都

可实现足够

高的效率。就

效果而言，此

类控制策略

必须满足所

谓“生长概率

逐层减半”条

件：

对于任意

0

 k < h，Sk中任一节点

在Sk+1中依然出

现的概率，始

终为1/2

也就是

说，S0中任一关

键码依然在

Sk中出现的概

率，等于2

-k。这也

可等效地理

解和模拟为

，

在各塔自底

而上逐层生

长的过程中

，通过投掷正

反面等概率

的理想硬币

（fair coin），来决定

是否

继续增长一

层亦即，对应

于当前的词

条，是否在上

一层列表中

再插入一个

节点。

那么，在

插入词条的

过程中，应该

如何从技术

上保证这一

条件始终成

立呢？具体的

方法稍后

将

在9.2.7节介绍，目

前不妨暂且

假定这一条

件的确成立

。

§9.2

*跳转表 第9章

词典

254



节点总

数的期望值

根据数学归

纳法，“生长概

率逐层减半

”条件同时也

意味着，列表

S0中任一节点

在列表Sk

中依

然出现的概

率均为1/2k

= 2-k。因此

，第k层列表所

含节点的期

望数目为：

E(|Sk|) = n 

2

-k

亦

即，各层列表

的规模将随

高度上升以

50%的比率迅速

缩小，故空间

总体消耗量

的期望值应

为：

E(k|Sk|)

= kE(|Sk|) = n

 (k2

-k

)

< 2n = O(n)

9.2.6 时间复杂

度

在由多层

四联表组成

的跳转表中

进行查找，需

访问的节点

数目是否会

实质性地增

加？由以上

代

码9.7中查找算

法skipSearch()可见，单次

纵向或横向

跳转本身只

需常数时间

，故查找所需

的时间应取

决于横向、纵

向跳转的总

次数。那么，是

否会因层次

过多而导致

横向或纵向

的跳转过

多

呢？以下从概

率的角度，分

别对其平均

性能做出估

计，并说明其

期望值均不

超过O(logn)。

 期望高

度与纵向跳

转次数

考查

第k层列表Sk。

Sk非

空，当且仅当

S0所含的n个节

点中，至少有

一个会出现

在Sk中，相应的

概率应为：

Pr(|Sk| > 0)

 n  2

-k

= n/2k

反

过来，Sk为空的

概率即为：

Pr(|Sk| = 0) 

1 - n/2k

可

以看出，这一

概率将随着

高度k的增加

，而迅速上升

并接近100%。

以第

k = 3∙logn层为例。该层

列表Sk为空，当

且仅当h <

k，对应

的概率为：

Pr(h < k)

= Pr(|Sk| = 0)

 1 - n/2k

= 1 - n/n3

= 1 - 1/n2

一

般地，k = a∙logn层列表

为空的概率

为1 -

1/na-1，a > 3后这一概

率将迅速地

接近100%。

这意味

着跳转表的

高度h有极大

的可能不会

超过

3∙logn，h的期望

值应为：

E(h) = O(logn)

按照

代码9.7的skipSearch()算法

，查找过程中

的跳转只能

向右或向下

（而不能向左

倒退

或向上

爬升），故活跃

节点的高度

必单调非增

，每一高度上

的纵向跳转

至多一次。因

此，整个查

找

过程中消耗

于纵向跳转

的期望时间

不超过跳转

表高度h的期

望值O(logn)。



横向跳

转

skipSearch()算法中的

内循环对应

于沿同一列

表的横向跳

转，且此类跳

转在同一高

度可做

多次

。那么，横向跳

转与上述纵

向跳转的这

一差异，是否

意味着这方

面的时间消

耗将不受跳

转表

高度h的

控制，并进而

对整体的查

找时间产生

实质性影响

？答案是否定

的。

进一步观

察skipSearch()算法可知

，沿同一列表

的横向跳转

所经过的节

点必然依次

紧邻，

而且它

们都应该是

各自所属塔

的塔顶。若将

同层连续横

向跳转的次

数记作Y，则对

于任意的0  k，

Y取

值为k对应于

“k个塔顶再加

最后一个非

塔顶”联合事

件，故其概率

应为：

Pr(Y = k)

= (1 - p)k

∙p

这是一

个典型的几

何分布（geometric distribution），其中

p =

1/2是塔继续生

长的概率。

因

此，Y的期望值

应为：

E(Y) =

(1 - p) /

p = (1 -

1/2) / (1/2) =

1

第9章 词

典 §9.2

*跳转表

255

也

就是说，在同

一高度上，彼

此紧邻的塔

顶节点数目

的期望值为

1 +

1 = 2；沿着每条查

找

路径，在每

一高度上平

均只做常数

次横向跳转

。因此，整个查

找过程中所

做横向跳转

的期望次数

，

应依然线性

正比于跳转

表的期望高

度，亦即O(logn)。

 其它

除以上纵向

和横向跳转

，skipSearch()还涉及其它

一些操作，但

总量亦不超

过O(logn)。

比如，内层

while循环尽管必

终止于失败

节点（key更大或

溢出至trailer），但此

类节点在每

层至多一个

，访问它们所

需的时间总

量仍不超过

跳转表的期

望高度E(h)

= O(logn)。

9.2.7 插入



put()

将词条(k, v)插入

跳转表的具

体操作过程

，可描述和实

现如代码9.8所

示。

1

template <typename K, typename

V> bool Skiplist<K, V>::put

( K k, V

v ) { //跳转表词

条揑入算法

2

Entry<K, V> e =

Entry<K, V> ( k,

v ); //待揑入癿词

条（将被随机

地揑入夗个

副本）

3

if ( empty() )

insertAsFirst ( new Quadlist<Entry<K,

V>> ); //揑入首

个Entry

4

ListNode<Quadlist<Entry<K, V>>*>* qlist =

first(); //从顶局四

联表癿

5 QuadlistNode<Entry<K,

V>>* p = qlist->data->first();

//首节

点出収

6 if (

skipSearch ( qlist, p,

k ) ) //查找

适弼癿揑入

位置（丌大亍

兲键码k癿最

后一个节点

p）

7 while ( p->below

) p = p->below;

//若已有雷同

词条，则需强

刢转刡塔底

8 qlist = last();

//以下，紧邻亍

p癿右侧，一座

新塔将自底

而上逐局生

长

9 QuadlistNode<Entry<K, V>>*

b = qlist->data->insertAfterAbove (

e, p ); //新节点b即

新塔基座

10 while ( rand()

& 1 ) {

//经

投掷硬币，若

确定新塔需

要再长高一

局，则

11 while (

qlist->data->valid ( p )

&& !p->above ) p

= p->pred; //找出丌

低亍此高度

癿最近前驱

12 if

( !qlist->data->valid ( p

) ) { //若诠前驱是

header

13 if ( qlist

== first() ) //且弼前已是

最顶局，则意

味着必须

14 insertAsFirst ( new

Quadlist<Entry<K, V>> ); //首

先创建新癿

一局，然后

15 p = qlist->pred->data->first()->pred;

//将

p转至上一局

Skiplist癿header

16 } else

//否则，可径

自

17 p =

p->above; //将p提升至

诠高度

18 qlist

= qlist->pred; //上升

一局，幵在诠

局

19

b = qlist->data->insertAfterAbove (

e, p, b );

//将新节点

揑入p乀后、b乀

上

20 }//诼后：调整

随机参数，观

察总体局高

癿相应发化

21 return

true; //Dictionary允讲重复元

素，故揑入必

成功——返不Hashtable等

Map略有差异

22 }

代

码9.8 Skiplist::put()揑入

这里

通过逻辑表

达式“rand() %

2”来模拟

投掷硬币，并

保证“生长概

率逐层减半

”条件。

也就是

说，通过（伪）随

机整数的奇

偶，近似地模

拟一次理想

的掷硬币实

验。只要（伪）随

机数

为奇数

（等价于掷出

硬币正面），新

塔就继续生

长；一旦取（伪

）随机数为偶

数（等价于掷

出反

面），循环

随即终止（生

长停止），整个

插入操作亦

告完成。

由此

可见，新塔最

终的（期望）高

度，将取决于

此前连续的

正面硬币事

件的（期望）次

数。

§9.2 *跳转表 第

9章

词典

256

 实例

考查如图9.2所

示的跳转表

。将关键码4插

入其中的过

程，如图9.3(a~d)所示

。

首先如图(a)所

示，经过查找

确定，应紧邻

于关键码3右

侧实施插入

。

然后如图(b)所

示，在底层列

表中，创建一

个节点作为

新塔的基座

。

此后，假定随

后掷硬币的

过程中，前两

次为正面，第

三次为反面

。于是如图(c)和

(d)所示，

新塔将

连续长高两

层后停止生

长。

图9.3 跳转表

节点揑入过

秳(a~d)，也是节点

初除癿逆过

秳(d~a)

新塔每长

高一层，塔顶

节点除须与

原塔纵向联

接，还须与所

在列表中的

前驱与后继

横向联接。



insertAfterAbove()

可

见，QuadlistNode节点总是

以塔为单位

自底而上地

成批插入，且

每一节点都

是作为当时

的新塔顶而

插入。也就是

说，QuadlistNode节点的插

入都属于同

一固定的模

式：创建关键

码为e

的新节

点，将其作为

节点p的后继

和节点b（当前

塔顶）的上邻

“植入”跳转表

。

因此，代码9.3只

需提供统一

的接口insertAfterAbove()，其具

体实现如代

码9.9所示。

第9章

词典 §9.2 *跳转表

257

1

template <typename T> QlistNodePosi(T)

//将e作为p癿后

继、b癿上邻揑

入Quadlist

2 Quadlist<T>::insertAfterAbove (

T const& e, QlistNodePosi(T)

p, QlistNodePosi(T) b =

NULL )

3 {

_size++; return p->insertAsSuccAbove (

e, b ); }

//迒回新节

点位置（below = NULL）

代码

9.9

Quadlist::insertAfterAbove()揑入

 insertAsSuccAbove()

上述接

口的实现，需

转而调用节

点p的insertAsSuccAbove()接口，如

代码9.10所示完

成

节点插入

的一系列实

质性操作。

1 template <typename

T> QlistNodePosi(T) //将

e作为弼前节

点癿后继、b癿

上邻揑入Quadlist

2

QuadlistNode<T>::insertAsSuccAbove ( T const&

e, QlistNodePosi(T) b =

NULL ) {

3

QlistNodePosi(T) x = new

QuadlistNode<T> ( e, this,

succ, NULL, b );

//创

建新节点

4 succ->pred =

x; succ = x;

//讴

置水平逆向

链接

5 if (

b ) b->above =

x; //讴置垂

直逆向链接

6 return x;

//迒回新节点

癿位置

7 }

代码

9.10

QuadlistNode::insertAsSuccAbove()揑入

具体过

程如图9.4(a)所示

，插入前节点

b的上邻总是

为空。

图9.4 四联

表节点揑入

过秳

首先，创

建一个关键

码为e

的节点

，其前驱和后

继分别设为

当 前 节

点 （ p ）

及

其 后 继

（p->succ），上邻

和下邻分别

设为NULL和节点

b。然后，沿水

平

和垂直方向

设置好逆向

的链

接。最终

结果如图(b)所

示。

因这里允

许关键码雷

同，故在插入

之前无需查

找确认是否

已有某个词

条的关键码

为e。



时间复杂

度

新塔每长

高一层，都要

紧邻于该层

的某一节点

p之后创建新

的塔顶节点

。准确地，在不

大于

新关键

码的所有节

点中，节点p为

最大者；若这

样的节点有

多个，则按约

定，p应取其中

最靠后者。

然

而，若在每一

层都从首节

点开始，通过

扫描确认p的

位置，则最坏

情况下可能

每一层四联

表都

几乎需

要遍历，耗时

量将高达(n)。然

而实际上，各

层四联表中

的位置p之间

自底而上存

在很强

的关

联性，利用这

一性质即可

保证高效而

精准地确定

各高度上的

插入位置p。

具

体地如代码

9.8所示，每次都

从当前节点

p的前驱出发

，先上升一层

，然后自右向

左依次

移动

，直到发现新

节点在新高

度上的前驱

。接下来，只需

将p更新为该

前驱的位置

，并将新塔顶

节点插入于

p之后，新塔顶

节点的插入

即告完成。实

际上，新塔每

增长一层，都

可重复上述

过程

完成新

塔顶节点的

插入。

整个过

程中p所经过

的路径，与关

键码的查找

路径恰好方

向相反。由9.2.6节

的结论，被访

问节点的期

望总数不超

过O(logn)，因此这也

是插入算法

运行时间期

望值的上界

。

§9.2 *跳转表

第9章

词典

258

9.2.8 删除

 Skiplist::remove()

从

跳转表中删

除关键码为

k词条的具体

操作过程，如

描述为代码

9.11。

1

template <typename K, typename

V> bool Skiplist<K, V>::remove

( K k )

{ //跳转表词条

初除算法

2 if

( empty() ) return

false; //空

表情冴

3 ListNode<Quadlist<Entry<K,

V>>*>* qlist = first();

//从顶

局Quadlist癿

4 QuadlistNode<Entry<K, V>>*

p = qlist->data->first(); //首节点

开始

5 if ( !skipSearch

( qlist, p, k

) ) return false;

//目标词

条丌存在，直

接迒回

6 do {

//若目

标词条存在

，则逐局拆除

不乀对应癿

塔

7 QuadlistNode<Entry<K, V>>*

lower = p->below; //记住下一

局节点，幵

8 qlist->data->remove ( p

); //初

除弼前局节

点，再

9 p

= lower; qlist =

qlist->succ; //转入下

一局

10 }

while ( qlist->succ );

//如上丌

断重复，直刡

塔基

11 while (

!empty() && first()->data->empty() )

//逐一地

12 List::remove ( first()

); //清除已可能

丌含词条癿

顶局Quadlist

13 return

true; //初除操

作成功完成

14 }

代码9.11

Skiplist::remove()初除

这

一过程的次

序，与插入恰

好相反。以如

图9.3(d)所示的跳

转表为例，若

欲从其中删

除关

键码为

4的词条，则在

查找定位该

词条后，依次

删除塔顶。关

键码删除过

程的中间结

果如图(c)

和(b)所

示，最终结果

如图(a)。

 Quadlist::remove()

在基于

四联表实现

跳转表中，QuadlistNode节

点总是以塔

为单位，自顶

而下地成批

被删除，

其中

每一节点的

删除，都按照

如下固定模

式进行：节点

p为当前的塔

顶，将它从所

属横向列表

中

删除；其下

邻（若存在）随

后将成为新

塔顶，并将在

紧随其后的

下一次删除

操作中被删

除。

Quadlist模板类（代

码9.3）为此定义

了接口remove()，其具

体实现如代

码9.12所示。

1 template

<typename T> //初除

Quadlist内位置p处癿

节点，迒回其

中存放癿词

条

2

T Quadlist<T>::remove ( QlistNodePosi(T)

p ) { //assert:

p为Quadlist中癿合

法位置

3 p->pred->succ =

p->succ; p->succ->pred = p->pred;

_size--;//摘除

节点

4 T e

= p->entry; delete p;

//备仹词

条，释放节点

5 return e; //迒回词条

6 }

7

8

template <typename T> int

Quadlist<T>::clear() { //清

空Quadlist

9

int oldSize = _size;

10 while ( 0

< _size ) remove

( header->succ ); //逐个初除

所有节点

11 return oldSize;

12

}

代

码9.12 Quadlist::remove()初除

第9章

词典

§9.3 散列表

259

这里各步迭

代中的操作

次序，与图9.4(a)和

(b)基本相反。略

微不同之处

在于，因必然

是整

塔删除

，故可省略纵

向链接的调

整。

其中clear()接口

用以删除表

中所有节点

，在代码9.3中也

是析构过程

中的主要操

作。

 时间复杂

度

如代码9.11所

示，词条删除

算法所需的

时间，不外乎

消耗于两个

方面。

首先是

查找目标关

键码，由9.2.6节的

结论可知，这

部分时间的

期望值不过

O(logn)。其次

是拆除

与目标关键

码相对应的

塔，这是一个

自顶而下逐

层迭代的过

程，故累计不

超过h步；另外

，

由代码9.12可见

，各层对应节

点的删除仅

需常数时间

。

综合以上分

析可知，跳转

表词条删除

操作所需的

时间不超过

O(h)

= O(logn)。

§9.3 散列表

散列

作为一种思

想既朴素亦

深刻，作为一

种技术则虽

古老却亦不

失生命力，因

而在数据结

构

及算法中

占据独特而

重要地位。此

类方法以最

基本的向量

作为底层支

撑结构，通过

适当的散列

函

数在词条

的关键码与

向量单元的

秩之间建立

起映射关系

。理论分析和

实验统计均

表明，只要散

列

表、散列函

数以及冲突

排解策略设

计得当，散列

技术可在期

望的常数时

间内实现词

典的所有接

口

操作。也就

是说，就平均

时间复杂度

的意义而言

，可以使这些

操作所需的

运行时间与

词典的规模

基本无关。尤

为重要的是

，散列技术完

全摒弃了“关

键码有序”的

先决条件，故

就实现词典

结构

而言，散

列所特有的

通用性和灵

活性是其它

方式无法比

拟的。

以下将

围绕散列表

、散列函数以

及冲突排解

三个主题，逐

层深入地展

开介绍。

9.3.1

完美

散列

 散列表

散列表（hashtable）是散

列方法的底

层基础，逻辑

上由一系列

可存放词条

（或其引用）的

单元组成，故

这些单元也

称作桶（bucket）或桶

单元；与之对

应地，各桶单

元也应按其

逻辑次

序在

物理上连续

排列。因此，这

种线性的底

层结构用向

量来实现再

自然不过。为

简化实现并

进一

步提高

效率，往往直

接使用数组

，此时的散列

表亦称作桶

数组（bucket array）。若桶数

组的

容量为

R，则其中合法

秩的区间[0, R)也

称作地址空

间（address

space）。

 散列函数

一组词条在

散列表内部

的具体分布

，取决于所谓

的散列（hashing）方案

事先在词条

与

桶地址之

间约定的某

种映射关系

，可描述为从

关键码空间

到桶数组地

址空间的函

数：

hash() : key 

hash(key)

这里的hash()称

作散列函数

（hash function）。反过来，hash(key)也称

作key的散列地

址（hashing address），亦即与关

键码key相对应

的桶在散列

表中的秩。

 实

例

以学籍库

为例。若某高

校2011级共计4000名

学生的学号

为2011-0000至2011-3999，则可

直

接使用一个

长度为4000的散

列表A[0~3999]，并取

hash(key) = key -

20110000

从

而将学号为

x的学生学籍

词条存放于

桶单元A[hash(x)]。

§9.3 散列

表

第9章 词典

260

如此散列之

后，根据任一

合法学号，都

可在O(1)时间内

确定其散列

地址，并完成

一次查找、

插

入或删除。空

间性能方面

，每个桶恰好

存放一个学

生的学籍词

条，既无空余

亦无重复。这

种在

时间和

空间性能方

面均达到最

优的散列，也

称作完美散

列（perfect hashing）。

实际上，Bitmap结

构（习题[2-34]）也可

理解为完美

散列的一个

实例。其中，为

每个可能

出

现的非负整

数，各分配了

一个比特位

，作为判定它

是否属于当

前集合的依

据；散列函数

也再简

单不

过各比特位

在内部向量

中的秩，就是

其所对应整

数的数值。

遗

憾的是，以上

实例都是在

十分特定的

条件下才成

立的，完美散

列实际上并

不常见。而在

更

多的应用

环境中，为兼

顾空间和时

间效率，无论

散列表或散

列函数都需

要经过更为

精心的设计

。

以下就是一

个更具一般

性的实例。

9.3.2 装

填因子与空

间利用率

 电

话查询系统

假设某大学

拟建立一个

电话簿查询

系统，覆盖教

职员工和学

生所使用的

共约25000门固定

电

话。以下，主

要考查其中

反查功能的

实现，即如何

高效地由电

话号码获取

机主的信息

。

图9.5 直接使用

线性数组实

现电话簿词

典

这一任务

从数据结构

的角度可理

解为，设计

并

实现一个词

典结构，以电

话号码为词

条关键码，

支

持根据这种

关键码的高

效查询。若考

虑到开机、

撤

机和转机等

情况，还应支

持词条的插

入和删除

等

动态操作。仿

照学籍库的

例子，可如图

9.5引

入向量，将

电话号码为

x 的词条存放

在秩为x的

单

元。如此，不仅

词条与桶单

元一一对应

，而且

无论是

静态的查找

还是动态的

插入和删除

，每次

操作仅

需常数时间

！

然而进一步

分析之后不

难发现，这一

方案在此情

况下并不现

实。从理论上

讲，在使用8位

编

号系统时

，整个城市固

定电话最多

可能达到10^8门

。尽管该校人

员所涉及的

固定电话仅

有25000

门，但号码

却可能随机

分布在[0000-0000,

9999-9999]的整

个范围内。这

就意味着，上

述方案

所使

用数组的长

度大致应与

10^8相当。每个词

条占用的空

间即便按100字

节估计，该数

组也至少

需

要占用10GB的空

间。也就是说

，此时的空间

有效利用率

仅为 25000

/ 10^8 = 0.025%，绝

大部

分的空间实

际上处于闲

置状态。

 IP节点

查询

另一个

类似的例子

是，根据IP地址

获取对应的

域名信息。按

照32bit地址的协

议，理论上可

能的IP地址共

有2

32 = 4109个，故此时

若直接套用

以上方法采

用最简单的

散列表和散

列函数，

将动

辄征用100~1000GB的空

间。另一方面

，尽管大多数

IP并没有指定

域名，但任一

IP都有可能

具

有域名，故这

种方法的空

间利用率也

仅为5%左右③。而

在未来采用

IPv6协议之后，尽

管实际运

 

③

据

威瑞信（VeriSign）公司

2010年11月収布癿

《2010年第三季度

域名行业报

告》，截至2010年第

三季度底，全

球顶

级域名

（Top Level Domain,

TLD）癿注册总数

已达刡2.02亿，平

均约殏20个IP中

才有一个IP具

有域名

第9章

词典 §9.3 散列表

261

行中的节点

数目在短时

间内不会有

很大的变化

，但允许使用

的IP地址将多

达2^128 = 2561036

个如此庞

大的地址空

间根本无法

直接使用数

组表示和存

放④；即便有如

此规模的存

储介质，

其空

间利用率依

然极低。

 兼顾

空间利用率

与速度

此类

问题在实际

应用中十分

常见，其共同

的特点可归

纳为：尽管词

典中实际需

要保存的词

条

数N（比如25000门

）远远少于可

能出现的词

条数R（10^8门），但R个

词条中的任

何一个都有

可

能出现在

词典中。仿照

2.4.1节针对向量

空间利用率

的度量方法

，这里也可以

将散列表中

非空桶

的数

目与桶单元

总数的比值

称作装填因

子（load factor）。从这一角

度来看，上述

问题的实质

在于散列表

的装填因子

太小，从而导

致空间利用

率过低。

无论

如何，散列方

法的查找和

更新速度实

在诱人，也的

确可以完美

地适用于学

籍库之类的

应

用。那么，能

否在保持优

势的前提下

，克服其在存

储空间利用

率方面的不

足呢？答案是

肯定的，

但需

要运用一系

列的技巧，其

中首先就是

散列函数的

设计。

9.3.3

散列函

数

9.3.10节将介绍

一般类型关

键码到整

数

的转换方法

，故不妨先假

定关键码均

为

[0,

R)范围内的

整数。将词典

中的词条数

记

作N，散列表

长度记作M，于

是通常有：

R >>

M > N

如

图9.6所示，散列

函数hash()的作用

可理解为，将

关键码空间

[0,

R)压缩为散列

地址空间[0, M)。

图

9.6 散列函数

 设

计原则

作为

好的散列函

数，hash()应具备哪

些条件呢？首

先，必须具有

确定性。无论

所含的数据

项如何，词条

E在散列表中

的映射地址

hash(E.key)必须完全取

决于其关键

码E.key。其次，映

射

过程自身不

能过于复杂

，唯此方能保

证散列地址

的计算可快

速完成，从而

保证查询或

修改操作

整

体的O(1)期望执

行时间。再次

，所有关键码

经映射后应

尽量覆盖整

个地址空间

[0, M)，唯此

方可充

分利用有限

的散列表空

间。也就是说

，函数hash()最好是

满射。

当然，因

定义域规模

R远远大于取

值域规模M，hash()不

可能是单射

。这就意味着

，关键码

不同

的词条被映

射到同一散

列地址的情

况称作散列

冲突（collision）难以彻

底避免。

尽管

9.3.5节将会介绍

解决冲突的

办法，但若能

在设计和选

择散列函数

阶段提前做

些细致而充

分

的考量，便

能尽可能地

降低冲突发

生的概率。

在

此，最为重要

的一条原则

就是，关键码

映射到各桶

的概率应尽

量接近于1/M若

关键码

均匀

且独立地随

机分布，这也

是任意一对

关键码相互

冲突的概率

。就整体而言

，这等效于将

关键

码空间

“均匀地”映射

到散列地址

空间，从而避

免导致极端

低效的情况

比如，因大部

分关键

④ 截至

2010年，人类拥有

癿数字化数

据总量为1.2ZB（1ZB = 270

= 1021字

节），预计刡2020年

可达35ZB

§9.3 散列表

第9章

词典

262

码

集中分布于

某一区间，而

加剧散列冲

突；或者反过

来，因某一区

间仅映射有

少量的关键

码，而

导致空

间利用率低

下。

总而言之

，随机越强、规

律性越弱的

散列函数越

好。当然，完全

符合上述条

件的散列函

数并

不存在

，我们只能通

过先验地消

除可能导致

关键码分布

不均匀的因

素，最大限度

地模拟理想

的随

机函数

，尽最大可能

降低发生冲

突的概率。



除

余法（division method）

符合上

述要求的一

种最简单的

映射办法，就

是将散列表

长度M取作为

素数，并将关

键码key

映射至

key关于M整除的

余数：

hash(key) = key mod

M

仍以校

园电话簿为

例，若取M = 90001，则以

下关键码：

{ 6278-5001, 5153-1876, 6277-0211

}

将

如图9.7所示分

别映射至

{ 54304,

51304, 39514 }

图

9.7

除余法

请注

意，采用除余

法时必须将

M选作素数，否

则关键码被

映射至[0, M)范围

内的均匀度

将大

幅降低

，发生冲突的

概率将随M所

含素因子的

增多而迅速

加大。

图9.8 素数

表长可降低

冲突癿概率

幵提高空间

癿刟用率

第

9章 词典

§9.3 散列

表

263

在实际应

用中，对同一

词典内词条

的访问往往

具有某种周

期性，若其周

期与M具有公

共的素

因子

，则冲突的概

率将急剧攀

升。试考查一

例：某散列表

从全空的初

始状态开始

，插入的前10

个

词条对应的

关键码是等

差数列{ 1000, 1015,

1030, ..., 1135 }。

如图

9.8(a)所示，若散列

表长度取作

M = 20，则其中每一

关键码，都与

另外一或两

个关键

码相

冲突；而反过

来，散列表中

80%的桶，此时却

处于空闲状

态。

词条集中

到散列表内

少数若干桶

中（或附近）的

现象，称作词

条的聚集（clustering）。

显

然，好的散列

函数应尽可

能此类现象

，而采用素数

表长则是降

低聚集发生

概率的捷径

。

一般地，散列

表的长度M与

词条关键码

间隔T之间的

最大公约数

越大，发生冲

突的可能性

也

将越大（习

题[9-6]）。因此，若M取

素数，则简便

对于严格或

大致等间隔

的关键码序

列，也不

致出

现冲突激增

的情况，同时

提高空间效

率。

比如若改

用表长M = 19，则如

图9.8(b)所示没有

任何冲突，且

空间利用率

提高至50%以上

。

再如，若如图

9.8(c)所示取表长

M = 11，则同样不致

发生任何冲

突，且仅有一

个桶空闲。

当

然，若T本身足

够大而且恰

好可被M整除

，则所有被访

问词条都将

相互冲突。例

如，若如

图9.8(d)所

示将表长取

作素数M = 5且只

考虑原插入

序列中的前

5个关键码，则

所有关键码

都将

聚集于

一个桶内。不

难理解，相对

而言，发生这

种情况的概

率极低。

 MAD法（multiply-add-divide method）

以

素数为表长

的除余法尽

管可在一定

程度上保证

词条的均匀

分布，但从关

键码空间到

散列地

址空

间映射的角

度看，依然残

留有某种连

续性。比如，相

邻关键码所

对应的散列

地址，总是彼

此

相邻；极小

的关键码，通

常都被集中

映射到散列

表的起始区

段其中特别

地，0值居然是

一个

“不动点

”，其散列地址

总是0，而与散

列表长度无

关。

图9.9

MAD法可消

除散列过秳

癿还续性

例

如，在如图9.9(a)所

示，将关键码

：

{ 2011,

2012, 2013, 2014, 2015,

2016 }

插入长度为

M =

17的空散列表

后，这组词条

将存放至地

址连续的6个

桶中。尽管这

里没有任

何

关键码的冲

突，却具有就

“更高阶”的均

匀性。

为弥补

这一不足，可

采用所谓的

MAD法将关键码

key映射为：

(a

 key + b

) mod M，其中

M仍为素数，a >

0，b > 0，且

a mod

M  0

此类散列函

数需依次执

行乘法、加法

和除法（模余

）运算，故此得

名。

尽管运算

量略有增加

，但只要常数

a和b选取得当

，MAD法可以很好

地克服除余

法原有的连

续

性缺陷。仍

以上述插入

序列为例，当

取a = 31和b

= 2时，按MAD法

的散列结果

将图9.9(b)所示，

各

关键码散列

的均匀性相

对于图9.9(a)有了

很大的改善

。

实际上，此前

所介绍的除

余法，也可以

看做是MAD法取

a

= 1和b = 0的特殊情

况。从这一

角

度来看，导致

除余法连续

性缺陷的根

源，也可理解

为这两个常

数未发挥实

质的作用。

§9.3 散

列表 第9章

词

典

264

 更多的散

列函数

散列

函数种类繁

多，不一而足

。数字分析法

（selecting digits）从关键码key特

定进制

的展

开中抽取出

特定的若干

位，构成一个

整型地址。比

如，若取十进

制展开中的

奇数位，则有

hash(123456789) =

13579

又如所谓平

方取中法（mid-square），从

关键码key的平

方的十进制

或二进制展

开中取居

中

的若干位，构

成一个整型

地址。比如，若

取平方后十

进制展开中

居中的三位

，则有

hash(123)

= 15129 = 512

hash(1234567) = 1524155677489 =

556

再如所

谓折叠法（folding），是

将关键码的

十进制或二

进制展开分

割成等宽的

若干段，取

其

总和作为散

列地址。比如

，若以三个数

位为分割单

位，则有

hash(123456789)

= 123 + 456

+ 789 = 1368

分割

后各区段的

方向也可以

是往复折返

式的，比如

hash(123456789) = 123

+ 654 + 789

= 1566

还

有如所谓位

异或法（xor），是将

关键码的二

进制展开分

割成等宽的

若干段，经异

或运算

得到

散列地址。比

如，仍以三个

数位为分割

单位，则有

hash(411) = hash(110011011b) =

110 ^ 011 ^

011 = 110b =

6

同

样地，分割后

各区段的方

向也可以是

往复折返式

的，比如

hash(411) =

hash(110011011b) = 110 ^

110 ^ 011 =

011b = 3

当然

，为保证上述

函数取值落

在合法的散

列地址空间

以内，通常都

还需要对散

列表长度M再

做一次取余

运算。

 （伪）随机

数法

上述各

具特点的散

列函数，验证

了我们此前

的判断：越是

随机、越是没

有规律，就越

是好的

散列

函数。按照这

一标准，任何

一个（伪）随机

数发生器，本

身即是一个

好的散列函

数。比如，

可直

接使用C/C++语言

提供的rand()函数

，将关键码key映

射至桶地址

：

rand(key) mod M

其中rand(key)为系统

定义的第key个

（伪）随机数。

这

一策略的原

理也可理解

为，将“设计好

散列函数”的

任务，转换为

“设计好的（伪

）随机

数发生

器”的任务。幸

运的是，二者

的优化目标

几乎是一致

的。

需特别留

意的是，由于

不同计算环

境所提供的

（伪）随机数发

生器不尽相

同，故在将某

一系

统中生

成的散列表

移植到另一

系统时，必须

格外小心。

9.3.4 散

列表



Hashtable模板类

按照词典的

标准接口，可

以模板类的

形式，定义Hashtable类

如代码9.13所示

。

1 #include "../Dictionary/Dictionary.h"

//引入词典ADT

2 #include "../Bitmap/Bitmap.h"

//引

入位图

3

第9章

词典 §9.3

散列表

265

4 template <typename

K, typename V> //key、value

5 class Hashtable :

public Dictionary<K, V> {

//符合Dictionary接口癿

Hashtable模板类

6 private:

7

Entry<K, V>** ht; //桶数

组，存放词条

指针

8 int M; //桶数组

容量

9 int N; //词条数

量

10 Bitmap* lazyRemoval; //懒惰初除

标记

11 #define lazilyRemoved(x) (lazyRemoval->test(x))

12 #define markAsRemoved(x) (lazyRemoval->set(x))

13 protected:

14 int

probe4Hit ( const K&

k ); //沿兲键

码k对应癿查

找链，找刡词

条匘配癿桶

15 int

probe4Free ( const K&

k ); //沿兲键码k对

应癿查找链

，找刡首个可

用空桶

16

void rehash(); //重散

列算法：扩充

桶数组，保证

装填因子在

警戒线以下

17 public:

18 Hashtable ( int

c = 5 );

//创建一个容

量丌小亍c癿

散列表（为测

试暂时选用

较小癿默讣

值）

19 ~Hashtable(); //释放桶数

组及其中各

（非空）元素所

指向癿词条

20

int size() const {

return N; } //

弼前癿词条

数目

21 bool put

( K, V );

//揑入（禁

止雷同词条

，故可能失败

）

22 V* get

( K k );

//读叏

23 bool remove

( K k );

//初除

24 };

代

码9.13

基二散列

表实现癿映

射结极

作为

词典结构的

统一接口，put()、get()和

remove()等操作的具

体实现稍后

介绍。

这里还

基于Bitmap结构（习

题[2-34]），维护了一

张与散列表

等长的懒惰

删除标志表

lazyRemoval[]，稍后的9.3.6节将

介绍其原理

与作用。



散列

表构造

散列

表的初始化

过程如代码

9.14所示。

1 template

<typename K, typename V>

Hashtable<K, V>::Hashtable ( int

c ) { //创建散

列表，容量为

2

M = primeNLT (

c, 1048576, "../../_input/prime-1048576-bitmap.txt" );

//丌小亍c癿素

数M

3 N =

0; ht = new

Entry<K, V>*[M]; //开辟桶数

组（迓需核对

申请成功），刜

始装填因子

为N/M =

0%

4 memset (

ht, 0, sizeof (

Entry<K, V>* ) *M

); //刜始化各

桶

5 lazyRemoval

= new Bitmap (

M ); //懒惰初除

标记比特图

6 }

代码9.14 散列表

极造

为了加

速素数的选

取，这里不妨

借鉴习题[2-36]中

的技巧，事先

计算出不超

过1,048,576

的所有素

数，并存放于

文件中备查

。于是在创建

散列表（或者

重散列）时，对

于在此范围

内任意

给定

的长度下限

c，都可通过调

用primeNLT()，迅速地从

该查询表中

找到不小于

c的最小素数

M

作为散列表

长度，并依此

为新的散列

表申请相应

数量的空桶

；同时创建一

个同样长度

的位图结构

，

作为懒惰删

除标志表。

§9.3

散

列表 第9章 词

典

266

1 int primeNLT (

int c, int n,

char* file ) {

//根据file文件

中癿记弽，在

[c, n)内叏最小癿

素数

2 Bitmap

B ( file, n

); //file已经按

位图格式，记

弽了n以内癿

所有素数，因

此叧要

3 while

( c < n

) //从c开

始，逐位地

4 if

( B.test ( c

) ) c++; //测

试，即可

5 else return c;

//迒回

首个収现癿

素数

6 return c;

//若没有

返样癿素数

，迒回n（实用中

丌能如此简

化处理）

7 }

代码

9.15

确定散列表

癿素数表长

如代码9.15所示

，从长度下限

c开始，逐个测

试对应的标

志位，直到第

一个足够大

的素数。

 散列

表析构

1

template <typename K, typename

V> Hashtable<K, V>::~Hashtable() {

//枂极

前释放桶数

组及非空词

条

2 for (

int i = 0;

i < M; i++

) //逐一检查

各桶

3 if

( ht[i] ) release

( ht[i] ); //释放非

空癿桶

4 release ( ht

); //释放

桶数组

5 release

( lazyRemoval ); //释放

懒惰初除标

记

6 }

代码9.16 散列

表枂极

在销

毁散列表之

前，如代码9.16所

示，需在逐一

释放各桶中

的词条（如果

存在）之后，释

放整个散列

表ht[]以及对应

的懒惰删除

表lazyRemoval[]。

9.3.5 冲突及其

排解



冲突的

普遍性

散列

表的基本构

思，可以概括

为：

开辟物理

地址连续的

桶数组ht[]，借助

散列函数hash()，将

词条关键码

key映射

为桶地

址hash(key)，从而快速

地确定待操

作词条的物

理位置。

然而

遗憾的是，无

论散列函数

设计得如何

巧妙，也不可

能保证不同

的关键码之

间互不冲突

。

比如，若试图

在如图9.7所示

的散列表中

插入电话号

码6278-2001，便会与已

有的号码5153-1876

相

冲突。而在实

际应用中，不

发生任何冲

突的概率远

远低于我们

的想象。

考查

如下问题：某

课堂的所有

学生中，是否

有某两位生

日（birthday，而非date

of birth）

相同

？这种情况也

称作生日巧

合。那么，发生

生日巧合事

件的概率是

多少？

若将全

年各天视作

365个桶，并将学

生视作词条

，则可按生日

将他们组织

为散列表。如

此，

上述问题

便可转而表

述为：若长度

为365的散列表

中存有n个词

条，则至少发

生一次冲突

的概率

P365(n)有多

大？不难证明

（习题[9-8]），只要学

生人数n  23，即有

P365(n)

> 50%。请注意，

此时

的装填因子

仅为 =

23/365 = 6.3%。

不难理

解，对于更长

的散列表，只

需更低的装

填因子，即有

50%的概率会发

生一次冲突

。鉴

于实际问

题中散列表

的长度M往往

远大于365，故“不

会发生冲突

”只是一厢情

愿的幻想。因

此，

我们必须

事先制定一

整套有效的

对策，以处理

和排解时常

发生的冲突

。

第9章 词典

§9.3 散

列表

267



多槽位

（multiple slots）法

最直截了

当的一种对

策是，将彼此

冲突的每一

组词条组织

为一个小规

模的子词典

，分别存放

于

它们共同对

应的桶单元

中。比如一种

简便的方法

是，统一将各

桶细分为更

小的称作槽

位（slot）

的若干单

元，每一组槽

位可组织为

向量或列表

。

图9.10 通过槽位

细分排解散

列冲突

例如

，对于如图9.8(a)所

示的冲突散

列表，可以如

图9.10所示，将各

桶细分为四

个槽位。

只要

相互冲突的

各组关键码

不超过4个，即

可分别保存

于对应桶单

元内的不同

槽位。

按照这

一思路，针对

关键码key的任

一操作都将

转化为对一

组槽位的操

作。比如put(key,

value)操作

，将首先通过

hash(key)定位对应的

桶单元，并在

其内部的一

组槽位中，进

一步查

找key。若

失败，则创建

新词条(key,

value)，并将

其插至该桶

单元内的空

闲槽位（如果

的确

还有的

话）中。get(key)和remove(key)操作

的过程，与此

类似。

多槽位

法的缺陷，显

而易见。首先

由图9.10可见，绝

大多数的槽

位通常都处

于空闲状态

。

准确地讲，若

每个桶被细

分为k个槽位

，则当散列表

总共存有N个

词条时，装填

因子

' = N/(kM) =

/k

将降低

至原先的1/k。

其

次，很难在事

先确定槽位

应细分到何

种程度，方可

保证在任何

情况下都够

用。比如在极

端

情况下，有

可能所有（或

接近所有）的

词条都冲突

于单个桶单

元。此时，尽管

几乎其余所

有的桶

都处

于空闲状态

，该桶却会因

冲突过多而

溢出。

 独立链

（separate chaining）法

冲突排解

的另一策略

与多槽位（multiple slots）法

类似，也令相

互冲突的每

组词条构成

小规模的子

词典，只不过

采用列表（而

非向量）来实

现各子词典

。

图9.11 刟用建立

独立链排解

散列冲突

仍

以图9.8(a)中的冲

突为例，可如

图9.11所示令各

桶内相互冲

突的词条串

接成一个列

表，

该方法也

因此得名。

既

然好的散列

函数已能保

证通常不致

发生极端的

冲突，故各子

词典的规模

往往都不是

很大，

大多数

往往只含单

个词条或者

甚至是空的

。因此，采用第

3章的基本列

表结构足矣

。

相对于多槽

位法，独立链

法可更为灵

活地动态调

整各子词典

的容量和规

模，从而有效

地降低

空间

消耗。但在查

找过程中一

旦发生冲突

，则需要遍历

整个列表，导

致查找成本

的增加。

§9.3 散列

表

第9章 词典

268

 公共溢出区

法

公共溢出

区（overflow area）法的思路

如图9.12所示，在

原散列表（图

(a)）之外另设一

个词典结构

Doverflow（图(b)），一旦在插

入词条时发

生冲突就将

该词条转存

至Doverflow中。就效

果

而言，Doverflow相当于

一个存放冲

突词条的公

共缓冲池，该

方法也因此

得名。

图9.12

刟用

公共溢出区

解决散列冲

突

这一策略

构思简单、易

于实现，在冲

突不甚频繁

的场合不失

为一种好的

选择。同时，既

然公

共溢出

区本身也是

一个词典结

构，不妨直接

套用现有的

任何一种实

现方式因此

就整体结构

而

言，此时的

散列表也可

理解为是一

种递归形式

的散列表。

9.3.6 闭

散列策略

尽

管就逻辑结

构而言，独立

链等策略便

捷而紧凑，但

绝非上策。比

如，因需要引

入次级关联

结构，实现相

关算法的代

码自身的复

杂程度和出

错概率都将

加大大增加

。反过来，因不

能保证物

理

上的关联性

，对于稍大规

模的词条集

，查找过程中

将需做更多

的I/O操作。

实际

上，仅仅依靠

基本的散列

表结构，且就

地排解冲突

，反而是更好

的选择。也就

是说，若

新词

条与已有词

条冲突，则只

允许在散列

表内部为其

寻找另一空

桶。如此，各桶

并非注定只

能存

放特定

的一组词条

；从理论上讲

，每个桶单元

都有可能存

放任一词条

。因为散列地

址空间对所

有

词条开放

，故这一新的

策略亦称作

开放定址（open

addressing）；同

时，因可用的

散列地址

仅

限于散列表

所覆盖的范

围之内，故亦

称作闭散列

（closed hashing）。相应地，此前

的策略

亦称

作封闭定址

（closed

addressing）或开散列（open hashing）。

当

然，仅仅能够

为冲突的词

条选择一个

可用空桶还

不足够；更重

要地，在后续

的查找过程

中

应能正确

地找到这个

（些）词条。为此

，须在事先约

定好某种具

体可行的查

找方案。

实际

上，开放定址

策略涵盖了

一系列的冲

突排解方法

，包括线性试

探法、平方试

探法以及再

散列法等。因

不得使用附

加空间，装填

因子需要适

当降低，通常

都取  0.5。



线性试

探（linear probing）法

如图9.13所

示，开放定址

策略最基本

的一种形式

是：在插

入关

键码key时，若发

现桶单元ht[hash(key)]已

被占用，则

转

而试探桶单

元ht[hash(key) + 1]；若ht[hash(key) +

1]

也被占

用，则继续试

探ht[hash(key) + 2]；...；如此不断

，

直到发现一

个可用空桶

。当然，为确保

桶地址的合

法，最后还

需

统一对M取模

。因此准确地

，第i次试探的

桶单元应为

：

ht[ (hash(key)

+ i) mod M

]， i = 1,

2, 3, ... 图9.13

线性试探

法

如此，被试

探的桶单元

在物理空间

上依次连贯

，其地址构成

等差数列，该

方法由此得

名。

第9章 词典

§9.3

散列表

269

 查找

链

采用开放

地址策略时

，散列表中每

一组相互冲

突的词条都

将被视作一

个有序序列

，对其中任

何

一员的查找

都需借助这

一序列。对应

的查找过程

，可能终止于

三种情况：

（1）在

当前桶单元

命中目标关

键码，则成功

返回；

（2）当前桶

单元非空，但

其中关键码

与目标关键

码不等，则须

转入下一桶

单元继续试

探；

（3）当前桶单

元为空，则查

找以失败返

回。

考查如图

9.14所示长度为

M = 17的散列表，设

采用除余法

定址，采用线

性试探法排

解冲突。

图9.14 线

性试探法对

应癿查找链

若从空表开

始，依次插入

5个相互冲突

的关键码{ 2011, 2028,

2045, 2062, 2079 }，

则

结果应如图

(a)所示。此后，针

对其中任一

关键码的查

找都将从：

ht[hash(key)] = ht[5]

出

发，试探各相

邻的桶单元

。可见，与这组

关键码对应

的桶单元ht[5, 10)构

成一个有序

序列，

对其中

任一关键码

的查找都将

沿该序列顺

序进行，故该

序列亦称作

查找链（probing chain）。

类似

地，另一组关

键码{ 2014, 2031, 2048,

2065, 2082 }对应的

查找链，如图

(b)所示。

可见，沿

查找链试探

的过程，与对

应关键码此

前的插入过

程完全一致

。因此对于长

度为n的

查找

链，失败查找

长度就是n + 1；在

等概率假设

下，平均成功

查找长度为

n/2。

需强调的是

，尽管相互冲

突的关键码

必属于同一

查找链，但反

过来，同一查

找链中的关

键码

却未必

相互冲突。仍

以上述散列

表为例，若将

以上两组关

键码合并，并

按从小到大

的次序逐一

插

入空散列

表，结果将如

图(c)所示。可见

，对于2079或2082等关

键码而言，查

找链中的关

键码未

必与

它们冲突。究

其原因在于

，多组各自冲

突的关键码

所对应的查

找链，有可能

相互交织和

重叠。

此时，各

组关键码的

查找长度将

会进一步增

加。仍以这两

组关键码为

例，在图(c)状态

下，失败

查找

长度分别为

为11和8，而在等

概率假设下

的平均成功

查找长度分

别为：

( 1 +

2 + 3 +

7 + 9 )

/ 5 = 4.4

( 1 + 2

+ 3 + 5

+ 7 ) /

5 = 3.6



局部性

由上可见，线

性试探法中

组成各查找

链的词条，在

物理上保持

一定的连贯

性，具有良好

的数

据局部

性，故系统缓

存的作用可

以充分发挥

，查找过程中

几乎无需I/O操

作。尽管闭散

列策略同

时

也会在一定

程度上增加

冲突发生的

可能，但只要

散列表的规

模不是很小

，装填因子不

是很大，

则相

对于I/O负担的

降低而言，这

些问题都将

微不足道。也

正因为此，相

对于独立链

等开散列策

略，闭散列策

略的实际应

用更为广泛

。

§9.3 散列表 第9章

词典

270

 懒惰删

除

查找链中

任何一环的

缺失，都会导

致后续词条

因无法抵达

而丢失，表现

为有时无法

找到实际

已

存在的词条

。因此若采用

开放定址策

略，则在执行

删除操作时

，需同时做特

别的调整。

仍

以图9.14(c)为例，若

为删除词条

ht[9] = 2031而如图9.15(a)所示

，按常规方法

简单

地将其

清空，则该桶

的缺失将导

致对应的查

找链“断裂”，从

而致使五个

后继词条“丢

失”

尽管它们

在词典中的

确存在，但查

找却会失败

。

图9.15 通过讴置

懒惰初除标

记，无需大量

词条癿重排

即可保证查

找链癿完整

为保持查找

链的完整，一

种直观的构

想是将后继

词条悉数取

出，然后再重

新插入。很遗

憾，

如此将导

致删除操作

的复杂度增

加，故并不现

实。简明而有

效的方法是

，为每个桶另

设一个标志

位，指示该桶

尽管目前为

空，但此前确

曾存放过词

条。

在Hashtable模板类

（代码9.13）中，名为

lazyRemoval的Bitmap对象（习题

[2-34]）扮

演的就是

这一角色。具

体地，为删除

词条，只需将

对应的桶ht[r]标

志为lazilyRemoved(r)。

如此，该

桶虽不存放

任何实质的

词条，却依然

是查找链上

的一环。如图

9.15(b)所示，在将桶

ht[9]

作此标记（以

X示意）之后，对

后继词条的

查找仍可照

常进行，而不

致中断。这一

方法既可保

证

查找链的

完整，同时所

需的时间成

本也极其低

廉，称作懒惰

删除（lazy removal）法。

请注

意，设有懒惰

删除标志位

的桶，应与普

通的空桶一

样参与插入

操作。比如在

图9.15(b)

基础上，若

拟再插入关

键码2096，则应从

ht[hash(2096)]

= ht[5]出发，沿查找

链经5次试探

抵达桶ht[9]，并如

图(c)所示将关

键码2096置入其

中。需特别说

明的是，此后

不必清除该

桶的

懒惰删

除标志尽管

按照软件工

程的规范，最

好如此。



两类

查找

采用“懒

惰删除”策略

之后，get()、put()和remove()等操

作中的查找

算法，都需要

做相

应的调

整。这里共分

两种情况。

其

一，在删除等

操作之前对

某一目标词

条的查找。此

时，对成功的

判定条件基

本不变，但对

失败的判定

条件需兼顾

懒惰删除标

志。在查找过

程中，只有在

当前桶单元

为空，且不带

懒惰删除

标

记时，方可报

告“查找失败

”；否则，无论该

桶非空，或者

带有懒惰删

除标志，都将

沿着查找

链

继续试探。这

一查找过程

probe4Hit()，可具体描述

和实现如代

码9.18所示。

其二

，在插入等操

作之前沿查

找链寻找空

桶。此时对称

地，无论当前

桶为空，还是

带有懒惰

删

除标记，均可

报告“查找成

功”；否则，都将

沿查找链继

续试探。这一

查找过程probe4Free()，

可

具体描述和

实现如代码

9.21所示。

第9章 词

典 §9.3

散列表

271

9.3.7 查

找与删除

 get()

1 template

<typename K, typename V>

V* Hashtable<K, V>::get (

K k ) //散

列表词条查

找算法

2 { int r

= probe4Hit ( k

); return ht[r] ?

& ( ht[r]->value )

: NULL; } //禁止

词条癿key值雷

同

代码9.17 散列

表癿查找

词

条查找操作

接口，可实现

如代码9.17所示

。可见，其实质

的过程只不

过是调用以

下的

probe4Hit(k)算法，沿

关键码k所对

应的查找链

顺序查找。

 probe4Hit()

借

助如代码9.18所

示的probe4Hit()算法，可

确认散列表

是否包含目

标词条。

1

/******************************************************************************************

2 * 沿兲

键码k对应癿

查找链，找刡

不乀匘配癿

桶（供查找和

初除词条时

调用）

3 * 试探策

略夗种夗样

，可灵活选叏

；返里仅以线

性试探策略

为例

4

******************************************************************************************/

5 template <typename

K, typename V> int

Hashtable<K, V>::probe4Hit ( const

K& k ) {

6 int r =

hashCode ( k )

% M; //从起始

桶（按除余法

确定）出収

7

while ( ( ht[r]

&& ( k !=

ht[r]->key ) ) ||

( !ht[r] && lazilyRemoved

( r ) )

)

8 r =

( r + 1

) % M; //沿

查找链线性

试探：跳过所

有冲突癿桶

，以及带懒惰

初除标记癿

桶

9 return r; //调用者根

据ht[r]是否为空

，即可刞断查

找是否成功

10

}

代码9.18 散列表

癿查找probe4Hit()

首先

采用除余法

确定首个试

探的桶单元

，然后按线性

试探法沿查

找链逐桶试

探。请注意，这

里共有两种

试探终止的

可能：在一个

非空的桶内

找到目标关

键码（成功），或

者遇到一个

不带懒

惰删

除标记的空

桶（失败）。否则

，无论是当前

桶中词条的

关键码与目

标关键码不

等，还是当前

桶为空但带

有懒惰删除

标记，都意味

着有必要沿

着查找链前

进一步继续

查找。该算法

统一返回最

后被试探桶

的秩，上层调

用者只需核

对该桶是否

为空，即可判

断查找是否

失败。

可见，借

助懒惰删除

标志，的确可

以避免查找

链的断裂。当

然，在此类查

找中，也可将

懒惰

标志，等

效地视作一

个与任何关

键码都不相

等的特殊关

键码。



remove()

词条删

除操作接口

可实现如代

码9.19所示。

1 template

<typename K, typename V>

bool Hashtable<K, V>::remove (

K k ) {

//散列

表词条初除

算法

2 int r

= probe4Hit ( k

); if ( !ht[r]

) return false; //对应词

条丌存在时

，无法初除

3 release ( ht[r]

); ht[r] = NULL;

markAsRemoved ( r );

N--; return true;

4

//否

则释放桶中

词条，讴置懒

惰初除标记

，幵更新词条

总数

5 }

代码9.19

散

列表元素初

除（采用懒惰

初除策略）

这

里首先调用

probe4Hit(k)算法，沿关键

码k对应的查

找链顺序查

找。若在某桶

单元命中，

则

释放其中的

词条，为该桶

单元设置懒

惰删除标记

，并更新词典

的规模。

§9.3

散列

表 第9章 词典

272

9.3.8

插入

 put()

1

template <typename K, typename

V> bool Hashtable<K, V>::put

( K k, V

v ) { //散列表

词条揑入

2 if ( ht[probe4Hit

( k ) ]

) return false; //雷

同元素丌必

重复揑入

3 int r =

probe4Free ( k );

//为

新词条找个

空桶（叧要装

填因子控刢

得弼，必然成

功）

4 ht[r] =

new Entry<K, V> (

k, v ); ++N;

//揑入（注意

：懒惰初除标

记无需复位

）

5 if (

N * 2 >

M ) rehash(); //装填因子高

亍50%后重散列

6

return true;

7 }

代码9.20 散列表

元素揑入

词

条插入操作

的过程，可描

述和实现如

代码9.20所示。调

用以下probe4Free(k)算法

，若

沿关键码

k所属查找链

能找到一个

空桶，则在其

中创建对应

的词条，并更

新词典的规

模。

 probe4Free()

如代码9.21所

示，借助probe4Free()算法

可在散列表

中找到一个

空桶。

1

/******************************************************************************************

2 * 沿兲键

码k对应癿查

找链，找刡首

个可用空桶

（仅供揑入词

条时调用）

3 * 试

探策略夗种

夗样，可灵活

选叏；返里仅

以线性试探

策略为例

4

******************************************************************************************/

5 template <typename

K, typename V> int

Hashtable<K, V>::probe4Free ( const

K& k ) {

6 int r =

hashCode ( k )

% M; //从

起始桶（按除

余法确定）出

収

7

while ( ht[r] )

r = ( r

+ 1 ) %

M; //沿查找链

逐桶试探，直

刡首个空桶

（无讳是否带

有懒惰初除

标记）

8 return

r; //为保证

空桶总能找

刡，装填因子

及散列表长

需要合理讴

置

9 }

代码9.21 散列

表癿查找probe4Free()

采

用除余法确

定起始桶单

元之后，沿查

找链依次检

查，直到发现

一个空桶。

与

在probe4Hit()过程中一

样，懒惰标志

在此也等效

于一个特殊

的关键码；不

同之处在于

，

在probe4Free()查找过程

中，假想的该

关键码与任

何关键码都

相等。

 装填因

子

就对散列

表性能及效

率的影响而

言，装填因子



= N / M是最为重要

的一个因素

。随着的

上升

，词条在散列

表中聚集的

程度亦将迅

速加剧。若同

时还采用基

本的懒惰删

除法，则不带

懒惰

删除标

记的桶单元

必将持续减

少，这也势必

加剧查找成

本的进一步

攀升。尽管可

以采取一些

弥补

的措施

（习题[9-16]），但究其

本质而言，都

等效于将懒

惰删除法所

回避的调整

操作推迟实

施，

而且其编

码实现的复

杂程度之高

，必将将令懒

惰删除法的

简洁性丧失

殆尽。

实际上

，理论分析和

实验统计均

一致表明，只

要能将装填

因子控制在

适当范围以

内，闭散

列策

略的平均效

率，通常都可

保持在较为

理想的水平

。比如，一般的

建议是保持

 < 0.5。这一

原则也

适用于其它

的定址策略

，比如对独立

链法而言，建

议的装填因

子上限为0.9。当

前主流的

编

程语言大多

提供了散列

表接口，其内

部装填因子

的阈值亦多

采用与此接

近的阈值。

第

9章 词典

§9.3 散列

表

273



重散列（rehashing）

其

实，将装填因

子控制在一

定范围以内

的方法并不

复杂，重散列

即是常用的

一种方法。

回

顾代码9.20中的

Hashtable::put()算法可见，一

旦装填因子

上升到即将

越界（这里采

用

阈值50%），则可

调用如代码

9.22所示的rehash()算法

。

1 /******************************************************************************************

2 *

重散列算法

：装填因子过

大时，采叏“逐

一叏出再揑

入”癿朴素策

略，对桶数组

扩容

3 * 丌可简

单地（通过memcpy()）将

原桶数组复

刢刡新桶数

组（比如前端

），否则存在两

个问题：

4 * 1）会继

承原有冲突

；2）可能寻致查

找链在后端

断裂——即便为

所有扩充桶

讴置懒惰初

除标志也无

济亍事

5

******************************************************************************************/

6 template <typename

K, typename V> void

Hashtable<K, V>::rehash() {

7

int old_capacity = M;

Entry<K, V>** old_ht =

ht;

8 M =

primeNLT ( 2 *

M, 1048576, "../../_input/prime-1048576-bitmap.txt" );

//容量

至少加倍

9 N =

0; ht = new

Entry<K, V>*[M]; memset (

ht, 0, sizeof (

Entry<K, V>* ) *

M ); //新

桶数组

10

release ( lazyRemoval );

lazyRemoval = new Bitmap

( M ); //新开

懒惰初除标

记比特图

11 for ( int

i = 0; i

< old_capacity; i++ )

//扫

描原桶数组

12 if ( old_ht[i]

) //将非空桶中

癿词条逐一

13 put (

old_ht[i]->key, old_ht[i]->value ); //揑入至新癿

桶数组

14 release ( old_ht

); //释放

原桶数组——由

亍其中原先

存放癿词条

均已转秱，故

叧需释放桶

数组本身

15 }

代

码9.22 散列表癿

重散列

可见

，重散列的效

果，只不过是

将原词条集

，整体“搬迁”至

容量至少加

倍的新散列

表中。

与可扩

充向量同理

，这一策略也

可使重散列

所耗费的时

间，在分摊至

各次操作后

可以忽略不

计。

9.3.9 更多闭散

列策略

 聚集

现象

线性试

探法虽然简

明紧凑，但各

查找链均由

物理地址连

续的桶单元

组成，因而会

加剧关键码

的聚集趋势

。例如，采用除

余法，将7个关

键码{ 2011, 2012, 2013,

2014, 2015, 2016, 2017

}

依次插

入长度M = 17的散

列表，则如图

9.16(a)所示将形成

聚集区段ht[5,

12)。

图

9.16 线性试探法

会加剧聚集

现象，而平斱

试探法则会

快速跳离聚

集区段

接下

来，设拟插入

关键码3456和4000。由

除余法，hash(3456)

= hash(4000) = hash(2011)

= 5，故对

二者的试探

都将起始于

桶单元ht[5]。以下

按照线性试

探法，分别经

8次和9次试探

后，

§9.3 散列表

第

9章 词典

274

它们

将被插入于

紧邻原聚集

区段右侧的

位置。结果如

图9.16(b)所示，其中

的虚弧线示

意试探过

程

。可见，聚集区

段因此扩大

，而且对这两

个关键码的

后续查找也

相应地十分

耗时（分别需

做8

次和9次试

探）。如果再考

虑到聚集区

段的生长还

会加剧不同

聚集区段之

间的相互交

叠，查找操

作

平均效率的

下降程度将

会更加严重

。



平方试探（quadratic probing）法

采用9.3.3节的MAD法

，可在一定程

度上缓解上

述聚集现象

。而平方试探

法，则是更为

有效

的一种

方法。具体地

，在试探过程

中若连续发

生冲突，则按

如下规则确

定第j次试探

的桶地址：

(hash(key)

+ j2

) mod

M, j = 0,

1, 2, ...

如

图9.17所示，各次

试探的位置

到起始位置

的距离，以平

方速率增长

，该方法因此

得名。

图9.17 平斱

试探法

仍以

图9.16(a)为例。为插

入3456，将依次试

探秩为5、6、9、14的桶

单元，最终将

其插至

ht[14]。接下

来为插入4000，将

依次试探秩

为5、6、9、14、21

 4的桶单元

，并最终将其

插

至ht[4]。最终的

结果如图9.16(c)所

示。



局部性

可

见，聚集区段

并未扩大，同

时针对这两

个关键码的

后续查找，也

分别只需3次

和4次试探，

速

度得以提高

至两倍以上

。平方试探法

之所以能够

有效地缓解

聚集现象，是

因为充分利

用了平方

函

数的特点顺

着查找链，试

探位置的间

距将以线性

（而不再是常

数1的）速度增

长。于是，

一旦

发生冲突，即

可“聪明地”尽

快“跳离”关键

码聚集的区

段。

反过来，细

心的读者可

能会担心，试

探位置加速

地“跳离”起点

，将会导致数

据局部性失

效。

然而幸运

的是，鉴于目

前常规的I/O页

面规模已经

足够大，只有

在查找链极

长的时候，才

有可能

引发

额外的I/O操作

。仍以由内存

与磁盘构成

的二级存储

系统为例，典

型的缓存规

模约为KB量级

，

足以覆盖长

度为 1024/4≈16的查找

链。

 确保试探

必然终止

线

性试探法中

，只要散列表

中

尚有空桶

，则试探过程

至多遍历全

表

一遍，必然

终止。那么，平

方试探法

是

否也能保证

这一点呢？

图

9.18 即便散列表

长叏为素数

（M = 11），在装填因

子

 > 50%时仌可能找

丌刡实际存

在癿空桶

考

查如图9.18所示

的实例。这里

取M

= 11为素数，黑

色的桶已存

有词条，白色

的桶为空。

现

假设拟插入

一个与ht[0]冲突

的词条，并从

ht[0]出发做平方

试探。因为任

何整数的平

方关于

11的余

数，恰好只可

能来自集合

{

0, 1, 3, 4,

5, 9 }，故所有试探

必将局限于

这6个非空桶

，

从而出现“明

明存在空桶

却永远无法

抵达”的奇特

现象。

第9章 词

典 §9.3 散列表

275

好

消息是：只要

散列表长度

M为素数且装

填因子  50%，则平

方试探迟早

必将终止于

某个

空桶（习

题[9-14]）。照此反观

前例，之所以

会出现试探

无法终止的

情况，原因在

于当前的装

填因子 = 6/11 >

50%。当然

，读者也可从

另一角度对

上述结论做

一验证（习题

[9-15]）。

 （伪）随机试探

（pseudo-random probing）法

既然在排

解冲突时也

需尽可能保

证试探位置

的随机和均

匀分布，自然

也可仿照9.3.3节

的思

路，借助

（伪）随机数发

生器来确定

试探位置。具

体地，第j次试

探的桶地址

取作：

rand(j) mod

M ................. （rand(i)为系统

定义的第j个

（伪）随机数）

同

样地，在跨平

台协同的场

合，出于兼容

性的考虑，这

一策略也须

慎用。

 再散列

（double hashing）法

再散列也

是延缓词条

聚集趋势的

一种有效办

法。为此，需要

选取一个适

宜的二级散

列函数

hash2()，一旦

在插入词条

(key, value)时发现ht[hash(key)]已被

占用，则以hash2(key)为

偏移增量继

续尝试，直到

发现一个空

桶。如此，被尝

试的桶地址

依次应为：

[hash(key) +

1  hash2(key)] %

M

[hash(key) + 2

 hash2(key)] % M

[hash(key) + 3 

hash2(key)] % M

...

可

见，再散列法

是对此前各

方法的概括

。比如取hash2(key) = 1时即

是线性试探

法。

9.3.10

散列码转

换

作为词典

的散列表结

构，既不能假

定词条关键

码所属的类

型天然地支

持大小比较

，更不应将

关

键码仅限定

为整数类型

。为扩大散列

技术的适用

范围，散列函

数hash()必须能够

将任意类型

的关键码key映

射为地址空

间[0, M)内的一个

整数hash(key)，以便确

定key所对应的

散列地址。

由

关键码到散

列地址的映

射，如图9.19所示

通常可分解

为两步。

首先

，利用某一种

散列码转换

函数

hashCode()，将关键

码key统一转换

为

一个整数

称作散列码

（hash

code）；

然后，再利用

散列函数将

散列码映射

为

散列地址

。

图9.19

分两步将

仸意类型癿

关键码，映射

为桶地址

那

么，这里的散

列码转换函

数hashCode()应具备哪

些条件呢？

首

先，为支持后

续尺度不同

的散列空间

，以及种类各

异的散列函

数，作为中间

桥梁的散列

码，

取值范围

应覆盖系统

所支持的最

大整数范围

。其次，各关键

码经hashCode()映射后

所得的散列

码，相互之间

的冲突也应

尽可能减少

否则，这一阶

段即已出现

的冲突，后续

的hash()函数

注定

无法消除。最

后，hashCode()也应与判

等器保持一

致。也就是说

，被判等器判

定为相等的

词条，对应的

散列码应该

相等；反之亦

然（习题[9-20]）。

以下

针对一些常

见的数据类

型，列举若干

对应的散列

码转换方法

。

 强制转换为

整数

对于byte、short、int和

char等本身即可

表示为不超

过32位整数的

数据类型，可

直接将它

们

的这种表示

作为其散列

码。比如，可通

过类型强制

将它们转化

为32位的整数

。

§9.3 散列表

第9章

词典

276

 对成员

对象求和

long long和

double之类长度超

过32位的基本

类型，不宜强

制转换为整

数。否则，将因

原

有数位的

丢失而引发

大量冲突。可

行的办法是

，将高32位和低

32位分别看作

两个32位整数

，将

二者之和

作为散列码

。这一方法，可

推广至由任

意多个整数

构成的组合

对象。比如，可

将其成员

对

象各自对应

的整数累加

起来，再截取

低32位作为散

列码。

 多项式

散列码

与一

般的组合对

象不同，字符

串内各字符

之间的次序

具有特定含

义，故在做散

列码转换时

，

务必考虑它

们之间的次

序。以英文为

例，同一组字

母往往可组

成意义完全

不同的多个

单词，比如

"stop"和

"tops"等。而玩过“Swipe & Spell”之

类组词游戏

的读者，对此

应该理解更

深。

若简单地

将各字母分

别对应到整

数（比如1 ~ 26），并将

其总和作为

散列码，则很

多单词

都将

相互冲突。即

便是对于句

子等更长的

字符串，这一

问题也很突

出，且此时发

生冲突的可

能性

远高于

直观想象。比

如依照此法

，以下三个字

符串均相互

冲突：

"I am Lord

Voldemort"

"Tom Marvolo Riddle"

"He's Harry Potter"

以下则

是此类冲突

的另一实例

：

"Key to improving your

programming skill"

"Learning Tsinghua

Data Structure and Algorithm"

为计入各字

符的出现次

序，可取常数

a  2，并将字符串

"x0x1...xn-1"的散列码取

作：

x0a

n-1

+ x1a

n-2

+ ... + xn-2a

1

+ xn-1

这一转换

等效于，依次

将字符串中

的各个字符

，视作一个多

项式的各项

系数，故亦称

作多项

式散

列码（polynomial hash code）。其中的

常数a非常关

键，为尽可能

多地保留原

字符串的

信

息以减少冲

突，其低比特

位不得全为

零。另外，针对

不同类型的

字符串，应通

过实验确定

a的

最佳取值

。实验表明，对

于英语单词

之类的字符

串，a = 33、37、39或41都是不

错的选择。



hashCode()的

实现

针对若

干常见类型

，代码9.23利用重

载机制，实现

了散列码的

统一转换方

法hashCode()。

1 static

size_t hashCode ( char

c ) { return

( size_t ) c;

} //字符

2 static

size_t hashCode ( int

k ) { return

( size_t ) k;

} //整数

以及长长整

数

3 static

size_t hashCode ( long

long i ) {

return ( size_t )

( ( i >>

32 ) + (

int ) i );

}

4 static size_t

hashCode ( char s[]

) { //生成字符

串癿循环秱

位散列码（cyclic shift

hash code）

5 int

h = 0; //散

列码

6 for ( size_t

n = strlen (

s ), i =

0; i < n;

i++ ) //自左向

右，逐个处理

殏一字符

7

{ h = (

h << 5 )

| ( h >>

27 ); h +=

( int ) s[i];

} //散

列码循环左

秱5位，再累加

弼前字符

8 return

( size_t ) h;

//如

此所得癿散

列码，实际上

可理解为近

似癿“夗项式

散列码”

9 } //对亍

英语单词，"循

环左秱5位"是

实验统计得

出癿最佳值

代码9.23

散列码

转换函数hashCode()

读

者可视具体

应用的需要

，在此基础之

上继续补充

、扩展和尝试

更多的关键

码类型。

第9章

词典 §9.4

*散列应

用

277

§9.4

*散列应用

9.4.1 桶排序

 简单

情况

考查如

下问题：给定

[0, M)内的n个互异

整数（n  M），如何高

效地对其排

序？

自然，2.8节向

量排序器或

3.5节列表排序

器中的任一

排序算法，均

可完成这一

任务。但正

如

2.7.5节所指出的

，CBA式排序算法

注定在最坏

情况下需要

(nlogn)时间。实际上

，针对数值

类

型和取值范

围特定的这

一具体问题

，完全可在更

短的时间内

完成排序。

为

此，引入长度

为M的散列表

。比如，图9.20即为

取M

= 10和n = 5的一个

实例。

图9.20 刟用

散列表对一

组互异整数

排序

接下来

，使用最简单

的散列函数

hash(key) =

key，将这些整数

视作关键码

并逐一插入

散

列表中。最

后，顺序遍历

一趟该散列

表，依次输出

非空桶中存

放的关键码

，即可得到原

整数集合

的

排序结果。

该

算法借助一

组桶单元实

现对一组关

键码的分拣

，故称作桶排

序（bucketsort）。

该算法所

用散列表共

占O(M)空间。散列

表的创建和

初始化耗时

O(M)，将所有关键

码插入散

列

表耗时O(n)，依次

读出非空桶

中的关键码

耗时O(M)，故总体

运行时间为

O(n + M)。

 一般情况

若

将上述问题

进一步推广

：若允许输入

整数重复，又

该如何高效

地实现排序

？

图9.21

刟用散列

表对一组可

能重复癿整

数排序

依然

可以沿用以

上构思，只不

过这次需要

处理散列冲

突。具体地如

图9.21所示，不妨

采用

独立链

法排解冲突

。在将所有整

数作为关键

码插入散列

表之后，只需

一趟顺序遍

历将各非空

桶中

的独立

链依次串接

起来，即可得

到完整的排

序结果。而且

只要在串联

时留意链表

方向，甚至可

以

确保排序

结果的稳定

，故如此实现

的桶排序算

法属于稳定

算法。

§9.4 *散列应

用 第9章

词典

278

如此推广之

后的桶排序

算法，依然只

需为维护散

列表而使用

O(M)的额外空间

；算法各步骤

所耗费的时

间也与前一

算法相同，总

体运行时间

亦为O(n + M)。

其实，这

一问题十分

常见，它涵盖

了众多实际

应用中的具

体需求。此类

问题往往还

具有另一

特

点，即n >> M。比如，若

对清华大学

2011级本科生按

生日排序，则

大致有n

= 3300和M = 365。

而

在人口普查

之后若需对

全国人口按

生日排序，则

大致有：

n > 1,300,000,000

和 M < 365

 100 = 36,500

再

如，尽管邮局

每天需要处

理的往来信

函和邮包不

计其数，但因

邮政编码不

过6位，故分拣

系统若使用

“散列表”，其长

度至多不过

10^6。

参照此前的

分析可知，在

n >> M的场合，桶排

序算法的运

行时间将是

：

O(n + M) =

O(max(n, M)) = O(n)

线性正比于

待排序元素

的数目，突破

了(nlogn)的下界！

其

实这不足为

奇。以上基于

散列表的桶

排序算法，采

用的是循秩

访问的方式

，摒弃了以往

基

于关键码

大小比较式

的设计思路

，故自然不在

受到CBA式算法

固有的下界

约束。正因为

此，桶排

序在

算法设计方

面也占有其

独特的地位

，以下即是一

例。

9.4.2 最大间隙

试考查如下

问题：任意n个

互异点都将

实轴切割为

n + 1段，除去最外

侧无界的两

段，其余

有界

的n - 1段中何者

最大？若将相

邻点对之间

的距离视作

间隙，则该问

题可直观地

表述为，找

出

其中的最大

间隙（maximum

gap）。比如，图

9.22(a)就是n = 7的实例

。

图9.22

刟用散列

法，在线性时

间内确定n个

共线点乊间

癿最大间隒

 平凡算法

显

而易见的一

种方法是：先

将各点按坐

标排序；再顺

序遍历，依次

计算出各相

邻点对之间

的

间隙；遍历

过程中只需

不断更新最

大间隙的记

录，则最终必

将得到全局

的最大间隙

。

该算法的正

确性毋庸置

疑，但就时间

复杂度而言

，第一步常规

排序即需(nlogn)时

间，故

在最坏

情况下总体

运行时间将

不可能少于

这一下界。

那

么，能否实现

更高的效率

呢？采用散列

策略即可做

到！



散列

具体

方法如图9.22(b)所

示。首先，通过

一趟顺序扫

描找到最靠

左和最靠右

的点，将其坐

标

分别记作

lo和hi；然后，建立

一个长度为

n的散列表，并

使用散列函

数

hash(x)

= (n - 1)

* (x - lo)

/ (hi - lo)

将各点分

别插入对应

的桶单元，其

中x为各点的

坐标值，hash(x)为对

应的桶编号

。其效果相当

于：将有效区

间[lo, hi)均匀地划

分为宽度w = (hi

- lo) / (n

- 1)的

n - 1个左闭右开

区

间，分别对

应于第0至n - 2号

桶单元；另外

，hi独自占用第

n -

1号桶。

第9章 词

典 §9.4

*散列应用

279

然后，对散列

表做一趟遍

历，在每个非

空桶（黑色）内

部确定最靠

左和最靠右

的点，并删除

所有的空桶

（白色）。最后，只

需再顺序扫

描一趟散列

表，即可确定

相邻非空桶

之间的间隙

，记

录并报告

其中的最大

者，即为全局

的最大间隙

。



正确性

该算

法的正确性

基于以下事

实：n - 1个间隙中

的最宽者，绝

不可能窄于

这些间隙的

平均宽

度，而

后者同时也

是各桶单元

所对应区间

的宽度，故有

：

maxGap  w

= (hi - lo)

/ (n - 1)

这就意味着

，最大间隙的

两个端点绝

不可能落在

同一个桶单

元内。进一步

地，它们必然

来自

两个不

同的非空桶

（当然，它们之

间可能会还

有若干个空

桶），且左（右）端

点在前一（后

一）

非空桶中

应该最靠右

（左）故在散列

过程中只需

记录各桶中

的最左、最右

点。



复杂度

空

间方面，除了

输入本身这

里只需维护

一个散列表

，共占用O(n)的辅

助空间。

无论

是生成散列

表、找出各桶

最左和最右

点，还是计算

相邻非空桶

之间的间距

，并找出其中

的最大者，该

算法的每一

步均耗时O(n)。故

即便在最坏

情况下，累计

运行时间也

不超过O(n)。

9.4.3

基数

排序

 字典序

正如9.3.10节所指

出的，实际应

用环境中词

条的关键码

，未必都是整

数。比如，一种

常见

的情形

是，关键码由

多个域（字段

）组合而成，并

采用所谓的

字典序（lexicographical

order）

确定

大小次序：任

意两个关键

码之间的大

小关系，取决

于它们第一

个互异的域

。

请注意，同一

关键码内各

字段的类型

也未必一致

。例如日期型

关键码，可分

解为year（年）、

month（月）和

day（日）三个整数

字段，并按常

规惯例，以“年

-月-日”的优先

级定义字典

序。

再如扑克

牌所对应的

关键码，可以

分解为枚举

型的suite（花色）和

整型的number（点数

）。

于是，若按照

桥牌的约定

，以“花色-点数

”为字典序，则

每副牌都可

按大小排列

为：

A >

K > Q >

J > 10 >

... > 2 >

A > K >

Q > J >

10 > ... >

2 > 

A

> K > Q

> J > 10

> ... > 2

> 

A >

K > Q >

J > 10 >

... > 2

一般地，对

于任意一组

此类关键码

，又该如何高

效地排序呢

？

 低位优先的

多趟桶排序

这里不妨假

定，各字段类

型所对应的

比较器均已

就绪，以将精

力集中于如

何高效实现

依字典

序的

排序。实际上

通过重写比

较器，以下算

法完全可以

推广至一般

情况。

假设关

键码由t个字

段{ kt, kt-1, ...,

k1 }组成，其中

字段kt（k1）的优先

级最高（低）。

于

是，以其中任

一字段ki为关

键码，均可调

用以上桶排

序算法做一

趟排序。稍后

我们将证明

，

只需按照优

先级递增的

次序（从k1到kt）针

对每一字段

各做一趟桶

排序，即可实

现按整个关

键码

字典序

的排序。

这一

算法称作基

数排序（radixsort），它采

用了低位字

段优先（least significant digit

first）的策

略。其中所做

桶排序的趟

数，取决于组

成关键码的

字段数。

§9.4 *散列

应用 第9章

词

典

280

 实例

表9.3给

出了一个基

数排序的实

例，其中待排

序的7个关键

码均可视作

由百位、十位

和个位

共三

个数字字段

组成。

表9.3 基数

排序实例

输

入序列 4 4 1

2 7 6 3

2 0 2 1

4 6 9 8

2 8 0 1

1 2

以个

位排序 3

2 0 2 8

0 4 4 1

1 1 2 2

1 4 2 7

6 6 9 8

以十

位排序 1 1 2

2 1 4 3

2 0 4 4

1 2 7 6

2 8 0 6

9 8

以百

位排序 1

1 2 2 1

4 2 7 6

2 8 0 3

2 0 4 4

1 6 9 8

可见

，在分别针对

个位、十位和

百位做过一

趟桶排序之

后，最终的确

得到了正确

的排序结果

。

这一成功绝

非偶然或幸

运，整个算法

的正确性可

用数学归纳

法证明。

 正确

性与稳定性

我们以如下

命题作为归

纳假设：在经

过基数排序

的前i趟桶排

序之后，所有

词条均已按

照关

键码最

低的i个字段

有序排列。

作

为归纳的起

点，在i = 1时这一

假设不证自

明。现在假定

该命题对于

前i

- 1趟均成立

，

继续考查第

i趟桶排序做

过之后的情

况。

任取一对

词条，并比较

其关键码的

第i个字段，无

非两种情况

。其一，二者的

这一字段不

等。

此时，由于

刚刚针对该

字段做过一

趟桶排序，故

二者的排列

次序不致颠

倒。其二，二者

的这一字

段

相等。此时，二

者的大小实

际上取决于

最低的i - 1个字

段。若采用9.4.1节

所实现的桶

排序

算法，则

得益于其稳

定性，由归纳

假设可知这

对词条在前

一趟桶排序

后正确的相

对次序将得

以延

续。整个

基数排序算

法的正确性

由此得证。

由

以上分析也

可发现，如此

实现的基数

排序算法同

样也是稳定

的。



复杂度

根

据以上基数

排序的流程

，总体运行时

间应等于其

中各趟桶排

序所需时间

的总和。

设各

字段取值范

围为[0, Mi)，1

 i  t。若记

M = max{ m1,

m2, ..., mt }

则

总体运行时

间不超过：

 O(n +

M1) + O(n +

M2) + ... +

O(n + Mt)

=

O(t * (n +

M))

第

10章

优先级队

列

§10.1

优先级队

列ADT 第10章 优先

级队列

282

此前

的搜索树结

构和词典结

构，都支持覆

盖数据全集

的访问和操

作。也就是说

，其中存储的

每一数据对

象都可作为

查找和访问

目标。为此，搜

索树结构需

要在所有元

素之间定义

并维护一个

显式的全序

（full order）关系；而词典

结构中的数

据对象之间

，尽管不必支

持比较大小

，但

在散列表

之类的具体

实现中，都从

内部强制地

在对象的数

值与其对应

的秩之间，建

立起某种关

联

（尽管实际

上这种关联

通常越“随机

”越好），从而隐

式地定义了

一个全序次

序。

就对外接

口的功能而

言，本章将要

介绍的优先

级队列，较之

此前的数据

结构反而有

所削弱。

具体

地，这类结构

将操作对象

限定于当前

的全局极值

者。比如，在全

体北京市民

中，查找年龄

最

长者；或者

在所有鸟类

中，查找种群

规模最小者

，等等。这种根

据数据对象

之间相对优

先级对其

进

行访问的方

式，与此前的

访问方式有

着本质区别

，称作循优先

级访问（call-by-priority）。

当然

，“全局极值”本

身就隐含了

“所有元素可

相互比较”这

一性质。然而

，优先级队列

并

不会也不

必忠实地动

态维护这个

全序，却转而

维护一个偏

序（partial order）关系。其高

明之

处在于

，如此不仅足

以高效地支

持仅针对极

值对象的接

口操作，更可

有效地控制

整体计算成

本。

正如我们

将要看到的

，对于常规的

查找、插入或

删除等操作

，优先级队列

的效率并不

低于此前的

结构；而对于

数据集的批

量构建及相

互合并等操

作，其性能却

更胜一筹。作

为不失高效

率的轻量

级

数据结构，优

先级队列在

许多领域都

是扮演着不

可替代的角

色。

§10.1 优先级队

列ADT

10.1.1 优先级与

优先级队列

除了作为存

放数据的容

器，数据结构

还应能够按

某种约定的

次序动态地

组织数据，以

支持高

效的

查找和修改

操作。比如4.5节

的队列结构

，可用以描述

和处理日常

生活中的很

多问题：在银

行排队等候

接受服务的

客户，提交给

网络打印机

的打印任务

等，均属此列

。在这类问题

中，无论

客户

还是打印任

务，接受服务

或处理的次

序完全取决

于其出现的

时刻先到的

客户优先接

受服

务，先提

交的打印任

务优先执行

此即所谓“先

进先出”原则

。

然而在更多

实际应用环

境中，这一简

单公平的原

则并不能保

证整体效率

必然达到最

高。试想，

若干

病人正在某

所医院的门

诊处排队等

候接受治疗

，忽然送来一

位骨折的病

人。要是固守

“先进

先出”的

原则，那么他

只能咬牙坚

持到目前已

经到达的每

位病人都已

接受过治疗

之后。显然，那

样的话该病

人将承受更

长时间的痛

苦，甚至贻误

治疗的最佳

时机。因此，医

院在此时都

会灵活变

通

，优先治疗这

位骨折的病

人。同理，若此

时又送来一

位心脏病突

发的患者，那

么医生肯定

也会

暂时把

骨折病人放

在一边（如果

没有更多医

生的话），转而

优先抢救心

脏病人。

由此

可见，在决定

病人接受治

疗次序时，除

了他们到达

医院的先后

次序，更应考

虑到病情的

轻重缓急，优

先治疗病情

最为危重的

病人。在数据

结构与算法

设计中，类似

的例子也屡

见不鲜。

在3.5.3节

的选择排序

算法中，每一

步迭代都要

调用selectMax()，从未排

序区间选出

最大者。

在5.5.3节

的Huffman编码算法

中，每一步迭

代都要调用

minHChar()，从当前的森

林中选出权

重

第10章 优先

级队列 §10.1

优先

级队列ADT

283

最小

的超字符。在

基于空间扫

描策略的各

种算法中，每

一步迭代都

要根据到当

前扫描线的

距离，

取出并

处理最近的

下一个事件

点。

从数据结

构的角度看

，无论是待排

序节点的数

值、超字符的

权重，还是事

件的发生时

间，数

据项的

某种属性只

要可以相互

比较大小，则

这种大小关

系即可称作

优先级（priority）。而按

照事先约定

的优先级，可

以始终高效

查找并访问

优先级最高

数据项的数

据结构，也统

称作优先级

队列（priority queue）。

10.1.2

关键码

、比较器与偏

序关系

仿照

词典结构，我

们也将优先

级队列中的

数据项称作

词条（entry）；而与特

定优先级相

对

应的数据

属性，也称作

关键码（key）。不同

应用中的关

键码，特点不

尽相同：有时

限定词条的

关键码须互

异，有时则允

许词条的关

键码雷同；有

些词条的关

键码一成不

变，有些则可

动态修改；

有

的关键码只

是一个数字

、一个字符或

一个字符串

，而复杂的关

键码则可能

由多个基本

类型组合

而

成；多数关键

码都取作词

条内部的某

一成员变量

，而有的关键

码则并非词

条的天然属

性。

无论具体

形式如何，作

为确定词条

优先级的依

据，关键码之

间必须可以

比较大小注

意，

这与词典

结构完全不

同，后者仅要

求关键码支

持判等操作

。因此对于优

先级队列，必

须以比较器

的形式兑现

对应的优先

级关系。出于

简化的考虑

，与此前各章

一样，本章依

然假定关键

码或者可

直

接比较，或者

已重载了对

应的操作符

。

需特别留意

的另一点是

，尽管定义了

明确的比较

器即意味着

在任何一组

词条之间定

义了一个

全

序关系，但正

如2.7节所指出

的，严格地维

护这样一个

全序关系必

将代价不菲

。实际上，优先

级队列作为

一类独特数

据结构的意

义恰恰在于

，通过转而维

护词条集的

一个偏序关

系。如此，不

仅

依然可以支

持对最高优

先级词条的

动态访问，而

且可将相应

的计算成本

控制在足以

令人满意的

范围之内。

10.1.3

操

作接口

优先

级队列接口

的定义说明

如表10.1所示。

表

10.1 优先级队列

ADT支持癿操作

接口

操 作 接

口 功

能 描 述

size() 报告优先级

队列癿觃模

，即其中词条

癿总数

insert() 将指

定词条揑入

优先级队列

getMax() 迒回优先级

最大癿词条

（若优先级队

列非空）

delMax()

初除

优先级最大

癿词条（若优

先级队列非

空）

需要说明

的是，本章允

许在同一优

先级队列中

出现关键码

雷同的多个

词条，故insert()操

作

必然成功，因

此该接口自

然不必返回

操作成功标

志。

10.1.4

操作实例

：选择排序

即

便仍不清楚

其具体实现

，我们也已经

可以按照以

上ADT接口，基于

优先级队列

描述和实现

各种算法。比

如，实现和改

进3.5.3节所介绍

的选择排序

算法。

§10.1 优先级

队列ADT

第10章 优

先级队列

284

具

体的构思如

下：将待排序

的词条组织

为一个优先

级队列，然后

反复调用delMax()接

口，

即可按关

键码由大而

小的次序逐

一输出所有

词条，从而得

到全体词条

的排序序列

。

例如，针对某

7个整数的这

一排序过程

，如表10.2所示。

表

10.2 优先级队列

操作实例：选

择排序（当前

癿最大元素

以斱框示意

）

操 作 优 先

级

队 列 输 出

initialization { 441, 276,

320, 214, 698, 280,

112 }

size() [unchanged]

7

delMax() { 441,

276, 320, 214, 280,

112 } 698

size()

[unchanged] 6

delMax() {

276, 320, 214, 280,

112 } 441

delMax()

{ 276, 214, 280,

112 } 320

delMax()

{ 276, 214, 112

} 280

delMax() {

214, 112 } 276

delMax() { 112 }

214

size() [unchanged] 1

delMax() { } 112

size() [unchanged] 0

10.1.5

接

口定义

如代

码10.1所示，这里

以模板类PQ的

形式给出以

上优先级队

列的操作接

口定义。

1 template

<typename T> struct PQ

{ //优先

级队列PQ模板

类

2 virtual

void insert ( T

) = 0; //按照比较

器确定癿优

先级次序揑

入词条

3 virtual T getMax()

= 0; //叏出

优先级最高

癿词条

4

virtual T delMax() =

0; //初除

优先级最高

癿词条

5 };

代码

10.1 优先级队列

标准接口

因

为这一组基

本的ADT接口可

能有不同的

实现方式，故

这里均以虚

函数形式统

一描述这些

接

口，以便在

不同的派生

类中具体实

现。

10.1.6 应用实例

：Huffman编码树

回到

5.4节Huffman编码的应

用实例。实际

上，基于以上

优先级队列

的标准接口

，即可实现

统

一的Huffman编码算

法无论优先

级队列的具

体实现方式

如何。

 数据结

构

为利用统

一的优先级

队列接口实

现Huffman编码并对

不同方法进

行对比，不妨

继续沿用代

码

5.29至代码5.33所

定义的Huffman超字

符、Huffman树、Huffman森林、Huffman编

码表、Huffman

二进制

编码串等数

据结构。

第10章

优先级队列

§10.1 优先级队列

ADT

285

 比较器

若将

Huffman森林视作优

先级队列，则

其中每一棵

树（每一个超

字符）即是一

个词条。为保

证词条之间

可以相互比

较，可如代码

5.29（145页）所示重载

对应的操作

符。进一步地

，因超字

符的

优先级可度

量为其对应

权重的负值

，故不妨将大

小关系颠倒

过来，令小权

重超字符的

优先级

更高

，以便于操作

接口的统一

。

这一技巧也

可运用于其

它场合。仍以

10.1.4节的选择排

序为例，在将

大小的定义

颠倒之后，

无

需修改其它

代码，即可实

现反方向的

排序。



编码算

法

经上述准

备，代码10.2即可

基于统一优

先级队列接

口给出通用

的Huffman编码算法

。

1 /******************************************************************************************

2 * Huffman树极造算法

：对传入癿Huffman森

枃forest逐步合幵

，直刡成为一

棵树

3

******************************************************************************************

4 * forest基亍优

先级队列实

现，此算法适

用亍符合PQ接

口癿仸何实

现斱式

5 * 为Huffman_PQ_List、Huffman_PQ_ComplHeap和

Huffman_PQ_LeftHeap共用

6

* 编译前

对应工程叧

需讴置相应

标志：DSA_PQ_List、DSA_PQ_ComplHeap戒DSA_PQ_LeftHeap

7 ******************************************************************************************/

8 HuffTree* generateTree (

HuffForest* forest ) {

9 while ( 1

< forest->size() ) {

10 HuffTree* s1 =

forest->delMax(); HuffTree* s2 =

forest->delMax();

11 HuffTree* s

= new HuffTree();

12

s->insertAsRoot ( HuffChar (

'^', s1->root()->data.weight + s2->root()->data.weight

) );

13 s->attachAsLC

( s->root(), s1 );

s->attachAsRC ( s->root(), s2

);

14 forest->insert (

s ); //将合

幵后癿Huffman树揑

回Huffman森枃

15

}

16 HuffTree* tree

= forest->delMax(); //至此

，森枃中癿最

后一棵树

17

return tree; //即

全尿Huffman编码树

18 }

代码10.2 刟用统

一癿优先级

队列接口，实

现通用癿Huffman编

码

 效率分析

相对于如代

码5.36（147页）所示的

版本，这里只

不过将minHChar()替换

为PQ::delMax()

标准接口

。正如我们很

快将要看到

的，优先级队

列的所有ADT操

作均可在O(logn)时

间内完成，

故

generateTree()算法也相应

地可在O(nlogn)时间

内构造出Huffman编

码树较之原

版本，

改进显

著。同理，通过

引入优先级

队列，将如代

码3.20（81页）所示的

selectMax()替换为

PQ::delMax()标准

接口，也可自

然地将选择

排序的性能

由O(n2

)改进至O(nlogn)。

自

然地，这一结

论可以推广

至任一需要

反复选取优

先级最高元

素的应用问

题，并可直接

改进

相关算

法的时间效

率。那么，作为

基础性数据

结构的优先

级队列，是否

的确可以保

证getMax()、

delMax()和insert()等接口

效率均为O(logn)？具

体地，又应如

何实现？

实际

上，借助无序

列表、有序列

表、无序向量

或有序向量

，都难以同时

兼顾insert()和

delMax()操作

的高效率（习

题[10-1]）。因此，必须

另辟蹊径，寻

找更为高效

的实现方法

。

§10.2 堆

第10章 优先

级队列

286

§10.2

堆

基

于列表或向

量等结构的

实现方式，之

所以无法同

时保证insert()和delMax()操

作的高效

率

，原因在于其

对优先级的

理解过于机

械，以致始终

都保存了全

体词条之间

的全序关系

。实际上，

尽管

优先级队列

的确隐含了

“所有词条可

相互比较”这

一条件，但从

操作接口层

面来看，并不

需

要真正地

维护全序关

系。比如执行

delMax()操作时，只要

能够确定全

局优先级最

高的词条即

可；

至于次高

者、第三高者

等其余词条

，目前暂时不

必关心。

有限

偏序集的极

值必然存在

，故此时借助

堆（heap）结构维护

一个偏序关

系即足矣。堆

有

多种实现

形式，以下首

先介绍其中

最基本的一

种形式完全

二叉堆（complete

binary heap）。

10.2.1 完全

二叉堆

 结构

性与堆序性

如图10.1实例所

示，完全二叉

堆应满足两

个条件。

图10.1 以

获奖先后为

优先级，由前

12届图灵奖得

主极成癿完

全事叉堆

首

先，其逻辑结

构须等同于

完全二叉树

，此即所谓的

“结构性”。如此

，堆节点将与

词条一

一对

应，故此后凡

不致引起误

解时，我们将

不再严格区

分“堆节点”与

“词条”。其次，就

优先

级而言

，堆顶以外的

每个节点都

不高（大）于其

父节点，此即

所谓的“堆序

性”。



大顶堆与

小顶堆

由堆

序性不难看

出，堆中优先

级最高的词

条必然始终

处于堆顶位

置。因此，堆结

构的getMax()

操作总

是可以在O(1)时

间内完成。

堆

序性也可对

称地约定为

“堆顶以外的

每个节点都

不低（小）于其

父节点”，此时

同理，优

先级

最低的词条

，必然始终处

于堆顶位置

。为以示区别

，通常称前（后

）者为大（小）顶

堆。

小顶堆和

大顶堆是相

对的，而且可

以相互转换

。实际上，我们

不久之前刚

刚见过这样

的一个

实例

在代码5.29中重

载Huffman超字符的

比较操作符

时，通过对超

字符权重取

负，颠倒优先

级关系，使之

与算法的实

际语义及需

求相吻合。

第

10章

优先级队

列 §10.2 堆

287

 高度

结

构等同于完

全二叉树的

堆，必然不致

太高。具体地

，由5.5.2节的分析

结论，n个词条

组

成的堆的

高度h

= log2n = O(logn)。稍后我

们即将看到

，insert()和delMax()操作的时

间

复杂度将

线性正比于

堆的高度h，故

它们均可在

O(logn)的时间内完

成。

 基于向量

的紧凑表示

尽管二叉树

不属于线性

结构，但作为

其特例的完

全二叉树，却

与向量有着

紧密的对应

关系。

图10.2

按照

局次遍历序

列，对完全事

叉树节点做

编号（其中囿

形表示内部

节点，斱形表

示外部节点

）

由图10.2可见，完

全二叉堆的

拓扑联接结

构，完全由其

规模n确定。按

照层次遍历

的次序，

每个

节点都对应

于唯一的编

号；反之亦然

。故若将所有

节点组织为

一个向量，则

堆中各节点

（编

号）与向量

各单元（秩）也

将彼此一一

对应！

这一实

现方式的优

势首先体现

在，各节点在

物理上连续

排列，故总共

仅需O(n)空间。而

更

重要地是

，利用各节点

的编号（或秩

），也可便捷地

判别父子关

系。

具体地，若

将节点v的编

号（秩）记作i(v)，则

根节点及其

后代节点的

编号分别为

：

i(root)

= 0

i(lchild(root)) =

1

i(rchild(root)) = 2

i(lchild(lchild(root)) = 3

...

更一般地，不

难验证，完全

二叉堆中的

任意节点v，必

然满足：

1）若v有

左孩子，则i(lchild(v)) = 2∙i(v)

+ 1；

2）若

v有右孩子，则

i(rchild(v)) =

2∙i(v) + 2；

3）若v有父节点

，则i(parent(v))

= (i(v) - 1)/2

= (i(v)/2 - 1

最后，由于

向量支持低

分摊成本的

扩容调整，故

随着堆的规

模和内容不

断地动态调

整，除标

准接

口以外的操

作所需的时

间可以忽略

不计。

所有这

些良好的性

质，不仅为以

下基于向量

实现堆结构

提供了充足

的理由，同时

也从基本的

原理和方法

的层面提供

了有力的支

持。

§10.2

堆 第10章 优

先级队列

288

 宏

为简化后续

算法的描述

及实现，可如

代码10.3所示预

先设置一系

列的宏定义

。

1 #define

InHeap(n, i) ( (

( -1 ) <

( i ) )

&& ( ( i

) < ( n

) ) ) //刞断PQ[i]是否合

法

2 #define Parent(i) (

( i - 1

) >> 1 )

//PQ[i]癿父节点

（floor((i-1)/2)，i无讳正负）

3 #define LastInternal(n)

Parent( n - 1

) //最

后一个内部

节点（即末节

点癿父亲）

4 #define

LChild(i) ( 1 +

( ( i )

<< 1 ) )

//PQ[i]癿

左孩子

5 #define RChild(i)

( ( 1 +

( i ) )

<< 1 ) //PQ[i]癿右

孩子

6 #define ParentValid(i) (

0 < i )

//刞断PQ[i]是

否有父亲

7 #define LChildValid(n,

i) InHeap( n, LChild(

i ) ) //刞

断PQ[i]是否有一

个（左）孩子

8 #define RChildValid(n, i)

InHeap( n, RChild( i

) ) //刞

断PQ[i]是否有两

个孩子

9

#define Bigger(PQ, i, j)

( lt( PQ[i], PQ[j]

) ? j :

i ) //叏大

者（等时前者

优先）

10

#define ProperParent(PQ, n, i)

/*父子（至

夗）三者中癿

大者*/ \

11 (

RChildValid(n, i) ? Bigger(

PQ, Bigger( PQ, i,

LChild(i) ), RChild(i) )

: \

12 (

LChildValid(n, i) ? Bigger(

PQ, i, LChild(i) )

: i \

13

) \

14 )

//相等时

父节点优先

，如此可避免

丌必要癿交

换

代码10.3 为简

化完全事叉

堆算法癿描

述及实现而

定义癿宏



PQ_ComplHeap模

板类

按照以

上思路，可以

借助多重继

承的机制，定

义完全二叉

堆模板类如

代码10.4所示。

1 #include

"../Vector/Vector.h" //倚

劣夗重继承

机刢，基亍向

量

2 #include

"../PQ/PQ.h" //按照优先

级队列ADT实现

癿

3 template

<typename T> class PQ_ComplHeap

: public PQ<T>, public

Vector<T> { //完全二叉

堆

4

protected:

5 Rank percolateDown

( Rank n, Rank

i ); //下滤

6

Rank percolateUp ( Rank

i ); //上滤

7 void

heapify ( Rank n

); //Floyd建堆算法

8 public:

9 PQ_ComplHeap() { }

//默

讣极造

10 PQ_ComplHeap (

T* A, Rank n

) { copyFrom (

A, 0, n );

heapify ( n );

} //批量

极造

11 void

insert ( T );

//按照比

较器确定癿

优先级次序

，揑入词条

12 T getMax();

//读

叏优先级最

高癿词条

13 T delMax();

//初

除优先级最

高癿词条

14 }; //PQ_ComplHeap

代

码10.4 完全事叉

堆接口

 getMax()

既然

全局优先级

最高的词条

总是位于堆

顶，故如代码

10.5所示，只需返

回向量的首

单元，

即可在

O(1)时间内完成

getMax()操作。

1 template

<typename T> T PQ_ComplHeap<T>::getMax()

{ return _elem[0]; }

//叏优先

级最高癿词

条

代码10.5 完全

事叉堆getMax()接口

第10章 优先级

队列

§10.2 堆

289

10.2.2

元素

插入

本节介

绍插入操作

insert()的实现。因堆

中的节点与

其中所存词

条以及词条

的关键码完

全

对应，故沿

用此前的习

惯，在不致歧

义的前提下

，以下对它们

将不再严格

区分。



算法

如

代码10.6所示，插

入算法分为

两个步骤。

1 template

<typename T> void PQ_ComplHeap<T>::insert

( T e )

{ //将

词条揑入完

全二叉堆中

2 Vector<T>::insert (

e ); //首先将新词

条接至向量

末尾

3

percolateUp ( _size -

1 ); //再对诠

词条实斲上

滤调整

4

}

代码

10.6 完全事叉堆

insert()接口癿主体

框架

首先，调

用向量的标

准插入接口

，将新词条接

至向量的末

尾。得益于向

量结构良好

的封装性，

这

里无需关心

这一步骤的

具体细节，尤

其是无需考

虑溢出扩容

等特殊情况

。

图10.3 完全事叉

堆词条揑入

过秳

尽管此

时如图10.3(a)所示

，新词条的引

入并未破坏

堆的结构性

，但只要新词

条e不是堆顶

，

就有可能与

其父亲违反

堆序性。

当然

，其它位置的

堆序性依然

满足。故以下

将调用percolateUp()函数

，对新接入的

词条

做适当

调整，在保持

结构性的前

提下恢复整

体的堆序性

。



上滤

不妨假

定原堆非空

，于是新词条

e的父亲p（深色

节点）必然存

在。根据e在向

量中对应的

秩，

可以简便

地确定词条

p对应的秩，即

i(p) =

(i(e) - 1)/2。

此时，若经比

较判定e

 p，则堆

序性在此局

部以至全堆

均已满足，插

入操作因此

即告完成。

反

之，若e >

p，则可在

向量中令e和

p互换位置。如

图10.3(b)所示，如此

不仅全堆的

结构性依

然

满足，而且e和

p之间的堆序

性也得以恢

复。

当然，此后

e与其新的父

亲，可能再次

违背堆序性

。若果真如此

，不妨继续套

用以上方法

，

如图10.3(c)所示令

二者交换位

置。当然，只要

有必要，此后

可以不断重

复这种交换

操作。

每交换

一次，新词条

e都向上攀升

一层，故这一

过程也形象

地称作上滤

（percolate up）。

当然，e至多上

滤至堆顶。一

旦上滤完成

，则如图10.3(d)所示

，全堆的堆序

性必将恢复

。

由上可见，上

滤调整过程

中交换操作

的累计次数

，不致超过全

堆的高度log2n。而

在向量

中，每

次交换操作

只需常数时

间，故上滤调

整乃至整个

词条插入算

法整体的时

间复杂度，均

为

O(logn)。这也是从

一个方面，兑

现了10.1节末尾

就优先级队

列性能所做

的承诺。

§10.2 堆

第

10章 优先级队

列

290



最坏情况

与平均情况

当然，不难通

过构造实例

说明，新词条

有时的确需

要一直上滤

至堆顶。然而

实际上，此类

最

坏情况通

常极为罕见

。以常规的随

机分布而言

，新词条平均

需要爬升的

高度，要远远

低于直觉的

估计（习题[10-6]）。在

此类场合中

，优先级队列

相对于其它

数据结构的

性能优势，也

因这一

特性

得到了进一

步的巩固。



实

例

通过上滤

调整实现插

入操作的一

个实例，如图

10.4所示。图中上

方为完全堆

的拓扑联接

结

构，下方为

物理上与之

对应的线性

存储结构。

图

10.4

完全事叉堆

词条揑入操

作实例

在如

图(a)所示由5个

元素组成的

初始完全堆

中，现拟插入

关键码为5的

新元素。为此

，首先

如图(b)所

示，将该元素

置于向量的

末尾。此时，新

元素5与其父

节点0逆序，故

如图(c)所示，

经

一次交换之

后，新元素5上

升一层。此后

，新元素5与其

新的父节点

4依然逆序，故

如图(d)所

示，经

一次交换后

再上升一层

。此时因已抵

达堆顶，插入

操作完毕，故

算法终止。

 实

现

以上调整

在向量中的

具体操作过

程，可描述和

实现如代码

10.7所示。

1 //对向量

中癿第i个词

条实斲上滤

操作，i < _size

2 template <typename T>

Rank PQ_ComplHeap<T>::percolateUp ( Rank

i ) {

3

while ( ParentValid (

i ) ) {

//叧要i有

父亲（尚未抵

达堆顶），则

4 Rank j

= Parent ( i

); //将

i乀父记作j

5 if

( lt ( _elem[i],

_elem[j] ) ) break;

//一

旦弼前父子

丌再逆序，上

滤旋即完成

6 swap ( _elem[i],

_elem[j] ); i =

j; //否则，父子交

换位置，幵继

续考查上一

局

7 }

//while

8 return i;

//迒回上滤

最终抵达癿

位置

9 }

代码10.7

完

全事叉堆癿

上滤

其中为

简化描述而

使用的Parent()、ParentValid()等快

捷方式，均以

宏的形式定

义如代

码10.3所

示。

需说明的

是，若仅考虑

插入操作，则

因被调整词

条的秩总是

起始于n

- 1，故无

需显式地指

第10章 优先级

队列 §10.2

堆

291

定输

入参数i。然而

，考虑到上滤

调整可能作

为一项基本

操作用于其

它场合（习题

[10-12]），

届时被调整

词条的秩可

能任意，故为

保持通用性

，这里不妨保

留一项参数

以指定具体

的起始位置

。

 改进

在如代

码10.7所示的版

本中，最坏情

况下在每一

层次都要调

用一次swap()，该操

作通常包

含

三次赋值。实

际上，只要注

意到，参与这

些操作的词

条之间具有

很强的相关

性，则不难改

进为

平均每

层大致只需

一次赋值（习

题[10-3]）；而若能充

分利用内部

向量“循秩访

问”的特性，

则

大小比较操

作的次数甚

至可以更少

(习题[10-4]）。

10.2.3 元素删

除

 算法

下面

再来讨论delMax()方

法的实现。如

代码10.8所示，删

除算法也分

为两个步骤

。

1

template <typename T> T

PQ_ComplHeap<T>::delMax() { //初除非空完

全二叉堆中

优先级最高

癿词条

2

T maxElem = _elem[0];

_elem[0] = _elem[ --_size

]; //摘除

堆顶（首词条

），代乀以末词

条

3 percolateDown

( _size, 0 );

//对新堆顶

实斲下滤

4 return maxElem;

//迒

回此前备仹

癿最大词条

5 }

代码10.8 完全事

叉堆delMax()接口癿

主体框架

首

先，既然待删

除词条r总是

位于堆顶，故

可直接将其

取出并备份

。此时如图10.5(a)所

示，

堆的结构

性将被破坏

。为修复这一

缺陷，可如图

(b)所示，将最末

尾的词条e转

移至堆顶。

图

10.5 完全事叉堆

词条初除过

秳

当然，新的

堆顶可能与

其孩子（们）违

背堆序性尽

管其它位置

的堆序性依

然满足。故以

下调用percolateDown()函数

调整新堆顶

，在保持结构

性的前提下

，恢复整体的

堆序性。

 下滤

若新堆顶e不

满足堆序性

，则可如图10.5(c)所

示，将e与其（至

多）两个孩子

中的大者（图

中深色节点

）交换位置。与

上滤一样，由

于使用了向

量来实现堆

，根据词条e的

秩可便捷地

确定

其孩子

的秩。此后，堆

中可能的缺

陷依然只能

来自于词条

e它与新孩子

可能再次违

背堆序性。

若

果真如此，不

妨继续套用

以上方法，将

e与新孩子中

的大者交换

，结果如图(d)所

示。实际上，

只

要有必要，此

后可如图(e)和

(f)不断重复这

种交换操作

。

因每经过一

次交换，词条

e都会下降一

层，故这一调

整过程也称

作下滤（percolate down）。

与上

滤同理，这一

过程也必然

终止。届时如

图(f)所示，全堆

的堆序性必

将恢复；而且

，下滤乃

至整

个删除算法

的时间复杂

度也为O(logn)同样

，这从另一方

面兑现了此

前的承诺。

§10.2 堆

第10章

优先级

队列

292

 实例

通

过下滤变换

实现删除操

作的一个实

例，如图10.6所示

。同样地，图中

上方和下方

分别为

完全

堆的拓扑结

构以及对应

的线性存储

结构。

图10.6 完全

事叉堆词条

初除操作实

例

从如图(a)所

示由6个元素

组成的完全

堆中，现拟删

除堆顶元素

5。为此，首先如

图(b)所示

将该

元素摘除，并

将向量的末

元素1转入首

单元，权作堆

顶。此后，1与其

孩子节点均

逆序。故如

图

(c)所示，在与其

孩子中的大

者4交换之后

，1下降一层。此

后，1与其新的

孩子2依然逆

序，故

如图(d)所

示经又一次

交换后再下

降一层。此时

因1已抵达底

层，删除操作

完毕，算法成

功终止。

 实现

以上调整在

向量中的具

体操作过程

，可描述和实

现如代码10.9所

示。

1 //对向量前

n个词条中癿

第i个实斲下

滤，i

< n

2 template

<typename T> Rank PQ_ComplHeap<T>::percolateDown

( Rank n, Rank

i ) {

3

Rank j; //i及其（至夗

两个）孩子中

，堪为父者

4

while ( i !=

( j = ProperParent

( _elem, n, i

) ) ) //叧

要i非j，则

5 { swap (

_elem[i], _elem[j] ); i

= j; } //二者

换位，幵继续

考查下降后

癿i

6 return i; //迒回下滤

抵达癿位置

（亦i亦j）

7 }

代码10.9 完

全事叉堆癿

下滤

这里为

简化算法描

述使用了宏

ProperParent()，其定义如288页

代码10.3所示。

出

于与上滤操

作同样的考

虑（习题[10-12]），这里

也可通过输

入参数i，灵活

地指定起始

位置。此前针

对上滤操作

所建议的改

进方法，有的

也同样适用

于下滤操作

（习题[10-3]），但

有的

却不再适用

（习题[10-4]）。

10.2.4

建堆

很

多算法中输

入词条都是

成批给出，故

在初始化阶

段往往需要

解决一个共

同问题：给定

一组

词条，高

效地将它们

组织成一个

堆。这一过程

也称作“建堆

”（heapification）。本节就以完

全二叉堆为

例介绍相关

的算法。当然

，以下算法同

样也适用其

它类型的堆

。



蛮力算法

乍

看起来，建堆

似乎并不成

其为一个问

题。既然堆符

合优先级队

列ADT规范，那么

从空堆起

第

10章 优先级队

列

§10.2 堆

293

反复调

用标准insert()接口

，即可将输入

词条逐一插

入其中，并最

终完成建堆

任务。很遗憾

，

尽管这一方

法无疑正确

，但其消耗的

时间却过多

。具体地，若共

有n个词条，则

共需迭代n次

。由

10.2.2节的结论

，第k轮迭代耗

时O(logk)，故累计耗

时间量应为

：

O(log1 +

log2 + ... +

logn) = O(logn!) =

O(nlogn)

或许对某些

具体问题而

言，后续操作

所需的时间

比这更多（或

至少不更少

），以致建堆操

作

是否优化

对总体复杂

度无实质影

响。但换个角

度看，如此多

的时间本来

足以对所有

词条做全排

序，

而在这里

花费同样多

时间所生成

的堆却只能

提供一个偏

序。这一事实

在某种程度

上也暗示着

，或

许存在某

种更快的建

堆算法。此外

，的确有些算

法的总体时

间复杂度主

要取决于堆

初始化阶段

的

效率，因此

探索并实现

复杂度为o(nlogn)的

建堆算法也

十分必要。

 自

上而下的上

滤

尽管蛮力

算法的效率

不尽如人意

，其实现过程

仍值得分析

和借鉴。在将

所有输入词

条纳入长

为

n的向量之后

，首单元处的

词条本身即

可视作一个

规模为1的堆

。接下来，考查

下一单元中

的词

条。不难

看出，为将该

词条插入当

前堆，只需针

对调用percolateUp()对其

上滤。此后，前

两个

单元将

构成规模为

2的堆。以下同

理，若再对第

三个词条上

滤，则前三个

单元将构成

规模为3的堆

。

实际上，这一

过程可反复

进行，直到最

终得到规模

为n的堆。

这一

过程可归纳

为：对任何一

棵完全二叉

树，只需自顶

而下、自左向

右地针对其

中每个节点

实施一次上

滤，即可使之

成为完全二

叉堆。在此过

程中，为将每

个节点纳入

堆中，所需消

耗的时

间量

将线性正比

于该节点的

深度。不妨考

查高度为h、规

模为n =

2h+1

- 1的满二

叉树，其中高

度为i的节点

共有2

i个，因此

整个算法的

总体时间复

杂度应为：

i=0

h (i∙2

i

) = (d -

1)  2

d+1

+ 2 = (log2(n

+ 1) - 2)∙(n

+ 1) + 2

= O(nlogn)

与

上面的分析

结论一致。



Floyd算

法

图10.7 堆合幵

算法原理

为

得到更快的

建堆算法，先

考查一个相

对简单的问

题：任给

堆H0和

H1，以及另一独

立节点p，如何

高效地将H0{p}H1转

化为

堆？从效

果来看，这相

当于以p为中

介将堆H0和H1合

二为一，故称

作堆合并操

作。

如图10.7，首先

为满足结构

性，可将这两

个堆当作p的

左、

右子树，联

接成一棵完

整的二叉树

。此时若p与孩

子r0和r1满足堆

序性，则该二

叉树已经就

是一个不折

不扣的堆。

实

际上，此时的

场景完全等

效于，在delMax()操作

中摘除堆顶

，再将末位词

条（p）转移至

堆

顶。故仿照10.2.3节

的方法，以下

只需对p实施

下滤操作，即

可将全树转

换为堆。

如果

将以上过程

作为实现堆

合并的一个

通用算法，则

在将所有词

条组织为一

棵完全二叉

树

后，只需自

底而上地反

复套用这一

算法，即可不

断地将处于

下层的堆捉

对地合并成

更高一层的

堆，

并最终得

到一个完整

的堆。按照这

一构思，即可

实现Floyd建堆算

法①。

 

①

由R. W. Floyd亍1964年収

明[57]

§10.2

堆 第10章 优

先级队列

294

 实

现

上述Floyd算法

，可以描述和

实现如代码

10.10所示。

1

template <typename T> void

PQ_ComplHeap<T>::heapify ( Rank n

) { //Floyd建堆算

法，O(n)时间

2

for ( int i

= LastInternal ( n

); InHeap ( n,

i ); i-- )

//自底

而上，依次

3 percolateDown (

n, i ); //下

滤各内部节

点

4 }

代码10.10 Floyd建堆

算法

可见，该

算法的实现

十分简洁：只

需自下而上

、由深而浅地

遍历所有内

部节点，并对

每个内

部节

点分别调用

一次下滤算

法percolateDown()（代码10.9）。

 实例

图10.8为Floyd算法的

一个实例。首

先如图(a)所示

，将9个词条组

织为一棵完

全二叉树。

多

数情况下，输

入词条集均

以向量形式

给出，故除了

通过各单元

的秩明确对

应的父子关

系外，并

不需

要做任何实

质的操作。

图

10.8 Floyd算法实例（虚

线示意下滤

过秳中癿交

换操作）

此时

，所有叶节点

各自即是一

个堆尽管其

规模仅为1。以

下，自底而上

地逐层合并

。

首先如图(b)所

示，在对3实施

下滤调整之

后，{ 8 }和{

5 }合并为

{ 8, 3,

5 }。接下来

如图

(c)所示，在对1实

施下滤调整

之后，{ 8,

3, 5 }与{ 9

}合并

为{ 9, 8, 1,

3, 5 }；

在对6实施

下滤调整之

后，{

7 }与{ 4 }合并为

{

7, 6, 4 }；最后如图(d)所

示，在对2实施

下滤调整之

后，{

9, 8, 1, 3,

5 }与{ 7, 6,

4 }合并为

{ 9, 8,

7, 5, 1, 6,

4, 3, 2 }。

从算法推进

的方向来看

，前述蛮力算

法与Floyd算法恰

好相反若将

前者理解为

“自上而

下的

上滤”，则后者

即是“自下而

上的下滤”。那

么，这一细微

的差异，是否

会对总体时

间复杂

度产

生实质的影

响呢？



复杂度

由代码10.10可见

，算法依然需

做n步迭代，以

对所有节点

各做一次下

滤。这里，每个

节点

的下滤

所需的时间

线性正比于

其高度，故总

体运行时间

取决于各节

点的高度总

和。

不妨仍以

高度为h、规模

为n =

2h+1

- 1的满二叉

树为例做一

大致估计，运

行时间应为

：

i=0

h ((d - i)∙2i

) = 2

d+1

- (d + 2)

= n - log2(n

+ 1) = O(n)

由于在遍历

所有词条之

前，绝不可能

确定堆的结

构，故以上已

是建堆操作

的最优算法

。

由此反观，蛮

力算法低效

率的根源，恰

在于其“自上

而下的上滤

”策略。如此，各

节点所消

耗

的时间线性

正比于其深

度而在完全

二叉树中，深

度小的节点

，远远少于高

度小的节点

。

第10章

优先级

队列 §10.2 堆

295

10.2.5 就地

堆排序

本节

讨论完全二

叉堆的另一

具体应用：对

于向量中的

n个词条，如何

借助堆的相

关算法，实

现

高效的排序

。相应地，这类

算法也称作

堆排序（heapsort）算法

。

既然此前归

并排序等算

法的渐进复

杂度已达到

理论上最优

的O(nlogn)，故这里将

更关注于

如

何降低复杂

度常系数在

一般规模的

应用中，此类

改进的实际

效果往往相

当可观。同时

，我

们也希望

空间复杂度

能够有所降

低，最好是除

输入本身以

外只需O(1)辅助

空间。

若果真

如此，则不妨

按照1.3.1节的定

义称之为就

地堆排序（in-place

heapsort）算

法。

 原理

算法

的总体思路

和策略与选

择排序算法

（3.5.3节）基本相同

：将所有词条

分成未排序

和已

排序两

类，不断从前

一类中取出

最大者，顺序

加至后一类

中。算法启动

之初，所有词

条均属于前

一类；此后，后

一类不断增

长；当所有词

条都已转入

后一类时，即

完成排序。

这

里的待排序

词条既然已

组织为向量

，不妨将其划

分为前缀H和

与之互补的

后缀S，分别对

应于上述未

排序和已排

序部分。与常

规选择排序

算法一样，在

算法启动之

初H覆盖所有

词条，而S

为空

。新算法的不

同之处在于

，整个排序过

程中，无论H包

含多少词条

，始终都组织

为一个堆。

另

外，整个算法

过程始终满

足如下不变

性：H中的最大

词条不会大

于S中的最小

词条除非二

者

之一为空

，比如算法的

初始和终止

时刻。算法的

迭代过程如

图10.9所示。

图10.9 就

地堆排序

首

先如图(a)，取出

首单元词条

M，将其与末单

元词条X交换

。M既是

当前堆

中的最大者

，同时根据不

变性

也不大

于S中的任何

词条，故如此

交

换之后M必

处于正确的

排序位置。故

如图(b)，此时可

等效地认为

S向前

扩大了

一个单元，H相

应地缩小了

一

个单元。请

注意，如此重

新分界之后

的H和S依然满

足以上不变

性。至此，

唯一

尚未解决的

问题是，词条

X通常

不能“胜

任”堆顶的角

色。

好在这并

非难事。仿照

此前的词条

删除算法（代

码10.8），只需对X实

施一次下滤

调整，即

可使

H整体的堆序

性重新恢复

，结果如图(c)所

示。

 复杂度

在

每一步迭代

中，交换M和X只

需常数时间

，对x的下滤调

整不超过O(logn)时

间。因此，全

部

n步迭代累计

耗时不超过

O(nlogn)。即便使用蛮

力算法而不

是Floyd算法来完

成H的初始化

，

整个算法的

运行时间也

不超过O(nlogn)。纵览

算法的整个

过程，除了用

于支持词条

交换的一个

辅助单元，几

乎不需要更

多的辅助空

间，故的确属

于就地算法

。

得益于向量

结构的简洁

性，几乎所有

以上操作都

可便捷地实

现，因此该算

法不仅可简

明地编

码，其

实际运行效

率也因此往

往要高于其

它O(nlogn)的算法。高

运行效率、低

开发成本以

及低

资源消

耗等诸多优

点的完美结

合，若离开堆

这一精巧的

数据结构实

在难以想象

。

§10.2 堆 第10章

优先

级队列

296

 实例

试考查利用

以上算法，对

向量{

4, 2, 5, 1,

3 }的堆排

序过程。首先

如图10.10所示，

采

用Floyd算法将该

向量整理为

一个完全二

叉堆。其中虚

线示意下滤

过程中的词

条交换操作

。

图10.10

就地堆排

序实例：建堆

以下如图10.11所

示共需5步迭

代。请对照以

上算法描述

，验证各步迭

代的具体过

程。

 

图10.11

就地堆

排序实例：迭

代

 实现

按照

以上思路，可

基于向量排

序器的统一

规范，实现就

地堆排序算

法如代码10.11所

示。

第10章 优先

级队列 §10.3 *左式

堆

297

1 template <typename

T> void Vector<T>::heapSort (

Rank lo, Rank hi

) { //0 <=

lo < hi <=

size

2 PQ_ComplHeap<T> H

( _elem + lo,

hi - lo );

//将待排序

匙间建成一

个完全二叉

堆，O(n)

3 while (

!H.empty() ) //反复地摘

除最大元幵

弻入已排序

癿后缀，直至

堆空

4

_elem[--hi] = H.delMax(); //等效亍

堆顶不末元

素对换后下

滤

5 }

代码10.11 基二

向量癿就地

堆排序

遵照

向量接口的

统一规范（60页

代码2.25），这里允

许在向量中

指定待排序

区间[lo, hi)，

从而作

为通用排序

算法具有更

好的灵活性

。

§10.3

*左式堆

10.3.1 堆合

并

除了标准

的插入和删

除操作，堆结

构在实际应

用中的另一

常见操作即

为合并。如图

10.12，

这一操作可

描述为：任给

堆A和堆B，如何

将二者所含

的词条组织

为一个堆。

图

10.12 堆合幵

直接

借助已有的

接口不难完

成这一任务

。比如，首先易

想到的一种

方法是：反复

取出堆B的

最

大词条并插

入堆A中；当堆

B为空时，堆A即

为所需的堆

H。这一过程可

简洁地描述

为：

1 while (

! B.empty() )

2

A.insert( B.delMax() );

将两个堆

的规模分别

记作n和m，且n

 m。每

一步迭代均

需做一次删

除操作和一

次插入操作

，

分别耗时O(logm)和

O(log(n +

m))。因共需做m步

迭代，故总体

运行时间应

为：

m  [O(logm)

+ O(log(n + m))]

= O(mlog(n + m))

= O(mlogn)

另一容易

想到的方法

是：将两个堆

中的词条视

作彼此独立

的对象，从而

可以直接借

助Floyd

算法，将它

们组织为一

个新的堆H。由

10.2.4节的结论，该

方法的运行

时间应为：

O(n + m) =

O(n)

尽

管其性能稍

优于前一方

法，但仍无法

令人满意。实

际上我们注

意到，既然所

有词条已分

两

组各自成

堆，则意味着

它们已经具

有一定的偏

序性；而一组

相互独立的

词条，谈不上

具有什么偏

序性。按此理

解，由前者构

建一个更大

的偏序集，理

应比由后者

构建偏序集

更为容易。

以

上尝试均未

奏效的原因

在于，不能保

证合并操作

所涉及的节

点足够少。为

此，不妨首先

打

破此前形

成的错觉并

大胆质疑：堆

是否也必须

与二叉搜索

树一样，尽可

能地保持平

衡？值得玩味

的是，对于堆

来说，为控制

合并操作所

涉及的节点

数，反而需要

保持某种意

义上的“不平

衡”！

§10.3 *左式堆 第

10章

优先级队

列

298

10.3.2 单侧倾斜

左式堆②（leftist

heap）是优

先级队列的

另一实现方

式，可高效地

支持堆合并

操作。其

基本

思路是：在保

持堆序性的

前提下附加

新的条件，使

得在堆的合

并过程中，只

需调整很少

量的

节点。具

体地，需参与

调整的节点

不超过O(logn)个，故

可达到极高

的效率。

具体

地如图10.13所示

，左式堆的整

体结构呈

单

侧倾斜状；依

照惯例，其中

节点的分布

均偏向左

侧

。也就是说，左

式堆将不再

如完全二叉

堆那样满

足

结构性。

这也

不难理解，毕

竟堆序性才

是堆结构的

关键

条件，而

结构性只不

过是堆的一

项附加条件

。正如

稍后将

要看到的，在

将平衡性替

换为左倾性

之后，

左式堆

结构的 merge()

操作

乃至 insert() 和

delMax()操作

均可以高效

地实现。

图10.13 整

体结极向左

倾斜，右侧通

路上癿节点

丌超过O(logn)个

10.3.3 PQ_LeftHeap模

板类

按照以

上思路，可以

借助多重继

承的机制，定

义左式堆模

板类如代码

10.12所示。

1 #include "../PQ/PQ.h"

//引入优

先级队列ADT

2 #include "../BinTree/BinTree.h"

//引

入二叉树节

点模板类

3

4 template

<typename T>

5 class

PQ_LeftHeap : public PQ<T>,

public BinTree<T> { //基

亍二叉树，以

左式堆形式

实现癿PQ

6 public:

7 PQ_LeftHeap()

{ } //默讣

极造

8

PQ_LeftHeap ( T* E,

int n ) //批量极

造：可改迕为

Floyd建堆算法

9 { for (

int i = 0;

i < n; i++

) insert ( E[i]

); }

10 void

insert ( T );

//按

照比较器确

定癿优先级

次序揑入元

素

11 T getMax();

//叏出优先

级最高癿元

素

12 T delMax();

//初除优先

级最高癿元

素

13 }; //PQ_LeftHeap

代码10.12 左式

堆PQ_LeftHeap模板类定

义

可见，PQ_LeftHeap模板

类借助多重

继承机制，由

PQ和BinTree结构共同

派生而得。

这

意味着，PQ_LeftHeap首先

继承了优先

级队列对外

的标准ADT接口

。另外，既然左

式堆的

逻辑

结构已不再

等价于完全

二叉树，墨守

成规地沿用

此前基于向

量的实现方

法，必将难以

控制空

间复

杂度。因此，改

用紧凑性稍

差、灵活性更

强的二叉树

结构，将更具

针对性。

其中

蛮力式批量

构造方法耗

时O(nlogn)，利用Floyd算法

可改进至O(n)（习

题[10-13]）。

② 由C. A. Crane亍1972年収

明[58]，后由D.

E. Knuth亍1973年

修订幵正式

命名[3]

第10章 优

先级队列

§10.3 *左

式堆

299

10.3.4

空节点

路径长度

左

式堆的倾斜

度，应该控制

在什么范围

？又该如何控

制？为此，可借

鉴AVL树和红黑

树的技

巧，为

各节点引入

所谓的“空节

点路径长度

”指标，并依此

确定相关算

法的执行方

向。

节点x的空

节点路径长

度（null

path length），记作npl(x)。若x为

外部节点，则

约定

npl(x) =

npl(null) = 0。反之若

x为内部节点

，则npl(x)可递归地

定义为：

npl(x)

= 1 + min(

npl(lc(x)), npl(rc(x)) )

也就

是说，节点x的

npl值取决于其

左、右孩子npl值

中的小者。

图

10.14 空节点路径

长度（其中有

个节点迗反

左倾性，以双

圀标出）

对照

如图10.14所示的

实例不难验

证：npl(x)既等于x到

外部节点的

最近距离（该

指标由此

得

名），同时也等

于以x为根的

最大满子树

（图中以矩形

框出）的高度

。

10.3.5 左倾性与左

式堆

左式堆

是处处满足

“左倾性”的二

叉堆，即任一

内部节点x都

满足

npl(lc(x))

 npl(rc(x))

也就是

说，就npl指标而

言，任一内部

节点的左孩

子都不小于

其右孩子。

图

10.15

左式堆：左孩

子癿npl值丌小

二右孩子，而

前者癿高度

却可能小二

后者

照此标

准不难验证

，如图10.15所示的

二叉堆即是

左式堆，而图

10.14中的二叉堆

不是。

由npl及左

倾性的定义

不难发现，左

式堆中任一

内节点x都应

满足：

npl(x)

= 1 + npl(rc(x))

也就是

说，左式堆中

每个节点的

npl值，仅取决于

其右孩子。

请

注意，“左孩子

的npl值不小于

右孩子”并不

意味着“左孩

子的高度必

不小于右孩

子”。

图10.15中的双

圈节点即为

一个反例，其

左子堆和右

子堆的高度

分别为1和2。

§10.3

*左

式堆 第10章 优

先级队列

300

10.3.6 最

右侧通路

从

x出发沿右侧

分支一直前

行直至空节

点，经过的通

路称作其最

右侧通路（rightmost

path），记

作rPath(x)。在左式堆

中，尽管右孩

子高度可能

大于左孩子

，但由“各节点

npl值

均决定于

其右孩子”这

一事实不难

发现，每个节

点的npl值，应恰

好等于其最

右侧通路的

长度。

图10.16 左式

堆癿最右侧

通路

根节点

r的最右侧通

路，在此扮演

的角色极其

重要。如图10.16所

示，rPath(r)的终点必

为

全堆中深

度最小的外

部节点。若记

：

npl(r) =

|rPath(r)| = d

则该堆应包

含一棵以r为

根、高度为d的

满二叉树（黑

色部分），且该

满二叉树至

少应包含2

d+1

-

1个

节点、2

d

- 1个内部

节点这也是

堆的规模下

限。反之，在包

含n个节点的

左式堆中，最

右侧通路必

然不会长于

log2(n + 1)

- 1 = O(logn)

10.3.7 合并算法

假

设待合并的

左式堆如图

10.17(a)所示分别以

a和b为堆顶，且

不失一般性

地a 

b。

图10.17 左式堆

合幵算法原

理

于是如图

(b)，可递归地将

a的右子堆aR与

堆b合并，然后

作为节点a的

右孩子替换

原先的aR。

当然

，为保证依然

满足左倾性

条件，最后还

需要比较a左

、右孩子的npl值

如有必要还

需将

二者交

换，以保证左

孩子的npl值不

低于右孩子

。

第10章 优先级

队列

§10.3 *左式堆

301

10.3.8 实例

考查如

图10.18(a)所示的一

对待合并左

式堆。

图10.18 左式

堆合幵算法

实例

如图(b)所

示，经过优先

级比对可确

定，应将堆17的

右子堆12与堆

15合并后，作为

节点17

新的右

子树。为完成

这一合并，如

图(c)所示，经过

优先级对比

可确定，应将

堆15的右子堆

8与

堆12合并后

，作为节点15新

的右子树。注

意到此时节

点12没有左孩

子，故按照退

化情况的处

理

规则，如图

(d)所示，可将堆

8直接作为节

点12的左孩子

。

至此，就结构

性而言两个

堆的合并任

务已经完成

。但为了保证

左倾性依然

满足，需要在

逐级

递归返

回的过程，及

时比较左右

孩子的npl值，如

有必要则将

二者交换位

置。仍继续上

例，当如

图(d)所

示执行到最

后一次递归

返回时，可以

发现根节点

17的左、右孩子

的npl值分别为

1和2，

故有必要

将子堆13和子

堆15交换位置

，最终结果如

图(e)所示。

§10.3

*左式

堆 第10章 优先

级队列

302

10.3.9 合并

操作的实现

按照以上思

路，左式堆合

并算法可具

体描述和实

现如代码10.13所

示。

1 template

<typename T> //根据相对

优先级确定

适宜癿斱式

，合幵以a和b为

根节点癿两

个左式堆

2

static BinNodePosi(T) merge (

BinNodePosi(T) a, BinNodePosi(T) b

) {

3 if

( ! a )

return b; //退

化情冴

4

if ( ! b

) return a; //退化

情冴

5 if ( lt

( a->data, b->data )

) swap ( a,

b ); //一般情

冴：首先确保

b丌大

6

a->rc = merge (

a->rc, b ); //将a癿右

子堆，不b合幵

7

a->rc->parent = a; //幵更新父子

兲系

8 if ( !a->lc

|| a->lc->npl < a->rc->npl

) //若有必

要

9 swap

( a->lc, a->rc );

//交换a癿左

、右子堆，以确

保右子堆癿

npl丌大

10 a->npl =

a->rc ? a->rc->npl +

1 : 1; //更新a癿

npl

11 return a; //迒回合幵后

癿堆顶

12 } //本算

法叧实现结

极上癿合幵

，堆癿觃模须

由上局调用

者负责更新

代码10.13 左式堆

合幵接口merge()

该

算法首先判

断并处理待

合并子堆为

空的边界情

况。然后再通

过一次比较

，并在必要时

做一

次交换

，以保证堆顶

a的优先级总

是不低于另

一堆顶b。

以下

按照前述原

理，递归地将

a的右子堆与

堆b合并，并作

为a的右子堆

重新接入。接

下来，

还需比

较此时a左、右

孩子的npl值，如

有必要还需

做一次交换

，以保证前者

不小于后者

。最后，

只需在

右孩子npl值的

基础上加一

，即可得到堆

顶a的新npl值。至

此，合并遂告

完成。

当然，以

上实现还足

以处理多种

退化的边界

情况，限于篇

幅不再赘述

，请读者对照

代码，就

此独

立分析和验

证。

10.3.10

复杂度

借

助递归跟踪

图不难看出

，在如代码10.13所

示的合并算

法中，所有递

归实例可排

成一个线

性

序列。因此，该

算法实质上

属于线性递

归，其运行时

间应线性正

比于递归深

度。

进一步地

，由该算法原

理及代码实

现不难看出

，递归只可能

发生于两个

待合并堆的

最右侧通

路

上。根据10.3.6节的

分析结论，若

待合并堆的

规模分别为

n和m，则其两条

最右侧通路

的长度

分别

不会超过O(logn)和

O(logm)，因此合并算

法总体运行

时间应不超

过：

O(logn) +

O(logm) = O( logn

+ logm ) =

O(log(max(n, m)))

可见，这一

效率远远高

于10.3.1节中的两

个直觉算法

。当然，与多数

算法一样，若

将以上

递归

版本改写为

迭代版本（习

题[10-15]），还可从常

系数的意义

上进一步提

高效率。

10.3.11 基于

合并的插入

和删除

若将

merge()操作当作一

项更为基本

的操作，则可

以反过来实

现优先级队

列标准的插

入和删

除等

操作。事实上

，得益于merge()操作

自身的高效

率，如此实现

的插入和删

除操作，在时

间效

率方面

毫不逊色于

常规的实现

方式。加之其

突出的简洁

性，使得这一

实现方式在

实际应用中

受到

更多的

青睐。

第10章 优

先级队列

§10.3 *左

式堆

303



delMax()

图10.19 基二

堆合幵操作

实现初除接

口

基于merge()操作

实现delMax()算法，原

理如图

10.19所示

。考查堆顶x及

其子堆HL和HR。

在

摘除x之后，HL和

HR即可被视作

为两个彼此

独立

的待合

并的堆。于是

，只要通过merge()操

作将它们

合

并起来，则其

效果完全等

同于一次常

规的delMax()

删除操

作。

照此思路

，即可基于merge()操

作实现delMax()接口

如代码10.14所示

。

1 template

<typename T> T PQ_LeftHeap<T>::delMax()

{ //基亍合幵操

作癿词条初

除算法（弼前

队列非空）

2 BinNodePosi(T)

lHeap = _root->lc; //左

子堆

3 BinNodePosi(T) rHeap =

_root->rc; //右子堆

4 T e

= _root->data; delete _root;

_size--; //初除根节点

5 _root =

merge ( lHeap, rHeap

); //原左右子堆

合幵

6 if

( _root ) _root->parent

= NULL; //若堆非

空，迓需相应

讴置父子链

接

7

return e; //迒回原根

节点癿数据

项

8

}

代码10.14 左式

堆节点初除

接口delMax()

时间成

本主要消耗

于对merge()的调用

，故由此前的

分析结论，总

体依然不超

过O(logn)。

 insert()

图10.20 基二堆

合幵操作实

现词条揑入

算法

基于merge()操

作实现insert()接口

的原理如

图

10.20所示。假设拟

将词条x插入

堆H中。

实际上

，只要将x也视

作（仅含单个

节点的）堆，

则

通过调用merge()操

作将该堆与

堆H合并之后

，其效

果即完

全等同于完

成了一次词

条插入操作

。

照此思路，即

可基于merge()操作

实现insert()接口如

代码10.15所示。

1 template

<typename T> void PQ_LeftHeap<T>::insert

( T e )

{ //基

亍合幵操作

癿词条揑入

算法

2 BinNodePosi(T)

v = new BinNode<T>

( e ); //为e创建

一个二叉树

节点

3 _root = merge

( _root, v );

//通过合

幵完成新节

点癿揑入

4 _root->parent =

NULL; //既

然此时堆非

空，迓需相应

讴置父子链

接

5 _size++;

//更新觃模

6 }

代码10.15 左式堆

节点揑入接

口insert()

同样，时间

成本主要也

是消耗于对

merge()的调用，总体

依然不超过

O(logn)。

§10.3 *左式堆 第10章

优先级队列

304

第11章

串

§11.1 串及

串匘配

第11章

串

306

串或字符

串（string）属于线性

结构，自然地

可直接利用

向量或列表

等序列结构

加以实现。

但

字符串作为

数据结构，特

点也极其鲜

明，这可归纳

为：结构简单

，规模庞大，元

素重复率高

。

所谓结构简

单，是指字符

表本身的规

模不大，甚至

可能极小。以

生物信息序

列为例，参与

蛋

白质（文本

）合成的常见

氨基酸（字符

）只有20种，而构

成DNA序列（文本

）的碱基（字符

）仅

有4种。尽管

就规模而言

，地球系统模

式的单个输

出文件长达

1~100GB，微软Windows系统逾

4000

万行的源代

码长度累计

达到40GB，但它们

都只不过是

由ASCII字符，甚至

是可打印字

符组成的。

因

此，以字符串

形式表示的

海量文本数

据的高效处

理技术，一直

都是相关领

域的研究重

点。

鉴于字符

串结构的上

述特点，本章

将直接利用

C++本身所提供

的字符数组

，并转而将讲

述的

重点，集

中于各种串

匹配算法indexOf()的

基本原理与

高效实现。

§11.1

串

及串匹配

11.1.1 串

 字符串

一般

地，由n个字符

构成的串记

作：

S = "a0

a1 ... an-1"， 其中，ai

 ，0  i

< n

这里

的是所有可

用字符的集

合，称作字符

表（alphabet），例如二进

制比特集 =

{ 0, 1 }、

ASCII字

符集、Unicode字符集

、构成DNA序列的

所有碱基、组

成蛋白质的

所有氨基酸

，等等。

字符串

S所含字符的

总数n，称作S的

长度，记作|S| = n。这

里只考虑长

度有限的串

，n

< 。

特别地，长度

为零的串称

作空串（null string）。请注

意，空串并非

由空格字符

'□'组成的串，

二

者完全不同

。

 子串

字符串

中任一连续

的片段，称作

其子串（substring）。具体

地，对于任意

的0

 i  i

+ 

k <

n，由字符串

S中起始于位

置i的连续k个

字符组成的

子串记作：

S.substr(i, k) =

"ai ai+1 ... ai+k-1"

= S[i, i +

k)

有

两种特殊子

串：起始于位

置0、长度为k的

子串称为前

缀（prefix），而终止于

位置n - 1、

长度为

k的子串称为

后缀（suffix），分别记

作：

prefix(S, k) =

S.substr(0, k) = S[0,

k)

suffix(S, k) =

S.substr(n - k, k)

= S[n - k,

n)

由上述定

义可直接导

出以下结论

：空串是任何

字符串的子

串，也是任何

字符串的前

缀和后缀；

任

何字符串都

是自己的子

串，也是自己

的前缀和后

缀。此类子串

、前缀和后缀

分别称作平

凡子串

（trivial

substring）、平凡

前缀（trivial prefix）和平凡

后缀（trivial suffix）。

反之，字

符串本身之

外的所有非

空子串、前缀

和后缀，分别

称作真子串

（proper

substring）、

真前缀（proper prefix）和真

后缀（proper suffix）。

第11章 串

§11.1 串及串匘配

307



判等

最后，字

符串S[0, n)和T[0, m)称作

相等，当且仅

当二者长度

相等（n

= m），且对应

的

字符分别

相同（对任何

0 

i < n都有S[i] =

T[i]）。

 ADT

串结构

主要的操作

接口可归纳

为表11.1。

表11.1 串ADT支

持癿操作看

接口

操 作

接

口 功 能

length()

查诟

串癿长度

charAt(i) 迒

回第i个字符

substr(i, k)

迒回从第i个

字符起、长度

为k癿子串

prefix(k) 迒

回长度为k癿

前缀

suffix(k)

迒回长

度为k癿后缀

equal(T) 刞断T是否不

弼前字符串

相等

concat(T) 将T串接

在弼前字符

串乀后

indexOf(P) 若P是

弼前字符串

癿一个子串

，则迒回诠子

串癿起始位

置；否则迒回

-1

比如，依次对

串S =

"data structures"执行如下

操作，结果依

次如表11.2所示

。

表11.2 串操作实

例

操 作 输 出

字

符 串 S

length()

15 "data structures"

charAt(5)

's' "data structures"

prefix(4)

"data" "data structures"

suffix(10)

"structures" "data structures"

concat("and

algorithms") "data structures and

algorithms"

equal("data structures") false

"data structures and algorithms"

equal("data structures and algorithms")

true "data structures and

algorithms"

indexOf("string") -1 "data

structures and algorithms"

indexOf("algorithm")

20 "data structures and

algorithms"

11.1.2 串匹

配



应用与问

题

在涉及字

符串的众多

实际应用中

，模式匹配是

最常使用的

一项基本操

作。比如UNIX Shell

的grep工

具（General

Regular Expression Parser）和DOS的find命令

，基本功能都

是在

指定的

字符串中查

找①特定模式

的字符串。又

如生物信息

处理领域，也

经常需要在

蛋白质序列

中

① 返两个命

令都是以文

件形式来指

定待查找癿

文本串，具体

格式分删是

：

%

grep <pattern> <file>

c:\>

find "pattern" <file>

§11.1

串及串匘配

第11章 串

308

寻找

特定的氨基

酸模式，或在

DNA序列中寻找

特定的碱基

模式。再如，邮

件过滤器也

需根据事先

定义的特征

串，通过扫描

电子邮件的

地址、标题及

正文来识别

垃圾邮件。还

有，反病毒系

统也会

扫描

刚下载的或

将要执行的

程序，并与事

先提取的特

征串相比对

，以判定其中

是否含有病

毒。

上述所有

应用问题，本

质上都可转

化和描述为

如下形式：

如

何在字符串

数据中，检测

和提取以字

符串形式给

出的某一局

部特征

这类

操作都属于

串模式匹配

（string

pattern matching）范畴，简称串

匹配。一般地

，即：

对基于同

一字符表的

任何文本串

T（|T| =

n）和模式串P（|P| = m）：

判

定T中是否存

在某一子串

与P相同

若存

在（匹配），则报

告该子串在

T中的起始位

置

串的长度

n和m本身通常

都很大，但相

对而言n更大

，即满足2 << m

<< n。比如

，若：

T =

"Now is the time

for all good people

to come"

P =

"people"

则匹配的

位置应该是

T.indexOf(P) = 29。

 问题分类

根

据具体应用

的要求不同

，串匹配问题

可以多种形

式呈现。

有些

场合属于模

式检测（pattern

detection）问题

：我们只关心

是否存在匹

配而不关心

具体的匹配

位置，比如垃

圾邮件的检

测。有些场合

属于模式定

位（pattern location）问题：

若经

判断的确存

在匹配，则还

需确定具体

的匹配位置

，比如带毒程

序的鉴别与

修复。有些场

合属

于模式

计数（pattern

counting）问题：若

有多处匹配

，则统计出匹

配子串的总

数，比如网络

热门词汇排

行榜的更新

。有些场合则

属于模式枚

举（pattern enumeration）问题：在有

多处

匹配时

，报告出所有

匹配的具体

位置，比如网

络搜索引擎

。

11.1.3

测评标准与

策略

串模式

匹配是一个

经典的问题

，有名字的算

法已不下三

十种。鉴于串

结构自身的

特点，在设

计

和分析串模

式匹配算法

时也必须做

特殊的考虑

。其中首先需

要回答的一

个问题就是

，如何对任

一

串匹配算法

的性能作出

客观的测量

和评估。

多数

读者首先会

想到采用评

估算法性能

的常规口径

和策略：以时

间复杂度为

例，假设文本

串

T和模式串

P都是随机生

成的，然后综

合其各种组

合从数学或

统计等角度

得出结论。很

遗憾，此类

构

思并不适用

于这一问题

。

以基于字符

表

= { 0, 1

}的二进制

串为例。任给

长度为n的文

本串，其中长

度为m的子串

不过n - m +

1个（m << n时接

近于n个）。另一

方面，长度为

m的随机模式

串多达2^m个，故

匹

配成功的

概率为n

/ 2^m。以n = 100,000、m

= 100为

例，这一概率

仅有

100,000 /

2

100 < 10-25

对于更

长的模式串

、更大的字符

表，这一概率

还将更低。因

此，这一策略

并不能有效

地覆盖成功

匹配的情况

，所得评测结

论也无法准

确地反映算

法的总体性

能。

实际上，有

效涵盖成功

匹配情况的

一种简便策

略是，随机选

取文本串T，并

从T中随机取

出

长度为m的

子串作为模

式串P。这也是

本章将采用

的评价标准

。

第11章

串 §11.2 蛮力

算法

309

§11.2 蛮力算

法

11.2.1 算法描述

图11.1

串模式匹

配癿蛮力算

法

蛮力串匹

配是最直接

最直觉的方

法。如图

11.1所示

，可假想地将

文本串和模

式串分别写

在两条印有

等间距方格

的纸带上，文

本串对应

的

纸带固定，模

式串纸带的

首字符与文

本串纸

带的

首字符对齐

，二者都沿水

平方向放置

。于

是，只需将

P与T中长度为

m的n - m

+ 1个子串

逐

一比对，即可

确定可能的

匹配位置。

不

妨按自左向

右的次序考

查各子串。在

初始状态下

，T的前m个字符

将与P的m个字

符两两对

齐

。接下来，自左

向右检查相

互对齐的这

m对字符：若当

前字符对相

互匹配，则转

向下一对字

符；

反之一旦

失配，则说明

在此位置文

本串与模式

串不可能完

全匹配，于是

可将P对应的

纸带右移一

个字符，然后

从其首字符

开始与T中对

应的新子串

重新对比。图

中，模式串P的

每一黑色方

格对应

于字

符对的一次

匹配，每一灰

色方格对应

于一次失配

，白色方格则

对应于未进

行的一次比

对。若

经过检

查，当前的m对

字符均匹配

，则意味着整

体匹配成功

，从而返回匹

配子串的位

置。

蛮力算法

的正确性显

而易见：既然

只有在某一

轮的m次比对

全部成功之

后才成功返

回，故不

致于

误报；反过来

，所有对齐位

置都会逐一

尝试，故亦不

致漏报。

11.2.2 算法

实现

以下给

出蛮力算法

的两个实现

版本。二者原

理相同、过程

相仿，但分别

便于引入后

续的不同

改

进算法，故在

此先做一比

较。

1 /******************************************************************************************

2 * Text :

0 1 2 .

. . i-j .

. . . i

. . n-1

3

* ------------------------|-------------------|------------

4 *

Pattern : 0 .

. . . j

. .

5 *

|-------------------|

6 ******************************************************************************************/

7

int match ( char*

P, char* T )

{ //串匘配算

法（Brute-force-1）

8 size_t

n = strlen (

T ), i =

0; //文本串长

度、弼前接叐

比对字符癿

位置

9 size_t

m = strlen (

P ), j =

0; //模式串

长度、弼前接

叐比对字符

癿位置

10 while

( j < m

&& i < n

) //自左

向右逐个比

对字符

11 if

( T[i] == P[j]

) //若匘

配

12 {

i ++; j ++;

} //则转刡下

一对字符

13 else

//否

则

14 { i

-= j - 1;

j = 0; }

//文本串回

退、模式串复

位

15 return i

- j; //如何通过

迒回值，刞断

匘配结枅？

16

}

代

码11.1 蛮力串匹

配算法（版本

一）

§11.2

蛮力算法

第11章 串

310

如代

码11.1所示的版

本借助整数

i和j，分别指示

T和P中当前接

受比对的字

符T[i]与P[j]。

若当前

字符对匹配

，则i和j同时递

增以指向下

一对字符。一

旦j增长到m则

意味着发现

了匹配，

即可

返回P相对于

T的对齐位置

i - j。一旦当前字

符对失配，则

i回退并指向

T中当前对齐

位置的

下一

字符，同时j复

位至P的首字

符处，然后开

始下一轮比

对。

1 /******************************************************************************************

2

* Text : 0

1 2 . .

. i i+1 .

. . i+j .

. n-1

3 *

------------------------|-------------------|------------

4 * Pattern

: 0 1 .

. . j .

.

5 * |-------------------|

6 ******************************************************************************************/

7 int

match ( char* P,

char* T ) {

//串匘配算

法（Brute-force-2）

8 size_t n

= strlen ( T

), i = 0;

//文本串长

度、不模式串

首字符癿对

齐位置

9 size_t m

= strlen ( P

), j; //模式

串长度、弼前

接叐比对字

符癿位置

10

for ( i =

0; i < n

- m + 1;

i++ ) { //文

本串从第i个

字符起，不

11 for ( j

= 0; j <

m; j++ ) //模

式串中对应

癿字符逐个

比对

12 if ( T[i

+ j] != P[j]

) break; //若失配

，模式串整体

右秱一个字

符，再做一轮

比对

13

if ( j >=

m ) break; //找刡匘

配子串

14 }

15 return

i; //如何

通过迒回值

，刞断匘配结

枅？

16 }

代码11.2 蛮力

串匹配算法

（版本事）

如代

码11.2所示的版

本，借助整数

i指示P相对于

T的对齐位置

，且随着i不断

递增，对齐的

位置逐步右

移。在每一对

齐位置i处，另

一整数j从0递

增至m -

1，依次指

示当前接受

比对的字

符

为T[i + j]与P[j]。因此，一

旦发现匹配

，即可直接返

回当前的对

齐位置i。

11.2.3 时间

复杂度

从理

论上讲，蛮力

算法至多迭

代n -

m + 1轮，且各轮

至多需进行

m次比对，故总

共只需做

不

超过(n

- m + 1)∙m次比对

。那么，这种最

坏情况的确

会发生吗？答

案是肯定的

。

考查如图11.2所

示的实例。无

论采用上述

哪个版本的

蛮力算法，都

需做n - m +

1轮迭代

，

且各轮都需

做m次比对。因

此，整个算法

共需做m∙(n - m

- 1)次字

符比对，其中

成功的和失

败

的各有(m -

1)∙(n - m -

1) + 1和

n -

m - 2次。因m <<

n，渐进的

时间复杂度

应为O(n∙m)。

图11.2 蛮力

算法癿最坏

情冴

（也是基

二坏字符策

略BM算法癿最

好情冴）

图11.3 蛮

力算法癿最

好情冴

（也是

基二坏字符

策略BM算法癿

最坏情冴）

当

然，蛮力算法

的效率也并

非总是如此

低下。如图11.3所

示，若将模式

串P左右颠倒

，则每

经一次

比对都可排

除文本串中

的一个字符

，故此类情况

下的运行时

间将为O(n)。实际

上，此类

最好

（或接近最好

）情况出现的

概率并不很

低，尤其是在

字符表较大

时（习题[11-9]）。

第11章

串 §11.3

KMP算法

311

§11.3 KMP算法

11.3.1

构思

上一节

的分析表明

，蛮力算法在

最坏情况下

所需时间，为

文本串长度

与模式串长

度的乘积，

故

无法应用于

规模稍大的

应用环境，很

有必要改进

。为此，不妨从

分析以上最

坏情况入手

。

稍加观察不

难发现，问题

在于这里存

在大量的局

部匹配：每一

轮的m次比对

中，仅最后一

次

可能失配

。而一旦发现

失配，文本串

、模式串的字

符指针都要

回退，并从头

开始下一轮

尝试。

实际上

，这类重复的

字符比对操

作没有必要

。既然这些字

符在前一轮

迭代中已经

接受过比对

并且成功，我

们也就掌握

了它们的所

有信息。那么

，如何利用这

些信息，提高

匹配算法的

效率呢？

以下

以蛮力算法

的前一版本

（代码11.1）为基础

进行改进。



简

单示例

如图

11.4所示，用T[i]和P[j]分

别表示当前

正在接受比

对的一对字

符。

图11.4 刟用以

往癿成功比

对所提供癿

信息，可以

避

免文本串字

符指针癿回

退

图11.5 刟用以

往癿成功比

对所提供癿

信息，

有可能

使模式串大

跨度地右秱

当本轮比对

进行到最后

一对字符并

发现失配后

，蛮力算法会

令两个字符

指针同步回

退（即令

i = i -

j + 1和j =

0），然

后再从这一

位置继续比

对。然而事实

上，指针i完全

不必回退。

 记

忆 =

经验 = 预知

力

经过前一

轮比对，我们

已经清楚地

知道，子串T[i

- j, i)完

全由'0'组成。记

住这一性质

便可预测出

：在回退之后

紧接着的下

一轮比对中

，前j -

1次比对必

然都会成功

。因此，可直接

令i保持不变

，令j = j -

1，然后继续

比对。如此，下

一轮只需1次

比对，共减少

j - 1次！

上述“令i保

持不变、j

= j - 1”的含

义，可理解为

“令P相对于T右

移一个单元

，然后从

前一

失配位置继

续比对”。实际

上这一技巧

可推而广之

：利用以往的

成功比对所

提供的信息

（记

忆），不仅可

避免文本串

字符指针的

回退，而且可

使模式串尽

可能大跨度

地右移（经验

）。

 一般实例

如

图11.5所示，再来

考查一个更

具一般性的

实例。

本轮比

对进行到发

现T[i] = 'E'

 'O' = P[4]失配后，在

保持i不变的

同时，应将模

式

串P右移几

个单元呢？有

必要逐个单

元地右移吗

？不难看出，在

这一情况下

移动一个或

两个单元

都

是徒劳的。事

实上，根据此

前的比对结

果，此时必然

有

T[i −

4, i) = P[0,

4) = "REGR"

若在此局

部能够实现

匹配，则至少

紧邻于T[i]左侧

的若干字符

均应得到匹

配比如，当

P[0]与

T[i - 1]对齐时，即属

这种情况。进

一步地，若注

意到i -

1是能够

如此匹配的

最左侧

位置

，即可直接将

P右移4 - 1

= 3个单元

（等效于i保持

不变，同时令

j = 1），然后继续比

对。

§11.3 KMP算法 第11章

串

312

11.3.2 next表

一般地

，如图11.6假设前

一轮比对终

止于T[i] 

P[j]。按以上

构想，指针i不

必回退，而

是

将T[i]与P[t]对齐并

开始下一轮

比对。那么，t准

确地应该取

作多少呢？

图

11.6 刟用此前成

功比对所提

供癿信息，在

安全癿前提

下尽可能大

跨度地右秱

模式串

由图

可见，经过此

前一轮的比

对，已经确定

匹配的范围

应为：

P[0, j) =

T[i - j, i)

于是，若

模式串P经适

当右移之后

，能够与T的某

一（包含T[i]在内

的）子串完全

匹配，则

一项

必要条件就

是：

P[0, t)

= T[i - t,

i) = P[j -

t, j)

亦即，在P[0, j)中

长度为t的真

前缀，应与长

度为t的真后

缀完全匹配

，故t必来自集

合：

N(P, j) = {

0  t <

j | P[0, t)

= P[j - t,

j) }

一般地，该

集合可能包

含多个这样

的t。但需要特

别注意的是

，其中具体由

哪些t值构成

，

仅取决于模

式串P以及前

一轮比对的

首个失配位

置P[j]，而与文本

串T无关！

从图

11.6还可看出，若

下一轮比对

将从T[i]与P[t]的比

对开始，这等

效于将P右移

j - t

个单元，位移

量与t成反比

。因此，为保证

P与T的对齐位

置（指针i）绝不

倒退，同时又

不致遗

漏任

何可能的匹

配，应在集合

N(P, j)中挑选最大

的t。也就是说

，当有多个值

得试探的右

移方

案时，应

该保守地选

择其中移动

距离最短者

。于是，若令

next[j]

= max( N(P, j)

)

则

一旦发现P[j]与

T[i]失配，即可转

而将P[ next[j] ]与T[i]彼此

对准，并从这

一位置开始

继续下一轮

比对。

既然集

合N(P, j)仅取决于

模式串P以及

失配位置j，而

与文本串无

关，作为其中

的最大元素

，

next[j]也必然具有

这一性质。于

是，对于任一

模式串P，不妨

通过预处理

提前计算出

所有位置j

所

对应的next[j]值，并

整理为表格

以便此后反

复查询亦即

，将“记忆力”转

化为“预知力

”。

11.3.3 KMP算法

上述思

路可整理为

代码11.3，即著名

的KMP算法②。

这里

，假定可通过

buildNext()构造出模式

串P的next表。对照

代码11.1的蛮力

算法，只是

在

else分支对失配

情况的处理

手法有所不

同，这也是KMP算

法的精髓所

在。

 

②

Knuth和Pratt师徒，不

Morris几乎同时収

明了返一算

法。他们稍后

联合署名収

表[60]诠算法，幵

以其姓氏首

字殎命名

第

11章 串 §11.3

KMP算法

313

1 int

match ( char* P,

char* T ) {

//KMP算

法

2 int* next

= buildNext ( P

); //极造next表

3 int

n = ( int

) strlen ( T

), i = 0;

//文

本串指针

4 int m

= ( int )

strlen ( P ),

j = 0; //模

式串指针

5 while ( j

< m && i

< n ) //自

左向右逐个

比对字符

6 if ( 0

> j || T[i]

== P[j] ) //若

匘配，戒P已秱

出最左侧（两

个刞断癿次

序丌可交换

）

7 { i ++;

j ++; } //则转刡下一

字符

8 else //否则

9

j = next[j]; //模

式串右秱（注

意：文本串丌

用回退）

10 delete [] next;

//释放

next表

11 return i

- j;

12 }

代码11.3 KMP主算

法（待改迕版

）

11.3.4 next[0]

= -1

不难看出，只

要j >

0则必有0  N(P, j)。此

时N(P,

j)非空，从而

可以保证“在

其中取

最大

值”这一操作

的确可行。但

反过来，若j = 0，则

即便集合N(P,

j)可

以定义，也必

是空集。

此种

情况下，又该

如何定义next[j = 0]呢

？

表11.3 next表实例：假

想地附加一

个通配符P[-1]

rank -1

0 1 2 3

4 5 6 7

8 9

P[] *

C H I N

C H I L

L A

next[] N/A

-1 0 0 0

0 1 2 3

0 0

反

观串匹配的

过程。若在某

一轮比对中

首对字符即

失配，则应将

P直接右移一

个字符，然后

启动下一轮

比对。因此如

表11.3所示，不妨

假想地在P[0]的

左侧“附加”一

个P[-1]，且该字符

与任何字符

都是匹配的

。就实际效果

而言，这一处

理方法完全

等同于“令next[0] =

-1”。

11.3.5 next[j +

1]

那

么，若已知next[0, j]，如

何才能递推

地计算出next[j +

1]？是

否有高效方

法？

图11.7 P[j] =

P[ next[j] ]时，必有

next[j +

1] = next[j] +

1

若next[j] = t，则意味着

在P[0,

j)中，自匹配

的真前缀和

真后缀的最

大长度为t，故

必

有next[j + 1]

 next[j] + 1而且特

别地，当且仅

当P[j]

= P[t]时如图11.7取

等号。

那么一

般地，若P[j] 

P[t]，又该

如何得到next[j + 1]？

§11.3

KMP算

法 第11章 串

314

此

种情况下如

图11.8，由next表的功

能定义，next[j + 1]的下

一候选者应

该依次是

next[

next[j] ] + 1,

next[ next[ next[j] ]

] + 1, ...

图

11.8 P[j]  P[

next[j] ]时，必有next[j + 1]

= next[ ... next[j]

... ] + 1

因此

，只需反复用

next[t]替换t（即令t = next[t]），即

可按优先次

序遍历以上

候选者；

一旦

发现P[j]与P[t]匹配

（含与P[t

= -1]的通配

），即可令next[j + 1]

= next[t] + 1。

既然

总有next[t] < t，故在此

过程中t必然

严格递减；同

时，即便t降低

至0，亦必然会

终

止于通配

的next[0]

= -1，而不致下

溢。如此，该算

法的正确性

完全可以保

证。

11.3.6 构造next表

按

照以上思路

，可实现next表构

造算法如代

码11.4所示。

1 int* buildNext

( char* P )

{ //极造

模式串P癿next表

2 size_t m

= strlen ( P

), j = 0;

//“主”串指针

3 int* N

= new int[m]; //next表

4

int t = N[0]

= -1; //模式串指针

5 while

( j < m

- 1 )

6

if ( 0 >

t || P[j] ==

P[t] ) { //匘配

7 j ++; t

++;

8 N[j] =

t; //此句可

改迕...

9 }

else //失配

10 t

= N[t];

11 return

N;

12 }

代

码11.4

next表癿极造

可见，next表的构

造算法与KMP算

法几乎完全

一致。实际上

按照以上分

析，这一构造

过程完

全等

效于模式串

的自我匹配

，因此两个算

法在形式上

的近似亦不

足为怪。

第11章

串 §11.3

KMP算法

315

11.3.7 性能

分析

由上可

见，KMP算法借助

next表可避免大

量不必要的

字符比对操

作，但这意味

着渐进意义

上

的时间复

杂度会有实

质改进吗？这

一点并非一

目了然，甚至

乍看起来并

不乐观。比如

就最坏情况

而言，共有(n)个

对齐位置，而

且在每一对

齐位置都有

可能需要比

对多达(m)次。

如

此说来，难道

在最坏情况

下，KMP算法仍可

能共需执行

(nm)次比对？不是

的。以下更为

精确的分析

将证明，即便

在最坏情况

下，KMP算法也只

需运行线性

的时间！

为此

，请留意代码

11.3中用作字符

指针的变量

i和j。若令k

= 2i - j并考

查k在KMP算法过

程中的变化

趋势，则不难

发现：while循环每

迭代一轮，k都

会严格递增

。

实际上，对应

于while循环内部

的if-else分支，无非

两种情况：若

转入if分支，则

i和j同

时加一

，于是k = 2i

- j必将增

加；反之若转

入else分支，则尽

管i保持不变

，但在赋值j = next[j]

之

后j必然减小

，于是k = 2i -

j也必然

会增加。

纵观

算法的整个

过程：启动时

有i = j

= 0，即k = 0；算法结

束时i

 n且j  0，故有

k

 2n。在此期间尽

管整数k从0开

始持续地严

格递增，但累

计增幅不超

过2n，故while循环至

多执

行2n轮。另

外，while循环体内

部不含任何

循环或调用

，故只需O(1)时间

。因此，若不计

构造next

表所需

的时间，KMP算法

本身的运行

时间不超过

O(n)。也就是说，尽

管可能有(n)个

对齐位置，

但

就分摊意义

而言，在每一

对齐位置仅

需O(1)次比对（习

题[11-4]）。

既然next表构

造算法的流

程与KMP算法并

无实质区别

，故仿照上述

分析可知，next表

的构造

仅需

O(m)时间。综上可

知，KMP算法的总

体运行时间

为O(n +

m)。

11.3.8 继续改进

尽管以上KMP算

法已可保证

线性的运行

时间，但在某

些情况下仍

有进一步改

进的余地。

考

查模式串P

= "000010"。按

照11.3.2节的定义

，其next表应如表

11.4所示。

在KMP算法

过程中，假设

如图11.9前一

轮

比对因T[i]

= '1'  '0'

= P[3]失配

而

中断。于是

按照以上的

next表，接下来KMP

算

法将依次将

P[2]、P[1]和P[0]与T[i]对准

并

做比对。

图11.9 按

照此前定义

癿next表，仌有可

能迕行多

次

本丌必要癿

字符比对操

作

表11.4 next表仌有

待优化癿实

例

rank -1

0 1 2 3

4 5

P[] *

0 0 0 0

1 0

next[] N/A

-1 0 1 2

3 0

从图11.9可见

，这三次比对

都报告“失

配

”。那么，这三次

比对的失败

结果属于偶

然吗？

进一步

地，这些比对

能否避免？

实

际上，即便说

P[3]与T[i]的比对还

算必

要，后续

的这三次比

对却都是不

必要的。实际

上，

它们的失

败结果早已

注定。

只需注

意到P[3] = P[2] =

P[1] = P[0] =

'0'，就不难

看出这一点

既然经过此

前的比

对已

发现T[i]  P[3]，那么继

续将T[i]和那些

与P[3]相同的字

符做比对，既

重蹈覆辙，更

徒劳

无益。

§11.3 KMP算

法 第11章

串

316

 记

忆

= 教训 = 预知

力

就算法策

略而言，11.3.2节引

入next表的实质

作用，在于帮

助我们利用

以往成功比

对所提

供的

“经验”，将记忆

力转化为预

知力。然而实

际上，此前已

进行过的比

对还远不止

这些，确切

地

说还包括那

些失败的比

对作为“教训

”，它们同样有

益，但可惜此

前一直被忽

略了。

依然以

图11.9为例，以往

所做的失败

比对，实际上

已经为我们

提供了一条

极为重要的

信息

T[i]  P[4]可惜我

们却未能有

效地加以利

用。原算法之

所以会执行

后续四次本

不必要

的比

对，原因也正

在于未能充

分汲取教训

。

 改进

为把这

类“负面”信息

引入next表，只需

将11.3.2节中集合

N(P, j)的定义修改

为：

N(P, j) = {

0  t <

j | P[0, t)

= P[j - t,

j) 且 P[t] 

P[j] }

也就是

说，除“对应于

自匹配长度

”以外，t只有还

同时满足“当

前字符对不

匹配”的必要

条件，方能归

入集合N(P, j)并作

为next表项的候

选。

相应地，原

next表构造算法

（代码11.4）也需稍

作修改，调整

为如下改进

版本。

1 int* buildNext

( char* P )

{ //极造模

式串P癿next表（改

迕版本）

2 size_t

m = strlen (

P ), j =

0; //“主”串

指针

3 int*

N = new int[m];

//next表

4 int t

= N[0] = -1;

//模式

串指针

5 while (

j < m -

1 )

6 if

( 0 > t

|| P[j] == P[t]

) { //匘配

7 j

++; t ++;

8

N[j] = ( P[j]

!= P[t] ? t

: N[t] ); //注意此句不

未改迕乀前

癿匙删

9 } else //失配

10

t = N[t];

11

return N;

12 }

代码11.5 改迕癿

next表极造算法

由代码11.5可见

，改进后的算

法与原算法

的唯一区别

在于，每次在

P[0, j)中发现长度

为t

的真前缀

和真后缀相

互匹配之后

，还需进一步

检查P[j]是否等

于P[t]。唯有在P[j]

 P[t]时

，

才能将t赋予

next[j]；否则，需转而

代之以next[t]。

仿照

11.3.7节的分析方

法易知，改进

后next表的构造

算法同样只

需O(m)时间。

 实例

仍以P = "000010"为例，改

进之后的next

表

如表11.5所示。读

者可参照图

11.9，就计算

效率

将新版本与

原版本（表11.4）做

一对比。

表11.5 改

迕后癿next表实

例

rank -1 0 1

2 3 4 5

P[] * 0 0

0 0 1 0

next[] N/A -1 -1

-1 -1 3 -1

利用新的

next表针对图11.9中

实例重新执

行KMP算法，在首

轮比对因T[i] = '1' 

'0' = 

P[3]失

配而中断之

后，将随即以

P[

next[3] ] = P[-1]（虚拟通配符

）与T[i]对齐，并启

动

下一轮比

对。将其效果

而言，等同于

聪明且安全

地跳过了三

个不必要的

对齐位置。

第

11章 串 §11.4

*BM算法

317

§11.4

*

BM算

法

11.4.1 思路与框

架

 构思

KMP算法

的思路可概

括为：当前比

对一旦失配

，即利用此前

的比对（无论

成功或失败

）所提

供的信

息，尽可能长

距离地移动

模式串。其精

妙之处在于

，无需显式地

反复保存或

更新比对的

历

史，而是独

立于具体的

文本串，事先

根据模式串

预测出所有

可能出现的

失配情况，并

将这些信息

“浓缩”为一张

next表。就其总体

思路而言，本

节将要介绍

的BM算法③与KMP算

法类似，二者

的

区别仅在

于预测和利

用“历史”信息

的具体策略

与方法。

BM算法

中，模式串P与

文本串T的对

准位置依然

“自左向右”推

移，而在每一

对准位置却

是

“自右向左

”地逐一比对

各字符。具体

地，在每一轮

自右向左的

比对过程中

，一旦发现失

配，则

将P右移

一定距离并

再次与T对准

，然后重新一

轮自右向左

的扫描比对

。为实现高效

率，BM算法

同样

需要充分利

用以往的比

对所提供的

信息，使得P可

以“安全地”向

后移动尽可

能远的距离

。

 主体框架

BM算

法的主体框

架，可实现如

代码11.6所示。

1 int match

( char* P, char*

T ) { //Boyer-Morre算

法（完全版，兼

顼Bad

Character不Good Suffix）

2 int*

bc = buildBC (

P ); int* gs

= buildGS ( P

); //极造BC表

和GS表

3 size_t

i = 0; //模式串

相对亍文本

串癿起始位

置（刜始时不

文本串左对

齐）

4 while ( strlen

( T ) >=

i + strlen (

P ) ) {

//丌断右秱

（距离可能丌

止一个字符

）模式串

5 int j

= strlen ( P

) - 1; //从模

式串最末尾

癿字符开始

6

while ( P[j] ==

T[i + j] )

//自右向左比

对

7 if (

0 > --j )

break;

8 if (

0 > j )

//若枀大匘

配后缀 == 整个

模式串（说明

已经完全匘

配）

9

break; //迒回匘配

位置

10 else

//否则，适

弼地秱劢模

式串

11 i +=

__max ( gs[j], j

- bc[ T[i +

j] ] ); //位秱量

根据BC表和GS表

选择大者

12 }

13 delete

[] gs; delete []

bc; //销

殍GS表和BC表

14 return

i;

15 }

代

码11.6

BM主算法

可

见，这里采用

了蛮力算法

后一版本（310页

代码11.2）的方式

，借助整数i和

j指示文本串

中当前的对

齐位置T[i]和模

式串中接受

比对的字符

P[j]。不过，一旦局

部失配，这里

不再是机

械

地令i +=

1并在下

一字符处重

新对齐，而是

采用了两种

启发式策略

确定最大的

安全移动距

离。

为此，需经

过预处理，根

据模式串P整

理出坏字符

和好后缀两

类信息。

与KMP一

样，算法过程

中指针i始终

单调递增；相

应地，P相对于

T的位置也绝

不回退。

③ 由R. S. Boyer和

J.

S. Moore亍1977年収明[61]

§11.4 *BM算

法

第11章 串

318

11.4.2

坏

字符策略

 坏

字符

如图11.10(a)和

(b)所示，若模式

串P当前在文

本串T中的对

齐位置为i，且

在这一轮自

右向

左将P与

substr(T, i, m)的比对过程

中，在P[j]处首次

发现失配：

T[i

+ j] = 'X'

 'Y' = P[j]

则

将'X'称作坏字

符（bad character）。问题是：

接

下来应该选

择P中哪个字

符对准T[i +

j]，然后

开始下一轮

自右向左的

比对？

图11.10 坏字

符策略：通过

右秱模式串

P，使T[i +

j]重新得刡

匹配

若P与T的

某一（包括T[i + j]在

内的）子串匹

配，则必然在

T[i

+ j] = 'X'处匹配；反

之

，若与T[i + j]对准的

字符不是'X'，则

必然失配。故

如图11.10(c)所示，只

需找出P中的

每

一字符

'X'，分

别与T[i + j] =

'X'对准，并

执行一轮自

右向左的扫

描比对。不难

看出，对应

于

每个这样的

字符'X'，P的位移

量仅取决于

原失配位置

j，以及'X'在P中的

秩，而与T和i无

关！

 bc[]表

若P中包

含多个'X'，则是

否真地有必

要逐一尝试

呢？实际上，这

既不现实如

此将无法

确

保文本串指

针i永不回退

更不必要。一

种简便而高

效的做法是

，仅尝试P中最

靠右的字符

'X'（若存在）。与KMP算

法类似，如此

便可在确保

不致遗漏匹

配的前提下

，始终单向地

滑动模

式串

。具体如图11.10(c)所

示，若P中最靠

右的字符'X'为

P[k] =

'X'，则P的右移量

即为j - k。

同样幸

运的是，对于

任一给定的

模式串P，k值只

取决于字符

T[i

+ j] = 'X'，因此可将其

视作从字符

表到整数（P中

字符的秩）的

一个函数：

bc(c) = 







k （若

P[k]

= c，且对所有的

i > k都有P[i]

 c）

-1 （若P[]中不

含字符c）

故如

代码11.6所示，如

当前对齐位

置为i，则一旦

出现坏字符

P[j] = 'Y'，即重新对齐

于：

i

+= j - bc[

T[i + j] ]

并启动下

一轮比对。为

此可仿照KMP算

法，预先将函

数bc()整理为一

份查询表，称

作BC表。

第11章 串

§11.4 *BM算法

319

 特殊情

况

可用的BC表

，还应足以处

理各种特殊

情况。比如，若

P根本就不含

坏字符'X'，则如

图11.10(d)

所示，应将

该串整体移

过失配位置

T[i + j]，用P[0]对准T[i +

j + 1]，再启

动下一轮比

对。

实际上，上

述对bc()函数的

定义已给出

了应对方法

将BC表中此类

字符的对应

项置为-1。这

种

处理手法与

KMP算法类似，其

效果也等同

于在模式串

的最左端，增

添一个通配

符。

另外，即使

P串中含有坏

字符'X'，但其中

最靠右者的

位置也可能

太靠右，以至

于k = bc['X']

 j。此时的j - k不

再是正数，故

若仍以此距

离右移模式

串，则实际效

果将如图11.10(e)所

示

等同于左

移。显然，这类

移动并不必

要匹配算法

若果真能够

进行至此，则

此前左侧的

所有位

置都

已被显式或

隐式地否定

排除了。因此

，这种情况下

不妨如图11.10(f)所

示，简单地将

P串右

移一个

字符，然后启

动下一轮自

右向左的比

对。



bc[]表实例

以

由大写英文

字母和空格

组成的字符

表 = {

'□', 'A'~'Z' }为例。按照

以上定义，与

模式串"DATA STRUCTURES"相对

应的BC表应如

表11.6所示。

表11.6 模

式串P = "DATA

STRUCTURES"及其对

应癿BC表

rank -1 0

1 2 3 4

5 6 7 8

9 10 11 12

13 14

P[] *

D A T A

□ S T R

U C T U

R E S

char

□ A B C

D E F G

H I J K

L M N O

P Q R S

T U V W

X Y Z

bc[]

4 3 -1 9

0 13 -1 -1

-1 -1 -1 -1

-1 -1 -1 -1

-1 -1 12 14

10 11 -1 -1

-1 -1 -1

其中

，字符'A'在秩为

1和3处出现了

两次，bc['A']取作其

中的大者3；字

符'T'则在秩为

2、

6和10处出现了

三次，bc['T']取作其

中的最大者

10。在该字符串

中并未出现

的字符，对应

的BC

表项均统

一取作-1，等效

于指向在字

符串最左端

假想着增添

的通配符。

 bc[]表

构造算法

按

照上述思路

，BC表的构造算

法可实现如

代码11.7所示。

1 //*****************************************************************************************

2

// 0 bc['X'] m-1

3 // | |

|

4 // ........................X***************************************

5 // .|<------------- 'X'

free ------------>|

6 //*****************************************************************************************

7 int* buildBC (

char* P ) {

//极

造Bad Charactor Shift表：O(m +

256)

8 int* bc

= new int[256]; //BC表，不字

符表等长

9 for ( size_t

j = 0; j

< 256; j ++

) bc[j] = -1;

//刜

始化：首先假

讴所有字符

均未在P中出

现

10 for (

size_t m = strlen

( P ), j

= 0; j <

m; j ++ )

//自左向右

扫描模式串

P

11 bc[ P[j]

] = j; //将字符P[j]癿BC项

更新为j（单调

逑增）——画家算

法

12 return bc;

13

}

代码11.7 BC表癿

极造

§11.4

*BM算法 第

11章 串

320

该算法

在对BC初始化

之后，对模式

串P做一遍线

性扫描，并不

断用当前字

符的秩更新

BC表中

的对应

项。因为是按

秩递增的次

序从左到右

扫描，故只要

字符c在P中出

现过，则最终

的bc[c]必

将如我

们的所期望

的那样，记录

下其中最靠

右者的秩。

若

将BC表比作一

块画布，则其

中各项的更

新过程，就犹

如画家在不

同位置堆积

不同的油彩

。

而画布上各

处最终的颜

色，仅取决于

在对应位置

所堆积的最

后一笔这类

算法，也因此

称作

“画家算

法”（painter's algorithm）。

代码11.7的运

行时间可划

分为两部分

，分别消耗于

其中的两个

循环。前者是

对字符表中

的

每个字符

分别做初始

化，时间量不

超过O(||)。后一循

环对模式串

P做一轮扫描

，其中每个字

符

消耗O(1)时间

，故共需O(m)时间

。由此可知，BC表

可在O(|| + m)时间内

构造出来，其

中||

为字符表

的规模，m为模

式串的长度

。

 匹配实例

一

次完整的查

找过程，如图

11.11所示。这里的

文本串T长度

为12(b)，模式串P长

度为4(a)。

模式串

P中各字符所

对应的bc[]表项

，如图(a)所示。

因

这里的字符

表涵盖常用

的汉字，规模

很大，故为节

省篇幅，除了

模式串所含

的四个字符

，

其余大量字

符的bc[]表项均

默认统一为

-1，在此不再逐

个标出。

以下

，首先如图(c1)所

示，在第一个

对齐位置，经

1次后比较发

现P[3]

= '常' 



'非' = T[3]。于是

如图(c2)所示，将

P[bc['非']] =

P[2]与T[3]对齐，并

经3

次比较后

发现P[1] = '名'

 '道' =

T[2]。于

是如图(c3)所示

，将P[bc['道']] 

= P[-1]与T[2]对齐

，并经1次比较

发现

P[3] = '常' 

'名' = T[6]。于

是如图

(c4)所示

，将P[bc['名']]

= P[1]与T[6]

对齐

，并经过1次比

较发现P[3] =

'常' 

'名

' =

T[8]。最后如图(c5)所

示，将

P[bc['名']] = P[1]与T[8]对

齐，并经4

次比

较后匹配成

功。

图11.11 借劣bc[]表

癿串匹配

可

见，整个过程

中总共做过

6次成功的（黑

色字符）和4次

失败的（灰色

字符）比较，累

计

10次，文本串

的每个有效

字符平均为

10/11不足一次。

 复

杂度

若暂且

不计构造BC表

的过程，BM算法

本身进行串

模式匹配所

需的时间与

具体的输入

十分相

关。若

将文本串和

模式串的长

度分别记作

n和m，则在通常

情况下的实

际运行时间

往往低于O(n)。

而

在最好的情

况下，每经过

常数次比对

，BM算法就可以

将模式串右

移m个字符（即

整体右移）。

比

如，图11.2中蛮力

算法的最坏

例子，却属于

BM算法的最好

情况。此类情

况下，只需经

过n /

m

次比对算

法即可终止

，故运行时间

不超过O(n / m)。

反之

，若如图11.3模式

串P左右颠倒

，则在每一轮

比对中，P总要

完整地扫描

一遍才发现

失

配并向右

移动一个字

符。此类情况

下的总体运

行时间将为

O(nm)，属于最坏情

况。

第11章 串

§11.4 *BM算

法

321

11.4.3

好后缀策

略

 构思

上述

基于坏字符

的启发策略

，充分体现了

“将教训转化

为预知力”的

构思：一旦发

现P[j]

与T[i + j]失配，就

将P与T重新对

齐于至少可

使T[i +

j]恢复匹配

（含通配）的位

置。然而正

如

上例所揭示

的，这一策略

有时仍显得

不够“聪明”，计

算效率将退

化为几乎等

同于蛮力算

法。

参照KMP算法

的改进思路

不难发现，坏

字符策略仅

利用了此前

（最后一次）失

败比对所提

供

的“教训”。而

实际上在此

之前，还做过

一系列成功

的比对，而这

些“经验”却被

忽略了。

回到

如图11.3所示的

最坏情况，每

当在P[0] = '1' 

'0'处失配

，自然首先应

该考虑将其

替换为字符

'0'（或通配符）。但

既然本轮比

对过程中已

有大量字符

'0'的成功匹配

，则无论将

P[0]对

准其中的任

何一个都注

定会失配。故

此时更明智

地，应将P整体

“滑过”这段区

间，直接

以P[0]对

准T中尚未接

受比对的首

个字符。果真

如此，算法的

运行时间将

有望降回至

O(n)！



好后缀

每轮

比对中的若

干次（连续的

）成功匹配，都

对应于模式

串P的一个后

缀，称作“好后

缀”

（good suffix）。按照以上

分析，必须充

分利用好好

后缀所提供

的“经验”。

一般

地，如图11.12(a)和(b)所

示，设本轮自

右向左的扫

描终止于失

配位置：

T[i + j]

= 'X'  'Y'

= P[j]

若分

别记

W

= substr(T, i +

j + 1, m

- j - 1)

= T[i + j

+ 1, m +

i)

U = suffix(P,

m - j -

1) = P[j +

1, m)

则U即为

当前的好后

缀，W为T中与之

匹配的子串

。

好后缀U长度

为m

- j - 1，故只要j

 m - 2，则

U必非空，且有

U

= W。此时具体地

：

根据好后缀

所提供的信

息应如何确

定，P中有哪个

（哪些）字符值

得与上一失

配

字符T[i

+ j]对齐

，然后启动下

一轮比对呢

？

图11.12 好后缀策

略：通过右秱

模式串P，使不

P后缀U匹配癿

W重新得刡匹

配

如图11.12(c)所示

，设存在某一

整数k，使得在

将P右移j - k个单

元，并使P[k]与T[i +

j]

相

互对齐之后

，P能够与文本

串T的某一（包

含T[m + i

- 1]在内的）子

串匹配，亦即

：

P =

substr(T, i + j

- k, m) =

T[i + j -

k, m + i

+ j - k)

于是，若记：

V(k) = substr(P,

k + 1, m

- j - 1)

= P[k + 1,

m - j +

k)

§11.4 *BM算

法 第11章

串

322

则

必然有：

V(k)

= W = U

也就

是说，若值得

将P[k]与T[i + j]对齐并

做新的一轮

比对，则P的子

串V(k)首先必须

与P自己

的后

缀U相互匹配

这正是从好

后缀中“挖掘

”出来的“经验

”。

此外，还有另

一必要条件

：P中这两个自

匹配子串的

前驱字符不

得相等，即P[k]  P[j]。

否

则，与第11.3.8节KMP算

法的改进同

理，在此对齐

位置也注定

不会出现与

P的整体匹配

。

当然，若模式

串P中同时存

在多个满足

上述必要条

件的子串V(k)，则

不妨选取其

中最靠右者

（对应于最大

的k、最小的右

移距离j - k）。这一

处理手法的

原理，依然与

KMP算法类似如

此既不致遗

漏匹配位置

，亦可保证始

终单向地“滑

动”模式串，而

不致回退。



gs[]表

如图11.12(c)所示，若

满足上述必

要条件的子

串V(k)起始于P[k + 1]，则

模式串对应

的右

移量应

就是j

- k。表面上

，此右移量同

时取决于失

配位置j以及

k；然而实际上

，k本身（也因

此

包括位移量

j -

k）仅取决于模

式串P以及j值

。因此可以仿

照KMP算法的做

法，通过预处

理，

将模式串

P事先转换为

另一张查找

表gs[0, m)，其中gs[j] =

j - k分别

记录对应的

位移量。

如图

11.12(d)所示，若P中没

有任何子串

V(k)可与好后缀

U完全匹配呢

？此时需从P的

所有

前缀中

，找出可与U的

某一（真）后缀

相匹配的最

长者，作为V(k)，并

取gs[j] = m -

|V(k)|。

表11.7 模式串

P =

"ICED RICE PRICE"对应癿GS表

j

0 1 2 3

4 5 6 7

8 9 10 11

12 13 14

P[j]

I C E D

□ R I C

E □ P R

I C E

gs[j]

12 12 12 12

12 12 12 12

12 12 6 12

15 15 1

考

查如表11.7所示

的实例。其中

的gs[10]

= 6可理解为

：一旦在P[10] = 'P'处发

生失配，

则应

将模式串P右

移6个字符，即

用P[10 - 6] =

P[4] = '□'对准文本

串T的失配字

符，然后

启动

下一轮比对

。类似地，gs[5]

= 12意味

着：一旦在P[5] = 'R'处

发生失配，则

应将模式串

P整体右移12个

字符，然后继

续启动下一

轮比对。当然

，也可以等效

地认为，以P[5

- 12] = P[-7]

对

准文本串中

失配的字符

，或以P[0]对准文

本串中尚未

对准过的最

左侧字符。

 匹

配实例

基于

好后缀策略

的匹配实例

，如图

11.13所示。首

先如图(c1)所示

，在第

一个对

齐位置，经1次

比较发现：

P[7] =

'也

'  '静' =

T[7]

于是如图

(c2)所示，将P右移

gs[7] = 1

位，经3次比较

发现：

P[5] = '故'

 '曰' = T[6]

于

是如图(c3)所示

，将P右移gs[5] = 4

位，经

8次比较后匹

配成功。

图11.13 借

劣gs[]表癿串匹

配：

(a) 模式串P及

其gs[]表；(b)

文本串

T

可见，整个过

程中总共做

10次成功的（黑

色字符）和2次

失败的（灰色

字符）比较，累

计12

次比较。文

本串的每个

字符，平均（12/13）不

足一次。

第11章

串

§11.4 *BM算法

323



复杂

度

如317页代码

11.6所示，可以同

时结合以上

BC表和GS表两种

启发策略，加

快模式串相

对于文

本串

的右移速度

。可以证明，对

于匹配失败

的情况，总体

比对的次数

不致超过O(n)

[60][62][63]。

若

不排除完全

匹配的可能

，则该算法在

最坏情况下

的效率，有可

能退化至与

蛮力算法相

当。

所幸，只要

做些简单的

改进，依然能

够保证总体

的比对次数

不超过线性

（习题[11-7]）。

综上所

述，在兼顾了

坏字符与好

后缀两种策

略之后，BM算法

的运行时间

为O(n +

m)。

11.4.4 gs[]表构造算

法



蛮力算法

根据以上定

义，不难直接

导出一个构

造gs[]表的“算法

”：对于每个好

后缀P(j, m)，按照

自

后向前（k从j -

1递

减至0）的次序

，将其与P的每

个子串P(k, m + k

- j)逐一

对齐，并核

对

是否出现如

图11.12(c~d)所示的匹

配。一旦发现

匹配，对应的

位移量即是

gs[j]的取值。

然而

遗憾的是，这

里共有O(m)个好

后缀，各需与

O(m)个子串对齐

，每次对齐后

在最坏情况

下都需要比

对O(m)次，因此该

“算法”可能需

要O(m

3

)的时间。

实

际上，仅需线

性的时间即

可构造出gs[]表

（习题[11-6]）。为此，我

们需要引入

ss[]表。



MS[]串与ss[]表

图

11.14 MS[j]和ss[j]表癿定义

不含义

如图

11.14所示，对于任

一整数j

 [0, m)，在P[0, j]的

所有后缀中

，考查那些与

P的某

一后缀

匹配者。若将

其中的最长

者记作MS[j]，则ss[j]就

是该串的长

度|MS[j]|。特别地，当

MS[j]不存在时，取

ss[j] = 0。

综上所述，可

定义ss[j]如下：

ss[j] = max{ 0

 s  j

+ 1 | P(j

- s, j] =

P[m - s, m)

}

特

别地，当j = m

- 1时，必

有s = m此时，有P(-1,

m - 1] =

P[0, m)。

 实

例

表11.8 模式串

P = "ICED

RICE PRICE"对应癿SS表

i 0

1 2 3 4

5 6 7 8

9 10 11 12

13 14

P[i] I

C E D □

R I C E

□ P R I

C E

ss[i] 0

0 3 0 0

0 0 0 4

0 0 0 0

0 15

仍

以表11.7中的模

式串P为例，按

照如上定义

，P所对应的ss[]表

应如表11.8所示

。

比如，其中之

所以有ss[8]

= 4，是因

为若取j = 8和s

= 4，则

有：

P(8 -

4, 8] = P(4,

8] = "RICE" =

P[11, 15) = P[15

- 4, 15)

实际上，ss[]表

中蕴含了gs[]表

的所有信息

，由前者足以

便捷地构造

出后者。

§11.4 *BM算法

第11章 串

324

 由ss[]表

构造gs[]表

如图

11.15所示，任一字

符P[j]所对应的

ss[j]值，可分两种

情况提供有

效的信息。

第

一种情况如

图(a)所示，设该

位置j满足：

ss[j] = j +

1

也

就是说，MS[j]就是

整个前缀P[0, j]。此

时，对于P[m -

j - 1]左侧

的每个字符

P[i]而言，

对应于

如图11.12(d)所示的

情况，m

- j - 1都应该

是gs[i]取值的一

个候选。

图11.15 由

ss[]表极造gs[]表

第

二种情况如

图(b)所示，设该

位置j满足：

ss[j]

 j

也

就是说，MS[j]只是

P[0, j]的一个真后

缀。此时，对于

字符P[m

- ss[j] - 1]而言，对

应

于如图11.12(c)所

示的情况，若

同时还满足

：

P[m - ss[j]

- 1]  P[

j - ss[j] ]

则m - j -

1也应是gs[m - ss[j] -

1]取

值的一个候

选。

反过来，根

据此前所做

的定义，每一

位置i所对应

的gs[i]值只可能

来自于以上

候选。进一

步

地，既然gs[i]的最

终取值是上

述候选中的

最小（最安全

）者，故仿照构

造bc[]表的画家

算法，

累计用

时将不超过

O(m)（习题[11-6]）。

 ss[]表的构

造

由上可见

，ss[]表的确是构

造gs[]表的基础

与关键。同样

地，若采用蛮

力策略，则对

每个

字符P[j]都

需要做一趟

扫描对比，直

到出现失配

。如此，累计需

要O(m

2

)时间。

为了

提高效率，我

们不妨自后

向前地逆向

扫描，并逐一

计算出各字

符P[j]对应的ss[j]值

。

如图11.16所示，因

此时必有P[j]

= P[m - hi

+ j - 1]，故

可利用此前

已计算出的

ss[m

- hi 

+

j - 1]，分两种情况

快速地导出

ss[j]。在此期间，只

需动态地记

录当前的极

长匹配后缀

：

P(lo,

hi] = P[m -

hi + lo, m)

第一种情况

如图(a)所示，设

：

ss[m - hi

+ j - 1]

 j - lo

此时，ss[m - hi +

j - 1]也是ss[j]可

能的最大取

值，于是便可

直接得到：

ss[j]

= ss[m - hi

+ j - 1]

第

11章 串 §11.4 *BM算法

325

图

11.16 极造ss[]表

第二

种情况如图

(b)所示，设：

j - lo <

ss[m - hi +

j - 1]

此时

，至少仍有：

P(lo, j] = P[m

- hi + lo,

m - hi +

j)

故

只需将

P(j -

ss[m - hi +

j - 1], lo]

与

P[m - hi

+ j - ss[m

- hi + j

- 1], m -

hi + lo)

做

一比对，也可

确定ss[j]。当然，这

种情况下极

大匹配串的

边界lo和hi也需

相应左移（递

减）。

同样地，以

上构思只要

实现得当，也

只需O(m)时间即

可构造出ss[]表

（习题[11-6]）。

 算法实

现

按照上述

思路，GS表的构

造算法可实

现如代码11.8所

示。

1 int* buildSS (

char* P ) {

//极造最大

匘配后缀长

度表：O(m)

2 int m

= strlen ( P

); int* ss =

new int[m]; //Suffix Size表

3 ss[m - 1]

= m; //对最

后一个字符

而言，不乀匘

配癿最长后

缀就是整个

P串

4

// 以下，从倒

数第二个字

符起自右向

左扫描P，依次

计算出ss[]其余

各项

5 for

( int lo =

m - 1, hi

= m - 1,

j = lo -

1; j >= 0;

j -- )

6

if ( ( lo

< j ) &&

( ss[m - hi

+ j - 1]

<= j - lo

) ) //情冴一

7 ss[j]

= ss[m - hi

+ j - 1];

//直接刟用此

前已计算出

癿ss[]

8 else {

//情冴二

9 hi =

j; lo = __min

( lo, hi );

10 while ( (

0 <= lo )

&& ( P[lo] ==

P[m - hi +

lo - 1] )

) //二

重循环？

11 lo--;

//逐个

对比处亍(lo, hi]前

端癿字符

12 ss[j]

= hi - lo;

13 }

14 return

ss;

15 }

16

§11.4 *BM算

法 第11章 串

326

17 int* buildGS

( char* P )

{ //极

造好后缀位

秱量表：O(m)

18 int*

ss = buildSS (

P ); //Suffix Size

table

19 size_t m

= strlen ( P

); int* gs =

new int[m]; //Good Suffix

shift table

20 for

( size_t j =

0; j < m;

j ++ ) gs[j]

= m; //刜始

化

21

for ( size_t i

= 0, j =

m - 1; j

< UINT_MAX; j --

) //逆向逐一

扫描各字符

P[j]

22 if

( j + 1

== ss[j] ) //若P[0,

j] = P[m -

j - 1, m)，则

23 while ( i

< m - j

- 1 ) //对亍P[m

- j - 1]左

侧癿殏个字

符P[i]而言（二重

循环？）

24 gs[i++] = m

- j - 1;

//m - j -

1都是gs[i]癿

一种选择

25 for (

size_t j = 0;

j < m -

1; j ++ )

//画

家算法：正向

扫描P[]各字符

，gs[j]丌断逑减，直

至最小

26 gs[m -

ss[j] - 1] =

m - j -

1; //m - j

- 1必是

其gs[m - ss[j]

- 1]值癿一种

选择

27 delete

[] ss; return gs;

28 }

代码11.8 GS表

癿极造

11.4.5 算法

纵览

 时间效

率的变化范

围

以上我们

针对串匹配

问题，依次介

绍了蛮力、KMP、基

于BC表、综合BC表

与GS表等四种

典型

算法，其

渐进复杂度

的跨度范围

，可概括如图

11.17所示。

图11.17 典型

串匹配算法

癿复杂度概

觅

其中，蛮力

（BF）算法的时间

效率介于O(n * m)至

O(n +

m)之间，而且其

最好情况与

KMP

算法相当！当

然，后者的优

势在于，无论

何种情况，时

间效率均稳

定在O(n + m)。因此在

蛮力

算法效

率接近或达

到最坏的O(n * m)时

，KMP算法的优势

才会十分明

显。

仅采用坏

字符启发策

略（BC）的BM算法，时

间效率介于

O(n

* m)至O(n / m)之间。可见

，

其最好情况

与最坏情况

相差悬殊。结

合了好后缀

启发策略（BC + GS）后

的BM算法，则介

于O(n +

m)和O(n / m)之间。可

见，在改进最

低效率的同

时，保持了最

高效率的优

势。



单次比对

成功概率

饶

有意味的是

，单次比对成

功的概率，是

决定串匹配

算法时间效

率的一项关

键因素。

纵观

以上串匹配

算法，在每一

对齐位置所

进行的一轮

比对中，仅有

最后一次可

能失败；反之

，

此前的所有

比对（若的确

进行过）必然

都是成功的

。反观诸如图

11.2、图11.3的实例可

见，各

种算法

的最坏情况

均可概括为

：因启发策略

不够精妙甚

至不当，在每

一对齐位置

都需进行多

达

(m)次成功的

比对（另加最

后一次失败

的比对）。

若将

单次比对成

功的概率记

作Pr，则以上算

法的时间性

能随Pr的变化

趋势，大致如

图11.18

第11章

串 §11.5 *Karp-Rabin算

法

327

所示。其中

纵坐标为运

行时间，分为

O(n / m)、O(n +

m)和O(n * m)三档当然

，此处只

是大

致示意，实际

的增长趋势

未必是线性

的。

图11.18 随着单

次比对成功

概率（横轰）癿

提高，串匹配

算法癿运行

时间（纵轰）通

常亦将增加

可见，对于同

一算法，计算

时间与Pr具有

单调正相关

关系这一点

不难理解，正

如以上

分析

，消耗于每一

对齐位置的

平均时间成

本随Pr的提高

而增加。



字符

表长度

实际

上，在所有字

符均等概率

出现的情况

下，Pr的取值将

主要决定于

字符表的长

度||，并

与之成

反比关系：字

符表越长，其

中任何一对

字符匹配的

概率越低。

这

一性质可用

以解释：在通

常的情况下

，蛮力算法实

际的运行效

率并不算太

低（习题

[11-9]）；不同

的串匹配算

法，因何各自

有其适用的

场合（习题[11-10]）。

§11.5 

*

Karp-Rabin算

法

11.5.1 构思



凡物

皆数

早在公

元前500年，先贤

毕达哥拉斯

及其信徒即

笃信"凡物皆

数"

④。近世以来

，以克罗内克

⑤

为代表的构

造主义数学

家曾坚定地

认为，唯有可

直接构造的

自然数才是

万物的本源

。而此后无论

是康托⑥还是

哥德尔⑦，都以

他们杰出的

发现，为这一

思想添加了

生动的注脚

。

其实，即便是

限于本书所

涉及和讨论

的计算机科

学领域，循着

这一思路也

可导出优美

、简洁

和高效

的数据结构

及算法。比如

，细细品味第

9章后不难领

悟到，散列技

术亦可视作

为这一思想

的产物。从这

一角度来看

，散列之所以

可实现极高

的效率，正在

于它突破了

通常对关键

码的狭义

理

解允许操作

对象不必支

持大小比较

从而在一般

类型的对象

（词条）与自然

数（散列地

址

）之间，建立起

直接的联系

。

那么，这一构

思与技巧，可

否转而运用

于本章讨论

的主题呢？答

案是肯定的

。

 串亦为数

为

此，可以效仿

康托的思路

，将任一有限

长度的整数

向量视作自

然数，进而在

字符串与自

然

数之间建

立联系。

 

④

"All things are numbers.",

Pythagoras (570 ~ 495

B.C.)

⑤

"God made

the integers; all else

is the work of

man.", L. Kronecker (1823

~ 1891)

⑥

Geogr

Cantor (1845 ~ 1918)

⑦

Kurt Godel (1906

~ 1978)

§11.5 *Karp-Rabin算法

第11章

串

328

若字

母表规模|| =

d，则

任一字符串

都将对应于

一个d + 1进制⑧的

整数。以由大

写英文

字母

组成的字母

表为例，若将

这些字符依

次映射为[1,

26]内

的自然数，则

每个这样的

字符串都

将

对应于一个

26 + 1

= 27进制的整数

，比如：

"CANTOR" =

<3, 1, 14, 20,

15, 18>(27) = 43,868,727(10)

"DATA" = <4, 1,

20, 1>(27) = 80002(10)

从算法

的角度来看

，这一映射关

系就是一个

不折不扣的

散列。

11.5.2 算法与

实现



算法

以

上散列并非

满射，但不含

'0'的任一d + 1进制

值自然数，均

唯一地对应

于某个字符

串，

故它几乎

已是一个完

美的算法。字

符串经如此

转换所得的

散列码，称作

其指纹（fingerprint）。

按照

这一理解，“判

断模式串P是

否与文本串

T匹配”的问题

，可以转化为

“判断T中是否

有

某个子串

与模式串P拥

有相同的指

纹”的问题。具

体地，只要逐

一取出T中长

度为m的子串

，并将

其对应

的指纹与P所

对应的指纹

做一比对，即

可确定是否

存在匹配位

置这已经可

以称作一个

串匹配算法

了，并以其发

明者姓氏命

名为Karp-Rabin算法。

该

算法相关的

预定义如代

码11.9所示。这里

仅考虑了阿

拉伯数字串

，故每个串的

指纹都已

一

个R = 10进制数。同

时，使用64位整

数的散列码

。

1 #define M 97

//散列表长度

：既然返里幵

丌需要真地

存储散列表

，丌妨叏更大

癿素数，以降

低误刞癿可

能

2 #define R

10 //基数：对亍

二迕刢串，叏

2；对亍十迕刢

串，叏10；对亍ASCII字

符串，叏128戒256

3 #define

DIGIT(S, i) ( (S)[i]

- '0' ) //叏

十迕刢串S癿

第i位数字值

（假定S合法）

4 typedef __int64 HashCode;

//用

64位整数实现

散列码

5 bool check1by1

( char* P, char*

T, size_t i );

6 HashCode prepareDm (

size_t m );

7

void updateHash ( HashCode&

hashT, char* T, size_t

m, size_t k, HashCode

Dm );

代码

11.9 Karp-Rabin算法相关癿

预定义

算法

的主体结构

如代码11.10所示

。除了预先计

算模式串指

纹hash(P)等预处理

，至多包含

|T| - |P|

= n - m轮

迭代，每轮都

需计算当前

子串的指纹

，并与目标指

纹比对。

1 int match (

char* P, char* T

) { //串匘

配算法（Karp-Rabin）

2

size_t m = strlen

( P ), n

= strlen ( T

); //assert: m <=

n

3 HashCode Dm

= prepareDm ( m

), hashP = 0,

hashT = 0;

4

for ( size_t i

= 0; i <

m; i++ ) {

//刜始

化

5 hashP =

( hashP * R

+ DIGIT ( P,

i ) ) %

M; //计算模式

串对应癿散

列值

6 hashT

= ( hashT *

R + DIGIT (

T, i ) )

% M; //计算文

本串（前m位）癿

刜始散列值

7 }

8 for ( size_t

k = 0; ;

) { //查找

⑧ 乀所以

叏d + 1而丌是d，是

为了回避'0'字

符以保证返

一映射是单

射

否则若字

符串中存在

由'0'字符组成

癿前缀，则无

讳诠前缀长

度仸何，都丌

会影响对应

癿整数叏值

第11章 串 §11.5 *Karp-Rabin算法

329

9 if ( hashT

== hashP )

10

if ( check1by1 (

P, T, k )

) return k;

11

if ( ++k >

n - m )

return k; //assert: k

> n - m，表示无匘配

12

else updateHash ( hashT,

T, m, k, Dm

); //否则，更新子

串散列码，继

续查找

13 }

14 }

代码

11.10 Karp-Rabin算法主体框

架

请注意，这

里并不需要

真正地设置

一个散列表

，故空间复杂

度与表长M无

关。

 数位与字

长

然而就效

率而言，将上

述方法称作

算法仍嫌牵

强。首先，直接

计算各子串

的指纹十分

耗时。

仍以上

述大写英文

字符母表为

例，稍长的字

符串就可能

对应于数值

很大的指纹

，比如：

"HASHING" = <8,

1, 19, 8, 9,

14, 7>(27) = 3,123,974,608(10)

"KARPRABIN" = <11, 1,

18, 16, 18, 1,

2, 9, 14>(27) =

3,124,397,993,144(10)

另一方

面，随着字母

表规模d的增

大，指纹的位

数也将急剧

膨胀。以d = 128

= 2^7的ASCII

字

符集为例，只

要模式串长

度m =

|P|  10，其指纹的

长度就会达

到m∙log2d =

70个比特，从

而超出目前

通常支持的

32 ~ 64位字长。这就

意味着，若指

纹持续加长

，即便不考虑

存储所需的

空间字长而

仅就时间成

本而言，无论

是指纹的计

算还是指纹

的比对，都无

法在O(1)时间内

完成。

确切地

说，这些操作

所需的时间

都将线性正

比于模式串

长度m。于是整

个“算法”的时

间复杂度

将

高达O(n * m)退回到

11.2节的蛮力算

法。



散列压缩

不妨暂且搁

置指纹的快

速计算问题

，首先讨论指

纹的快速比

对。既然上述

指纹完全等

效于字

符串

的散列码，上

述问题也就

与我们在9.3.2节

中所面临的

困境类似若

不能对整个

散列空间

进

行有效的压

缩，则以上方

法将仅停留

于朴素的构

思，而将无法

兑现为实用

的算法。

仿照

9.3.3节的思路和

方

法，这里不

妨以除余法

为示

例，通过

散列函数hash(key) 

=

key % M，将

指纹的数值

压

缩至一个

可以接受的

范围。以

十进

制数字串为

例，字母表规

模d = 10。

例如，如图

11.19所示即

为散

列表长选作

M = 97时，一

次完整

的匹配过程

。

图11.19 Karp-Rabin串匹配算

法实例：

模式

串指纹hash("82818") =

82,818 % 97 =

77

首先

经预处理，提

前计算出模

式串P的指纹

hash("82818") = 77。

此后，自左向

右地依次取

出文本串T中

长度为m的各

个子串，计算

其指纹并与

上述指纹对

比。

由图11.19可见

，经过三次比

对失败，最终

确认匹配于

substr(T, 3, 5)

= P。

可见，经散列

压缩之后，指

纹比对所需

的时间将仅

取决于散列

表长M，而与模

式串长m无关

。

§11.5

*Karp-Rabin算法 第11章 串

330



散列冲突

压

缩散列空间

的同时，必然

引起冲突。就

Karp-Rabin算法而言这

体现为，文本

串中不同子

串的指纹可

能相同，甚至

恰好都与模

式串的指纹

相同。

仍考查

以上实例，但

如图11.20所示改

换为P =

"18284"，其指纹

hash("18284") = 48。

图11.20

Karp-Rabin串匹配算

法实例：模式

串指纹hash("18284") = 18,284 %

97 = 48

于是

，尽管在第二

次指纹比对

时（图(b)）即发现

hash("71828")

= 48，与模式串的

指纹

相同，但

真正的匹配

却应该在第

七次比对后

（图(g)）才能确认

。

既然指纹相

同并不是匹

配的充分条

件，故在发现

指纹相等之

后，还必须如

代码11.11所示，

对

原字符串做

一次严格的

逐位比对。

1 bool check1by1

( char* P, char*

T, size_t i )

{ //指

纹相同时，逐

位比对以确

讣是否真正

匘配

2 for

( size_t m =

strlen ( P ),

j = 0; j

< m; j++, i++

) //尽管需

要O(m)时间

3 if

( P[j] != T[i]

) return false; //但叧

要散列得弼

，调用本例程

幵迒回false癿概

率将枀低

4 return true;

5

}

代

码11.11 指纹相同

时迓需逐个

字符地比对

尽管这种比

对需耗时O(m)，但

只要散列策

略设计得当

，即可有效地

控制发生冲

突以及执行

此类严格比

对的概率。以

此处的除余

法为例，若散

列表容量选

作M，则在“各字

符皆独立且

均匀

分布”的

假定条件下

，指纹相同的

可能性应为

1/M；而随着M的增

大，冲突的概

率将急速下

降。

代码11.9中选

取M = 97完全是出

于演示的需

要，实际应用

中不妨适当

地选用更长

的散列表。



快

速指纹更新

最后，讨论快

速指纹计算

的实现。对图

11.20等实例细加

观察不难发

现，按照自左

向右的次

序

，任何两次相

邻比对所对

应的子串之

间存在极强

的相关性，子

串的指纹亦

是如此。

实际

上，二者仅在

首、末字符处

有所

出入。准

确地如图11.21所

示，前一子串

删

除首字符

之后的后缀

，与后一子串

删除末

字符

之后的前缀

完全相同。 图

11.21 相邻子串内

容及指纹癿

相关性

第11章

串 §11.5 *Karp-Rabin算法

331

利用

这种相关性

，可以根据前

一子串的指

纹，在常数时

间内得到后

一子串的指

纹。也就是说

，

整个算法过

程中消耗于

子串指纹计

算的时间，平

均每次仅为

O(1)。

该算法的具

体实现，如代

码11.12所示。

1

// 子串

指纹快速更

新算法

2 void

updateHash ( HashCode& hashT,

char* T, size_t m,

size_t k, HashCode Dm

) {

3 hashT

= ( hashT -

DIGIT ( T, k

- 1 ) *

Dm ) % M;

//在前

一指纹基础

上，去除首位

T[k - 1]

4

hashT = ( hashT

* R + DIGIT

( T, k +

m - 1 )

) % M; //添加末位T[k

+ m - 1]

5 if ( 0

> hashT ) hashT

+= M; //确

保散列码落

在合法匙间

内

6

}

代码11.12 串指

纹癿快速更

新

这里，前一

子串最高位

对指纹的贡

献量应为P[0]

 M

m-1。只

要注意到其

中的M

m-1始终不

变，

即可考虑

如代码11.13所示

，通过预处理

提前计算出

其对应的模

余值。

为此尽

管可采用代

码1.8中的快速

幂算法power2()，但考

虑到此处仅

需调用一次

，同时兼顾

算

法的简洁性

，故不妨直接

以蛮力累乘

的形式实现

。

1

HashCode prepareDm ( size_t

m ) { //预处理：计算

R^(m

- 1) % M

（仅需调用一

次，丌必优化

）

2 HashCode Dm

= 1;

3 for

( size_t i =

1; i < m;

i++ ) Dm =

( R * Dm

) % M; //直接累乘m

- 1次

，幵叏模

4 return

Dm;

5 }

代码

11.13

提前计算M^(m-1)

§11.5 *Karp-Rabin算

法 第11章

串

332

第

12章

排序

§12.1 快速

排序 第12章 排

序

334

此前各章

已结合具体

的数据结构

，循序渐进地

介绍过多种

基本的排序

算法：2.8节和3.5节

分别针对向

量和列表，统

一以排序器

的形式实现

过起泡排序

、归并排序、插

入排序以及

选择排序

等

算法；9.4.1节也曾

按照散列的

思路与手法

，实现过桶排

序算法；9.4.3节还

将桶排序推

广至

基数排

序算法；10.2.5节也

曾完美地利

用完全二叉

堆的特长，实

现过就地堆

排序算法。

本

章着重于高

级排序算法

。与以上基本

算法一样，其

构思与技巧

各具特色，在

不同应用中

的

效率也各

有千秋。因此

在学习过程

中，唯有更多

地关注不同

算法之间细

微而本质的

差异，留意体

会其优势与

不足，方能做

到运用自如

，并结合实际

问题的需要

，合理取舍与

并适当改造

。

§12.1 快速排序

12.1.1 分

治策略

与归

并排序算法

一样，快速排

序（quicksort）算法①也是

分治策略的

典型应用，但

二者之

间也

有本质区别

。2.8.3节曾指出，归

并排序的计

算量主要消

耗于有序子

向量的归并

操作，而子

向

量的划分却

几乎不费时

间。快速排序

恰好相反，它

可以在O(1)时间

内，由子问题

的解直接得

到原问题的

解；但为了将

原问题划分

为两个子问

题，却需要O(n)时

间。

快速排序

算法虽然能

够确保，划分

出来的子任

务彼此独立

，并且其规模

总和保持渐

进不变，

却不

能保证两个

子任务的规

模大体相当

实际上，甚至

有可能极不

平衡。因此，该

算法并不能

保证最坏情

况下的O(nlogn)时间

复杂度。尽管

如此，它仍然

受到人们的

青睐，并在实

际应用中

往

往成为首选

的排序算法

。究其原因在

于，快速排序

算法易于实

现，代码结构

紧凑简练，而

且对

于按通

常规律随机

分布的输入

序列，快速排

序算法实际

的平均运行

时间较之同

类算法更少

。

下面结合向

量介绍该算

法的原理，并

针对实际需

求相应地给

出不同的实

现版本。

12.1.2 轴点

图12.1

序列癿轰

点（返里用高

度来表示各

元素癿大小

）

 

①

由英国计算

机科学家、1980年

图灵奖得主

C. A. R. Hoare爵士亍1960年収

明[64]

第12章 排序

§12.1 快速排序

335

如

图12.1所示，考查

任一向量区

间S[lo, hi)。对于任何

lo  mi

< hi，以元素S[mi]为

界

，都可分割出

前、后两个子

向量S[lo, mi)和S(mi,

hi)。若S[lo, mi)中

的元素均不

大于

S[mi]，且S(mi, hi)中的

元素均不小

于S[mi]，则元素S[mi]称

作向量S的一

个轴点（pivot）。

设向

量S经排序可

转化为有序

向量S'。不难看

出，轴点位置

mi必然满足如

下充要条件

：

a) S[mi] =

S'[mi]

b) S[lo, mi)和S'[lo,

mi)的成员完

全相同

c) S(mi, hi)和S'(mi,

hi)的

成员完全相

同

因此，不仅

以轴点S[mi]为界

，前、后子向量

的排序可各

自独立地进

行，而且更重

要的是，

一旦

前、后子向量

各自完成排

序，即可立即

（在O(1)时间内）得

到整个向量

的排序结果

。

采用分治策

略，递归地利

用轴点的以

上特性，便可

完成原向量

的整体排序

。

12.1.3 快速排序算

法

按照以上

思路，可作为

向量的一种

排序器，实现

快速排序算

法如代码12.1所

示。

1

template <typename T> //向量快速

排序

2 void Vector<T>::quickSort (

Rank lo, Rank hi

) { //0 <=

lo < hi <=

size

3 if (

hi - lo <

2 ) return; //单元素

匙间自然有

序，否则...

4 Rank mi =

partition ( lo, hi

- 1 ); //在[lo,

hi - 1]内

极造轴点

5

quickSort ( lo, mi

); //对

前缀逑弻排

序

6 quickSort

( mi + 1,

hi ); //对后缀逑

弻排序

7

}

代码

12.1 向量癿快速

排序

可见，轴

点的位置一

旦确定，则只

需以轴点为

界，分别递归

地对前、后子

向量实施快

速排序；

子向

量的排序结

果就地返回

之后，原向量

的整体排序

即告完成。算

法的核心与

关键在于：

轴

点构造算法

partition()应如何实现

？可以达到多

高的效率？

12.1.4 快

速划分算法



反例

事情远

非如此简单

，我们首先遇

到的困难就

是，并非每个

向量都必然

含有轴点。以

如图12.2

所示长

度为9的向量

为例，不难验

证，其中任何

元素都不是

轴点。

图12.2

有序

向量绊循环

左秱一个单

元后，将丌含

仸何轰点

事

实上根据此

前的分析，任

一元素作为

轴点的必要

条件之一是

，其在初始向

量S与排序后

有

序向量S'中

的秩应当相

同。因此反过

来一般地，只

要向量中所

有元素都是

错位的即所

谓的错

排序

列则任何元

素都不可能

是轴点。

由上

可见，若保持

原向量的次

序不变，则不

能保证总是

能够找到轴

点。因此反过

来，唯有通

过

适当地调整

向量中各元

素的位置，方

可“人为地”构

造出一个轴

点。

§12.1 快速排序

第12章

排序

336

 思

路

为在区间

[lo, hi]内构造出一

个轴点，首先

需要任取某

一元素m作为

“培养对象”。

图

12.3 轰点极造算

法癿极思

如

图12.3(a)所示，不妨

取首元素m = S[lo]作

为候选，将其

从向量中取

出并做备份

，腾出

的空闲

单元便于其

它元素的位

置调整。然后

如图(b)所示，不

断试图移动

lo和hi，使之相互

靠拢。

当然，整

个移动过程

中，需始终保

证lo（hi）左侧（右侧

）的元素均不

大于（不小于

）m。

最后如图(c)所

示，当lo与hi彼此

重合时，只需

将原备份的

m回填至这一

位置，则S[lo = hi]

= m便成

为一个名副

其实的轴点

。

以上过程在

构造出轴点

的同时，也按

照相对于轴

点的大小关

系，将原向量

划分为左、右

两个

子向量

，故亦称作快

速划分（quick

partitioning）算法

。

 实现

按照以

上思路，快速

划分算法可

实现如代码

12.2所示。

1 template <typename T>

//轴点极

造算法：通过

调整元素位

置极造匙间

[lo, hi]癿轴点，幵迒

回其秩

2 Rank

Vector<T>::partition ( Rank lo,

Rank hi ) {

//版本

A：基本形式

3 swap (

_elem[lo], _elem[lo + rand()

% ( hi -

lo + 1 )

] ); //仸

选一个元素

不首元素交

换

4

T pivot = _elem[lo];

//以首元素

为候选轴点

——经以上交换

，等效亍随机

选叏

5 while (

lo < hi )

{ //从向量

癿两端交替

地向中间扫

描

6 while

( ( lo <

hi ) && (

pivot <= _elem[hi] )

) //在丌小亍

pivot癿前提下

7 hi--;

//向

左拓展右端

子向量

8 _elem[lo] =

_elem[hi]; //小亍

pivot者弻入左侧

子序列

9 while

( ( lo <

hi ) && (

_elem[lo] <= pivot )

) //在丌

大亍pivot癿前提

下

10 lo++;

//向右拓展

左端子向量

11 _elem[hi] = _elem[lo];

//大亍pivot者弻入

右侧子序列

12 } //assert: lo

== hi

13 _elem[lo]

= pivot; //将备仹癿轴

点记弽置亍

前、后子向量

乀间

14

return lo; //迒回轴

点癿秩

15

}

代码

12.2 轰点极造算

法（版本A）

为便

于和稍后的

改进版本进

行比较，不妨

称作版本A。

第

12章 排序 §12.1 快速

排序

337

 过程

可

见，算法的主

体框架为循

环迭代；主循

环的内部，通

过两轮迭代

交替地移动

lo和hi。

图12.4 轰点极

造过秳

各迭

代的初始状

态如图12.4(a)所示

。反复地将候

选轴点pivot与当

前的_elem[hi]做比较

，

只要前者不

大于后者，就

不断向左移

动hi（除非hi即将

越过lo）。hi无法移

动继续时，当

如图

(b)所示。于

是接下来如

图(c)所示，将_elem[hi]转

移至_elem[lo]，并归入

左侧子向量

。

随后对称地

，将_elem[lo]与pivot做比较

，只要前者不

大于后者，就

不断向右移

动lo（除

非lo即将

越过hi）。lo无法继

续移动时，当

如图(d)所示。于

是接下来如

图(e)所示，将_elem[lo]

转

移至_elem[hi]，并归入

右侧子向量

。

每经过这样

的两轮移动

，lo与hi的间距都

会缩短，故该

算法迟早会

终止。当然，若

如图(e)

所示lo与

hi仍未重合，则

可再做两轮

移动。不难验

证，在任一时

刻，在以lo和hi为

界的三个子

向量中，左、右

子向量分别

满足12.1.2节所列

的轴点充要

条件b)和c)。而随

着算法的持

续推进，

中间

子向量的范

围则不断压

缩。当主循环

退出时lo和hi重

合，充要条件

a)也随即满足

。至此，

只需将

pivot“镶嵌”于左、右

子向量之间

，即实现了对

原向量的一

次轴点划分

。

该算法的运

行时间线性

正比于被移

动元素的数

目，线性正比

于原向量的

规模O(hi - lo)。



实例

图

12.5 轰点极造算

法实例

快速

划分算法的

一次完整运

行过程，如图

12.5所示。

输入序

列A如图(a)长度

为10，选择A[0] = 6作为

轴点候

选。以

下，hi和lo的第一

趟交替移动

的过程及结

果如图

(b~c)所示

，第二趟交替

移动的过程

及结果如图

(d~e)所

示，最后一

趟交替移动

的过程及结

果如图(f~g)所示

。

由于lo和hi的移

动方向相反

，故原处于向

量右（左）

端较

小（大）的元素

将按颠倒的

次序转移至

左（右）端；

特别

地，重复的元

素也将按颠

倒的次序转

移至相对的

一端，

因而不

再保持其原

有的相对次

序。由此可见

，如此实现的

快速排序算

法并不稳定

。从图12.5实例中

数值为5的两

个

元素的移

动过程与最

终效果，不难

看出这一点

。

§12.1

快速排序 第

12章 排序

338

12.1.5 复杂

度

 最坏情况

上节的分析

结论指出，采

用代码12.2中的

partition()算法，可在线

性时间内将

原向量的

排

序问题分解

为两个相互

独立、总体规

模保持线性

的子向量排

序问题；而且

根据轴点的

性质，由

各自

排序后的子

向量，可在常

数时间内得

到整个有序

向量。也就是

说，分治策略

得以高效实

现的

两个必

要条件子问

题划分的高

效性及其相

互之间的独

立性均可保

证。然而尽管

如此，另

一项

关键的必要

条件子任务

规模接近在

这里却无法

保证。事实上

，由partition()算法

划分

出的子任务

在规模上不

仅不能保证

接近，而且可

能相差悬殊

。

反观partition()算法不

难发现，其划

分所得子序

列的长度与

划分的具体

过程无关，而

是完

全取决

于入口处所

选的候选轴

点。具体地，若

在最终有序

向量中该候

选元素的秩

为r，则子向量

的规模必为

r和n -

r - 1。特别地，r =

0时

子向量规模

分别为0和n - 1左

侧子向量为

空，

而右侧子

向量与原向

量几乎等长

。当然，对称的

r

= n - 1亦属最坏情

况。

更糟糕的

是，这类最坏

情况可能持

续发生。比如

，若每次都是

简单地选择

最左端元素

_elem[lo]作为候选轴

点，则对于完

全（或几乎完

全）有序的输

入向量，每次

（或几乎每次

）划

分的结果

都是如此。这

种情况下，若

将快速排序

算法处理规

模为n的向量

所需的时间

记作T(n)，

则如下

递推关系始

终成立：

T(n)

= T(0) + T(n

- 1) + O(n)

= T(n - 1)

+ O(n)

综合

考虑到其常

数复杂度的

递归基，与以

上递推关系

联立即可解

得：

T(n)

= T(n - 2)

+ 2∙O(n) = ...

= T(0) + n∙O(n)

= O(n2

)

也就是说

，其效率居然

低到与起泡

排序相近。

 降

低最坏情况

概率

那么，如

何才能降低

上述最坏情

况出现的概

率呢？读者可

能已注意到

，代码12.2的

partition()算法

在入口处增

加了swap()一句，在

区间内任选

一个元素与

_elem[lo]交换。就

其效

果而言，这使

得后续的处

理等同于随

机选择一个

候选轴点，从

而在一定程

度上降低上

述最坏

情况

出现的概率

。这种方法称

作随机法。

类

似地，也可采

用所谓三者

取中法：从待

排序向量中

任取三个元

素，将数值居

中者作为候

选

轴点。理论

分析及实验

统计均表明

，较之固定选

取某个元素

或随机选取

单个元素的

策略，如此选

出的轴点在

最终有序向

量中秩过小

或过大的概

率更低尽管

还不能彻底

杜绝最坏情

况。

 平均运行

时间

以上关

于最坏情况

下效率仅为

O(n2

)的结论不免

令人沮丧，难

道快速排序

名不副实？实

际

上，更为细

致的分析与

实验统计都

一致地显示

，在大多数情

况下，快速排

序算法的平

均效率依然

可以达到O(nlogn)；而

且较之其它

排序算法，其

时间复杂度

中的常系数

更小。以下就

以最常见

的

场景为例，对

采用随机法

确定候选轴

点的快速排

序算法的平

均效率做一

估算。

假设待

排序的元素

服从独立均

匀随机分布

。于是，partition()算法在

经过n -

1次比较

和

至多n + 1次移

动操作之后

，对规模为n的

向量的划分

结果无非n种

可能，划分所

得左侧子序

列的

长度分

别是0, 1, ..., n

- 1，分别决

定于所取候

选元素在最

终有序序列

中的秩。按假

定条件，

每种

情况的概率

均为1/n，故若将

算法的平均

运行时间记

作^

T(n)，则有：

第12章

排序 §12.1 快速排

序

339

^

T(n) = (n

+ 1) + (1/n)

 k=1

n

[T

^

(k - 1)

+ T

^

(n

- k)]

 =

(n + 1) +

(2/n)  k=1

n

T

^

(k -

1)

等式两侧

同时乘以n，则

有：

n∙

^

T(n) = (n +

1)∙n + 2∙k=1

n

T

^

(k -

1)

以及同理

：

(n -

1)∙^

T(n - 1)

= (n - 1)∙n

+ 2∙k=1

n-1

T

^

(k - 1)

以上两式相

减，即得：

n∙

^

T(n)

- (n - 1)∙^

T(n - 1) =

2n + 2∙^

T(n

- 1)

n∙

^

T(n) = (n +

1)∙^

T(n - 1)

+ 2n

^

T(n)/(n

+ 1) =

^

T(n - 1)/n +

2/(n + 1)

=

^

T(n -

2)/(n - 1) +

2/(n + 1) +

2/n

 =

^

T(n - 3)/(n

- 2) + 2/(n

+ 1) + 2/n

+ 2/(n - 1)

= ...

 =

^

T(0)/1 + 2/(n

+ 1) + 2/n

+ 2/(n - 1)

+ ... + 2/2

= 2∙k=1

n+1(1/k) -

1

 =

②

O(2∙lnn) = O(2∙ln2∙log2n) =

O(1.386∙log2n)

正因

为其良好的

平均性能，加

上其形象直

观和易于实

现的特点，快

速排序算法

自诞生起就

一

直受到人

们的青睐，并

被集成到Linux和

STL等环境中。

12.1.6

应

对退化

 重复

元素

图12.6

partition()算法

癿退化情冴

，也是最坏情

冴

考查所有

（或几乎所有

）元素均重复

的退化情况

。对照代码

12.2不

难发现，partition()算法

的版本A对此

类输入的处

理完全

等效

于此前所举

的最坏情况

。事实上对于

此类向量，主

循环内部前

一子循环的

条件中“pivot

<= _elem[hi]”形同

虚设，故该子

循

环将持续

执行，直至“lo <

hi”不

再满足。当然

，在此之后另

一

内循环及

主循环也将

随即结束。

如

图12.6所示，如此

划分的结果

必然是以最

左端元素为

轴点，

原向量

被分为极不

对称的两个

子向量。更糟

糕的是，这一

最坏情况

还

可能持续发

生，从而使整

个算法过程

等效地退化

为线性递归

，递

归深度为

O(n)，导致总体运

行时间高达

O(n2

)。

② 若记h(n) = 1

+ 1/2 + 1/3

+ ... + 1/n，则有ln(n+1)

= i=1

n+1(1/x) <

h(n) < 1 +

i=1

n

(1/x) =

1 + lnn

§12.1

快

速排序 第12章

排序

340

当然，可

以在每次深

入递归之前

做统一核验

，若确属退化

情况，则无需

继续递归而

直接返回。

但

在重复元素

不多时，如此

不仅不能改

进性能，反而

会增加额外

的计算量，总

体权衡后得

不偿失。

 改进

轴点构造算

法可行的一

种改进方案

如代码12.3所示

。为与如代码

12.2所示同名算

法版本A

相区

别，不妨称作

版本B。

1 template <typename T>

//轴点极

造算法：通过

调整元素位

置极造匙间

[lo, hi]癿轴点，幵迒

回其秩

2 Rank

Vector<T>::partition ( Rank lo,

Rank hi ) {

//版本

B：可优化处理

夗个兲键码

雷同癿退化

情冴

3 swap (

_elem[lo], _elem[lo + rand()

% ( hi -

lo + 1 )

] ); //仸选一

个元素不首

元素交换

4

T pivot = _elem[lo];

//以

首元素为候

选轴点——经以

上交换，等效

亍随机选叏

5 while ( lo

< hi ) {

//从向量癿两

端交替地向

中间扫描

6 while (

lo < hi )

7 if ( pivot

< _elem[hi] ) //在

大亍pivot癿前提

下

8 hi--; //向左拓展

右端子向量

9 else

//直至遇刡丌

大亍pivot者

10 { _elem[lo++]

= _elem[hi]; break; }

//将其

弻入左端子

向量

11 while (

lo < hi )

12 if ( _elem[lo]

< pivot ) //在小亍

pivot癿前提下

13 lo++; //向

右拓展左端

子向量

14

else //直至

遇刡丌小亍

pivot者

15 {

_elem[hi--] = _elem[lo]; break;

} //将其弻入

右端子向量

16 } //assert:

lo == hi

17

_elem[lo] = pivot; //将备仹癿轴

点记弽置亍

前、后子向量

乀间

18 return lo; //迒回轴

点癿秩

19 }

代码

12.3 轰点极造算

法（版本B）

较之

版本A，版本B主

要是调整了

两个内循环

的终止条件

。以前一内循

环为例，原条

件

pivot <= _elem[hi]

在此更改

为：

pivot < _elem[hi]

也就是说

，一旦遇到重

复元素，右端

子向量随即

终止拓展，并

将右端重复

元素转移至

左端。因此，

若

将版本A的策

略归纳为“勤

于拓展、懒于

交换”，版本B的

策略则是“懒

于拓展、勤于

交换”。

 效果及

性能

对照代

码12.3不难验证

，对于由重复

元素构成的

输入向量，以

上版本B将交

替地将右（左

）

侧元素转移

至左（右）侧，并

最终恰好将

轴点置于正

中央的位置

。这就意味着

，退化的输入

向量

能够始

终被均衡的

切分，如此反

而转为最好

情况，排序所

需时间为O(nlogn)。

当

然，以上改进

并非没有代

价。比如，单趟

partition()算法需做更

多的元素交

换操作。好

在

这并不影响

该算法的线

性复杂度。另

外，版本B倾向

于反复交换

重复的元素

，故它们在原

输入

向量中

的相对次序

更难保持，快

速排序算法

稳定性的不

足更是雪上

加霜。

第12章 排

序

§12.2 *选叏不中

位数

341

§12.2

*选取与

中位数

12.2.1 概述

 k-选取

考查如

下问题：

在任

意一组可比

较大小的元

素中，如何找

出由小到大

次序为k者？

如

图12.7(a)所示，也就

是要从与这

组元素对应

的有序序列

S中，找出秩为

k的元素S[k]，

故称

作选取（selection）问题

。若将目标元

素的秩记作

k，则亦称作k-选

取（k-selection）

问题。以无

序向量A = { 3,

13, 2, 5, 8

}为例

，对应的有序

向量为S = { 2,

3, 5, 8, 13

}，

其中

的元素依次

与k = {

0, 1, 2, 3,

4 }相对应。

图

12.7 选叏不中位

数

作为k-选取

问题的特例

，0-选取即通常

的最小值问

题，而(n - 1)-选取问

题即通常的

最大

值问题

。这两个问题

都有平凡的

最优解，例如

List::selectMax()（82页代码3.21）。

在允

许元素重复

的场合，秩为

k的元素可能

同时存在多

个副本。此时

不妨约定，其

中任何一

个

都可作为解

答输出。

 中位

数

如图12.7(b)所示

，在长度为n的

有序序列S中

，位序居中的

元素S[n/2]称作中

值或中位数

（median）。例如，有序序

列S = { 2,

3, 5, 8, 13

}的中位数

，为S[5/2] = S[2] =

5；

而有序序

列S = {

2, 3, 5, 8,

13, 21 }的中位数

，则为S[6/2] =

S[3] = 8。

即便对

于尚未排序

的序列，也可

定义中位数

也就是在对

原数据集排

序之后，对应

的有序

序列

的中位数。例

如，无序序列

A = { 3,

13, 2, 5, 8

}的中位数为

元素A[3] = 5。

由于中

位数可将原

数据集（原问

题）划分为大

小明确、规模

相仿且彼此

独立的两个

子集（子

问题

），故能否高效

地确定中位

数，将直接关

系到采用分

治策略的算

法能否高效

地实现。

 蛮力

算法

由中位

数的定义，可

直接得到查

找中位数的

如下直觉算

法：对所有元

素做排序，将

其转换为

有

序序列S；于是

，S[n/2]便是所要找

的中位数。然

而根据2.7.5节的

结论，该算法

在最坏情

况

下需要(nlogn)时间

。于是，基于该

算法的任何

分治算法，时

间复杂度都

会不低于：

T(n) =

nlogn + 2∙T(n/2) =

O(nlog2

n)

这

一效率难以

令人接受。

综

上可见，中位

数查找问题

的挑战恰恰

就在于：

如何

在避免全排

序的前提下

，在o(nlogn)时间内找

出中位数？

不

难看出，所谓

中位数查找

问题，也可以

理解为是选

取问题在k = n/2时

的特例。稍后

我

们将看到

，中位数查找

问题既是选

取问题的特

例，同时也是

选取问题中

的难度最大

者。

以下先结

合若干特定

情况讨论中

位数的定位

算法，然后再

回到一般性

的选取问题

。

§12.2 *选叏不中位

数

第12章 排序

342

12.2.2 众数

 问题

为

达到热身的

目的，不妨先

来讨论中位

数问题的一

个简化版本

。在任一无序

向量A中，若有

一半以上元

素的数值同

为m，则将m称作

A的众数（majority）。例如

，向量{ 5,

3, 9, 3, 3,

2, 3, 3 }的众数

为3；而虽然3在

向量{

5, 3, 9, 3,

1, 2, 3, 3

}中最多

，确非众数。

那

么，任给无序

向量，如何快

速判断其中

是否存在众

数，并在存在

时将其找出

？尽管只是以

整数向量为

例，以下算法

不难推广至

元素类型支

持判等和比

较操作的任

意向量。

 必要

性与充分性

不难理解但

容易忽略的

一个事实是

：若众数存在

，则必然同时

也是中位数

。否则，在对应

的

有序向量

中，总数超过

半数的众数

必然被中位

数分隔为非

空的两组与

向量的有序

性相悖。

1 template <typename

T> bool majority (

Vector<T> A, T& maj

) { //众数

查找算法：T可

比较可刞等

2 maj

= majEleCandidate ( A

); //必要性：选出

候选者maj

3 return

majEleCheck ( A, maj

); //充分

性：验证maj是否

癿确弼选

4 }

代

码12.4 众数查找

算法主体框

架

因此可如

代码12.4所示，通

过调用majEleCandidate()，从向

量A中找到中

位数maj（如果

的

确可以高效

地查找到的

话），并将其作

为众数的唯

一候选者。

然

后再如代码

12.5所示，调用majEleCheck()在

线性时间内

扫描一遍向

量，通过统计

该中

位数出

现的次数，即

可验证其作

为众数的充

分性，从而最

终判断向量

A的众数是否

的确存在。

1 template

<typename T> bool majEleCheck

( Vector<T> A, T

maj ) { //验

证候选者是

否确为众数

2

int occurrence = 0;

//maj在A[]中出现癿

次数

3 for (

int i = 0;

i < A.size(); i++

) //逐一遍

历A[]癿各个元

素

4 if

( A[i] == maj

) occurrence++; //殏遇刡一

次maj，均更新计

数器

5

return 2 * occurrence

> A.size(); //根据最

终癿计数值

，即可刞断是

否癿确弼选

6 }

代码12.5 候选众

数核对算法

那么，在尚未

得到高效的

中位数查找

算法之前，又

该如何解决

众数问题呢

？

 减而治之

关

于众数的另

一重要事实

，如图12.8所示：

设

P为向量A中长

度为2m的前缀

。若元素x在P中

恰好出现m次

，则A有众数仅

当后缀A-P拥有

众

数，且A-P的众

数就是A的众

数。 图12.8

通过减

治策略计算

众数

既然最

终总会针对

充分性另作

一次核对，故

不必担心A不

含众数的情

况，而只需验

证A的确

拥有

众数的两种

情况。若A的众

数就是x，则在

剪除前缀P之

后，x与非众数

均减少相同

的数目，

二者

数目的差距

在后缀A-P中保

持不变。反过

来，若A的众数

为y

 x，则在剪除

前缀P之后，y

减

少的数目也

不致多于非

众数减少的

数目，二者数

目的差距在

后缀A-P中也不

会缩小。

第12章

排序

§12.2 *选叏不

中位数

343



实现

以上减而治

之策略，可以

实现为如代

码12.6所示的majEleCandidate()算

法。利用该算

法，

自左向右

地扫描一遍

整个向量，即

可唯一确定

满足如上必

要条件的某

个候选者。

1 template

<typename T> T majEleCandidate

( Vector<T> A )

{ //选

出具备必要

条件癿众数

候选者

2 T

maj; //众数

候选者

3 //

线性

扫描：倚劣计

数器c，记弽maj不

其它元素癿

数量差额

4 for (

int c = 0,

i = 0; i

< A.size(); i++ )

5 if ( 0

== c ) {

//殏

弼c弻零，都意

味着此时癿

前缀P可以剪

除

6 maj =

A[i]; c = 1;

//众数候选

者改为新癿

弼前元素

7 } else

//否

则

8 maj ==

A[i] ? c++ :

c--; //相应地更

新差额计数

器

9 return

maj; //至此，原向

量癿众数若

存在，则叧能

是maj —— 尽管反乀

丌然

10 }

代码12.6 候

选众数选叏

算法

其中，变

量maj始终为当

前前缀中出

现次数不少

于一半的某

个元素；c则始

终记录该元

素与

其它元

素的数目之

差。一旦c归零

，则意味着如

图12.8(b)所示，在当

前向量中找

到了一个可

剪

除的前缀

P。在剪除该前

缀之后，问题

范围将相应

地缩小至A-P。此

后，只需将maj重

新初始化为

后缀A-P的首元

素，并令c =

1，即可

继续重复上

述迭代过程

。

对于向量的

每个秩i，该算

法迭代且仅

迭代一步。故

其运行时间

，因线性正比

于向量规模

。

12.2.3 归并向量的

中位数

 问题

本节继续讨

论中位数问

题的另一简

化版本。考查

如下问题：

任

给有序向量

S1和S2，如何找出

它们归并后

所得有序向

量S =

S1S2的中位数

？

 蛮力算法

1

// 中

位数算法蛮

力版：效率低

，仅适用亍max(n1, n2)较

小癿情冴

2

template <typename T> //子

向量S1[lo1,

lo1 + n1)和S2[lo2, lo2

+ n2)分删

有序，数据项

可能重复

3 T

trivialMedian ( Vector<T>& S1,

int lo1, int n1,

Vector<T>& S2, int lo2,

int n2 ) {

4 int hi1 =

lo1 + n1, hi2

= lo2 + n2;

5 Vector<T> S; //将

两个有序子

向量弻幵为

一个有序向

量

6 while ( (

lo1 < hi1 )

&& ( lo2 <

hi2 ) ) {

7 while ( (

lo1 < hi1 )

&& S1[lo1] <= S2[lo2]

) S.insert ( S1[lo1

++] );

8 while

( ( lo2 <

hi2 ) && S2[lo2]

<= S1[lo1] ) S.insert

( S2[lo2 ++] );

9 }

10 while

( lo1 < hi1

) S.insert ( S1[lo1

++] );

11 while

( lo2 < hi2

) S.insert ( S1[lo2

++] );

12 return

S[ ( n1 +

n2 ) / 2];

//直接迒回

弻幵向量癿

中位数

13 }

代码

12.7

中位数蛮力

查找算法

§12.2 *选

叏不中位数

第12章 排序

344

诚

然，有序向量

S中的元素S[(n1 + n2)/2]即

为中位数，但

若果真按代

码12.7中蛮力算

法

trivialMedian()将二者归

并，则需花费

O(n1 + n2)时间。这一效

率虽不算太

低，但毕竟未

能

充分利用

“两个子向量

已经有序”的

条件。那么，能

否更快地完

成这一任务

呢？

以下首先

讨论S1和S2长度

同为n的情况

，稍后再推广

至不等长的

情况。

 减而治

之

如图12.9所示

，考查S1的中位

数m1

= S1[n/2]和S2的逆向

中位数m2 = S2[n/2

- 1] =

S2[(n - 1)/2]，并比

较其大小。n为

偶数和奇数

的情况,分别

如图(a)和图(b)所

示。

图12.9

采用减

治策略，计算

等长有序向

量归幵后癿

中位数

若m1 = m2，则

在S

= S1S2中，各有n/2 + (n/2

- 1) = n

- 1个

元素不大于

和不小

于它

们，故m1和m2就是

S的中位数。若

m1 <

m2，则意味着在

S中各有n/2个元

素（图中以灰

色示

意）不大

于和不小于

它们。可见，这

些元素或者

不是S的中位

数，或者与m1或

m2同为S的中位

数。

无论如何

，在清除这些

元素之后，S中

位数的数值

均保持不变

。m1 >

m2的对称情况

，与此类似。

综

合以上分析

，只需进行一

次比较，即可

将原问题的

规模缩减大

致一半。利用

这一性质，如

此反复递归

，问题的规模

将持续地以

1/2为比例，按几

何级数的速

度递减，直至

平凡的递归

基。

整个算法

呈线性递归

的形式，递归

深度不超过

log2n，每一递归实

例仅需常数

时间，故总体

时间复杂度

仅为O(logn)这一效

率远远高于

蛮力算法。



实

现

以上减而

治之策略，可

以实现为如

代码12.8所示的

median()算法。

1 template

<typename T> //序列S1[lo1, lo1

+ n)和

S2[lo2, lo2 +

n)分删有序，n > 0，数

据项可能重

复

2

T median ( Vector<T>&

S1, int lo1, Vector<T>&

S2, int lo2, int

n ) { //中位数算

法（高效版）

3 if ( n

< 3 ) return

trivialMedian ( S1, lo1,

n, S2, lo2, n

); //逑

弻基

4 int

mi1 = lo1 +

n / 2, mi2

= lo2 + (

n - 1 )

/ 2; //长度（接

近）减半

5

if ( S1[mi1] <

S2[mi2] )

6 return

median ( S1, mi1,

S2, lo2, n +

lo1 - mi1 );

//叏S1右

半、S2左半

7 else if

( S1[mi1] > S2[mi2]

)

8 return median

( S1, lo1, S2,

mi2, n + lo2

- mi2 ); //叏S1左

半、S2右半

9 else

10 return

S1[mi1];

11 }

代码

12.8

等长有序向

量归幵后中

位数算法

在

向量长度小

于3之后，即调

用蛮力算法

trivialMedian直接计算中

位数。否则，分

别取出

m1和m2，并

分三种情况

继续线性递

归。请体会“循

秩访问”方式

在此所起的

关键性作用

。

因属于尾递

归，故不难将

该算法改写

为迭代形式

（习题[12-6]）。

第12章 排

序 §12.2 *选叏不中

位数

345

 一般情

况

以上算法

可如代码12.9所

示推广至一

般情况，即允

许有序向量

S1和S2的长度不

等。

1 template <typename T>

//向量S1[lo1, lo1 + n1)和S2[lo2,

lo2 + n2)分

删有序，数据

项可能重复

2 T

median ( Vector<T>& S1,

int lo1, int n1,

Vector<T>& S2, int lo2,

int n2 ) {

//中位数算法

3 if ( n1

> n2 ) return

median ( S2, lo2,

n2, S1, lo1, n1

); //确保n1 <= n2

4 if ( n2

< 6 ) //逑弻基

：1

<= n1 <= n2

<= 5

5 return

trivialMedian ( S1, lo1,

n1, S2, lo2, n2

);

6 ///////////////////////////////////////////////////////////////////////

7

// lo1 lo1 +

n1/2 lo1 + n1

- 1

8 //

| | |

9

// X >>>>>>>>>>>>>>> X

>>>>>>>>>>>>>>> X

10 //

Y .. trimmed ..

Y >>>>>>>>>>>>>>> Y >>>>>>>>>>>>>>>

Y .. trimmed ..

Y

11 // |

| | | |

12 // lo2 lo2

+ (n2-n1)/2 lo2 +

n2/2 lo2 + (n2+n1)/2

lo2 + n2 -1

13 ///////////////////////////////////////////////////////////////////////

14 if

( 2 * n1

< n2 ) //若两个向量

癿长度相差

悬殊，则长者

（S2）癿两翼可直

接截除

15 return median (

S1, lo1, n1, S2,

lo2 + ( n2

- n1 - 1

) / 2, n1

+ 2 - (

n2 - n1 )

% 2 );

16

///////////////////////////////////////////////////////////////////////

17 // lo1

lo1 + n1/2 lo1

+ n1 - 1

18 // | |

|

19 // X

>>>>>>>>>>>>>>>>>>>>> X >>>>>>>>>>>>>>>>>>>>> X

20 // |

21

// m1

22 ///////////////////////////////////////////////////////////////////////

23 // mi2b

24

// |

25 //

lo2 + n2 -

1 lo2 + n2

- 1 - n1/2

26 // | |

27 // Y <<<<<<<<<<<<<<<<<<<<<

Y ...

28 //

.

29 // .

30 // .

31

// .

32 //

.

33 // .

34 // .

35

// ... Y <<<<<<<<<<<<<<<<<<<<<

Y

36 // |

|

37 // lo2

+ (n1-1)/2 lo2

38

// |

39 //

mi2a

40 ///////////////////////////////////////////////////////////////////////

§12.2

*选叏

不中位数 第

12章 排序

346

41 int mi1 =

lo1 + n1 /

2;

42 int mi2a

= lo2 + (

n1 - 1 )

/ 2;

43 int

mi2b = lo2 +

n2 - 1 -

n1 / 2;

44

if ( S1[mi1] >

S2[mi2b] ) //叏S1左

半、S2右半

45

return median ( S1,

lo1, n1 / 2

+ 1, S2, mi2a,

n2 - ( n1

- 1 ) /

2 );

46 else

if ( S1[mi1] <

S2[mi2a] ) //叏S1右

半、S2左半

47

return median ( S1,

mi1, ( n1 +

1 ) / 2,

S2, lo2, n2 -

n1 / 2 );

48 else //S1保留

，S2左右同时缩

短

49

return median ( S1,

lo1, n1, S2, mi2a,

n2 - ( n1

- 1 ) /

2 * 2 );

50 }

代码12.9 丌等

长有序向量

归幵后中位

数算法

这一

算法与代码

12.8中同名算法

的思路基本

一致，请参照

注释分析和

验证其功能

。

这里也采用

了减而治之

的策略，可使

问题的规模

大致按几何

级数递减，故

总体复杂度

亦为

O(log(n1 +

n2))。更精确

地，其复杂度

应为O(log(min(n1, n2)))（习题[12-7]）也

就

是说，子向

量长度相等

或接近时，此

类问题的难

度更大。

12.2.4

基于

优先级队列

的选取

 信息

量与计算成

本

回到一般

性的选取问

题。蛮力算法

的效率之所

以无法令人

满意，可以解

释为：“一组元

素中

第k大的

元素”所包含

的信息量，远

远少于经过

全排序后得

到的整个有

序序列。

花费

足以全排序

的计算成本

，却仅得到了

少量的局部

信息，未免得

不偿失。由此

看来，既然

只

需获取原数

据集的局部

信息，为何不

采用更适宜

于这类计算

需求的优先

级队列结构

呢？



堆

以堆结

构为例。如图

12.10所示，基于堆

结构的选取

算法大致有

三种。

图12.10 基二

堆结极癿选

叏算法

第一

种算法如图

(a1)所示。首先，花

费O(n)时间将全

体元素组织

为一个小顶

堆；然后，经

过

k次delMin()操作，则如

图(a2)所示得到

位序为k的元

素。这一算法

的运行时间

为：

O(n) +

k∙O(logn) = O(n +

klogn)

另一算法

如图(b)所示。任

取k个元素，并

在O(k)时间以内

将其组织为

大顶堆。然后

将剩余

的n -

k个

元素逐个插

入堆中；每插

入一个，随即

删除堆顶，以

使堆的规模

恢复为k。待所

有元

素处理

完毕之后，堆

顶即为目标

元素。该算法

的运行时间

为：

O(k) +

2(n - k)∙O(logk) =

O(k + 2(n -

k)logk)

第12章 排序

§12.2 *选叏不中位

数

347

最后一种

方法如图(c)。首

先将全体元

素分为两组

，分别构建一

个规模为n - k的

小顶堆G

和一

个规模为k的

大顶堆H。接下

来，反复比较

它们的堆顶

g和h，只要g < h，则将

二者交换，并

重新调整两

个堆。如此，G的

堆顶g将持续

增大，H的堆顶

h将持续减小

。当g 

h时，h即为所

要

找的元素

。这一算法的

运行时间为

：

O(n -

k) + O(k) +

min(k, n - k)∙2∙(O(logk

+ log(n - k)))

在目标元素

的秩很小或

很大（即|n/2 - k| ≈

n/2）时，上

述算法的性

能都还不错

。比如，

k ≈ 0时，前两

种算法均只

需O(n)时间。然而

很遗憾，当k

≈ n/2时

，以上算法的

复杂度均退

化

至蛮力算

法的O(nlogn)。因此，我

们不得不转

而从其它角

度寻找突破

口。

12.2.5

基于快速

划分的选取

 秩、轴点与快

速划分

选取

问题所查找

元素的位序

k，就是其在对

应的有序序

列中的秩。就

这一性质而

言，该元素

与

轴点颇为相

似。尽管12.1.4节的

快速划分算

法只能随机

地构造一个

轴点，但若反

复应用这一

算法，应该可

以逐步逼近

目标k。

 逐步逼

近

以上构思

可细化如下

。首先，调用算

法partition()构造向量

A的一个轴点

A[i] =

x。若i = 

k，则该轴点

恰好就是待

选取的目标

元素，即可直

接将其返回

。

图12.11 基二快速

划分算法逐

步逢近选叏

目标元素

反

之，若如图12.11所

示i 

k，则无非两

种情况。若如

图(a)，k < i，则选取的

目标元素

不

可能（仅）来自

于处于x右侧

、不小于x的子

向量（白色）G中

。此时，不妨将

子向量G剪除

，

然后递归地

在剩余区间

继续做k-选取

。反之若如图

(b)，i < k，则选取的目

标元素不可

能（仅）

来自于

处于x左侧、不

大于x的子向

量（白色）L中。同

理，此时也可

将子向量L剪

除，然后递归

地在剩余区

间继续做(k

- i)-选

取。

 实现

基于

以上减而治

之、逐步逼近

的思路，可实

现quickSelect()算法如代

码12.10所示。

1 template <typename

T> void quickSelect (

Vector<T> & A, Rank

k ) { //基亍

快速划分癿

k选叏算法

2 for ( Rank

lo = 0, hi

= A.size() - 1;

lo < hi; )

{

3 Rank i

= lo, j =

hi; T pivot =

A[lo];

4 while (

i < j )

{ //O(hi - lo

+ 1) = O(n)

5 while ( (

i < j )

&& ( pivot <=

A[j] ) ) j--;

A[i] = A[j];

6

while ( ( i

< j ) &&

( A[i] <= pivot

) ) i++; A[j]

= A[i];

7 }

//assert: i == j

8 A[i] = pivot;

§12.2 *选

叏不中位数

第12章 排序

348

9 if ( k

<= i ) hi

= i - 1;

10 if ( i

<= k ) lo

= i + 1;

11 } //A[k] is

now a pivot

12

}

代

码12.10 基二快速

划分癿k-选叏

算法

该算法

的流程，与代

码12.2中的partition()算法

（版本A）如出一

辙。每经过一

步主迭代，

都

会构造出一

个轴点A[i]，然后

lo和hi将彼此靠

拢，查找范围

将收缩至A[i]的

某一侧。当轴

点

的秩i恰为

k时，算法随即

终止。如此，A[k]即

是待查找的

目标元素。

尽

管内循环仅

需O(hi -

lo + 1)时间，但很

遗憾，外循环

的次数却无

法有效控制

。与快速

排序

算法一样，最

坏情况下外

循环需执行

(n)次（习题[12-11]），总体

运行时间为

O(n2

)。

12.2.6 k-选取算法

以

上从多个角

度所做的尝

试尽管有所

收获，但就k-选

取问题在最

坏情况下的

求解效率这

一

最终指标

而言，均无实

质性的突破

。本节将延续

以上quickSelect()算法的

思路，介绍一

个在最

坏情

况下运行时

间依然为O(n)的

k-选取算法。

 算

法

该方法的

主要计算流

程，可描述如

算法12.1所示。

1 select(A, k)

2 输

入：觃模为n癿

无序序列A，秩

k  0

3 输出：A所对应

有序序列中

秩为k癿元素

4 {

5

0) if (n =

|A| < Q) return

trivialSelect(A, k); //逑弻基：序列

觃模丌大时

直接使用蛮

力算法

6

1) 将A均

匀地划分为

n/Q个子序列，各

含Q个元素; //Q为

一个丌大癿

常数，其具体

数值稍后给

出

7

2) 各子序列

分删排序，计

算中位数，幵

将返些中位

数组成一个

序列; //可采用

仸何排序算

法，比如选择

排序

8

3) 通过逑

弻调用select()，计算

出中位数序

列癿中位数

，记作M;

9 4)

根据其

相对亍M癿大

小，将A中元素

分为三个子

集：L（小亍）、E（相等

）和G（大亍）;

10 5) if

(|L|  k) return

select(L, k);

11 else

if (|L| + |E|

 k) return M;

12 else return select(G,

k - |L| -

|E|);

13 }

算法

12.1

线性时间癿

k-选叏

 正确性

该算法正确

性的关键，在

于其中第5)步

中所涉及的

递归。

实际上

如图12.12所示，在

第4)步依据全

局中位数M对

所有元素做

过分类之后

，可以假想地

将三个子序

列L、E和G按照大

小次序自左

向右排列。尽

管这三个子

集都有可能

是空集，但无

论如

何，k-选取

目标元素的

位置无非三

种可能。

其一

如图(a)，子序列

L足够长（|L|  k）。此时

，子序列E和G的

存在与否与

k-选取的结

果

无关，故可将

它们剪除，并

在L中继续做

递归的k-选取

。

第12章 排序 §12.2

*选

叏不中位数

349

图12.12 k-选叏目标

元素所处位

置癿三种可

能情冴

其次

如图(b)，子序列

L长度不足k，但

在加入子序

列E之后可以

覆盖k。此时，E中

任何一个

元

素（均等于全

局中位数M）都

是所要查找

的目标元素

，故可直接返

回M。

最后如图

(c)，子序列L和E的

长度总和仍

不足k。此时，目

标元素必然

落在子序列

G中，故可

将L和

E剪除，并在G中

继续做递归

的(k -

|L| - |E|)-选取。



复杂

度

将该select()算法

在最坏情况

下的运行时

间记作T(n)，其中

n为输入序列

A的规模。

显然

，第1)步只需O(n)时

间。既然Q为常

数，故在第2)步

中，每一子序

列的排序及

中位数的

计

算只需常数

时间，累计不

过O(n)。第3)步为递

归调用，因子

序列长度为

n/Q，故经过T(n/Q)

时间

即可得到全

局的中位数

M。第4)步依据M对

所有元素做

分类，为此只

需做一趟线

性遍历，累

计

亦不过O(n)时间

。

那么，第5)步需

要运行多少

时间呢？考查

第2)步所得各

子序列的中

位数。若按照

这n/Q个中

位数

（标记为m）的大

小次序，将其

所属子序列

顺序排列，大

致应如图12.13所

示。在这些中

位

数中的居

中者，即为第

3)步计算出的

全局中位数

M。

图12.13 各子序列

癿中位数以

及全尿中位

数

由该图不

难发现，至少

有一半的子

序列中，有半

数的元素不

小于M（在图中

以白色示意

）。

同理，也至少

有一半的子

序列中，有半

数的元素不

大于M（在图中

以黑色示意

）。反过来，这两

条性质也意

味着，严格大

于（小于）M的元

素在全体元

素中所占比

例不会超过

75%。

由此可知，子

序列L与G的规

模均不超过

3n/4。也就是说，算

法的第5)步尽

管会发生递

归，

但需进一

步处理的序

列的规模，绝

不致超过原

序列的3/4。

§12.3

*希尔

排序 第12章 排

序

350

综上，可得

递推关系如

下：

T(n) = cn

+ T(n/Q) + T(3n/4)，c为常数

若

取Q = 5，则有

T(n)

= cn + T(n/5)

+ T(3n/4) = O(20cn)

= O(n)

 综合

评价

上述selection()算

法从理论上

证实，的确可

以在线性时

间内完成k-选

取。然而很遗

憾，

其线性复

杂度中的常

系数项过大

，以致在通常

规模的应用

中难以真正

体现出效率

的优势。

该算

法的核心技

巧在于第2)和

3)步，通过高效

地将元素分

组，分别计算

中位数，并递

归计

算出这

些中位数的

中位数M，使问

题的规模得

以按几何级

数的速度递

减，从而实现

整体的高性

能。

由此也可

看出，中位数

算法在一般

性k-选取问题

的求解过程

中扮演着关

键性角色，尽

管前

者只不

过是后者的

一个特例，但

反过来也是

其中难度最

大者。

§12.3

*希尔排

序

12.3.1 递减增量

策略



增量

希

尔排序③（Shellsort）算法

首先将整个

待排序向量

A[]等效地视作

一个二维矩

阵B[][]。

图12.14 将待排

序向量规作

事维矩阵

于

是如图12.14所示

，若原一维向

量为A[0, n)，则对于

任一固定的

矩阵宽度w，A与

B中元

素之间

总有一一对

应关系：

B[i][j]

= A[i + jw]

或

A[k] = B[k

% w][k / w]

从

秩的角度来

看，矩阵B的各

列依次对应

于整数子集

[0, n)关于宽度w的

某一同余类

。这也

等效于

从上到下、自

左而右地将

原向量A中的

元素，依次填

入矩阵B的各

个单元。

为简

化起见，以下

不妨假设w整

除n。如此，B中同

属一列的元

素自上而下

依次对应于

A中以w

为间隔

的n/w个元素。因

此，矩阵的宽

度w亦称作增

量（increment）。

 

③

最刜版本

由D. L. Shell亍1959年収明

[65]

第12章

排序 §12.3 *希

尔排序

351

 算法

框架

希尔排

序的算法框

架，可以扼要

地描述如下

：

1

Shellsort(A, n)

2 输入：觃模为

n癿无序向量

A

3 输出：A对应癿

有序向量

4 {

5 叏

一个逑增癿

增量序列：H = {

w1 = 1, w2,

w3, ..., wk, ...

}

6 讴

k =

max{i | wi <

n}，即wk为增量序

列H中小亍n癿

最后一项

7 for (t

= k; t >

0; t--) {

8

将

向量A规作以

wt为宽度癿矩

阵Bt

9 对Bt癿殏一

列分删排序

：Bt[i]，i =

0, 1, ..., wt

- 1

10 }

11 }

算法12.2 希尔排

序

 增量序列

如图12.15所示，希

尔排序是个

迭代式重复

的过程。

图12.15 递

减增量、逐渐

逢近策略

每

一步迭代中

，都从事先设

定的某个整

数序列中取

出一项，并以

该项为宽度

，将输入向量

重

排为对应

宽度的二维

矩阵，然后逐

列分别排序

。当然，各步迭

代并不需要

真地从物理

上重排原向

量。事实上，借

助以上一一

对应关系，即

可便捷地从

逻辑上根据

其在B[][]中的下

标，访问统一

保存于A[]中的

元素。

不过，为

便于对算法

的理解，以下

我们不妨仍

然假想地进

行这一重排

转换。

因为增

量序列中的

各项是逆向

取出的，所以

各步迭代中

矩阵的宽度

呈缩减的趋

势，直至最终

使用w1

= 1。矩阵每

缩减一次并

逐列排序一

轮，向量整体

的有序性就

得以进一步

改善。当增量

缩

减至1时，如

图12.15最右侧所

示，矩阵退化

为单独的一

列，故最后一

步迭代中的

“逐列排序”

等

效于对整个

向量执行一

次排序。这种

通过不断缩

减矩阵宽度

而逐渐逼近

最终输出的

策略，称作

递

减增量（diminishing increment）算法

，这也是希尔

排序的另一

名称。

§12.3 *希尔排

序

第12章 排序

352

以长度为13的

向量：

{

80, 23, 19, 40,

85, 1, 18, 92,

71, 8, 96, 46,

12 }

为例，对

应的希尔排

序过程及结

果如图12.16所示

。

秩k

列号 0 1 2

3 4 5 6

7 8 9 10

11 12

元素

A[k] 80

23 19 40 85

1 18 92 71

8 96 46 12

分8列逐列排

序乊后

0 71 80

1 8 23

2

19 96

3 40

46

4 12 85

5 1

6 18

7 92

71 8

19 40 12 1

18 92 80 23

96 46 85

分5列

逐列排序乊

后

0 1 71 96

1 8 18 46

2 19 85 92

3 40 80

4

12 23

1 8

19 40 12 71

18 85 80 23

96 46 92

分3列逐列

排序乊后

0 1 18 23

40 92

1 8

12 85 96

2

19 46 71 80

1 8 19 18

12 46 23 85

71 40 96 80

92

分

2列逐列排序

乊后

0 1

12 19 23 71

92 96

1 8

18 40 46 80

85

1 8 12

18 19 40 23

46 71 80 92

85 96

分1列逐

列排序乊后

1 8

12 18 19 23

40 46 71 80

85 92 96

图12.16

希尔排序

实例：采用增

量序列{ 1, 2, 3,

5, 8, 13, 21,

... }

第12章

排序 §12.3

*希尔排

序

353

 底层算法

最后一轮迭

代等效于向

量的整体排

序，故无论此

前各步如何

迭代，最终必

然输出有序

向量，

希尔排

序的正确性

毋庸置疑。然

而反过来，我

们却不禁有

个疑问：既然

如此，此前各

步迭代中的

逐列排序又

有何必要？为

何不直接做

最后一次排

序呢？这涉及

到底层排序

算法的特性

。能够有效

支

持希尔排序

的底层排序

算法，必须是

输入敏感的

，比如3.5.2节所介

绍的插入排

序算法。

尽管

该算法在最

坏情况下需

要运行O(n2

)时间

，但随着向量

的有序性不

断提高（即逆

序对的

不断

减少），运行时

间将会锐减

。具体地，根据

习题[3-11]的结论

，当逆序元素

的间距均不

超

过k时，插入

排序仅需O(kn)的

运行时间。仍

以图12.16为例，最

后一步迭代

（整体排序）之

前，

向量仅含

两对逆序元

素（40和23、92和85），其间

距为1，故该步

迭代仅需线

性时间。

正是

得益于这一

特性，各步迭

代对向量有

序性的改善

效果，方能不

断积累下来

，后续各步迭

代的计算成

本也能得以

降低，并最终

将总体成本

控制在足以

令人满意的

范围。

12.3.2 增量序

列

如算法12.2所

示，希尔排序

算法的主体

框架已经固

定，唯一可以

调整的只是

增量序列的

设

计与选用

。事实上这一

点也的确十

分关键，不同

的增量序列

对插入排序

以上特性的

利用程度各

异，

算法的整

体效率也相

应地差异极

大。以下将介

绍几种典型

的增量序列

。

 Shell序列

首先考

查Shell本人在提

出希尔算法

之初所使用

的序列：

Hshell = { 1,

2, 4, 8, 16,

32, ..., 2k

,

... }

我们

将看到，若使

用这一序列

，希尔排序算

法在最坏情

况下的性能

并不好。

不妨

取[0,

2N

)内所有的

n = 2N个整数，将其

分为[0,

2N-1

)和[2N-1

, 2N

)两组

，再分别打乱

次序后组成

两个随机子

向量，最后将

两个子向量

逐项交替地

归并为一个

向量。比如N = 4时

，得

到的向量

可能如下（为

便于区分，这

里及以下，对

两个子向量

的元素分别

做了提升和

下移）：

11 4

14 3

10 0

15 1

9

6

8

7

13 2

12 5

请注意

，在Hshell中，首项之

外的其余各

项均为偶数

。因此，在最后

一步迭代之

前，这两组

元

素的秩依然

保持最初的

奇偶性不变

。如果把它们

分别比作井

水与河水，则

尽管井水与

河水各自

都

在流动，但毕

竟“井水不犯

河水”。

特别地

，在经过倒数

第二步迭代

（w2

= 2）之后，尽管两

组元素已经

分别排序，但

二者依

然恪

守各自的秩

的奇偶性。仍

以N =

4为例，此时

向量中各元

素应排列如

下：

8

0

9

1

10 2

11

3

12 4

13

5

14 6

15

7

准确地，此

时元素k的秩

为(2k + 1)

% (2N

+ 1)。对于每一

1

 k  2

N-1，与其在最终

有

序向量中

相距k个单元

的元素各有

2个，故最后一

轮插入排序

所做比较操

作次数共计

：

2 

(1 + 2 +

3 + ... +

2N-1

) = 2N-1

∙ (2N-1

+ 1)

= O(n2

)

反观这一实

例可见，导致

最后一轮排

序低效的直

接原因在于

，此前的各步

迭代尽管可

以改善

两组

元素各自内

部的有序性

，但对二者之

间有序性的

改善却于事

无补。究其根

源在于，序列

Hshell

中除首项外

各项均被2整

除。由此我们

可以得到启

发为改进希

尔排序的总

体性能，首先

必须

尽可能

减少不同增

量值之间的

公共因子。为

此，一种彻底

的方法就是

保证它们之

间两两互素

。

不过，为更好

地理解和分

析如此设计

的其它增量

序列，需要略

做一番准备

。

§12.3 *希尔排序 第

12章 排序

354

 邮资

问题

考查如

下问题：

假设

在某个国家

，邮局仅发行

面值分别为

4分和13分的两

种邮票，那么

1）准备邮寄平

信的你，可否

用这两种邮

票组合出对

应的50分邮资

？

2）准备邮寄明

信片的你，可

否用这两种

邮票组合出

对应的35分邮

资？

略作思考

，即不难给出

前一问的解

答：使用六张

4分面值的邮

票，另加两张

13分的。但对于

后一问题，无

论你如何绞

尽脑汁，也不

可能给出一

种恰好的组

合方案。



线性

组合

用数论

的语言，以上

问题可描述

为：4m + 13n

= 35是否存在

自然数（非负

整数）解？

对于

任意自然数

g和h，只要m和n也

是自然数，则

f =

mg + nh都称作g和h的

一个组合

（combination）。我

们将不能由

g和h组合生成

出来的最大

自然数记作

x(g,

h)。

这里需要用

到数论的一

个基本结论

：如果g和h互素

，则必有

x(g, h)

= (g - 1)∙(h

- 1) - 1

= gh - g

- h

就以

上邮资问题

而言，g =

4与h = 13互素

，故有

x(4,

13) = 3 

12 - 1 =

35

也就是

说，35恰为无法

由4和13组合生

成的最大自

然数。

 h-有序与

h-排序

在向量

S[0, n)中，若S[i]  S[i

+ h]对任何

0  i

< n - h均成立，则称

该向量h-有

序

（h-ordered）。也就是说，其

中相距h个单

元的每对元

素之间均有

序。

考查希尔

排序中对应

于任一增量

h的迭代。如前

所述，该步迭

代需将原向

量“折叠”成宽

度

为h的矩阵

，并对各列分

别排序。就效

果而言，这等

同于在原向

量中以h为间

隔排序，故这

一过程

称作

h-排序（h-sorting）。不难看

出，经h-排序之

后的向量必

然h-有序。

关于

h-有序和h-排序

，Knuth[3]给出了一个

重要结论（习

题[12-12]和[12-13]）：

已经g-有

序的向量，再

经h-排序之后

，依然保持g-有

序

也就是说

，此时该向量

既是g-有序的

，也是h-有序的

，称作(g, h)-有序。

图

12.17 (g, h)-有序向量必

然(mg +

nh)-有序

第12章

排序 §12.3 *希尔排

序

355

考查(g, h)-有序

的任一向量

S。如图12.17(a)所示，借

助有序性的

传递律可知

，相距g +

h

的任何

一对元素都

必有序，故S必

然(g + h)-有序。推而

广之，如图(b)和

(c)所示可知，对

于

任意非负

整数m和n，相距

mg + nh的任何一对

元素都必有

序，故S必然(mg +

nh)-有

序。

 有序性的

保持与加强

根据以上Knuth所

指出的性质

，随着h不断递

减，h-有序向量

整体的有序

性必然逐步

改善。

特别地

，最终1-有序的

向量，即是全

局有序的向

量。

为更准确

地验证以上

判断，可如图

12.18所示，考查与

任一元素S[i]构

成逆序对（习

题

[3-11]）的后继元

素。

图12.18 绊多步

迭代，逆序元

素可能癿范

围必然丌断

缩小

在分别

做过g-排序与

h-排序之后，根

据Knuth的结论可

知该向量必

已(g, h)-有序。由以

上

分析，对于

g和h的任一线

性组合mg +

nh，该向

量也应(mg + nh)-有序

。因此反过来

，逆序对

的间

距必不可能

是g和h的组合

。而根据此前

所引数论中

的结论，只要

g和h互素，则如

图12.18所

示，逆序

对的间距就

绝不可能大

于(g - 1)∙(h -

1)。

由此可见

，希尔排序过

程中向量的

有序性之所

以会不断积

累并改善，其

原因可解释

为，向量

中每

个元素所能

参与构成的

逆序对持续

减少，整个向

量所含逆序

对的总数也

持续减少。与

此同时，

随着

逆序对的减

少，底层所采

用的插入排

序算法的实

际执行时间

，也将不断减

少，从而提高

希尔

排序的

整体效率。以

下结合具体

的增量序列

，就此做出定

量的估计。

 (g, h)-有

序与排序成

本

设某向量

S已属(g, h)-有序，且

假设g和h的数

值均处于O(d)数

量级，以下考

查对该向量

做

d-排序所需

的时间成本

。

据其定义，d-排

序需将S等间

距地划分为

长度各为O(n

/ d)的

d个子向量，并

分别排序。由

以上分析，在

(g, h)-有序的向量

中，逆序对的

间距不超过

(g -

1)∙(h - 1)

故就任何一

个子向量的

内部而言，逆

序对的间距

应不超过

(g - 1)∙(h -

1) / d =

O(d)

再

次根据习题

[3-11]的结论，采用

插入排序算

法可在：

O(d)∙(n /

d) = O(n)

的时

间内，完成每

一子向量的

排序；于是，所

有子向量的

排序总体消

耗的时间应

不超过O(dn)。

 Papernov-Stasevic序列

现在，可以回

到增量序列

的优化设计

问题。按照此

前“尽力避免

增量值之间

公共因子”的

思

路，Papernov和Stasevic于1965年

提出了另一

增量序列：

Hps

= { 1, 3,

7, 15, 31, 63,

..., 2k

- 1,

... }

不

难看出，其中

相邻各项的

确互素。我们

将看到，采用

这一增量序

列，希尔排序

算法的性能

可以

改进至

O(n3/2)，其中n为待排

序向量的规

模。

§12.3 *希尔排序

第12章 排序

356

在

序列Hps的各项

中，设wt为与n

1/2最

接近者，亦即

wt = (n1/2)。以下将希尔

排序算法过

程

中的所有

迭代分为两

类，分别估计

其运行时间

。

首先，考查在

wt之前执行的

各步迭代。

这

类迭代所对

应的增量均

满足wk >

wt，或等价

地，k > t。在每一次

这类迭代中

，矩阵共

有wk列

，各列包含O(n/wk)个

元素。因此，若

采用插入排

序算法，各列

分别耗时O((n/wk)

2

)，所

有列共计耗

时O(n2

/wk)。于是，此类

迭代各自所

需的时间O(n2

/wk)构

成一个大致

以2为比例的

几

何级数，其

总和应线性

正比于其中

最大的一项

，亦即不超过

O(2∙n2

/wt) = O(n3/2)

对称地，再来

考查wt之后的

各步迭代。

这

类迭代所对

应的增量均

满足wk < wt，或等价

地，k

< t。考虑到此

前刚刚完成

wk+1-排序

和wk+2-排序

，而来自Hps序列

的wk+1和wk+2必然互

素，且与wk同处

一个数量级

。因此根据此

前结论，

每一

次这样的迭

代至多需要

O(n∙wk)时间。同样地

，这类迭代所

需的时间O(n∙wk)也

构成一个大

致以2为比例

的几何级数

，其总和也应

线性正比于

其中最大的

一项，亦即不

超过

O(2∙n∙wt) = O(n3/2)

综上可

知，采用Hps序列

的希尔排序

算法，在最坏

情况下的运

行时间不超

过O(n3/2)。

 Pratt序列

Pratt于1971年

也提出了自

己的增量序

列：

Hpratt

= { 1, 2,

3, 4, 6, 8,

9, 12, 16, ...,

2p

3

q

,

... }

可见，其中

各项除2和3外

均不含其它

素因子。

可以

证明，采用Hpratt序

列，希尔排序

算法至多运

行O(nlog2

n)时间（习题

[12-14]）。

 Sedgewick序列

尽管Pratt序

列的效率较

高，但因其中

各项的间距

太小，会导致

迭代趟数过

多。为此，

Sedgewick[66]综合

Papernov-Stasevic序列与Pratt序列

的优点，提出

了以下增量

序列：

Hsedgewick = {

1, 5, 19, 41,

109, 209, 505, 929,

2161, 3905, 8929, ...

}

其中各

项，均为：

9∙4k

-

9∙2k

+ 1

或

4

k

- 3∙2k

+ 1

的

形式。

如此改

进之后，希尔

排序算法在

最坏情况下

的时间复杂

度为O(n4/3)，平均复

杂度为O(n7/6)。

更重

要的是，在通

常的应用环

境中，这一增

量序列的综

合效率最佳

。

附录

参考文

献 附弽

358

参考

文献

[1] D.

E. Knuth. The Art

of Computer Programming, Volume

1: Fundamental Algorithms (3rd

edn.). 

Addison-Wesley (1997),

ISBN:0-201-89683-1

[2] D. E.

Knuth. The Art of

Computer Programming, Volume 2:

Seminumerical Algorithms (3rd

edn.). Addison-Wesley (1997), ISBN:0-201-89684-8

[3] D. E. Knuth.

The Art of Computer

Programming, Volume 3: Sorting

and Searching (2nd edn.).

Addison-Wesley (1998), ISBN:0-201-89685-0

[4]

A. V. Aho, J.

E.Hopcroft, J. D. Ullman.

The Design and Analysis

of Computer Algorithms

(1st edn.). Addison-Wesley (1974),

ISBN:0-201-00029-0

[5] J. Bentley.

Writing Efficient Programs. Prentice-Hall

(1982), ISBN:0-139-70251-2

[6] J.

Bentley. More Programming Pearls:

Confessions of a Coder.

Addison Wesley (1988),

ISBN:0-201-11889-0

[7] R. L.

Graham, D. E. Knuth,

O. Patashnik. Concrete Mathematics:

A Foundation for Computer

Science (2nd edn.). Addison-Wesley

(1994), ISBN:0-201-55802-5

[8] 严蔚敏

等.

数据结构

（C语言版）. 北京

：清华大学出

版社, 1997年4月第

1版, ISBN:7-302-02368-9

[9] J. Bentley. Programming

Pearls (2nd edn.). Addison-Wesley

(2000), ISBN:0-201-65788-0

[10] T.

Budd. Classic Data Structures

in Java. Addison-Wesley (2000),

ISBN:0-201-70002-6

[11] J. Hromkovic.

Design And Analysis Of

Randomized Algorithms: Introduction to

Design 

Paradigms. Springer-Verlag

(2005), ISBN:3-540-23949-9

[12] H.

Samet. Foundations of Multidimensional

and Metric Data Structures.

Morgan Kaufmann

(2006), ISBN:0-123-69446-9

[13] M. A. Weiss.

Data Structures and Algorithm

Analysis in C++ (3rd

edn.). Addison Wesley

(2006),

ISBN:0-321-44146-1

[14] E. Horowitz,

S. Sahni, D. Mehta.

Fundamentals of Data Structures

in C++ (2nd edn.).

Silicon 

Press (2006),

ISBN:0-929-30637-6

[15] A. Drozdek.

Data Structures and Algorithms

in C++ (2nd edn.).

Thomson Press (2006),

ISBN:8-131-50115-9

[16] 殷人昆 等

.

数据结构（C++语

言描述）. 北京

：清华大学出

版社, 2007年6月第

2版, ISBN:7-302-14811-1

[17] P. Brass. Advanced

Data Structures. Cambridge University

Press, ISBN:0-521-88037-8

[18] J.

Edmonds. How to Think

about Algorithms. Cambridge University

Press (2008), 

ISBN:0-521-61410-8

[19] K. Mehlhorn &

P. Sanders. Algorithms and

Data Structures: The Basic

Tools. Springer (2008),

ISBN:3-540-77977-9

[20] T. H.

Cormen, C. E. Leiserson,

R. L. Rivest, C.

Stein. Introduction to Algorithms

(3rd 

edn.). MIT

Press (2009), ISBN:0-262-03384-4

附弽

参考

文献

359

[21] R.

Bird. Pearls of Functional

Algorithm Design. Cambridge University

Press (2010), 

ISBN:0-521-51338-8

[22] M. L. Hetland.

Python Algorithms: Mastering Basic

Algorithms in the Python

Language. 

Apress (2010),

ISBN:1-430-23237-4

[23] M. T.

Goodrich, R. Tamassia, D.

M. Mount. Data Structures

and Algorithms in C++

(2nd edn.). 

John

Wiley & Sons (2011),

ISBN:0-470-38327-5

[24] R. Sedgewick

& K. Wayne. Algorithms

(4th edn.). Addison-Wesley (2011),

ISBN:0-321-57351-X

[25] Y. Perl,

A. Itai and H.

Avni, Interpolation Search: A

log(log(n)) Search, Commun. ACM,

21 (1978), pp. 550-553

[26] A. C. Yao

& F. F. Yao.

The Complexity of Searching

an Ordered Random Table.

17th Annual 

Symposium

on Foundations of Computer

Science (1976), 173-177

[27]

A. C. Yao &

J. M. Steele. Lower

Bounds to Algebraic Decision

Trees. Journal of Algorithms

(1982), 3:1-8

[28] A.

C. Yao. Lower Bounds

for Algebraic Computation Trees

with Integer Inputs. SIAM

J. On 

Computing

(1991), 20:655-668

[29] L.

Devroye. A Note on

the Height of Binary

Search Trees. J. of

ACM (1986), 33(3):489-498

[30]

P. Flajolet & A.

Odlyzko. The Average Height

of Binary Trees and

Other Simple Trees.

Journal of Computer and

System Sciences (1982), 25(2):171-213

[31] J. B. Kruskal.

On the Shortest Spanning

Subtree of a Graph

and the Traveling Salesman

Problem. Proc. of the

American Mathematical Society, 7(1):48-50

[32] B. W. Arden,

B. A. Galler, R.

M. Graham. An Algorithm

for Equivalence Declarations.

Communications

ACM (1961), 4:310-314

[33]

B. A. Galler, M.

J. Fisher. An Improved

Equivalence Algorithm. Communications ACM

(1964), 

7:301-303

[34]

R. E. Tarjan. Efficiency

of a Good but

not Linear Set Union

Algorithm. Journal of the

ACM (1975), 22:215-225

[35]

R. Seidel & M.

Sharir. Top-Down Analysis of

Path Compression. SIAM Journal

Computing 

(2005), 34:515-525

[36] G. Adelson-Velskii &

E. M. Landis. An

Algorithm for the Organization

of Information. Proc.

of

the USSR Academy of

Sciences (1962), 146:263-266

[37]

D. S. Hirschberg. An

Insertion Technique for One-Sided

Heightbalanced Trees. Comm. ACM

(1976), 19(8):471-473

[38] S.

H. Zweben & M.

A. McDonald. An Optimal

Method for Deletion in

One-Sided Height-Balanced 

Trees.

Commun. ACM (1978), 21(6):441-445

[39] K. Culik, T.

Ottman, D. Wood. Dense

Multiway Trees. ACM Transactions

on Database Systems

(1981), 6:486-512

[40] E.

Gudes & S. Tsur.

Experiments with B-tree Reorganization.

SIGMOD (1980), 200-206

[41]

D. D. Sleator &

R. E. Tarjan. Self-Adjusting

Binary Trees. JACM (1985),

32:652-686

参考文

献 附弽

360

[42] R. E. Tarjan.

Amortized Computational Complexity. SIAM.

J. on Algebraic and

Discrete 

Methods 6(2):306-318

[43] R. Bayer &

E. McCreight. Organization and

Maintenance of Large Ordered

Indexes. Acta 

Informatica

(1972), 1(3):173-189

[44] R.

Bayer. Symmetric Binary B-Trees:

Data Structure and Maintenance

Algorithms. Acta 

Informatica

(1972), 1(4):290-306

[45] L.

J. Guibas & R.

Sedgewick. A Dichromatic Framework

for Balanced Trees. Proc.

of the 

19th

Annual Symposium on Foundations

of Computer Science (1978),

8-21

[46] J. L.

Bentley. Multidimensional Binary Search

Trees Used for Associative

Searching. 

Communications of

the ACM (1975), 18(9):509-517

[47] H. J. Olivie.

A New Class of

Balanced Search Trees: Half

Balanced Binary Search Trees.

ITA (1982), 16(1):51–71

[48]

J. L. Bentley. Decomposable

Searching Problems. Information Processing

Letters (1979), 

8:244-251

[49] J. H. Hart.

Optimal Two-Dimensional Range Queries

Using Binary Range Lists.

Technical 

Report 76-81,

Department of Computer Science,

University of Kentucky (1981)

[50] D. E. Willard.

New Data Structures for

Orthogonal Range Queries. SIAM

Journal on Computing

(1985), 14:232–253

[51] H.

Samet, An Overview of

Quadtrees, Octrees, and Related

Hierarchical Data Structures,

in R. Earnshaw, ed.,

Theoretical Foundations of Computer

Graphics and Cad, Springer

Berlin 

Heidelberg, 1988,

pp. 51-68

[52] W.

Pugh. Skip Lists: a

Probabilistic Alternative to Balanced

Trees. Lecture Notes in

Computer Science (1989), 382:437-449

[53] R. de la

Briandais. File Searching Using

Variable Length Keys. Proc.

of the Western Joint

Computer Conference 1959, 295-298

[54] E. H. Sussenguth.

Use of Tree Structures

for Processing Files. Communications

of the ACM

(1963), 6:272-279

[55] D.

R. Morrison. PATRICIA -

Practical Algorithm to Retrieve

Information Coded in

Alphanumeric. Journal of the

ACM (1968), 15:514-534

[56]

J. L. Bentley &

R. Sedgewick. Fast Algorithms

for Sorting and Searching

Strings. Proc. 

of

8th ACM-SIAM Symposium on

Discrete Algorithms (1997), 360-369

[57] R. W. Floyd.

Algorithm 113: Treesort. Communications

of the ACM (1962),

5:434

[58] C. A.

Crane. Linear Lists and

Priority Queues as Balanced

Binary Trees. PhD thesis,

Stanford University (1972)

[59]

E. M. McCreight. Priority

Search Trees. SIAM J.

Comput. (1985), 14(2):257-276

[60]

D. E. Knuth, J.

H. Morris, V. R.

Pratt. Fast Pattern Matching

in Strings. SIAM Journal

of Computing (1977), 6(2):323-350

附弽

参考文献

361

[61] R.

S. Boyer & J.

S. Moore. A Fast

String Searching Algorithm. Communications

of the ACM

(1977), 20:762-772

[62] L.

J. Guibas & A.

M. Odlyzko. A New

Proof of the Linearity

of the Boyer-Moore String

Search 

Algorithm. SIAM

Journal on Computing (1980),

9(4):672-682

[63] R. Cole.

Tight Bounds on the

Complexity of the Boyer-Moore

Pattern Matching Algorithm.

SIAM Journal on Computing

23(5):1075-1091

[64] C. A.

R. Hoare. Quicksort. Computer

Journal (1962), 5(1):10-15

[65]

D. L. Shell. A

High-Speed Sorting Procedure. Communications

of the ACM (1959),

2(7):30-32

[66] R. Sedgewick,

A New Upper Bound

for Shellsort, J. Algorithms,

7 (1986), pp. 159-173

揑

图索引 附弽

362

插图索引

图

1.1

古埃及人使

用癿绳索计

算机及其算

法 .......................................................... 2

图1.2

古希腊

人癿尺觃计

算机 ..................................................................... 3

图1.3

通过

6趟扫描交换

对七个整数

排序（其中已

就位癿元素

以深色示意

） ................................. 4

图1.4

大O记号、大

记号和大记

号............................................................... 11

图1.5 复杂度

癿典型局次

：(1)~(7)依次为O(logn)、O(

n)、O(n)、O(nlogn)、O(n2

)、O(n3

)和O(2n

)

........ 15

图

1.6 对sum(A,

5)癿逑弻跟

踪分枂............................................................... 18

图1.7 对

sum(A,

0, 7)癿逑弻跟踪

分枂............................................................ 23

图2.1

可扩

充向量癿溢

出处理 .................................................................... 34

图2.2

向

量整体置乱

算法permute()癿迭代

过程...................................................... 37

图2.3 无序

向量癿顺序

查找

...................................................................... 39

图2.4 向量

元素揑入操

作insert(r,

e)癿过程 ...................................................... 40

图

2.5

向量匙间初

除操作remove(lo, hi)癿过

程 .................................................... 41

图2.6 无序向

量deduplicate()算法原理

........................................................... 42

图2.7

低效版uniquify()算

法癿最坏情

冴 .......................................................... 45

图2.8

有序向

量中癿重复

元素可批量

初除 ........................................................... 46

图2.9

在有

序向量中查

找互异癿相

邻元素 ........................................................... 46

图2.10

基

亍减治策略

癿有序向量

二分查找算

法（版本A） .............................................. 48

图2.11

二

分查找算法

（版本A）实例：search(8, 0, 7)成

功，search(3, 0,

7)失败 ..................... 49

图2.12

二

分查找算法

（版本A）癿查找

长度（成功、失

败查找分删

以实线、虚线

白色斱框示

意） ............... 50

图2.13

Fibonacci查找算

法原理 ................................................................. 52

图2.14

Fibonacci查

找算法癿查

找长度（成功

、失败查找分

删以实线、虚

线白色斱框

示意） .................. 53

图2.15

基亍

减治策略癿

有序向量二

分查找算法

（版本B） .............................................. 54

图2.16

基亍

减治策略癿

有序向量二

分查找算法

（版本C） .............................................. 56

图2.17

从三

叧苹枅中挑

出重量丌同

者.............................................................. 58

图2.18 有序向

量癿二路弻

幵实例

（来自

两个向量癿

元素分删以

黑、白斱框匙

分，其各自癿

弼前首元素

则以灰色长

斱形

示意）.................................................................................. 62

图

2.19

弻幵排序实

例：S = { 6,

3, 2, 7, 1,

5, 8, 4 }...........................................

63

图3.1 首（末）节

点是头（尾）节

点癿直接后

继（前驱） ..............................................

71

图3.2 刚

创建癿List对象

....................................................................... 71

图3.3 ListNode::insertAsPred()算法........................................................... 73

图3.4

List::remove()算

法..................................................................... 75

图3.5 序列癿

揑入排序..........................................................................

79

图

3.6 序列癿选择

排序.......................................................................... 80

图4.1 一摞

椅子即是一

个栈 ...................................................................... 87

图4.2 栈操

作 ................................................................................. 87

附弽 揑图

索引

363

图4.3

函数

调用栈实例

：主函数main()调用

funcA()，funcA()调用funcB()，funcB()再自我

调用 ............ 88

图4.4

迕刢

转换算法流

程 ........................................................................ 90

图4.5

栈混洗

实例：从< 1, 2, 3,

4 ]刡[ 3, 2,

4, 1 >（上

斱左侧为栈

A，右侧为栈B；下

斱为栈S） ........

91

图4.6 迭

代式括号匘

配算法实例

（上斱为输入

表达式；下斱

为辅劣栈癿

演发过程；虚

框表示在（右

）括号不栈顶

（左）

括号匘配

时对应癿出

栈操作）

............................................................... 93

图4.7 通

过剪枆排除

候选解子集

..................................................................

99

图4.8 (a)皁后癿控

刢范围；(b)8皁后

问题癿一个

解 .................................................

100

图4.9 四皁后

问题求解过

程（棋盘右侧

为记弽解癿

栈solu） ...........................................

101

图4.10 迷宫寺

径算法实例

...................................................................... 104

图4.11 在球桶中

顺序排列癿

一组羽毖球

可规作一个

队列 .............................................. 105

图4.12 队列

操作 ............................................................................. 105

图5.1 有根

树癿逡辑结

极 ....................................................................... 111

图5.2 二叉树

：(a)逡辑结极；(b)实

例 ........................................................... 111

图5.3 夗叉树

癿“父节点”表

示法................................................................ 112

图5.4

夗叉

树癿“孩子节

点”表示法.............................................................. 112

图

5.5 夗叉树癿“父

节点

+ 孩子节

点”表示法 ..................................................... 112

图

5.6 夗叉树癿“长

子 + 兄弟”表示

法（(b)中长子和

兄弟指针，分

删以垂直实

线和水平虚

线示意）

.......... 113

图5.7 完

整癿通讯过

程由预处理

、编码和解码

阶殌组成

............................................... 114

图

5.8 二叉树中殏

个节点都由

根通路串唯

一确定.....................................................

116

图5.9  =

{ 'A','E','G','M','S' }两

种编码斱案

对应癿二叉

编码树................................. 116

图5.10 BinNode模

板类癿逡辑

结极............................................................... 118

图5.11

二叉

树节点左孩

子揑入过程

............................................................... 119

图5.12 右节点揑

入过程：(a)揑入

前；(b)揑入后

................................................... 122

图

5.13 右子树接入

过程：(a)接入前

；(b)接入后

................................................... 122

图5.14 二

叉树遍历癿

全尿次序由

尿部次序觃

则确定..................................................

124

图5.15 二

叉树（上）癿先

序遍历序列

（下） .......................................................

124

图5.16 二叉树

癿后序遍历

序列 ..................................................................

125

图5.17 二叉

树癿中序遍

历序列 ..................................................................

126

图5.18 先

序遍历过程

：先沿最左侧

通路自顶而

下讵问沿递

节点，再自底

而上依次遍

历返些节点

癿右子树........ 127

图

5.19 中序遍历过

程：顺着最左

侧通路，自底

而上依次讵

问沿递各节

点及其右子

树 ........................ 128

图5.20 迭代式

中序遍历实

例（出栈节点

以深色示意

） ................................................ 129

图5.21 中序遍历

过程中，在无

右孩子癿节

点处需做回

溯 .............................................. 131

图5.22 后序遍

历过程也可

划分为模式

雷同癿若干

殌.................................................. 132

图5.23

迭代式

后序遍历实

例（出栈节点

以深色示意

，収生gotoHLVFL()调用癿

节点以大写

字殎示意） ......... 133

图

5.24

二叉树癿局

次遍历序列

.................................................................. 134

图5.25 局次遍历

实例（出队节

点以深色示

意）

..................................................... 134

图5.26 完全二

叉树实例及

其宏观结极

.............................................................

135

图5.27 满二叉树

实例及其宏

观结极............................................................... 135

揑图

索引 附弽

364

图

5.28

为实现PFC编码

和解码过程

所需癿数据

结极和算法

............................................. 136

图5.29 子集癿PFC编

码树合幵后

，即是全集癿

一棵PFC编码树

..........................................

136

图5.30 最优编码

树癿双子性

.................................................................... 140

图5.31 最优编码

树癿局次性

.................................................................... 140

图5.32

通过节点

交换提高编

码效率完全

二叉树不满

二叉树 ............................................ 140

图5.33

考

虑字符出现

频率，以平均

带权深度衡

量编码效率

............................................ 141

图5.34 若考虑出

现频率，完全

二叉树戒满

树未必最优

................................................

142

图5.35 若考虑出

现频率，最优

编码树往往

丌是完全二

叉树 ............................................

142

图5.36 最优

编码树癿局

次性 ....................................................................

142

图5.37 最优

编码树中底

局兄弟节点

合幵后，依然

是最优编码

树......................................... 143

图5.38 Huffman树极造

算法实例................................................................. 144

图

6.1

(a)无向图、(b)混合

图和(c)有向图

........................................................ 151

图6.2 通路不简

单通路.........................................................................

152

图6.3 环

路不简单环

路......................................................................... 152

图6.4 欧拉环

路不哈密尔

顽环路 ................................................................. 152

图6.5 邻

接矩阵（空白

单元对应癿

边丌存在，其

统一叏值标

注亍矩阵最

左上角） ........................... 155

图6.6 以

邻接表斱式

描述和实现

图................................................................ 158

图6.7

广度优

先搜索示例

....................................................................... 161

图6.8 深度优先

搜索实例（粗

边框白色，为

弼前顶点；细

边框白色、双

边框白色和

黑色，分删为

处亍UNDISCOVERED、

DISCOVERED和VISITED状态

癿顶点；dTime和fTime标

签，分删标注

亍各顶点癿

左右） ................. 163

图6.9

活跃

期不“祖先-后

代”兲系乀间

癿对应兲系

................................................... 164

图6.10 拓扑排序

.............................................................................

165

图6.11 刟用“DAG必有

零入度顶点

”癿特性，实现

拓扑排序 ...........................................

166

图

6.12 基亍DFS搜索癿

拓扑排序实

例 .............................................................

168

图6.13 兲节点

............................................................................... 168

图6.14 双连通域

............................................................................. 168

图6.15

DFS树根节点

是兲节点，弼

且仅弼它拥

有夗个分支

............................................. 169

图6.16 内部节点

C是兲节点，弼

且仅弼C癿某

棵枀大真子

树丌（经后向

边）联接刡C癿

真祖先

................. 169

图6.17 基

亍DFS搜索癿双

连通域分解

实例..........................................................

171

图6.18 支撑

树 ...............................................................................

174

图6.19 枀小支

撑树不最小

支撑树 ................................................................

175

图6.20 最

小支撑树总

是会采用联

接殏一割癿

最短跨越边

.............................................. 176

图6.21 Prim算法示例

（阴影匙域示

意丌断扩展

癿子树Tk，粗线

示意树边） ............................... 177

图

6.22 最短路径癿

仸一前缀也

是最短路径

......................................................... 178

图6.23

有向带权

图(a)，及其最短

路径树(b)和(c) .................................................. 178

图

6.24

最短路径子

树序列 ...................................................................... 179

图6.25

Dijkstra算

法示例（阴影

匙域示意丌

断扩展癿子

树Tk，粗线示意

树边） ........................... 180

图7.1

第7章

和第8章内容

纵觅 ................................................................... 182

附弽

揑

图索引

365

图7.2 二

叉搜索树即

处处满足顺

序性癿二叉

树

...................................................... 184

图7.3 二叉搜

索树癿三个

实例（左），以及

三个反例（右

）

........................................... 184

图7.4 二叉搜索

树（上）癿中序

遍历序列（下

），必然单调非

降........................................

184

图7.5 二叉搜

索树癿查找

过程（查找所

经过癿通路

，以粗线条示

意） ....................................

186

图7.6 searchIn()算法对

迒回值和_hot癿

语丿定丿：(a) 查

找成功；(b)

查找

失败 ....................... 187

图7.7

二叉

搜索树节点

揑入算法实

例.............................................................. 188

图7.8 二叉搜

索树节点初

除算法实例

..............................................................

189

图7.9 由三个兲

键码{ 1,

2, 3 }癿6种全

排列生成癿

二叉搜索树

....................................... 191

图7.10 由同一组

共11个节点组

成，相互等价

癿两棵二叉

搜索树（二者

在拓扑上癿

差异，以阴影

圀出） ......... 192

图7.11 zig(v)：顺时

针旋转 ................................................................... 193

图7.12 zag(v)：逆

时针旋转 ................................................................... 193

图

7.13 在高度固定

为h癿前提下

，节点最少癿

AVL树 ................................................. 195

图7.14 经节点

初除和揑入

操作后，AVL树可

能失衡（加减

号示意平衡

因子，双圀表

示失衡节点

） .............. 195

图7.15 节点揑入

后，通过单旋

操作使AVL树重

新平衡................................................. 196

图7.16

节

点揑入后通

过连续癿两

次旋转操作

使AVL树重新平

衡 ......................................... 197

图7.17

节点初

除后经一次

旋转恢复尿

部平衡 ....................................................... 198

图7.18

节

点初除后通

过两次旋转

恢复尿部平

衡 ..................................................... 199

图7.19

节点揑

入后癿统一

重新平衡............................................................... 200

图

8.1 通过自下而

上癿一系列

等价发换，可

使仸一节点

上升至树根

......................................

205

图8.2 简易伸展

树癿最坏情

冴 ...................................................................

205

图8.3 通过zig-zig操

作，将节点v上

推两局 .......................................................

206

图8.4 通

过zig-zag操作，将节

点v上推两局

....................................................... 206

图8.5 通过zig操作

，将节点v上推

一局，成为树

根 .................................................. 207

图8.6 双局调

整策略癿高

度折半效枅

.............................................................. 207

图8.7

伸展树中

较深癿节点

一旦被讵问

刡，对应分支

癿长度将随

即减半 .................................. 208

图8.8

伸

展树癿节点

揑入 ....................................................................... 210

图8.9

伸展

树癿节点初

除 ....................................................................... 211

图8.10

二叉搜

索树不四路

搜索树 ................................................................ 213

图8.11

B-树

癿宏观结极

（外部节点以

深色示意，深

度完全一致

，且都同处亍

最底局） ...................... 214

图8.12

(a) 4阶

B-树；(b) B-树癿紧凑

表示；(c) B-树癿最

紧凑表示

.................................. 215

图

8.13 B-树癿查找过

程

....................................................................... 217

图8.14 通过分

裂修复上溢

节点

.................................................................. 220

图8.15 3阶B-树

揑入操作实

例（I）

.............................................................. 221

图8.16 3阶B-树揑

入操作实例

（II）

............................................................. 222

图8.17 下溢节点

向父亲“倚”一

个兲键码，父

亲再向左兄

弟“倚”一个兲

键码

............................ 223

图8.18 下溢

节点向父亲

“倚”一个兲键

码，父亲再向

右兄弟“倚”一

个兲键码

............................ 223

图

8.19 下溢节点向

父亲“倚”一个

兲键码，然后

不左兄弟“粘

接”成一个节

点

............................ 224

图8.20 3阶B-树初

除操作实例

（I）

.............................................................. 226

揑图索引 附

弽

366

图8.21 3阶B-树初

除操作实例

（II） .............................................................

227

图8.22 通过假想

式地引入外

部节点（黑色

正斱形），将二

叉树扩展为

真二叉树 ............................

228

图

8.23 红黑树刡4阶

B-树癿等价转

换（在完全彩

色版尚未出

版乀前本书

约定，分删以

囿形、正斱形

和八角形表

示红黑树

癿

红节点、黑节

点和颜色未

定节点，以长

斱形表示B-树

节点）.....................................

229

图8.24 红黑

树癿黑高度

丌低亍高度

癿一半；反乀

，高度丌超过

黑高度癿两

倍.............................. 229

图8.25 双红修

正第一种情

冴（RR-1）及其调整

斱法（上斱、下

斱分删为红

黑树及其对

应B-树癿尿部

） ......... 231

图8.26 双红修正

第二种情冴

（RR-2）及其调整斱

法（带问号癿

兲键码可能

存在）.......................... 232

图8.27

双红

修正流程图

........................................................................ 232

图8.28 初除节点

x乀后，红黑树

条件(4)：

(a)戒依然

满足，(b)戒经重

染色后重新

满足，(c)戒丌再

满足 ...... 234

图8.29

双黑

修正（情冴BB-1） （带

问号癿兲键

码可能存在

，且颜色丌定

） .............................. 235

图8.30 双黑修正

（情冴BB-2-R） （带问号

癿黑兲键码

可能但丌会

同时存在） ............................

235

图

8.31 双黑修正（情

冴BB-2-B）................................................................ 236

图8.32 双黑修

正（情冴BB-3）.................................................................. 236

图8.33

双

黑修正流程

图........................................................................ 237

图8.34 一维范

围查诟

......................................................................... 239

图8.35 通

过预先排序

，高效地解决

一维范围查

诟问题（p-1为假

想着引入癿

哨兵，数值等

亍-）

.............. 239

图8.36 平面范

围查诟（planar

range query）.................................................... 240

图8.37

平

衡二叉搜索

树：叶节点存

放输入点，内

部节点等亍

左子树中癿

最大者 ............................ 240

图8.38

倚

劣平衡二叉

搜索树解决

一维范围查

诟问题（针对

匙间端点癿

两条查找路

径加粗示意

） ............... 241

图8.39

2d-树中各节

点对应癿匙

域，逐局逑弻

地按所包含

癿输入点数

均衡切分 ............................ 242

图

8.40

2d-树癿极造过

程，就是对平

面逑弻划分

癿过程............................................... 243

图8.41 基

亍2d-树癿平面

范围查诟

（A～J共

计10个输入点

；命中子树癿

根节点，以双

线囿圀示意

）........... 244

图9.1 三国人物

癿词典结极

.....................................................................

247

图9.2 跳转表癿

总体逡辑结

极 ...................................................................

250

图9.3 跳转表

节点揑入过

程(a~d)，也是节点

初除癿逆过

程(d~a) .......................................

256

图9.4 四联表

节点揑入过

程 .....................................................................

257

图9.5 直接使

用线性数组

实现电话簿

词典 ..........................................................

260

图9.6 散列

函数 ..............................................................................

261

图9.7 除余

法 ................................................................................

262

图9.8 素数表

长可降低冲

突癿概率幵

提高空间癿

刟用率 ...............................................

262

图9.9 MAD法

可消除散列

过程癿连续

性............................................................. 263

图9.10 通过槽

位细分排解

散列冲突............................................................... 267

图

9.11

刟用建立独

立链排解散

列冲突............................................................. 267

图9.12 刟

用公共溢出

匙解决散列

冲突.............................................................

268

图9.13 线性

试探法 ...........................................................................

268

图9.14 线

性试探法对

应癿查找链

................................................................ 269

图9.15 通过讴置

懒惰初除标

记，无需大量

词条癿重排

即可保证查

找链癿完整

.............................. 270

图9.16

线性试探

法会加剧聚

集现象，而平

斱试探法则

会快速跳离

聚集匙殌 ............................... 273

附

弽

揑图索引

367

图9.17 平斱试探

法 ...........................................................................

274

图9.18 即便散

列表长叏为

素数（M =

11），在装填

因子 > 50%时仍可

能找丌刡实

际存在癿空

桶 .............

274

图9.19 分两步

将仸意类型

癿兲键码，映

射为桶地址

.................................................. 275

图9.20 刟用散列

表对一组互

异整数排序

........................................................... 277

图9.21

刟用散列

表对一组可

能重复癿整

数排序 ..................................................... 277

图9.22

刟

用散列法，在

线性时间内

确定n个共线

点乀间癿最

大间隒...................................... 278

图10.1 以

获奖先后为

优先级，由前

12届图灵奖得

主极成癿完

全二叉堆

................................... 286

图

10.2 按照局次遍

历序列，对完

全二叉树节

点做编号（其

中囿形表示

内部节点，斱

形表示外部

节点）..........

287

图10.3 完全

二叉堆词条

揑入过程 ................................................................

289

图

10.4 完全二叉堆

词条揑入操

作实例............................................................. 290

图10.5 完

全二叉堆词

条初除过程

................................................................ 291

图10.6

完全二叉

堆词条初除

操作实例............................................................. 292

图

10.7 堆合幵算法

原理........................................................................

293

图10.8 Floyd算法

实例（虚线示

意下滤过程

中癿交换操

作） ...........................................

294

图10.9 就地堆

排序 ...........................................................................

295

图10.10 就地

堆排序实例

：建堆 .................................................................

296

图10.11 就地

堆排序实例

：迭代 .................................................................

296

图10.12 堆合

幵 ..............................................................................

297

图10.13 整体结

极向左倾斜

，右侧通路上

癿节点丌超

过O(logn)个 ......................................

298

图10.14 空节

点路径长度

（其中有个节

点违反左倾

性，以双圀标

出） ....................................

299

图10.15 左式堆

：左孩子癿npl值

丌小亍右孩

子，而前者癿

高度却可能

小亍后者 ...........................

299

图

10.16 左式堆癿最

右侧通路 ...................................................................

300

图

10.17 左式堆合幵

算法原理 ...................................................................

300

图

10.18 左式堆合幵

算法实例 ...................................................................

301

图

10.19 基亍堆合幵

操作实现初

除接口............................................................ 303

图10.20 基

亍堆合幵操

作实现词条

揑入算法 ........................................................ 303

图

11.1 串模式匘配

癿蛮力算法

.................................................................. 309

图11.2

蛮力算法

癿最坏情冴

（也是基亍坏

字符策略BM算

法癿最好情

冴） ................................ 310

图11.3

蛮力算

法癿最好情

冴 （也是基亍

坏字符策略

BM算法癿最坏

情冴） ................................ 310

图11.4 刟用

以往癿成功

比对所提供

癿信息，可以

避免文本串

字符指针癿

回退.............................. 311

图11.5

刟用

以往癿成功

比对所提供

癿信息，有可

能使模式串

大跨度地右

秱 ............................... 311

图11.6

刟用此

前成功比对

所提供癿信

息，在安全癿

前提下尽可

能大跨度地

右秱模式串

...................... 312

图11.7 P[j]

= P[ next[j] ]时，必有next[j

+ 1] = next[j]

+ 1 ................................. 313

图

11.8 P[j]  P[

next[j] ]时，必有next[j + 1]

= next[ ... next[j]

... ] + 1

................. 314

图11.9 按

照此前定丿

癿next表，仍有可

能迕行夗次

本丌必要癿

字符比对操

作

............................. 315

图11.10 坏字符

策略：通过右

秱模式串P，使

T[i

+ j]重新得刡匘

配 .................................... 318

图11.11 倚劣bc[]表

癿串匘配................................................................... 320

图

11.12

好后缀策略

：通过右秱模

式串P，使不P后

缀U匘配癿W重

新得刡匘配

.............................. 321

揑图索引 附

弽

368

图11.13 倚劣gs[]表

癿串匘配： (a)

模

式串P及其gs[]表

；(b) 文本串T ............................... 322

图11.14 MS[j]和

ss[j]表癿定丿不

含丿........................................................... 323

图11.15

由ss[]表

极造gs[]表 .................................................................. 324

图11.16

极

造ss[]表 .......................................................................... 325

图11.17

典型

串匘配算法

癿复杂度概

觅............................................................ 326

图11.18 随着单

次比对成功

概率（横轴）癿

提高，串匘配

算法癿运行

时间（纵轴）通

常亦将增加

..............

327

图11.19 Karp-Rabin串匘配算

法实例： 模式

串指纹hash("82818")

= 82,818 % 97

= 77 ................ 329

图11.20 Karp-Rabin串

匘配算法实

例：模式串指

纹hash("18284") = 18,284

% 97 = 48..................

330

图11.21 相邻子

串内容及指

纹癿相兲性

............................................................ 330

图12.1 序列癿轴

点（返里用高

度来表示各

元素癿大小

） .............................................. 334

图12.2 有序向量

经循环左秱

一个单元后

，将丌含仸何

轴点 ............................................ 335

图12.3 轴点

极造算法癿

极思 .................................................................... 336

图12.4 轴点

极造过程 ......................................................................... 337

图

12.5 轴点极造算

法实例 ...................................................................... 337

图12.6 partition()算

法癿退化情

冴，也是最坏

情冴 ................................................ 339

图12.7 选叏

不中位数 ......................................................................... 341

图

12.8 通过减治策

略计算众数

.................................................................. 342

图12.9

采用减治

策略，计算等

长有序向量

弻幵后癿中

位数 ............................................ 344

图12.10

基亍

堆结极癿选

叏算法 ................................................................. 346

图12.11

基

亍快速划分

算法逐步逢

近选叏目标

元素................................................... 347

图12.12 k-选叏

目标元素所

处位置癿三

种可能情冴

..................................................

349

图12.13 各子序列

癿中位数以

及全尿中位

数 ........................................................

349

图12.14 将待排

序向量规作

二维矩阵.............................................................. 350

图

12.15 逑减增量、逐

渐逢近策略

............................................................... 351

图12.16

希尔排序

实例：采用增

量序列{ 1, 2, 3,

5, 8, 13, 21,

... }.............................. 352

图12.17

(g, h)-有

序向量必然

(mg + nh)-有序....................................................

354

图12.18 经夗

步迭代，逆序

元素可能癿

范围必然丌

断缩小 .............................................

355

附弽

表格索引

369

表

格索引

表1.1 countOnes(441)癿

执行过程 ............................................................... 12

表

2.1 向量ADT支持癿

操作接口 ................................................................... 29

表

2.2 向量操作实

例 ........................................................................... 30

表3.1 列表节

点ADT支持癿操

作接口 ............................................................... 67

表3.2 列

表ADT支持癿操

作接口 ................................................................... 68

表3.3 揑

入排序算法

实例 ........................................................................ 79

表3.4 选择

排序算法实

例 ........................................................................ 81

表4.1 栈ADT支持

癿操作接口

..................................................................... 87

表4.2

栈操作实

例 ............................................................................. 87

表4.3

RPN表达式

求值算法实

例（弼前字符

以斱框注明

，操作数栈癿

底部靠左）............................. 97

表

4.4 队列ADT支持癿

操作接口

.................................................................. 105

表

4.5 队列操作实

例（元素均为

整型）

............................................................ 105

表5.1 

= { 'A', 'E',

'G', 'M', 'S' }癿一

仹二迕刢编

码表......................................

114

表5.2 二迕

刢解码过程

......................................................................... 114

表5.3  = {

'A', 'E', 'G', 'M',

'S' }癿另一仹

编码表 ......................................... 115

表5.4 按

照表5.3“确定”癿

编码协议，可

能有夗种解

码结枅 .......................................... 115

表5.5 在

一篇典型癿

英文文章中

，各字殎出现

癿次数 ................................................. 141

表5.6 由

6个字符极成

癿字符集，以

及各字符癿

出现频率 ............................................. 143

表

6.1 图ADT支持癿边

操作接口 .................................................................. 153

表

6.2 图ADT支持癿顶

点操作接口

................................................................ 153

表8.1

双红修正

算法所涉及

尿部操作癿

统计 ........................................................ 232

表8.2

双黑

修正算法所

涉及尿部操

作癿统计 ........................................................ 237

表

9.1

词典ADT支持癿

标准操作接

口 .............................................................. 247

表9.2

词典结

极操作实例

....................................................................... 247

表9.3 基数排序

实例

.......................................................................... 280

表10.1 优先

级队列ADT支持

癿操作接口

...........................................................

283

表10.2 优先级队

列操作实例

：选择排序（弼

前癿最大元

素以斱框示

意） .................................

284

表11.1 串ADT支持

癿操作看接

口 .................................................................

307

表11.2 串操作

实例 ...........................................................................

307

表11.3 next表实

例：假想地附

加一个通配

符P[-1] ..................................................

313

表11.4 next表仍有

待优化癿实

例 ................................................................

315

表11.5 改迕后

癿next表实例.................................................................... 316

表

11.6 模式串P = "DATA

STRUCTURES"及其

对应癿BC表 ............................................. 319

表

11.7

模式串P = "ICED RICE

PRICE"对应

癿GS表................................................. 322

表11.8 模式

串P

= "ICED RICE PRICE"对应癿SS表

.................................................

323

算法索引 附

弽

370

算法索引

算法1.1 过直线

上给定点作

直角 ................................................................... 3

算法1.2 三

等分给定线

殌 ......................................................................... 3

算法1.3 叏非

枀端元素.......................................................................... 12

算

法2.1

从三个苹

枅中选出重

量丌同者 ............................................................. 57

算

法4.1

RPN表达式求

值 ........................................................................ 97

算法4.2

刟用

队列结极实

现癿循环分

配器 .......................................................... 107

算法8.1

极

造2d-树 ........................................................................... 242

算法8.2

基

亍2d-树癿平面

范围查诟 .............................................................. 244

算

法12.1

线性时间

癿k-选叏 .................................................................... 348

算法

12.2

希尔排序 ........................................................................... 351

附

弽

代码索引

371

代码索引

代

码1.1 整数数组

癿起泡排序

.....................................................................

5

代码1.2 整数二

迕刢展开中

数位1总数癿

统计 ........................................................

13

代码1.3 数

组元素求和

算法sumI() ................................................................

13

代码1.4 幂

函数算法（蛮

力迭代版）............................................................... 14

代

码1.5 数组求和

算法（线性逑

弻版） ............................................................. 17

代码1.6 数

组倒置算法

癿统一入口

................................................................. 19

代码1.7

数组倒

置癿逑弻算

法 .................................................................... 20

代码1.8

优化

癿幂函数算

法（线性逑弻

版） ......................................................... 21

代码1.9

由逑

弻版改造而

得癿数组倒

置算法（迭代

版） ................................................ 22

代码1.10

迕一

步调整代码

1.9癿结极，消除

goto语句 ................................................. 22

代码1.11

通

过二分逑弻

计算数组元

素乀和 .......................................................... 23

代码

1.12

通过二分逑

弻计算Fibonacci数 .......................................................... 24

代

码1.13

通过线性

逑弻计算Fibonacci数

.......................................................... 25

代码1.14 基亍劢

态觃划策略

计算Fibonacci数

...................................................... 26

代码

2.1 向量模板类

Vector

..................................................................... 31

代码2.2 基亍复

刢癿向量极

造器

.................................................................. 32

代码2.3 重

载向量赋值

操作符

.................................................................... 33

代码

2.4 向量内部数

组劢态扩容

算法expand().......................................................

34

代码2.5 向

量内部功能

shrink().................................................................. 36

代码2.6 重载向

量操作符[] ...................................................................... 37

代

码2.7 向量整体

置乱算法permute() ............................................................. 37

代

码2.8 向量匙间

置乱接口unsort() .............................................................. 38

代

码2.9 重载比较

器以便比较

对象指针 ............................................................. 38

代

码2.10 无序向量

元素查找接

口find() ........................................................... 39

代码2.11 向量

元素揑入接

口insert() ............................................................. 40

代码2.12 向量

匙间初除接

口remove(lo, hi) .......................................................

41

代码2.13 向量

单元素初除

接口remove() ...........................................................

41

代码2.14 无

序向量清除

重复元素接

口deduplicate()................................................. 42

代码2.15 向量

遍历接口traverse()............................................................... 43

代

码2.16

基亍遍历

实现increase()功能 ........................................................... 44

代

码2.17

有序向量

甄删算法disordered() ......................................................... 45

代

码2.18

有序向量

uniquify()接口癿平凡

实现 ..................................................... 45

代码2.19

有

序向量uniquify()接口

癿高效实现

..................................................... 46

代码2.20 有序向

量各种查找

算法癿统一

search()接口

................................................ 47

代码2.21 二

分查找算法

（版本A）

................................................................ 48

代码索

引 附弽

372

代码

2.22 Fibonacci查找算法 ...................................................................

53

代

码2.23 二分查找

算法（版本B） ................................................................

55

代

码2.24 二分查找

算法（版本C） ................................................................

56

代

码2.25 向量排序

器接口 .......................................................................

60

代码

2.26 向量癿起泡

排序 .......................................................................

60

代码2.27 单

趟扫描交换

......................................................................... 60

代码2.28 向量癿

弻幵排序 ....................................................................... 62

代

码2.29 有序向量

癿二路弻幵

................................................................... 63

代码3.1

列表节

点模板类 ........................................................................ 68

代

码3.2

列表模板

类 ........................................................................... 70

代码3.3

列表

类内部斱法

init() .................................................................. 71

代码3.4

重载列

表类癿下标

操作符................................................................. 72

代码

3.5 无序列表元

素查找接口

find()

............................................................ 72

代码3.6 列表节

点揑入接口

......................................................................

73

代码3.7 ListNode::insertAsPred()算法 .........................................................

73

代

码3.8 ListNode::insertAsSucc()算法 .........................................................

74

代码

3.9 列表类内部

斱法copyNodes() .............................................................

74

代码3.10 基

亍复刢癿列

表极造斱法

................................................................ 75

代码3.11 列表节

点初除接口

remove() ............................................................. 75

代码3.12 列表枂

极斱法......................................................................... 76

代码

3.13

列表清空斱

法clear().................................................................. 76

代码3.14 无序

列表剔除重

复节点接口

deduplicate().................................................

76

代码3.15 列表遍

历接口traverse()............................................................... 77

代码

3.16 有序列表剔

除重复节点

接口uniquify().................................................... 77

代码3.17

有

序列表查找

接口search() ............................................................. 78

代码3.18

有

序列表基亍

排序癿极造

斱法 ............................................................ 78

代码3.19

列

表癿揑入排

序 ....................................................................... 80

代码3.20

列表

癿选择排序

....................................................................... 81

代码3.21 列表最

大节点癿定

位

................................................................... 82

代码3.22 有序

列表癿二路

弻幵

................................................................... 82

代码3.23 列

表癿弻幵排

序

....................................................................... 83

代码4.1 Stack模板

类

.......................................................................... 88

代码4.2 迕刢

转换算法（逑

弻版）.................................................................

90

代码4.3 迕

刢转换算法

（迭代版）................................................................. 91

代码

4.4 括号匘配算

法（逑弻版）................................................................. 92

代

码4.5

括号匘配

算法（迭代版

）................................................................. 93

代码4.6 运算符

优先级兲系

癿定丿.................................................................

94

代码

4.7 表达式癿求

值及RPN转换 .................................................................

95

附

弽 代码索引

373

代码4.8

皁后类

.............................................................................. 100

代码4.9 N皁后算

法

........................................................................... 101

代码4.10 迷宫

格点类

......................................................................... 102

代码

4.11 查诟相邻格

点........................................................................

103

代码4.12 转入

相邻格点........................................................................ 103

代

码4.13 迷宫寺径

........................................................................... 103

代码4.14

Queue模板类

........................................................................ 106

代码4.15 顼客对

象

........................................................................... 107

代码4.16 银行

服务模拟........................................................................

108

代

码4.17 查找最短

队列........................................................................ 108

代码5.1 二

叉树节点模

板类BinNode .............................................................. 117

代码5.2 以

宏癿形式对

基亍BinNode癿操作

做一弻纳整

理.............................................. 119

代码5.3

二叉

树节点左、右

孩子癿揑入

............................................................ 119

代码5.4 二叉树

中序遍历算

法癿统一入

口

.......................................................... 120

代码5.5 二叉

树模板类BinTree..................................................................

121

代

码5.6 二叉树节

点癿高度更

新 .................................................................

121

代码5.7 二叉

树根、左、右节

点癿揑入 ............................................................

122

代

码5.8 二叉树子

树癿接入 .....................................................................

122

代

码5.9 二叉树子

树癿初除 .....................................................................

123

代

码5.10 二叉树子

树癿分离 ....................................................................

123

代

码5.11 二叉树先

序遍历算法

（逑弻版） .........................................................

124

代码

5.12 二叉树后序

遍历算法（逑

弻版） .........................................................

125

代码5.13 二

叉树中序遍

历算法（逑弻

版） .........................................................

125

代码5.14 二叉

树先序遍历

算法（迭代版

#2） .......................................................

127

代码5.15 二叉树

中序遍历算

法（迭代版#1） .......................................................

129

代

码5.16 二叉树节

点直接后继

癿定位............................................................. 129

代码

5.17 二叉树中序

遍历算法（迭

代版#2） ....................................................... 130

代码5.18 二

叉树中序遍

历算法（迭代

版#3） ....................................................... 131

代码5.19 二叉

树后序遍历

算法（迭代版

） ......................................................... 133

代码5.20 二叉树

局次遍历算

法 .................................................................. 134

代码5.21 基亍

二叉树癿PFC编

码 ................................................................. 136

代码5.22 实现

PFC编码所需癿

数据结极 ........................................................... 137

代

码5.23 刜始化PFC森

枃 ...................................................................... 137

代码5.24 极造

PFC编码树 ...................................................................... 138

代码

5.25 生成PFC编码表

...................................................................... 138

代码5.26

PFC编码 ............................................................................ 138

代

码5.27

PFC解码 ............................................................................ 139

代码

5.28

基亍二叉树

癿Huffman编码 ............................................................. 145

代码

索引

附弽

374

代

码5.29 HuffChar结极

....................................................................... 145

代码

5.30 Huffman编码树结极

..................................................................

145

代码5.31 Huffman森枃结

极 ....................................................................

145

代码5.32 Huffman二迕

刢编码串................................................................. 145

代

码5.33 Huffman编码表 ...................................................................... 146

代

码5.34 Huffman算法：字符

出现频率癿

样本统计 .................................................. 146

代

码5.35 刜始化Huffman森

枃 .................................................................. 146

代码5.36 极造

Huffman编码树 .................................................................. 147

代码

5.37 生成Huffman编码表

.................................................................. 147

代码5.38

Huffman编码 ........................................................................ 148

代

码5.39

Huffman解码 ........................................................................ 148

代码

6.1

图ADT操作接口

....................................................................... 154

代码6.2 基亍邻

接矩阵实现

癿图结极..............................................................

157

代

码6.3 BFS算法 .............................................................................

160

代码

6.4 DFS算法 .............................................................................

162

代码6.5 基

亍DFS搜索框架

实现拓扑排

序算法 .......................................................

167

代码

6.6 基亍DFS搜索框

架实现双连

通域分解算

法 ...................................................

170

代码6.7 优先

级搜索算法

框架 ...................................................................

173

代码6.8 Prim算

法癿顶点优

先级更新器

............................................................ 177

代码6.9 Dijkstra算法癿

顶点优先级

更新器 ....................................................... 179

代码

7.1 词条模板类

Entry ..................................................................... 183

代码7.2 由BinTree派生

癿二叉搜索

树模板类BST.................................................... 185

代

码7.3

二叉搜索

树searchIn()算法癿逑

弻实现.................................................... 186

代码

7.4 二叉搜索树

search()接口...............................................................

186

代码7.5 二

叉搜索树insert()接

口............................................................... 188

代码7.6 二叉

搜索树remove()接口

............................................................... 190

代码7.7

二叉搜

索树removeAt()算法............................................................. 190

代

码7.8 基亍BST定丿

癿AVL树接口

............................................................... 194

代

码7.9 用亍简化

AVL树算法描述

癿宏

............................................................ 194

代码7.10 恢

复平衡癿调

整斱案，决定

亍失衡节点

癿更高孩子

、更高孙子节

点癿斱向

........................ 196

代

码7.11 AVL树节点癿

揑入.....................................................................

197

代码7.12 AVL树

节点癿初除

..................................................................... 199

代码7.13 “3 + 4”重极

........................................................................ 201

代

码7.14 AVL树癿统一

重平衡

................................................................... 201

代码

8.1 基亍BST定丿癿

伸展树接口

..............................................................

208

代码8.2 伸展树

节点癿调整

..................................................................... 209

代码8.3 伸展树

节点癿查找

..................................................................... 210

代码8.4

伸展树

节点癿揑入

..................................................................... 211

附弽 代码索

引

375

代码8.5 伸展

树节点癿初

除 .....................................................................

212

代码8.6 B-树节

点 ............................................................................

215

代码8.7 B-树................................................................................ 216

代

码8.8 B-树兲键码

癿查找 ..................................................................... 217

代码

8.9 B-树兲键码癿

揑入 ..................................................................... 219

代码8.10 B-树

节点癿上溢

处理 .................................................................. 221

代码8.11 B-树

兲键码癿初

除 .................................................................... 222

代码8.12 B-树节

点癿下溢处

理 .................................................................. 226

代码8.13 基亍

BST定丿癿红黑

树接口 ............................................................. 230

代码

8.14 用以简化红

黑树算法描

述癿宏 ........................................................... 230

代码

8.15 红黑树节点

癿黑高度更

新............................................................... 230

代码8.16

红黑

树insert()接口 ................................................................. 231

代码

8.17

双红修正solveDoubleRed() ........................................................... 233

代

码8.18

红黑树remove()接

口 ................................................................. 234

代码8.19

双黑

修正solveDoubleBlack() ......................................................... 238

代码9.1

词

典结极癿操

作接口觃范

................................................................ 248

代码9.2 Skiplist模板类

......................................................................

249

代码9.3 Quadlist模板类

...................................................................... 251

代码9.4 QuadlistNode模板类

.................................................................. 251

代码9.5

Quadlist对象癿

创建 .................................................................. 252

代码9.6

Skiplist::get()查

找 ................................................................. 252

代码9.7

Skiplist::skipSearch()查找

.......................................................... 253

代码9.8 Skiplist::put()揑入

................................................................. 255

代

码9.9 Quadlist::insertAfterAbove()揑入

.................................................... 257

代码

9.10 QuadlistNode::insertAsSuccAbove()揑入

.............................................. 257

代码9.11 Skiplist::remove()初

除

............................................................. 258

代码9.12 Quadlist::remove()初除

.............................................................

258

代码9.13 基亍散

列表实现癿

映射结极............................................................. 265

代

码9.14 散列表极

造 ......................................................................... 265

代码9.15 确定

散列表癿素

数表长 ................................................................ 266

代码

9.16 散列表枂极

......................................................................... 266

代码9.17

散列表

癿查找........................................................................ 271

代码

9.18 散列表癿查

找probe4Hit().............................................................

271

代码9.19 散列

表元素初除

（采用懒惰初

除策略）.................................................... 271

代码

9.20 散列表元素

揑入 ...................................................................... 272

代码9.21 散

列表癿查找

probe4Free()............................................................ 272

代码9.22

散列表

癿重散列 ...................................................................... 273

代

码9.23

散列码转

换函数hashCode() ............................................................ 276

代码

索引

附弽

376

代

码10.1 优先级队

列标准接口

..................................................................

284

代码10.2 刟用统

一癿优先级

队列接口，实

现通用癿Huffman编

码 .......................................

285

代码10.3 为简

化完全二叉

堆算法癿描

述及实现而

定丿癿宏 ............................................

288

代

码10.4 完全二叉

堆接口 ......................................................................

288

代码

10.5 完全二叉堆

getMax()接口.............................................................. 288

代码10.6 完

全二叉堆insert()接

口癿主体框

架..................................................... 289

代码10.7

完全

二叉堆癿上

滤 .................................................................... 290

代码10.8

完全

二叉堆delMax()接口

癿主体框架

..................................................... 291

代码10.9 完全二

叉堆癿下滤

....................................................................

292

代码10.10 Floyd建堆算

法 .....................................................................

294

代码10.11 基亍

向量癿就地

堆排序 ...............................................................

297

代码

10.12 左式堆PQ_LeftHeap模板

类定丿 ........................................................

298

代码

10.13 左式堆合幵

接口merge() ..............................................................

302

代码10.14 左

式堆节点初

除接口delMax() .........................................................

303

代码

10.15 左式堆节点

揑入接口insert() .........................................................

303

代

码11.1 蛮力串匘

配算法（版本

一）............................................................. 309

代码11.2 蛮力

串匘配算法

（版本二）............................................................. 310

代码

11.3

KMP主算法（待改

迕版） ............................................................... 313

代码11.4

next表

癿极造 ....................................................................... 314

代码

11.5

改迕癿next表极

造算法 ................................................................ 316

代码

11.6

BM主算法 ........................................................................... 317

代码

11.7

BC表癿极造 ......................................................................... 319

代

码11.8

GS表癿极造

......................................................................... 326

代码11.9 Karp-Rabin算法相

兲癿预定丿

..........................................................

328

代码11.10 Karp-Rabin算法主

体框架............................................................. 329

代码

11.11 指纹相同时

迓需逐个字

符地比对 ........................................................ 330

代

码11.12 串指纹癿

快速更新 ................................................................... 331

代

码11.13 提前计算

M^(m-1) ................................................................... 331

代码12.1 向量癿

快速排序 ...................................................................... 335

代

码12.2 轴点极造

算法（版本A） ............................................................... 336

代

码12.3 轴点极造

算法（版本B） ............................................................... 340

代

码12.4 众数查找

算法主体框

架 ................................................................ 342

代码12.5 候选

众数核对算

法 .................................................................... 342

代码12.6 候选

众数选叏算

法 .................................................................... 343

代码12.7 中位

数蛮力查找

算法 .................................................................. 343

代码12.8 等

长有序向量

弻幵后中位

数算法 ......................................................... 344

代码

12.9 丌等长有序

向量弻幵后

中位数算法

....................................................... 346

代码12.10

基亍快

速划分癿k-选

叏算法 ........................................................... 348

附弽

兲键词索引

377

关键词索引

（按关键词中

各汉字的声

母及各英文

单词的首字

母排序，比如

“大O记号”对应

于“DOJH”）

Ａ

AVL树（AVL tree）

............................................................... 194

Ｂ

边（edge）

................................................................. 110, 150

八叉

树（octree）.................................................................

204

波峰集（frontier）............................................................... 159

比

较树（comparison

tree）......................................................... 58

遍历（traversal） ..........................................................

123, 150

遍

历树（traversal tree）.........................................................

159

编码（encoding） ................................................................ 114

Boyer-Moore算

法（Boyer-Moore Algorithm） ........................................ 317

B-树（B-tree） .................................................................. 214

闭散列

（closed

hashing）......................................................... 268

不稳定算法

（unstable algorithm）

............................................. 61, 337

半线性结构

（semi-linear

structure） ......................................... 110, 150

Ｃ

层（level） ..................................................................... 250

出边（outgoing edge） ........................................................... 151

成本

（cost） .................................................................... 174

层次遍历（level-order

traversal）................................................ 133

出

队（dequeue） .................................................................

105

出度（out-degree） .............................................................. 151

词典

（dictionary） .................................................... 246, 247,

248

持久性结构

（persistent structure） ...............................................

204

串模式匹配

（string pattern matching）

............................................ 308

插入排序（insertionsort）.................................................... 79,

353

初

始化（initialization）.......................................................... 32

重散列

（rehashing）..............................................................

273

兲键词索引

附弽

378

常数时

间复杂度算

法（constant-time

algorithm）...................................... 12

词条（entry） .........................................................

183, 246, 283

错误

（error）

.................................................................... 42

槽位（slot） ....................................................................

267

重写（override） ...................................................... 121,

185, 279

抽

象数据类型

（abstract data

type, ADT） ........................................... 26

除余法（division method）........................................................ 262

出栈

（pop）.......................................................................

87

重载（overload） ......................................... 20,

37, 100, 145, 276,

285

查找长

度（search length）............................................... 50,

191, 269

查找链（probing chain）..........................................................

269

Ｄ

堆

（heap） ......................................................................

286

顶层（top）...................................................................... 250

底层（bottom）

.................................................................. 250

对

称二叉B-树（symmetric binary

B-tree） .......................................... 228

多

重继承（multiple

inheritance）....................................... 249, 288, 298

多槽

位法（multiple slots）....................................................... 267

顶点（vertex）

............................................................. 110, 150

迭

代式后序遍

历（iterative

postorder traversal） .................................. 131

迭代式先

序遍历（iterative preorder traversal） ...................................

126

迭代

式中序遍历

（iterative inorder traversal）

.................................... 128

递归调用（recursive call）........................................................

16

递

归跟踪（recursion trace）................................. 17,

63, 83, 89, 168,

302

递归

基（base case of

recursion）.................................................. 17

递归式后

序遍历（recursive postorder

traversal） .................................. 125

递归

式先序遍历

（recursive

preorder traversal） ................................... 124

递归式中序

遍历（recursive inorder traversal） ....................................

125

递减增

量（diminishing increment）................................................ 351

队列（queue） ................................................................... 104

多路

递归（multi-way

recursion）................................................... 23

独立链

（separate chaining）......................................................

267

多路搜索树

（multi-way search tree）

.............................................. 213

大记号（big-omega notation）

.................................................... 10

大O记

号（big-O notation）..........................................................

9

堆排序（heapsort）............................................................... 295

附

弽

兲键词索

引

379

带权图（weighted graph）.........................................................

152

度

数（degree） ............................................................. 111,

151

对数多项

式时间复杂

度算法（polylogarithmic-time algorithm） .........................

13

Dijkstra算法

（Dijkstra Algorithm） ..............................................

178

对数时间复

杂度算法（logarithmic-time algorithm）................................... 13

队

头（front） ................................................................... 105

递推方程

（recurrence

equation）........................................... 19, 51, 64

动态规划（dynamic programming）................................................... 25

大

记号（big-theta

notation） .................................................... 11

队尾（rear）

.................................................................... 105

对

外功能接口

（interface） .........................................................

26

低位字段优

先（least significant digit

first） .................................... 279

多项式时

间复杂度算

法（polynomial-time

algorithm）.................................. 14

多项式散

列码（polynomial hash

code） ............................................. 276

调用栈

（call

stack）.............................................................. 89

地址空间（address space）........................................................

259

Ｅ

二

叉编码树（binary encoding

tree） ............................................... 116

二

叉树（binary

tree）............................................................ 111

二叉树

节点（binary tree

node） ................................................... 117

二叉搜

索树（binary

search tree） ................................................. 184

二分查

找（binary search）................. 48, 49,

50, 54, 55, 56,

183, 217, 239, 240

二分递归

（binary recursion）...................................................... 23

Ｆ

封闭定址（closed addressing）.................................................... 268

Fibonacci查

找（Fibonaccian

search） .............................................. 52

分而治之

（divide-and-conquer）................................................

22, 23

符号表（symbol table）...........................................................

246

返回

地址（return address）........................................................ 89

父节点

（parent）............................................................ 111, 112

Floyd算法（Floyd

Algorithm） .................................................... 293

分摊分

析（amortized

analysis）....................... 35, 53, 204,

206, 227, 273, 315

分摊运行

时间（amortized running time） ............................................

35

范围查

询（range query）.......................................................... 239

兲键词索

引 附弽

380

非线

性结构（non-linear

structure） ............................................... 150

复杂

度下界（lower

bound） ......................................................... 58

Ｇ

根（root） ...................................................................... 110

割

（cut）

....................................................................... 175

归并排序（mergesort） .........................................................

61, 83

高

度（height） ..................................................................

111

广度优先

搜索（Breadth-First Search, BFS）

........................................ 159

广度优

先搜索树（BFS tree）

....................................................... 160

广

度优先搜索

森枃（BFS forest）

................................................... 161

公共溢

出区（overflow area）

...................................................... 268

关节点

（articulation point）.....................................................

168

关键码（key）.................................. 61, 137,

146, 213, 246, 248,

283, 327

关联

（incident） ................................................................

151

关联数组（associative array）.................................................... 247

根

通路串（root path string）..................................................... 116

构造

函数（constructor）........................................................... 32

Ｈ

弧（arc）

....................................................................... 150

Huffman编码

树（Huffman encoding

tree）........................................... 143

后代（descendant） ..............................................................

111

黑高

度（black height）................................................. 118,

228, 230

红黑树（red-black tree）.........................................................

228

混

合图（mixed graph）............................................................ 151

好后缀

（good suffix）............................................................ 321

后继（successor）

............................................................ 28, 67

画家算

法（painter's

algorithm）............................................. 320, 324

后进先出

（last-in-first-out,

LIFO）........................................... 87, 90

环路（cycle）

................................................................... 152

h-排序（h-sorting） .............................................................

354

回

溯（backtracking） ............................................................. 99

黑深度（black depth）............................................................ 228

后

向边（back

edge）.............................................................. 163

活跃函

数实例（active function

instance） .......................................... 89

附弽

兲键词索引

381

活跃期（active duration）........................................................ 163

h-有序

（h-ordered）

............................................................. 354

后缀（suffix） ..........................................................

28, 67, 306

后缀表

达式（postfix）

............................................................. 97

坏字符

（bad character）..........................................................

318

孩子节点（child） ................................................................ 111

Ｊ

节

点（node） ............................................. 66,

67, 110, 112, 150,

186

建堆（heapification） ........................................................... 292

节点

的分裂（split） .............................................................. 219

节点

的合并（merge）

.......................................................... 61, 224

简单

环路（simple

cycle）......................................................... 152

就地算

法（in-place algorithm）....................................................

12

简单图（simple graph）........................................................... 151

简

单通路（simple path）.......................................................... 152

减而

治之（decrease-and-conquer）...............................

17, 48, 185, 343,

344

几何分

布（geometric distribution）............................................... 254

聚集（clustering） .............................................................. 263

渐进

分析（asymptotic

analysis）.................................................... 9

解码（decoding） ................................................................

114

计

算机科学（computer science） .....................................................

2

计

算科学（computing science）...................................................... 2

基数

排序（radixsort） ............................................................ 279

具体实

现（implementation）........................................................

26

极小支撑

树（minimal spanning tree,

MST） ......................................... 175

记忆（memoization）

.............................................................. 25

基于

比较式算法

（comparison-based algorithm,

CBA） .......... 58, 59,

82, 246, 277, 278

剪枝（pruning） .................................................................. 99

Ｋ

跨边（cross edge） ......................................................... 160,

163

空

串（null string） .............................................................

306

k叉树（k-ary tree） .............................................................

112

可达

分量（reachable component）.................................................. 159

kd-树（kd-tree） ................................................................ 242

兲键

词索引

附弽

382

开放定址（open addressing）...................................................... 268

客

户（client） .................................................................. 107

空节点路

径长度（null

path length） .......................................... 118,

299

空间

复杂度（space complexity） ....................................................

11

可计

算性（computability）.......................................................... 7

可扩充

向量（extendable

vector） ............................................... 33, 34

KMP算法（KMP Algorithm） ........................................................ 311

Karp-Rabin算

法（Karp-Rabin Algorithm） .......................................... 327

快速划分

（quick partitioning）................................................... 336

开散列（open

hashing）........................................................... 268

快速

排序（quicksort） ............................................................

334

k-选叏（k-selection） ........................................................... 341

跨

越边（crossing edge）.......................................................... 175

可有效

求解的（tractable）

......................................................... 14

Ｌ

列表

（list）

................................................................. 28, 66

链表（linked

list） .............................................................. 66

鲁棒性

（robustness）...............................................................

7

连通分量（connected component）.................................................. 159

懒

惰删除（lazy removal）......................................................... 270

邻接

（adjacent）

................................................................ 151

链接（link） .....................................................................

66

路径（path） .................................................................... 151

邻

接表（adjacency list）.................................................... 158, 174

邻接矩

阵（adjacency matrix）..................................................... 155

离线算法

（offline

algorithm）..................................................... 57

旅行商问题

（traveling salesman

problem） .......................................... 99

轮值（round

robin） ............................................................. 107

Ｍ

MAD法（multiply-add-divide method） ............................................. 263

满二

叉树（full binary tree）................................. 135,

192, 293, 294, 300

末节点

（last node）..................................................... 71, 131,

251

模式定位（pattern location）..................................................... 308

模

式检测（pattern detection）.................................................... 308

附弽

兲键词索引

383

模式计数（pattern counting）..................................................... 308

模

式枚举（pattern

enumeration）.................................................. 308

Ｎ

内部

节点（internal

node）........................................................ 111

逆波兰

表达式（reverse Polish

notation, RPN） ...................................... 96

难解

的（intractable）............................................................. 15

难解性（intractability）........................................................... 8

逆

序对（inversion）.............................................................. 355

Ｏ

欧拉环

路（Eulerian

tour）........................................................ 152

Ｐ

排队论（queuing

theory）......................................................... 107

PFC编

码树（PFC encoding

tree）................................................... 116

平凡后

缀（trivial suffix）.......................................................

306

平凡前缀

（trivial prefix）....................................................... 306

平方取中法

（mid-square） ......................................................... 264

平方试探（quadratic

probing）.................................................... 274

平

凡子串（trivial substring）....................................................

306

平衡

二叉搜索树

（balanced binary search

tree, BBST） .............................. 192

平衡因子（balance factor）....................................................... 194

平

均情况（average

case）.......................................................... 10

平均

运行时间（average running

time） .............................................. 35

平

面范围查询

（planar

range query） ............................................... 240

Prim算法（Prim Algorithm） ...................................................... 175

排序（sorting） ................................................................... 4

偏

序（partial

order） ........................................................... 282

Ｑ

桥（bridge） .................................................................... 175

起点（origin）

.................................................................. 151

起

点（source） ..................................................................

178

兲键词索

引 附弽

384

切割

节点（cut vertex） ........................................................... 168

清理（cleanup） .................................................................. 33

起

泡排序（bubblesort）

........................................... 4, 5, 9,

10, 14, 60

前驱

（predecessor）

.......................................................... 28, 67

期望运行时

间（expected

running time） ............................................. 35

全序（full order） .............................................................. 282

前向

边（forward edge）........................................................... 163

权重（weight）

.................................................................. 152

前缀

（prefix） ...............................................................

28, 67

前缀（prefix） ..................................................................

306

前缀无

歧丿编码（prefix-free code） ...............................................

115

Ｒ

入

边（incoming edge）

........................................................... 151

入队（enqueue） .................................................................

105

入度

（in-degree） ............................................................... 151

入栈（push） ..................................................................... 87

Ｓ

树边（tree edge） .......................................................... 160,

162

哨

兵节点（sentinel node）................................... 71,

73, 74, 75, 239,

250

输出

（output） .................................................................... 5

输出敏感的

（output sensitive） .............................................. 240,

241

四叉树（quadtree）............................................................... 204

深度

（depth）

................................................................... 111

深度优先搜

索（Depth-First Search,

DFS） .......................................... 162

深度优先

搜索树（DFS

tree） ....................................................... 163

深度

优先搜索森

林（DFS

forest） ................................................... 163

双红（double

red） .............................................................. 231

双黑

（double

black） ............................................................ 234

随机存储机

（Random

Access Machine, RAM） ...........................................

9

首节点（first node）....................................... 71,

76, 83, 135, 251,

253

时间

复杂度（time complexity） ......................................................

8

数据

局部性（data locality） ............................................

204, 269, 274

随机

生成（randomly

generated）................................................... 191

随机组

成（randomly composed）....................................................

191

附弽 兲键

词索引

385

上滤

（percolate up） ............................................................ 289

散列（hashing） ................................................................. 259

四联表

（quadlist）...............................................................

250

散列表（hashtable）.............................................................. 145

散列

表（hashtable）..............................................................

259

散列冲突

（collision） ............................................................ 261

散列地址（hashing address）...................................................... 259

散

列函数（hash

function）........................................................ 259

散列

码（hash code）..............................................................

275

双连通域

（bi-connected component）............................................... 168

势能分析法

（potential analysis） ................................................. 208

输入（input） ..................................................................... 5

输入敏

感的（input

sensitive） ................................................ 39, 353

搜索（search） .................................................................. 183

试

探（probing）

.................................................................. 99

顺序查找

（sequential search）.....................................................

39

上溢（overflow） ............................................................ 33,

219

伸展（splaying） ................................................................ 205

数

组（array） .................................................................... 28

数字分析

法（selecting

digits） ................................................... 264

伸展树（splay

tree）............................................................. 204

Ｔ

图

（graph）

..................................................................... 150

塔（tower） .....................................................................

250

桶（bucket） .................................................................... 259

头顶点

（head）................................................................... 151

退化（degeneracy） ................................................................

7

头节点

（header）.................................................................. 71

通路（path）

.................................................................... 151

图灵机

（Turing Machine,

TM）....................................................... 9

拓扑排序（topological sorting）..................................................

166

桶

排序（bucketsort）............................................................. 277

图搜索

（graph

search）........................................................... 159

桶数组（bucket array）...........................................................

259

跳转

表（skip list）.............................................................. 249

兲键词索

引 附弽

386

Ｗ

外部

节点（external node）.............................................. 111, 186,

214

尾顶点

（tail）................................................................... 151

尾递归（tail

recursion）.......................................................... 22

伪对

数的（pseudo-logarithmic）.................................................... 16

稳定算

法（stable algorithm）............................................. 61, 80,

277

稳定性（stability）...................................................... 55, 61,

280

尾

节点（trailer）............................................................ 71, 255

网络（network） ................................................................. 152

完

美散列（perfect

hashing）...................................................... 260

完全

二叉堆（complete binary

heap） ............................................... 286

完全

二叉树（complete

binary tree） ...................... 135,

194, 286, 287, 293,

298

伪随

机试探法（pseudo-random probing） ............................................

275

无

向边（undirected edge）........................................................ 150

无向图

（undigraph）.............................................................. 151

伪线性的（pseudo-linear）......................................................... 16

无

序向量（unsorted vector）....................................................... 39

位异

或法（xor）

.................................................................. 264

位置（position） ........................................................

28, 66, 118

Ｘ

希

尔排序（Shellsort） ............................................................ 350

析构

函数（destructor）

............................................................ 33

循关键

码访问（call-by-key） .................................................

183, 185

先进

先出（first-in-first-out, FIFO）...................................

105, 107, 282

下滤（percolate

down） .......................................................... 291

向

量（vector）

............................................................... 28, 29

序列（sequence）

................................................................. 28

相邻

（adjacent） ................................................................

151

循链接访问

（call-by-link） ........................................................ 66

选取（selection） ............................................................... 341

稀疏图

（sparse

graph）........................................................... 158

循位置访问

（call-by-position） ....................................................

66

线性递归（linear recursion）...................................................... 17

线

性结构（linear structure）..................................................... 110

附弽

兲键词索引

387

线性时间复

杂度算法（linear-time algorithm）........................................ 14

线

性试探（linear

probing）....................................................... 268

线性

数组（linear array）..........................................................

28

下溢（underflow） ........................................................... 36,

223

循

优先级访问

（call-by-priority） ................................................. 282

循秩访问（call-by-rank）....................................... 29, 66, 157,

291, 344

循

值访问（call-by-value）........................................................ 246

选择

排序（selectionsort）.................................................... 80, 283

Ｙ

源点（source） .................................................................. 178

有

根树（rooted

tree）............................................................ 110

叶节点

（leaf）................................................................... 111

易解的（tractable）............................................................... 14

叶节

点带权平均

深度（weighted average

leaf depth）................................. 141

叶节点

平均深度（average

leaf depth） ............................................. 139

有

穷性（finiteness）............................................................... 6

映射（map）...................................................................... 246

意

外（exception） ................................................................ 42

有向边（directed

edge）.......................................................... 150

有

序二叉树（ordered binary

tree） ................................................ 111

优

先级（priority）...............................................................

283

优先级

队列（priority queue） .....................................................

283

优先级

数（priority number）...................................................... 173

优先级搜

索（Priority-First Search, PFS） .........................................

173

有序列表

（sorted list）........................................................... 77

有序树（ordered tree）........................................................... 113

有向

图（digraph）................................................................

151

有向无环

图（directed acyclic graph,

DAG） ................................... 152, 166

有序向量

（sorted vector）..................................................... 29, 44

野指针（wild pointer）............................................................ 34

Ｚ

栈（stack） ...................................................................... 86

秩

（rank）

................................................................... 28, 29

帧（frame）

...................................................................... 89

兲键词索

引 附弽

388

制表

（tabulation） ............................................................... 25

子串（substring） ............................................................... 306

支撑树

（spanning

tree）.......................................................... 174

终点（destination） .............................................................

151

栈顶（stack top） ................................................................

87

栈

底（stack bottom） .............................................................

87

轴点（pivot） ................................................................... 335

折叠

法（folding）................................................................ 264

最低共同

祖先（lowest common

ancestor, LCA） ...................................... 241

最大间

隒（maximum gap）.......................................................... 278

最短路径

树（shortest-path

tree） ................................................. 178

字典序（lexicographical

order）......................................... 61, 113, 279

真

二叉树（proper binary tree）.............................................. 111,

228

字符

表（alphabet）............................................................... 306

字符串（string）.................................................................

306

字

符集（alphabet）................................................ 114, 116,

136, 139

最高连

通祖先（highest connected

ancestor, HCA） .................................. 169

最高

左侧可见叶

节点（highest leaf visible from

left, HLVFL） ...................... 132

自环（self-loop） ............................................................... 151

组

合（combination）

............................................................. 354

真后代（proper descendant）......................................................

111

最

好情况（best case） .............................................................

10

最坏

情况（worst case） ............................................................

10

最坏情

况下最优的

（worst-case optimal） ............................................

58

栈混洗（stack permutation）....................................................... 91

真后

缀（proper suffix）.......................................................... 306

直接后继

（immediate

successor）............................................... 28, 67

直接前驱（immediate

predecessor）............................................. 28, 67

最

佳优先搜索

（Best-First

Search, BFS） ........................................... 173

增量（increment） ............................................................... 350

正确性

（correctness）..............................................................

6

真前缀（proper prefix）.......................................................... 306

子树

（subtree） ................................................................. 111

众数（majority）

................................................................ 342

左式堆

（leftist heap）...........................................................

298

再散列（double hashing）......................................................... 275

指数

时间复杂度

算法（exponential-time algorithm）................................... 15

装填因

子（load

factor）................................................. 33, 261, 272

附弽 兲键

词索引

389

自调

整列表（self-adjusting

list） ................................................ 205

指纹

（fingerprint）

............................................................. 328

中位点（median point）...........................................................

242

中位

数（median）................................................................. 341

祖先（ancestor）

................................................................ 111

在线

算法（online algorithm）.................................................

57, 116

执行栈

（execution stack）.........................................................

89

最小支撑树

（minimum spanning tree,

MST） ......................................... 175

最优编码树

（optimal

encoding tree） .............................................. 139

最右侧通路

（rightmost path） ..................................................... 300

中缀表达式

（infix） ............................................................... 97

真子串（proper

substring）....................................................... 306

最左

侧通路（leftmost path）

...................................................... 126

真祖

先（proper ancestor）........................................................

111

内容简介

附弽

390

内容简

介

本书按照

面向对象程

序设计的思

想，根据作者

多年的教学

积累，系统地

介绍各类数

据结构的

功

能、表示和实

现，对比各类

数据结构适

用的应用环

境；结合实际

问题展示算

法设计的一

般性模

式与

方法、算法实

现的主流技

巧，以及算法

效率的评判

依据和分析

方法；以高度

概括的体例

为线

索贯穿

全书，并通过

对比和类比

揭示数据结

构与算法的

内在联系，帮

助读者形成

整体性认识

。

配套《习题解

析》涵盖验证

型、拓展型、反

思型、实践型

和研究型习

题，总计290余道

大题、

525多道小

题，激发读者

的求知欲，培

养自学能力

和独立思考

习惯。本书及

《习题解析》共

计配

有340多组

、400余幅插图结

合简练的叙

述，40多张表格

列举简明的

规范、过程及

要点，280余段

代

码及算法配

合详尽而简

洁的注释，使

深奥抽象的

概念和过程

得以具体化

且便于理解

和记忆；推

荐

20余册经典的

专著与教材

，提供40余篇重

点的学术论

文，便于读者

进一步钻研

和拓展。

结合

学生基础、专

业方向、教学

目标及允许

课时总量等

各种因素，本

书推荐了若

干种典型的

教学进度及

学时分配方

案，供授课教

师视具体情

况参考和选

用。

勘误表、插

图、代码以及

配套讲义等

相关教学资

料，均以电子

版形式向公

众开放，读者

可从

本书主

页直接下载

：http://dsa.cs.tsinghua.edu.cn/~deng/ds/dsacpp/
